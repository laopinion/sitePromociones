/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "32704c563d0a4bbf80be"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (typeof dep === "undefined") hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (typeof dep === "undefined") hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "home";
/******/ 			{
/******/ 				// eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted
/******/ 			)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/ansi-html/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ansi-html/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = ansiHTML\n\n// Reference to https://github.com/sindresorhus/ansi-regex\nvar _regANSI = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/\n\nvar _defColors = {\n  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]\n  black: '000',\n  red: 'ff0000',\n  green: '209805',\n  yellow: 'e8bf03',\n  blue: '0000ff',\n  magenta: 'ff00ff',\n  cyan: '00ffee',\n  lightgrey: 'f0f0f0',\n  darkgrey: '888'\n}\nvar _styles = {\n  30: 'black',\n  31: 'red',\n  32: 'green',\n  33: 'yellow',\n  34: 'blue',\n  35: 'magenta',\n  36: 'cyan',\n  37: 'lightgrey'\n}\nvar _openTags = {\n  '1': 'font-weight:bold', // bold\n  '2': 'opacity:0.5', // dim\n  '3': '<i>', // italic\n  '4': '<u>', // underscore\n  '8': 'display:none', // hidden\n  '9': '<del>' // delete\n}\nvar _closeTags = {\n  '23': '</i>', // reset italic\n  '24': '</u>', // reset underscore\n  '29': '</del>' // reset delete\n}\n\n;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\n  _closeTags[n] = '</span>'\n})\n\n/**\n * Converts text with ANSI color codes to HTML markup.\n * @param {String} text\n * @returns {*}\n */\nfunction ansiHTML (text) {\n  // Returns the text if the string has no ANSI escape code.\n  if (!_regANSI.test(text)) {\n    return text\n  }\n\n  // Cache opened sequence.\n  var ansiCodes = []\n  // Replace with markup.\n  var ret = text.replace(/\\033\\[(\\d+)*m/g, function (match, seq) {\n    var ot = _openTags[seq]\n    if (ot) {\n      // If current sequence has been opened, close it.\n      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast\n        ansiCodes.pop()\n        return '</span>'\n      }\n      // Open tag.\n      ansiCodes.push(seq)\n      return ot[0] === '<' ? ot : '<span style=\"' + ot + ';\">'\n    }\n\n    var ct = _closeTags[seq]\n    if (ct) {\n      // Pop sequence\n      ansiCodes.pop()\n      return ct\n    }\n    return ''\n  })\n\n  // Make sure tags are closed.\n  var l = ansiCodes.length\n  ;(l > 0) && (ret += Array(l + 1).join('</span>'))\n\n  return ret\n}\n\n/**\n * Customize colors.\n * @param {Object} colors reference to _defColors\n */\nansiHTML.setColors = function (colors) {\n  if (typeof colors !== 'object') {\n    throw new Error('`colors` parameter must be an Object.')\n  }\n\n  var _finalColors = {}\n  for (var key in _defColors) {\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null\n    if (!hex) {\n      _finalColors[key] = _defColors[key]\n      continue\n    }\n    if ('reset' === key) {\n      if (typeof hex === 'string') {\n        hex = [hex]\n      }\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\n        return typeof h !== 'string'\n      })) {\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')\n      }\n      var defHexColor = _defColors[key]\n      if (!hex[0]) {\n        hex[0] = defHexColor[0]\n      }\n      if (hex.length === 1 || !hex[1]) {\n        hex = [hex[0]]\n        hex.push(defHexColor[1])\n      }\n\n      hex = hex.slice(0, 2)\n    } else if (typeof hex !== 'string') {\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')\n    }\n    _finalColors[key] = hex\n  }\n  _setTags(_finalColors)\n}\n\n/**\n * Reset colors.\n */\nansiHTML.reset = function () {\n  _setTags(_defColors)\n}\n\n/**\n * Expose tags, including open and close.\n * @type {Object}\n */\nansiHTML.tags = {}\n\nif (Object.defineProperty) {\n  Object.defineProperty(ansiHTML.tags, 'open', {\n    get: function () { return _openTags }\n  })\n  Object.defineProperty(ansiHTML.tags, 'close', {\n    get: function () { return _closeTags }\n  })\n} else {\n  ansiHTML.tags.open = _openTags\n  ansiHTML.tags.close = _closeTags\n}\n\nfunction _setTags (colors) {\n  // reset all\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]\n  // inverse\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]\n  // dark grey\n  _openTags['90'] = 'color:#' + colors.darkgrey\n\n  for (var code in _styles) {\n    var color = _styles[code]\n    var oriColor = colors[color] || '000'\n    _openTags[code] = 'color:#' + oriColor\n    code = parseInt(code)\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor\n  }\n}\n\nansiHTML.reset()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sL2luZGV4LmpzPzRlMWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsSUFBSSxTQUFTLE1BQU0sSUFBSTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7QUFDSDtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVUsK0JBQStCO0FBQ2hGO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cblxudmFyIF9kZWZDb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cbiAgYmxhY2s6ICcwMDAnLFxuICByZWQ6ICdmZjAwMDAnLFxuICBncmVlbjogJzIwOTgwNScsXG4gIHllbGxvdzogJ2U4YmYwMycsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgY3lhbjogJzAwZmZlZScsXG4gIGxpZ2h0Z3JleTogJ2YwZjBmMCcsXG4gIGRhcmtncmV5OiAnODg4J1xufVxudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufVxudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLCAvLyBkaW1cbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXG4gICc0JzogJzx1PicsIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJywgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn1cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59XG5cbjtbMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXG59KVxuXG4vKipcbiAqIENvbnZlcnRzIHRleHQgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIHRvIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBhbnNpSFRNTCAodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvLyBDYWNoZSBvcGVuZWQgc2VxdWVuY2UuXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKSptL2csIGZ1bmN0aW9uIChtYXRjaCwgc2VxKSB7XG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nXG4gICAgICB9XG4gICAgICAvLyBPcGVuIHRhZy5cbiAgICAgIGFuc2lDb2Rlcy5wdXNoKHNlcSlcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcbiAgICB9XG5cbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICByZXR1cm4gY3RcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoXG4gIDsobCA+IDApICYmIChyZXQgKz0gQXJyYXkobCArIDEpLmpvaW4oJzwvc3Bhbj4nKSlcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQ3VzdG9taXplIGNvbG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcbiAqL1xuYW5zaUhUTUwuc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bjb2xvcnNgIHBhcmFtZXRlciBtdXN0IGJlIGFuIE9iamVjdC4nKVxuICB9XG5cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBfZGVmQ29sb3JzKSB7XG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoJ3Jlc2V0JyA9PT0ga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gW2hleF1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJ1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgICB9XG4gICAgICB2YXIgZGVmSGV4Q29sb3IgPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdXG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dXG4gICAgICAgIGhleC5wdXNoKGRlZkhleENvbG9yWzFdKVxuICAgICAgfVxuXG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycylcbn1cblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxufVxuXG4vKipcbiAqIEV4cG9zZSB0YWdzLCBpbmNsdWRpbmcgb3BlbiBhbmQgY2xvc2UuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5hbnNpSFRNTC50YWdzID0ge31cblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfb3BlblRhZ3MgfVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Nsb3NlVGFncyB9XG4gIH0pXG59IGVsc2Uge1xuICBhbnNpSFRNTC50YWdzLm9wZW4gPSBfb3BlblRhZ3NcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3Ncbn1cblxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXVxuICAvLyBpbnZlcnNlXG4gIF9vcGVuVGFnc1snNyddID0gJ2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzFdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzBdXG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcblxuICBmb3IgKHZhciBjb2RlIGluIF9zdHlsZXMpIHtcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJ1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvclxuICB9XG59XG5cbmFuc2lIVE1MLnJlc2V0KClcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ansi-html/index.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/ExecutionEnvironment.js":
/*!*******************************************************!*\
  !*** ./node_modules/fbjs/lib/ExecutionEnvironment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanM/YzRiMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/ExecutionEnvironment.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelize.js":
/*!*******************************************!*\
  !*** ./node_modules/fbjs/lib/camelize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanM/MzYwMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelize.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelizeStyleName.js":
/*!****************************************************!*\
  !*** ./node_modules/fbjs/lib/camelizeStyleName.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar camelize = __webpack_require__(/*! ./camelize */ \"./node_modules/fbjs/lib/camelize.js\");\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanM/OTU5ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelizeStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/containsNode.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/containsNode.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar isTextNode = __webpack_require__(/*! ./isTextNode */ \"./node_modules/fbjs/lib/isTextNode.js\");\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzPzRkNmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/containsNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcz9hMjExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyFunction.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyObject = {};\n\nif (true) {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanM/Yjc3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyObject.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/getActiveElement.js":
/*!***************************************************!*\
  !*** ./node_modules/fbjs/lib/getActiveElement.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?DOMDocument} doc Defaults to current document.\n * @return {?DOMElement}\n */\nfunction getActiveElement(doc) /*?DOMElement*/{\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nmodule.exports = getActiveElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcz84ZTVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxuICogeWV0IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHs/RE9NRG9jdW1lbnR9IGRvYyBEZWZhdWx0cyB0byBjdXJyZW50IGRvY3VtZW50LlxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSAvKj9ET01FbGVtZW50Ki97XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/getActiveElement.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenate.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzP2Y5YTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenate.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenateStyleName.js":
/*!*****************************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenateStyleName.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar hyphenate = __webpack_require__(/*! ./hyphenate */ \"./node_modules/fbjs/lib/hyphenate.js\");\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzP2ZiYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenateStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (true) {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzP2Q4ZGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/invariant.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isNode.js":
/*!*****************************************!*\
  !*** ./node_modules/fbjs/lib/isNode.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  var doc = object ? object.ownerDocument || object : document;\n  var defaultView = doc.defaultView || window;\n  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzP2Y3ODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isTextNode.js":
/*!*********************************************!*\
  !*** ./node_modules/fbjs/lib/isTextNode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar isNode = __webpack_require__(/*! ./isNode */ \"./node_modules/fbjs/lib/isNode.js\");\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcz80OTBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isTextNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/shallowEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/shallowEqual.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzP2FmMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/shallowEqual.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (true) {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcz9kYTY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/warning.js\n");

/***/ }),

/***/ "./node_modules/html-entities/index.js":
/*!*********************************************!*\
  !*** ./node_modules/html-entities/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  XmlEntities: __webpack_require__(/*! ./lib/xml-entities.js */ \"./node_modules/html-entities/lib/xml-entities.js\"),\n  Html4Entities: __webpack_require__(/*! ./lib/html4-entities.js */ \"./node_modules/html-entities/lib/html4-entities.js\"),\n  Html5Entities: __webpack_require__(/*! ./lib/html5-entities.js */ \"./node_modules/html-entities/lib/html5-entities.js\"),\n  AllHtmlEntities: __webpack_require__(/*! ./lib/html5-entities.js */ \"./node_modules/html-entities/lib/html5-entities.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9pbmRleC5qcz84MmM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFhtbEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi94bWwtZW50aXRpZXMuanMnKSxcbiAgSHRtbDRFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDQtZW50aXRpZXMuanMnKSxcbiAgSHRtbDVFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKSxcbiAgQWxsSHRtbEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/index.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/html4-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html4-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];\nvar HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];\n\nvar alphaIndex = {};\nvar numIndex = {};\n\nvar i = 0;\nvar length = HTML_ALPHA.length;\nwhile (i < length) {\n    var a = HTML_ALPHA[i];\n    var c = HTML_CODES[i];\n    alphaIndex[a] = String.fromCharCode(c);\n    numIndex[c] = a;\n    i++;\n}\n\n/**\n * @constructor\n */\nfunction Html4Entities() {}\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.decode = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    return str.replace(/&(#?[\\w\\d]+);?/g, function(s, entity) {\n        var chr;\n        if (entity.charAt(0) === \"#\") {\n            var code = entity.charAt(1).toLowerCase() === 'x' ?\n                parseInt(entity.substr(2), 16) :\n                parseInt(entity.substr(1));\n\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\n                chr = String.fromCharCode(code);\n            }\n        } else {\n            chr = alphaIndex[entity];\n        }\n        return chr || s;\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.decode = function(str) {\n    return new Html4Entities().decode(str);\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.encode = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var alpha = numIndex[str.charCodeAt(i)];\n        result += alpha ? \"&\" + alpha + \";\" : str.charAt(i);\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.encode = function(str) {\n    return new Html4Entities().encode(str);\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.encodeNonUTF = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var cc = str.charCodeAt(i);\n        var alpha = numIndex[cc];\n        if (alpha) {\n            result += \"&\" + alpha + \";\";\n        } else if (cc < 32 || cc > 126) {\n            result += \"&#\" + cc + \";\";\n        } else {\n            result += str.charAt(i);\n        }\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.encodeNonUTF = function(str) {\n    return new Html4Entities().encodeNonUTF(str);\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.encodeNonASCII = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        if (c <= 255) {\n            result += str[i++];\n            continue;\n        }\n        result += '&#' + c + ';';\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.encodeNonASCII = function(str) {\n    return new Html4Entities().encodeNonASCII(str);\n};\n\nmodule.exports = Html4Entities;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanM/MWYwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhUTUxfQUxQSEEgPSBbJ2Fwb3MnLCAnbmJzcCcsICdpZXhjbCcsICdjZW50JywgJ3BvdW5kJywgJ2N1cnJlbicsICd5ZW4nLCAnYnJ2YmFyJywgJ3NlY3QnLCAndW1sJywgJ2NvcHknLCAnb3JkZicsICdsYXF1bycsICdub3QnLCAnc2h5JywgJ3JlZycsICdtYWNyJywgJ2RlZycsICdwbHVzbW4nLCAnc3VwMicsICdzdXAzJywgJ2FjdXRlJywgJ21pY3JvJywgJ3BhcmEnLCAnbWlkZG90JywgJ2NlZGlsJywgJ3N1cDEnLCAnb3JkbScsICdyYXF1bycsICdmcmFjMTQnLCAnZnJhYzEyJywgJ2ZyYWMzNCcsICdpcXVlc3QnLCAnQWdyYXZlJywgJ0FhY3V0ZScsICdBY2lyYycsICdBdGlsZGUnLCAnQXVtbCcsICdBcmluZycsICdBZWxpZycsICdDY2VkaWwnLCAnRWdyYXZlJywgJ0VhY3V0ZScsICdFY2lyYycsICdFdW1sJywgJ0lncmF2ZScsICdJYWN1dGUnLCAnSWNpcmMnLCAnSXVtbCcsICdFVEgnLCAnTnRpbGRlJywgJ09ncmF2ZScsICdPYWN1dGUnLCAnT2NpcmMnLCAnT3RpbGRlJywgJ091bWwnLCAndGltZXMnLCAnT3NsYXNoJywgJ1VncmF2ZScsICdVYWN1dGUnLCAnVWNpcmMnLCAnVXVtbCcsICdZYWN1dGUnLCAnVEhPUk4nLCAnc3psaWcnLCAnYWdyYXZlJywgJ2FhY3V0ZScsICdhY2lyYycsICdhdGlsZGUnLCAnYXVtbCcsICdhcmluZycsICdhZWxpZycsICdjY2VkaWwnLCAnZWdyYXZlJywgJ2VhY3V0ZScsICdlY2lyYycsICdldW1sJywgJ2lncmF2ZScsICdpYWN1dGUnLCAnaWNpcmMnLCAnaXVtbCcsICdldGgnLCAnbnRpbGRlJywgJ29ncmF2ZScsICdvYWN1dGUnLCAnb2NpcmMnLCAnb3RpbGRlJywgJ291bWwnLCAnZGl2aWRlJywgJ29zbGFzaCcsICd1Z3JhdmUnLCAndWFjdXRlJywgJ3VjaXJjJywgJ3V1bWwnLCAneWFjdXRlJywgJ3Rob3JuJywgJ3l1bWwnLCAncXVvdCcsICdhbXAnLCAnbHQnLCAnZ3QnLCAnT0VsaWcnLCAnb2VsaWcnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdZdW1sJywgJ2NpcmMnLCAndGlsZGUnLCAnZW5zcCcsICdlbXNwJywgJ3RoaW5zcCcsICd6d25qJywgJ3p3aicsICdscm0nLCAncmxtJywgJ25kYXNoJywgJ21kYXNoJywgJ2xzcXVvJywgJ3JzcXVvJywgJ3NicXVvJywgJ2xkcXVvJywgJ3JkcXVvJywgJ2JkcXVvJywgJ2RhZ2dlcicsICdEYWdnZXInLCAncGVybWlsJywgJ2xzYXF1bycsICdyc2FxdW8nLCAnZXVybycsICdmbm9mJywgJ0FscGhhJywgJ0JldGEnLCAnR2FtbWEnLCAnRGVsdGEnLCAnRXBzaWxvbicsICdaZXRhJywgJ0V0YScsICdUaGV0YScsICdJb3RhJywgJ0thcHBhJywgJ0xhbWJkYScsICdNdScsICdOdScsICdYaScsICdPbWljcm9uJywgJ1BpJywgJ1JobycsICdTaWdtYScsICdUYXUnLCAnVXBzaWxvbicsICdQaGknLCAnQ2hpJywgJ1BzaScsICdPbWVnYScsICdhbHBoYScsICdiZXRhJywgJ2dhbW1hJywgJ2RlbHRhJywgJ2Vwc2lsb24nLCAnemV0YScsICdldGEnLCAndGhldGEnLCAnaW90YScsICdrYXBwYScsICdsYW1iZGEnLCAnbXUnLCAnbnUnLCAneGknLCAnb21pY3JvbicsICdwaScsICdyaG8nLCAnc2lnbWFmJywgJ3NpZ21hJywgJ3RhdScsICd1cHNpbG9uJywgJ3BoaScsICdjaGknLCAncHNpJywgJ29tZWdhJywgJ3RoZXRhc3ltJywgJ3Vwc2loJywgJ3BpdicsICdidWxsJywgJ2hlbGxpcCcsICdwcmltZScsICdQcmltZScsICdvbGluZScsICdmcmFzbCcsICd3ZWllcnAnLCAnaW1hZ2UnLCAncmVhbCcsICd0cmFkZScsICdhbGVmc3ltJywgJ2xhcnInLCAndWFycicsICdyYXJyJywgJ2RhcnInLCAnaGFycicsICdjcmFycicsICdsQXJyJywgJ3VBcnInLCAnckFycicsICdkQXJyJywgJ2hBcnInLCAnZm9yYWxsJywgJ3BhcnQnLCAnZXhpc3QnLCAnZW1wdHknLCAnbmFibGEnLCAnaXNpbicsICdub3RpbicsICduaScsICdwcm9kJywgJ3N1bScsICdtaW51cycsICdsb3dhc3QnLCAncmFkaWMnLCAncHJvcCcsICdpbmZpbicsICdhbmcnLCAnYW5kJywgJ29yJywgJ2NhcCcsICdjdXAnLCAnaW50JywgJ3RoZXJlNCcsICdzaW0nLCAnY29uZycsICdhc3ltcCcsICduZScsICdlcXVpdicsICdsZScsICdnZScsICdzdWInLCAnc3VwJywgJ25zdWInLCAnc3ViZScsICdzdXBlJywgJ29wbHVzJywgJ290aW1lcycsICdwZXJwJywgJ3Nkb3QnLCAnbGNlaWwnLCAncmNlaWwnLCAnbGZsb29yJywgJ3JmbG9vcicsICdsYW5nJywgJ3JhbmcnLCAnbG96JywgJ3NwYWRlcycsICdjbHVicycsICdoZWFydHMnLCAnZGlhbXMnXTtcbnZhciBIVE1MX0NPREVTID0gWzM5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc0LCAxNzUsIDE3NiwgMTc3LCAxNzgsIDE3OSwgMTgwLCAxODEsIDE4MiwgMTgzLCAxODQsIDE4NSwgMTg2LCAxODcsIDE4OCwgMTg5LCAxOTAsIDE5MSwgMTkyLCAxOTMsIDE5NCwgMTk1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjEwLCAyMTEsIDIxMiwgMjEzLCAyMTQsIDIxNSwgMjE2LCAyMTcsIDIxOCwgMjE5LCAyMjAsIDIyMSwgMjIyLCAyMjMsIDIyNCwgMjI1LCAyMjYsIDIyNywgMjI4LCAyMjksIDIzMCwgMjMxLCAyMzIsIDIzMywgMjM0LCAyMzUsIDIzNiwgMjM3LCAyMzgsIDIzOSwgMjQwLCAyNDEsIDI0MiwgMjQzLCAyNDQsIDI0NSwgMjQ2LCAyNDcsIDI0OCwgMjQ5LCAyNTAsIDI1MSwgMjUyLCAyNTMsIDI1NCwgMjU1LCAzNCwgMzgsIDYwLCA2MiwgMzM4LCAzMzksIDM1MiwgMzUzLCAzNzYsIDcxMCwgNzMyLCA4MTk0LCA4MTk1LCA4MjAxLCA4MjA0LCA4MjA1LCA4MjA2LCA4MjA3LCA4MjExLCA4MjEyLCA4MjE2LCA4MjE3LCA4MjE4LCA4MjIwLCA4MjIxLCA4MjIyLCA4MjI0LCA4MjI1LCA4MjQwLCA4MjQ5LCA4MjUwLCA4MzY0LCA0MDIsIDkxMywgOTE0LCA5MTUsIDkxNiwgOTE3LCA5MTgsIDkxOSwgOTIwLCA5MjEsIDkyMiwgOTIzLCA5MjQsIDkyNSwgOTI2LCA5MjcsIDkyOCwgOTI5LCA5MzEsIDkzMiwgOTMzLCA5MzQsIDkzNSwgOTM2LCA5MzcsIDk0NSwgOTQ2LCA5NDcsIDk0OCwgOTQ5LCA5NTAsIDk1MSwgOTUyLCA5NTMsIDk1NCwgOTU1LCA5NTYsIDk1NywgOTU4LCA5NTksIDk2MCwgOTYxLCA5NjIsIDk2MywgOTY0LCA5NjUsIDk2NiwgOTY3LCA5NjgsIDk2OSwgOTc3LCA5NzgsIDk4MiwgODIyNiwgODIzMCwgODI0MiwgODI0MywgODI1NCwgODI2MCwgODQ3MiwgODQ2NSwgODQ3NiwgODQ4MiwgODUwMSwgODU5MiwgODU5MywgODU5NCwgODU5NSwgODU5NiwgODYyOSwgODY1NiwgODY1NywgODY1OCwgODY1OSwgODY2MCwgODcwNCwgODcwNiwgODcwNywgODcwOSwgODcxMSwgODcxMiwgODcxMywgODcxNSwgODcxOSwgODcyMSwgODcyMiwgODcyNywgODczMCwgODczMywgODczNCwgODczNiwgODc0MywgODc0NCwgODc0NSwgODc0NiwgODc0NywgODc1NiwgODc2NCwgODc3MywgODc3NiwgODgwMCwgODgwMSwgODgwNCwgODgwNSwgODgzNCwgODgzNSwgODgzNiwgODgzOCwgODgzOSwgODg1MywgODg1NSwgODg2OSwgODkwMSwgODk2OCwgODk2OSwgODk3MCwgODk3MSwgOTAwMSwgOTAwMiwgOTY3NCwgOTgyNCwgOTgyNywgOTgyOSwgOTgzMF07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgbnVtSW5kZXggPSB7fTtcblxudmFyIGkgPSAwO1xudmFyIGxlbmd0aCA9IEhUTUxfQUxQSEEubGVuZ3RoO1xud2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XG4gICAgdmFyIGMgPSBIVE1MX0NPREVTW2ldO1xuICAgIGFscGhhSW5kZXhbYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgIG51bUluZGV4W2NdID0gYTtcbiAgICBpKys7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw0RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMiksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICByZXN1bHQgKz0gYWxwaGEgPyBcIiZcIiArIGFscGhhICsgXCI7XCIgOiBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbY2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2MgPCAzMiB8fCBjYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJiNcIiArIGNjICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNEVudGl0aWVzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/html4-entities.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/html5-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html5-entities.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];\n\nvar alphaIndex = {};\nvar charIndex = {};\n\ncreateIndexes(alphaIndex, charIndex);\n\n/**\n * @constructor\n */\nfunction Html5Entities() {}\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.decode = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    return str.replace(/&(#?[\\w\\d]+);?/g, function(s, entity) {\n        var chr;\n        if (entity.charAt(0) === \"#\") {\n            var code = entity.charAt(1) === 'x' ?\n                parseInt(entity.substr(2).toLowerCase(), 16) :\n                parseInt(entity.substr(1));\n\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\n                chr = String.fromCharCode(code);\n            }\n        } else {\n            chr = alphaIndex[entity];\n        }\n        return chr || s;\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.decode = function(str) {\n    return new Html5Entities().decode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.encode = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var charInfo = charIndex[str.charCodeAt(i)];\n        if (charInfo) {\n            var alpha = charInfo[str.charCodeAt(i + 1)];\n            if (alpha) {\n                i++;\n            } else {\n                alpha = charInfo[''];\n            }\n            if (alpha) {\n                result += \"&\" + alpha + \";\";\n                i++;\n                continue;\n            }\n        }\n        result += str.charAt(i);\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.encode = function(str) {\n    return new Html5Entities().encode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.encodeNonUTF = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        var charInfo = charIndex[c];\n        if (charInfo) {\n            var alpha = charInfo[str.charCodeAt(i + 1)];\n            if (alpha) {\n                i++;\n            } else {\n                alpha = charInfo[''];\n            }\n            if (alpha) {\n                result += \"&\" + alpha + \";\";\n                i++;\n                continue;\n            }\n        }\n        if (c < 32 || c > 126) {\n            result += '&#' + c + ';';\n        } else {\n            result += str.charAt(i);\n        }\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.encodeNonUTF = function(str) {\n    return new Html5Entities().encodeNonUTF(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.encodeNonASCII = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        if (c <= 255) {\n            result += str[i++];\n            continue;\n        }\n        result += '&#' + c + ';';\n        i++\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.encodeNonASCII = function(str) {\n    return new Html5Entities().encodeNonASCII(str);\n };\n\n/**\n * @param {Object} alphaIndex Passed by reference.\n * @param {Object} charIndex Passed by reference.\n */\nfunction createIndexes(alphaIndex, charIndex) {\n    var i = ENTITIES.length;\n    var _results = [];\n    while (i--) {\n        var e = ENTITIES[i];\n        var alpha = e[0];\n        var chars = e[1];\n        var chr = chars[0];\n        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;\n        var charInfo;\n        if (addChar) {\n            charInfo = charIndex[chr] = charIndex[chr] || {};\n        }\n        if (chars[1]) {\n            var chr2 = chars[1];\n            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);\n            _results.push(addChar && (charInfo[chr2] = alpha));\n        } else {\n            alphaIndex[alpha] = String.fromCharCode(chr);\n            _results.push(addChar && (charInfo[''] = alpha));\n        }\n    }\n}\n\nmodule.exports = Html5Entities;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanM/MTdmZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw1LWVudGl0aWVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEVOVElUSUVTID0gW1snQWFjdXRlJywgWzE5M11dLCBbJ2FhY3V0ZScsIFsyMjVdXSwgWydBYnJldmUnLCBbMjU4XV0sIFsnYWJyZXZlJywgWzI1OV1dLCBbJ2FjJywgWzg3NjZdXSwgWydhY2QnLCBbODc2N11dLCBbJ2FjRScsIFs4NzY2LCA4MTldXSwgWydBY2lyYycsIFsxOTRdXSwgWydhY2lyYycsIFsyMjZdXSwgWydhY3V0ZScsIFsxODBdXSwgWydBY3knLCBbMTA0MF1dLCBbJ2FjeScsIFsxMDcyXV0sIFsnQUVsaWcnLCBbMTk4XV0sIFsnYWVsaWcnLCBbMjMwXV0sIFsnYWYnLCBbODI4OV1dLCBbJ0FmcicsIFsxMjAwNjhdXSwgWydhZnInLCBbMTIwMDk0XV0sIFsnQWdyYXZlJywgWzE5Ml1dLCBbJ2FncmF2ZScsIFsyMjRdXSwgWydhbGVmc3ltJywgWzg1MDFdXSwgWydhbGVwaCcsIFs4NTAxXV0sIFsnQWxwaGEnLCBbOTEzXV0sIFsnYWxwaGEnLCBbOTQ1XV0sIFsnQW1hY3InLCBbMjU2XV0sIFsnYW1hY3InLCBbMjU3XV0sIFsnYW1hbGcnLCBbMTA4MTVdXSwgWydhbXAnLCBbMzhdXSwgWydBTVAnLCBbMzhdXSwgWydhbmRhbmQnLCBbMTA4MzddXSwgWydBbmQnLCBbMTA4MzVdXSwgWydhbmQnLCBbODc0M11dLCBbJ2FuZGQnLCBbMTA4NDRdXSwgWydhbmRzbG9wZScsIFsxMDg0MF1dLCBbJ2FuZHYnLCBbMTA4NDJdXSwgWydhbmcnLCBbODczNl1dLCBbJ2FuZ2UnLCBbMTA2NjBdXSwgWydhbmdsZScsIFs4NzM2XV0sIFsnYW5nbXNkYWEnLCBbMTA2NjRdXSwgWydhbmdtc2RhYicsIFsxMDY2NV1dLCBbJ2FuZ21zZGFjJywgWzEwNjY2XV0sIFsnYW5nbXNkYWQnLCBbMTA2NjddXSwgWydhbmdtc2RhZScsIFsxMDY2OF1dLCBbJ2FuZ21zZGFmJywgWzEwNjY5XV0sIFsnYW5nbXNkYWcnLCBbMTA2NzBdXSwgWydhbmdtc2RhaCcsIFsxMDY3MV1dLCBbJ2FuZ21zZCcsIFs4NzM3XV0sIFsnYW5ncnQnLCBbODczNV1dLCBbJ2FuZ3J0dmInLCBbODg5NF1dLCBbJ2FuZ3J0dmJkJywgWzEwNjUzXV0sIFsnYW5nc3BoJywgWzg3MzhdXSwgWydhbmdzdCcsIFsxOTddXSwgWydhbmd6YXJyJywgWzkwODRdXSwgWydBb2dvbicsIFsyNjBdXSwgWydhb2dvbicsIFsyNjFdXSwgWydBb3BmJywgWzEyMDEyMF1dLCBbJ2FvcGYnLCBbMTIwMTQ2XV0sIFsnYXBhY2lyJywgWzEwODYzXV0sIFsnYXAnLCBbODc3Nl1dLCBbJ2FwRScsIFsxMDg2NF1dLCBbJ2FwZScsIFs4Nzc4XV0sIFsnYXBpZCcsIFs4Nzc5XV0sIFsnYXBvcycsIFszOV1dLCBbJ0FwcGx5RnVuY3Rpb24nLCBbODI4OV1dLCBbJ2FwcHJveCcsIFs4Nzc2XV0sIFsnYXBwcm94ZXEnLCBbODc3OF1dLCBbJ0FyaW5nJywgWzE5N11dLCBbJ2FyaW5nJywgWzIyOV1dLCBbJ0FzY3InLCBbMTE5OTY0XV0sIFsnYXNjcicsIFsxMTk5OTBdXSwgWydBc3NpZ24nLCBbODc4OF1dLCBbJ2FzdCcsIFs0Ml1dLCBbJ2FzeW1wJywgWzg3NzZdXSwgWydhc3ltcGVxJywgWzg3ODFdXSwgWydBdGlsZGUnLCBbMTk1XV0sIFsnYXRpbGRlJywgWzIyN11dLCBbJ0F1bWwnLCBbMTk2XV0sIFsnYXVtbCcsIFsyMjhdXSwgWydhd2NvbmludCcsIFs4NzU1XV0sIFsnYXdpbnQnLCBbMTA3NjldXSwgWydiYWNrY29uZycsIFs4NzgwXV0sIFsnYmFja2Vwc2lsb24nLCBbMTAxNF1dLCBbJ2JhY2twcmltZScsIFs4MjQ1XV0sIFsnYmFja3NpbScsIFs4NzY1XV0sIFsnYmFja3NpbWVxJywgWzg5MDldXSwgWydCYWNrc2xhc2gnLCBbODcyNl1dLCBbJ0JhcnYnLCBbMTA5ODNdXSwgWydiYXJ2ZWUnLCBbODg5M11dLCBbJ2JhcndlZCcsIFs4OTY1XV0sIFsnQmFyd2VkJywgWzg5NjZdXSwgWydiYXJ3ZWRnZScsIFs4OTY1XV0sIFsnYmJyaycsIFs5MTQxXV0sIFsnYmJya3RicmsnLCBbOTE0Ml1dLCBbJ2Jjb25nJywgWzg3ODBdXSwgWydCY3knLCBbMTA0MV1dLCBbJ2JjeScsIFsxMDczXV0sIFsnYmRxdW8nLCBbODIyMl1dLCBbJ2JlY2F1cycsIFs4NzU3XV0sIFsnYmVjYXVzZScsIFs4NzU3XV0sIFsnQmVjYXVzZScsIFs4NzU3XV0sIFsnYmVtcHR5dicsIFsxMDY3Ml1dLCBbJ2JlcHNpJywgWzEwMTRdXSwgWydiZXJub3UnLCBbODQ5Ml1dLCBbJ0Jlcm5vdWxsaXMnLCBbODQ5Ml1dLCBbJ0JldGEnLCBbOTE0XV0sIFsnYmV0YScsIFs5NDZdXSwgWydiZXRoJywgWzg1MDJdXSwgWydiZXR3ZWVuJywgWzg4MTJdXSwgWydCZnInLCBbMTIwMDY5XV0sIFsnYmZyJywgWzEyMDA5NV1dLCBbJ2JpZ2NhcCcsIFs4ODk4XV0sIFsnYmlnY2lyYycsIFs5NzExXV0sIFsnYmlnY3VwJywgWzg4OTldXSwgWydiaWdvZG90JywgWzEwNzUyXV0sIFsnYmlnb3BsdXMnLCBbMTA3NTNdXSwgWydiaWdvdGltZXMnLCBbMTA3NTRdXSwgWydiaWdzcWN1cCcsIFsxMDc1OF1dLCBbJ2JpZ3N0YXInLCBbOTczM11dLCBbJ2JpZ3RyaWFuZ2xlZG93bicsIFs5NjYxXV0sIFsnYmlndHJpYW5nbGV1cCcsIFs5NjUxXV0sIFsnYmlndXBsdXMnLCBbMTA3NTZdXSwgWydiaWd2ZWUnLCBbODg5N11dLCBbJ2JpZ3dlZGdlJywgWzg4OTZdXSwgWydia2Fyb3cnLCBbMTA1MDldXSwgWydibGFja2xvemVuZ2UnLCBbMTA3MzFdXSwgWydibGFja3NxdWFyZScsIFs5NjQyXV0sIFsnYmxhY2t0cmlhbmdsZScsIFs5NjUyXV0sIFsnYmxhY2t0cmlhbmdsZWRvd24nLCBbOTY2Ml1dLCBbJ2JsYWNrdHJpYW5nbGVsZWZ0JywgWzk2NjZdXSwgWydibGFja3RyaWFuZ2xlcmlnaHQnLCBbOTY1Nl1dLCBbJ2JsYW5rJywgWzkyNTFdXSwgWydibGsxMicsIFs5NjE4XV0sIFsnYmxrMTQnLCBbOTYxN11dLCBbJ2JsazM0JywgWzk2MTldXSwgWydibG9jaycsIFs5NjA4XV0sIFsnYm5lJywgWzYxLCA4NDIxXV0sIFsnYm5lcXVpdicsIFs4ODAxLCA4NDIxXV0sIFsnYk5vdCcsIFsxMDk4OV1dLCBbJ2Jub3QnLCBbODk3Nl1dLCBbJ0JvcGYnLCBbMTIwMTIxXV0sIFsnYm9wZicsIFsxMjAxNDddXSwgWydib3QnLCBbODg2OV1dLCBbJ2JvdHRvbScsIFs4ODY5XV0sIFsnYm93dGllJywgWzg5MDRdXSwgWydib3hib3gnLCBbMTA2OTddXSwgWydib3hkbCcsIFs5NDg4XV0sIFsnYm94ZEwnLCBbOTU1N11dLCBbJ2JveERsJywgWzk1NThdXSwgWydib3hETCcsIFs5NTU5XV0sIFsnYm94ZHInLCBbOTQ4NF1dLCBbJ2JveGRSJywgWzk1NTRdXSwgWydib3hEcicsIFs5NTU1XV0sIFsnYm94RFInLCBbOTU1Nl1dLCBbJ2JveGgnLCBbOTQ3Ml1dLCBbJ2JveEgnLCBbOTU1Ml1dLCBbJ2JveGhkJywgWzk1MTZdXSwgWydib3hIZCcsIFs5NTcyXV0sIFsnYm94aEQnLCBbOTU3M11dLCBbJ2JveEhEJywgWzk1NzRdXSwgWydib3hodScsIFs5NTI0XV0sIFsnYm94SHUnLCBbOTU3NV1dLCBbJ2JveGhVJywgWzk1NzZdXSwgWydib3hIVScsIFs5NTc3XV0sIFsnYm94bWludXMnLCBbODg2M11dLCBbJ2JveHBsdXMnLCBbODg2Ml1dLCBbJ2JveHRpbWVzJywgWzg4NjRdXSwgWydib3h1bCcsIFs5NDk2XV0sIFsnYm94dUwnLCBbOTU2M11dLCBbJ2JveFVsJywgWzk1NjRdXSwgWydib3hVTCcsIFs5NTY1XV0sIFsnYm94dXInLCBbOTQ5Ml1dLCBbJ2JveHVSJywgWzk1NjBdXSwgWydib3hVcicsIFs5NTYxXV0sIFsnYm94VVInLCBbOTU2Ml1dLCBbJ2JveHYnLCBbOTQ3NF1dLCBbJ2JveFYnLCBbOTU1M11dLCBbJ2JveHZoJywgWzk1MzJdXSwgWydib3h2SCcsIFs5NTc4XV0sIFsnYm94VmgnLCBbOTU3OV1dLCBbJ2JveFZIJywgWzk1ODBdXSwgWydib3h2bCcsIFs5NTA4XV0sIFsnYm94dkwnLCBbOTU2OV1dLCBbJ2JveFZsJywgWzk1NzBdXSwgWydib3hWTCcsIFs5NTcxXV0sIFsnYm94dnInLCBbOTUwMF1dLCBbJ2JveHZSJywgWzk1NjZdXSwgWydib3hWcicsIFs5NTY3XV0sIFsnYm94VlInLCBbOTU2OF1dLCBbJ2JwcmltZScsIFs4MjQ1XV0sIFsnYnJldmUnLCBbNzI4XV0sIFsnQnJldmUnLCBbNzI4XV0sIFsnYnJ2YmFyJywgWzE2Nl1dLCBbJ2JzY3InLCBbMTE5OTkxXV0sIFsnQnNjcicsIFs4NDkyXV0sIFsnYnNlbWknLCBbODI3MV1dLCBbJ2JzaW0nLCBbODc2NV1dLCBbJ2JzaW1lJywgWzg5MDldXSwgWydic29sYicsIFsxMDY5M11dLCBbJ2Jzb2wnLCBbOTJdXSwgWydic29saHN1YicsIFsxMDE4NF1dLCBbJ2J1bGwnLCBbODIyNl1dLCBbJ2J1bGxldCcsIFs4MjI2XV0sIFsnYnVtcCcsIFs4NzgyXV0sIFsnYnVtcEUnLCBbMTA5MjZdXSwgWydidW1wZScsIFs4NzgzXV0sIFsnQnVtcGVxJywgWzg3ODJdXSwgWydidW1wZXEnLCBbODc4M11dLCBbJ0NhY3V0ZScsIFsyNjJdXSwgWydjYWN1dGUnLCBbMjYzXV0sIFsnY2FwYW5kJywgWzEwODIwXV0sIFsnY2FwYnJjdXAnLCBbMTA4MjVdXSwgWydjYXBjYXAnLCBbMTA4MjddXSwgWydjYXAnLCBbODc0NV1dLCBbJ0NhcCcsIFs4OTE0XV0sIFsnY2FwY3VwJywgWzEwODIzXV0sIFsnY2FwZG90JywgWzEwODE2XV0sIFsnQ2FwaXRhbERpZmZlcmVudGlhbEQnLCBbODUxN11dLCBbJ2NhcHMnLCBbODc0NSwgNjUwMjRdXSwgWydjYXJldCcsIFs4MjU3XV0sIFsnY2Fyb24nLCBbNzExXV0sIFsnQ2F5bGV5cycsIFs4NDkzXV0sIFsnY2NhcHMnLCBbMTA4MjldXSwgWydDY2Fyb24nLCBbMjY4XV0sIFsnY2Nhcm9uJywgWzI2OV1dLCBbJ0NjZWRpbCcsIFsxOTldXSwgWydjY2VkaWwnLCBbMjMxXV0sIFsnQ2NpcmMnLCBbMjY0XV0sIFsnY2NpcmMnLCBbMjY1XV0sIFsnQ2NvbmludCcsIFs4NzUyXV0sIFsnY2N1cHMnLCBbMTA4MjhdXSwgWydjY3Vwc3NtJywgWzEwODMyXV0sIFsnQ2RvdCcsIFsyNjZdXSwgWydjZG90JywgWzI2N11dLCBbJ2NlZGlsJywgWzE4NF1dLCBbJ0NlZGlsbGEnLCBbMTg0XV0sIFsnY2VtcHR5dicsIFsxMDY3NF1dLCBbJ2NlbnQnLCBbMTYyXV0sIFsnY2VudGVyZG90JywgWzE4M11dLCBbJ0NlbnRlckRvdCcsIFsxODNdXSwgWydjZnInLCBbMTIwMDk2XV0sIFsnQ2ZyJywgWzg0OTNdXSwgWydDSGN5JywgWzEwNjNdXSwgWydjaGN5JywgWzEwOTVdXSwgWydjaGVjaycsIFsxMDAwM11dLCBbJ2NoZWNrbWFyaycsIFsxMDAwM11dLCBbJ0NoaScsIFs5MzVdXSwgWydjaGknLCBbOTY3XV0sIFsnY2lyYycsIFs3MTBdXSwgWydjaXJjZXEnLCBbODc5MV1dLCBbJ2NpcmNsZWFycm93bGVmdCcsIFs4NjM0XV0sIFsnY2lyY2xlYXJyb3dyaWdodCcsIFs4NjM1XV0sIFsnY2lyY2xlZGFzdCcsIFs4ODU5XV0sIFsnY2lyY2xlZGNpcmMnLCBbODg1OF1dLCBbJ2NpcmNsZWRkYXNoJywgWzg4NjFdXSwgWydDaXJjbGVEb3QnLCBbODg1N11dLCBbJ2NpcmNsZWRSJywgWzE3NF1dLCBbJ2NpcmNsZWRTJywgWzk0MTZdXSwgWydDaXJjbGVNaW51cycsIFs4ODU0XV0sIFsnQ2lyY2xlUGx1cycsIFs4ODUzXV0sIFsnQ2lyY2xlVGltZXMnLCBbODg1NV1dLCBbJ2NpcicsIFs5Njc1XV0sIFsnY2lyRScsIFsxMDY5MV1dLCBbJ2NpcmUnLCBbODc5MV1dLCBbJ2NpcmZuaW50JywgWzEwNzY4XV0sIFsnY2lybWlkJywgWzEwOTkxXV0sIFsnY2lyc2NpcicsIFsxMDY5MF1dLCBbJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU0XV0sIFsnY2x1YnMnLCBbOTgyN11dLCBbJ2NsdWJzdWl0JywgWzk4MjddXSwgWydjb2xvbicsIFs1OF1dLCBbJ0NvbG9uJywgWzg3NTldXSwgWydDb2xvbmUnLCBbMTA4NjhdXSwgWydjb2xvbmUnLCBbODc4OF1dLCBbJ2NvbG9uZXEnLCBbODc4OF1dLCBbJ2NvbW1hJywgWzQ0XV0sIFsnY29tbWF0JywgWzY0XV0sIFsnY29tcCcsIFs4NzA1XV0sIFsnY29tcGZuJywgWzg3MjhdXSwgWydjb21wbGVtZW50JywgWzg3MDVdXSwgWydjb21wbGV4ZXMnLCBbODQ1MF1dLCBbJ2NvbmcnLCBbODc3M11dLCBbJ2Nvbmdkb3QnLCBbMTA4NjFdXSwgWydDb25ncnVlbnQnLCBbODgwMV1dLCBbJ2NvbmludCcsIFs4NzUwXV0sIFsnQ29uaW50JywgWzg3NTFdXSwgWydDb250b3VySW50ZWdyYWwnLCBbODc1MF1dLCBbJ2NvcGYnLCBbMTIwMTQ4XV0sIFsnQ29wZicsIFs4NDUwXV0sIFsnY29wcm9kJywgWzg3MjBdXSwgWydDb3Byb2R1Y3QnLCBbODcyMF1dLCBbJ2NvcHknLCBbMTY5XV0sIFsnQ09QWScsIFsxNjldXSwgWydjb3B5c3InLCBbODQ3MV1dLCBbJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NV1dLCBbJ2NyYXJyJywgWzg2MjldXSwgWydjcm9zcycsIFsxMDAwN11dLCBbJ0Nyb3NzJywgWzEwNzk5XV0sIFsnQ3NjcicsIFsxMTk5NjZdXSwgWydjc2NyJywgWzExOTk5Ml1dLCBbJ2NzdWInLCBbMTA5NTldXSwgWydjc3ViZScsIFsxMDk2MV1dLCBbJ2NzdXAnLCBbMTA5NjBdXSwgWydjc3VwZScsIFsxMDk2Ml1dLCBbJ2N0ZG90JywgWzg5NDNdXSwgWydjdWRhcnJsJywgWzEwNTUyXV0sIFsnY3VkYXJycicsIFsxMDU0OV1dLCBbJ2N1ZXByJywgWzg5MjZdXSwgWydjdWVzYycsIFs4OTI3XV0sIFsnY3VsYXJyJywgWzg2MzBdXSwgWydjdWxhcnJwJywgWzEwNTU3XV0sIFsnY3VwYnJjYXAnLCBbMTA4MjRdXSwgWydjdXBjYXAnLCBbMTA4MjJdXSwgWydDdXBDYXAnLCBbODc4MV1dLCBbJ2N1cCcsIFs4NzQ2XV0sIFsnQ3VwJywgWzg5MTVdXSwgWydjdXBjdXAnLCBbMTA4MjZdXSwgWydjdXBkb3QnLCBbODg0NV1dLCBbJ2N1cG9yJywgWzEwODIxXV0sIFsnY3VwcycsIFs4NzQ2LCA2NTAyNF1dLCBbJ2N1cmFycicsIFs4NjMxXV0sIFsnY3VyYXJybScsIFsxMDU1Nl1dLCBbJ2N1cmx5ZXFwcmVjJywgWzg5MjZdXSwgWydjdXJseWVxc3VjYycsIFs4OTI3XV0sIFsnY3VybHl2ZWUnLCBbODkxMF1dLCBbJ2N1cmx5d2VkZ2UnLCBbODkxMV1dLCBbJ2N1cnJlbicsIFsxNjRdXSwgWydjdXJ2ZWFycm93bGVmdCcsIFs4NjMwXV0sIFsnY3VydmVhcnJvd3JpZ2h0JywgWzg2MzFdXSwgWydjdXZlZScsIFs4OTEwXV0sIFsnY3V3ZWQnLCBbODkxMV1dLCBbJ2N3Y29uaW50JywgWzg3NTRdXSwgWydjd2ludCcsIFs4NzUzXV0sIFsnY3lsY3R5JywgWzkwMDVdXSwgWydkYWdnZXInLCBbODIyNF1dLCBbJ0RhZ2dlcicsIFs4MjI1XV0sIFsnZGFsZXRoJywgWzg1MDRdXSwgWydkYXJyJywgWzg1OTVdXSwgWydEYXJyJywgWzg2MDldXSwgWydkQXJyJywgWzg2NTldXSwgWydkYXNoJywgWzgyMDhdXSwgWydEYXNodicsIFsxMDk4MF1dLCBbJ2Rhc2h2JywgWzg4NjddXSwgWydkYmthcm93JywgWzEwNTExXV0sIFsnZGJsYWMnLCBbNzMzXV0sIFsnRGNhcm9uJywgWzI3MF1dLCBbJ2RjYXJvbicsIFsyNzFdXSwgWydEY3knLCBbMTA0NF1dLCBbJ2RjeScsIFsxMDc2XV0sIFsnZGRhZ2dlcicsIFs4MjI1XV0sIFsnZGRhcnInLCBbODY1MF1dLCBbJ0REJywgWzg1MTddXSwgWydkZCcsIFs4NTE4XV0sIFsnRERvdHJhaGQnLCBbMTA1MTNdXSwgWydkZG90c2VxJywgWzEwODcxXV0sIFsnZGVnJywgWzE3Nl1dLCBbJ0RlbCcsIFs4NzExXV0sIFsnRGVsdGEnLCBbOTE2XV0sIFsnZGVsdGEnLCBbOTQ4XV0sIFsnZGVtcHR5dicsIFsxMDY3M11dLCBbJ2RmaXNodCcsIFsxMDYyM11dLCBbJ0RmcicsIFsxMjAwNzFdXSwgWydkZnInLCBbMTIwMDk3XV0sIFsnZEhhcicsIFsxMDU5N11dLCBbJ2RoYXJsJywgWzg2NDNdXSwgWydkaGFycicsIFs4NjQyXV0sIFsnRGlhY3JpdGljYWxBY3V0ZScsIFsxODBdXSwgWydEaWFjcml0aWNhbERvdCcsIFs3MjldXSwgWydEaWFjcml0aWNhbERvdWJsZUFjdXRlJywgWzczM11dLCBbJ0RpYWNyaXRpY2FsR3JhdmUnLCBbOTZdXSwgWydEaWFjcml0aWNhbFRpbGRlJywgWzczMl1dLCBbJ2RpYW0nLCBbODkwMF1dLCBbJ2RpYW1vbmQnLCBbODkwMF1dLCBbJ0RpYW1vbmQnLCBbODkwMF1dLCBbJ2RpYW1vbmRzdWl0JywgWzk4MzBdXSwgWydkaWFtcycsIFs5ODMwXV0sIFsnZGllJywgWzE2OF1dLCBbJ0RpZmZlcmVudGlhbEQnLCBbODUxOF1dLCBbJ2RpZ2FtbWEnLCBbOTg5XV0sIFsnZGlzaW4nLCBbODk0Nl1dLCBbJ2RpdicsIFsyNDddXSwgWydkaXZpZGUnLCBbMjQ3XV0sIFsnZGl2aWRlb250aW1lcycsIFs4OTAzXV0sIFsnZGl2b254JywgWzg5MDNdXSwgWydESmN5JywgWzEwMjZdXSwgWydkamN5JywgWzExMDZdXSwgWydkbGNvcm4nLCBbODk5MF1dLCBbJ2RsY3JvcCcsIFs4OTczXV0sIFsnZG9sbGFyJywgWzM2XV0sIFsnRG9wZicsIFsxMjAxMjNdXSwgWydkb3BmJywgWzEyMDE0OV1dLCBbJ0RvdCcsIFsxNjhdXSwgWydkb3QnLCBbNzI5XV0sIFsnRG90RG90JywgWzg0MTJdXSwgWydkb3RlcScsIFs4Nzg0XV0sIFsnZG90ZXFkb3QnLCBbODc4NV1dLCBbJ0RvdEVxdWFsJywgWzg3ODRdXSwgWydkb3RtaW51cycsIFs4NzYwXV0sIFsnZG90cGx1cycsIFs4NzI0XV0sIFsnZG90c3F1YXJlJywgWzg4NjVdXSwgWydkb3VibGViYXJ3ZWRnZScsIFs4OTY2XV0sIFsnRG91YmxlQ29udG91ckludGVncmFsJywgWzg3NTFdXSwgWydEb3VibGVEb3QnLCBbMTY4XV0sIFsnRG91YmxlRG93bkFycm93JywgWzg2NTldXSwgWydEb3VibGVMZWZ0QXJyb3cnLCBbODY1Nl1dLCBbJ0RvdWJsZUxlZnRSaWdodEFycm93JywgWzg2NjBdXSwgWydEb3VibGVMZWZ0VGVlJywgWzEwOTgwXV0sIFsnRG91YmxlTG9uZ0xlZnRBcnJvdycsIFsxMDIzMl1dLCBbJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzNF1dLCBbJ0RvdWJsZUxvbmdSaWdodEFycm93JywgWzEwMjMzXV0sIFsnRG91YmxlUmlnaHRBcnJvdycsIFs4NjU4XV0sIFsnRG91YmxlUmlnaHRUZWUnLCBbODg3Ml1dLCBbJ0RvdWJsZVVwQXJyb3cnLCBbODY1N11dLCBbJ0RvdWJsZVVwRG93bkFycm93JywgWzg2NjFdXSwgWydEb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQxXV0sIFsnRG93bkFycm93QmFyJywgWzEwNTE1XV0sIFsnZG93bmFycm93JywgWzg1OTVdXSwgWydEb3duQXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25hcnJvdycsIFs4NjU5XV0sIFsnRG93bkFycm93VXBBcnJvdycsIFs4NjkzXV0sIFsnRG93bkJyZXZlJywgWzc4NV1dLCBbJ2Rvd25kb3duYXJyb3dzJywgWzg2NTBdXSwgWydkb3duaGFycG9vbmxlZnQnLCBbODY0M11dLCBbJ2Rvd25oYXJwb29ucmlnaHQnLCBbODY0Ml1dLCBbJ0Rvd25MZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzZdXSwgWydEb3duTGVmdFRlZVZlY3RvcicsIFsxMDU5MF1dLCBbJ0Rvd25MZWZ0VmVjdG9yQmFyJywgWzEwNTgyXV0sIFsnRG93bkxlZnRWZWN0b3InLCBbODYzN11dLCBbJ0Rvd25SaWdodFRlZVZlY3RvcicsIFsxMDU5MV1dLCBbJ0Rvd25SaWdodFZlY3RvckJhcicsIFsxMDU4M11dLCBbJ0Rvd25SaWdodFZlY3RvcicsIFs4NjQxXV0sIFsnRG93blRlZUFycm93JywgWzg2MTVdXSwgWydEb3duVGVlJywgWzg4NjhdXSwgWydkcmJrYXJvdycsIFsxMDUxMl1dLCBbJ2RyY29ybicsIFs4OTkxXV0sIFsnZHJjcm9wJywgWzg5NzJdXSwgWydEc2NyJywgWzExOTk2N11dLCBbJ2RzY3InLCBbMTE5OTkzXV0sIFsnRFNjeScsIFsxMDI5XV0sIFsnZHNjeScsIFsxMTA5XV0sIFsnZHNvbCcsIFsxMDc0Ml1dLCBbJ0RzdHJvaycsIFsyNzJdXSwgWydkc3Ryb2snLCBbMjczXV0sIFsnZHRkb3QnLCBbODk0NV1dLCBbJ2R0cmknLCBbOTY2M11dLCBbJ2R0cmlmJywgWzk2NjJdXSwgWydkdWFycicsIFs4NjkzXV0sIFsnZHVoYXInLCBbMTA2MDddXSwgWydkd2FuZ2xlJywgWzEwNjYyXV0sIFsnRFpjeScsIFsxMDM5XV0sIFsnZHpjeScsIFsxMTE5XV0sIFsnZHppZ3JhcnInLCBbMTAyMzldXSwgWydFYWN1dGUnLCBbMjAxXV0sIFsnZWFjdXRlJywgWzIzM11dLCBbJ2Vhc3RlcicsIFsxMDg2Ml1dLCBbJ0VjYXJvbicsIFsyODJdXSwgWydlY2Fyb24nLCBbMjgzXV0sIFsnRWNpcmMnLCBbMjAyXV0sIFsnZWNpcmMnLCBbMjM0XV0sIFsnZWNpcicsIFs4NzkwXV0sIFsnZWNvbG9uJywgWzg3ODldXSwgWydFY3knLCBbMTA2OV1dLCBbJ2VjeScsIFsxMTAxXV0sIFsnZUREb3QnLCBbMTA4NzFdXSwgWydFZG90JywgWzI3OF1dLCBbJ2Vkb3QnLCBbMjc5XV0sIFsnZURvdCcsIFs4Nzg1XV0sIFsnZWUnLCBbODUxOV1dLCBbJ2VmRG90JywgWzg3ODZdXSwgWydFZnInLCBbMTIwMDcyXV0sIFsnZWZyJywgWzEyMDA5OF1dLCBbJ2VnJywgWzEwOTA2XV0sIFsnRWdyYXZlJywgWzIwMF1dLCBbJ2VncmF2ZScsIFsyMzJdXSwgWydlZ3MnLCBbMTA5MDJdXSwgWydlZ3Nkb3QnLCBbMTA5MDRdXSwgWydlbCcsIFsxMDkwNV1dLCBbJ0VsZW1lbnQnLCBbODcxMl1dLCBbJ2VsaW50ZXJzJywgWzkxOTFdXSwgWydlbGwnLCBbODQ2N11dLCBbJ2VscycsIFsxMDkwMV1dLCBbJ2Vsc2RvdCcsIFsxMDkwM11dLCBbJ0VtYWNyJywgWzI3NF1dLCBbJ2VtYWNyJywgWzI3NV1dLCBbJ2VtcHR5JywgWzg3MDldXSwgWydlbXB0eXNldCcsIFs4NzA5XV0sIFsnRW1wdHlTbWFsbFNxdWFyZScsIFs5NzIzXV0sIFsnZW1wdHl2JywgWzg3MDldXSwgWydFbXB0eVZlcnlTbWFsbFNxdWFyZScsIFs5NjQzXV0sIFsnZW1zcDEzJywgWzgxOTZdXSwgWydlbXNwMTQnLCBbODE5N11dLCBbJ2Vtc3AnLCBbODE5NV1dLCBbJ0VORycsIFszMzBdXSwgWydlbmcnLCBbMzMxXV0sIFsnZW5zcCcsIFs4MTk0XV0sIFsnRW9nb24nLCBbMjgwXV0sIFsnZW9nb24nLCBbMjgxXV0sIFsnRW9wZicsIFsxMjAxMjRdXSwgWydlb3BmJywgWzEyMDE1MF1dLCBbJ2VwYXInLCBbODkxN11dLCBbJ2VwYXJzbCcsIFsxMDcyM11dLCBbJ2VwbHVzJywgWzEwODY1XV0sIFsnZXBzaScsIFs5NDldXSwgWydFcHNpbG9uJywgWzkxN11dLCBbJ2Vwc2lsb24nLCBbOTQ5XV0sIFsnZXBzaXYnLCBbMTAxM11dLCBbJ2VxY2lyYycsIFs4NzkwXV0sIFsnZXFjb2xvbicsIFs4Nzg5XV0sIFsnZXFzaW0nLCBbODc3MF1dLCBbJ2Vxc2xhbnRndHInLCBbMTA5MDJdXSwgWydlcXNsYW50bGVzcycsIFsxMDkwMV1dLCBbJ0VxdWFsJywgWzEwODY5XV0sIFsnZXF1YWxzJywgWzYxXV0sIFsnRXF1YWxUaWxkZScsIFs4NzcwXV0sIFsnZXF1ZXN0JywgWzg3OTldXSwgWydFcXVpbGlicml1bScsIFs4NjUyXV0sIFsnZXF1aXYnLCBbODgwMV1dLCBbJ2VxdWl2REQnLCBbMTA4NzJdXSwgWydlcXZwYXJzbCcsIFsxMDcyNV1dLCBbJ2VyYXJyJywgWzEwNjA5XV0sIFsnZXJEb3QnLCBbODc4N11dLCBbJ2VzY3InLCBbODQ5NV1dLCBbJ0VzY3InLCBbODQ5Nl1dLCBbJ2VzZG90JywgWzg3ODRdXSwgWydFc2ltJywgWzEwODY3XV0sIFsnZXNpbScsIFs4NzcwXV0sIFsnRXRhJywgWzkxOV1dLCBbJ2V0YScsIFs5NTFdXSwgWydFVEgnLCBbMjA4XV0sIFsnZXRoJywgWzI0MF1dLCBbJ0V1bWwnLCBbMjAzXV0sIFsnZXVtbCcsIFsyMzVdXSwgWydldXJvJywgWzgzNjRdXSwgWydleGNsJywgWzMzXV0sIFsnZXhpc3QnLCBbODcwN11dLCBbJ0V4aXN0cycsIFs4NzA3XV0sIFsnZXhwZWN0YXRpb24nLCBbODQ5Nl1dLCBbJ2V4cG9uZW50aWFsZScsIFs4NTE5XV0sIFsnRXhwb25lbnRpYWxFJywgWzg1MTldXSwgWydmYWxsaW5nZG90c2VxJywgWzg3ODZdXSwgWydGY3knLCBbMTA2MF1dLCBbJ2ZjeScsIFsxMDkyXV0sIFsnZmVtYWxlJywgWzk3OTJdXSwgWydmZmlsaWcnLCBbNjQyNTldXSwgWydmZmxpZycsIFs2NDI1Nl1dLCBbJ2ZmbGxpZycsIFs2NDI2MF1dLCBbJ0ZmcicsIFsxMjAwNzNdXSwgWydmZnInLCBbMTIwMDk5XV0sIFsnZmlsaWcnLCBbNjQyNTddXSwgWydGaWxsZWRTbWFsbFNxdWFyZScsIFs5NzI0XV0sIFsnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJywgWzk2NDJdXSwgWydmamxpZycsIFsxMDIsIDEwNl1dLCBbJ2ZsYXQnLCBbOTgzN11dLCBbJ2ZsbGlnJywgWzY0MjU4XV0sIFsnZmx0bnMnLCBbOTY0OV1dLCBbJ2Zub2YnLCBbNDAyXV0sIFsnRm9wZicsIFsxMjAxMjVdXSwgWydmb3BmJywgWzEyMDE1MV1dLCBbJ2ZvcmFsbCcsIFs4NzA0XV0sIFsnRm9yQWxsJywgWzg3MDRdXSwgWydmb3JrJywgWzg5MTZdXSwgWydmb3JrdicsIFsxMDk2OV1dLCBbJ0ZvdXJpZXJ0cmYnLCBbODQ5N11dLCBbJ2ZwYXJ0aW50JywgWzEwNzY1XV0sIFsnZnJhYzEyJywgWzE4OV1dLCBbJ2ZyYWMxMycsIFs4NTMxXV0sIFsnZnJhYzE0JywgWzE4OF1dLCBbJ2ZyYWMxNScsIFs4NTMzXV0sIFsnZnJhYzE2JywgWzg1MzddXSwgWydmcmFjMTgnLCBbODUzOV1dLCBbJ2ZyYWMyMycsIFs4NTMyXV0sIFsnZnJhYzI1JywgWzg1MzRdXSwgWydmcmFjMzQnLCBbMTkwXV0sIFsnZnJhYzM1JywgWzg1MzVdXSwgWydmcmFjMzgnLCBbODU0MF1dLCBbJ2ZyYWM0NScsIFs4NTM2XV0sIFsnZnJhYzU2JywgWzg1MzhdXSwgWydmcmFjNTgnLCBbODU0MV1dLCBbJ2ZyYWM3OCcsIFs4NTQyXV0sIFsnZnJhc2wnLCBbODI2MF1dLCBbJ2Zyb3duJywgWzg5OTRdXSwgWydmc2NyJywgWzExOTk5NV1dLCBbJ0ZzY3InLCBbODQ5N11dLCBbJ2dhY3V0ZScsIFs1MDFdXSwgWydHYW1tYScsIFs5MTVdXSwgWydnYW1tYScsIFs5NDddXSwgWydHYW1tYWQnLCBbOTg4XV0sIFsnZ2FtbWFkJywgWzk4OV1dLCBbJ2dhcCcsIFsxMDg4Nl1dLCBbJ0dicmV2ZScsIFsyODZdXSwgWydnYnJldmUnLCBbMjg3XV0sIFsnR2NlZGlsJywgWzI5MF1dLCBbJ0djaXJjJywgWzI4NF1dLCBbJ2djaXJjJywgWzI4NV1dLCBbJ0djeScsIFsxMDQzXV0sIFsnZ2N5JywgWzEwNzVdXSwgWydHZG90JywgWzI4OF1dLCBbJ2dkb3QnLCBbMjg5XV0sIFsnZ2UnLCBbODgwNV1dLCBbJ2dFJywgWzg4MDddXSwgWydnRWwnLCBbMTA4OTJdXSwgWydnZWwnLCBbODkyM11dLCBbJ2dlcScsIFs4ODA1XV0sIFsnZ2VxcScsIFs4ODA3XV0sIFsnZ2Vxc2xhbnQnLCBbMTA4NzhdXSwgWydnZXNjYycsIFsxMDkyMV1dLCBbJ2dlcycsIFsxMDg3OF1dLCBbJ2dlc2RvdCcsIFsxMDg4MF1dLCBbJ2dlc2RvdG8nLCBbMTA4ODJdXSwgWydnZXNkb3RvbCcsIFsxMDg4NF1dLCBbJ2dlc2wnLCBbODkyMywgNjUwMjRdXSwgWydnZXNsZXMnLCBbMTA5MDBdXSwgWydHZnInLCBbMTIwMDc0XV0sIFsnZ2ZyJywgWzEyMDEwMF1dLCBbJ2dnJywgWzg4MTFdXSwgWydHZycsIFs4OTIxXV0sIFsnZ2dnJywgWzg5MjFdXSwgWydnaW1lbCcsIFs4NTAzXV0sIFsnR0pjeScsIFsxMDI3XV0sIFsnZ2pjeScsIFsxMTA3XV0sIFsnZ2xhJywgWzEwOTE3XV0sIFsnZ2wnLCBbODgyM11dLCBbJ2dsRScsIFsxMDg5OF1dLCBbJ2dsaicsIFsxMDkxNl1dLCBbJ2duYXAnLCBbMTA4OTBdXSwgWydnbmFwcHJveCcsIFsxMDg5MF1dLCBbJ2duZScsIFsxMDg4OF1dLCBbJ2duRScsIFs4ODA5XV0sIFsnZ25lcScsIFsxMDg4OF1dLCBbJ2duZXFxJywgWzg4MDldXSwgWydnbnNpbScsIFs4OTM1XV0sIFsnR29wZicsIFsxMjAxMjZdXSwgWydnb3BmJywgWzEyMDE1Ml1dLCBbJ2dyYXZlJywgWzk2XV0sIFsnR3JlYXRlckVxdWFsJywgWzg4MDVdXSwgWydHcmVhdGVyRXF1YWxMZXNzJywgWzg5MjNdXSwgWydHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDddXSwgWydHcmVhdGVyR3JlYXRlcicsIFsxMDkxNF1dLCBbJ0dyZWF0ZXJMZXNzJywgWzg4MjNdXSwgWydHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OF1dLCBbJ0dyZWF0ZXJUaWxkZScsIFs4ODE5XV0sIFsnR3NjcicsIFsxMTk5NzBdXSwgWydnc2NyJywgWzg0NThdXSwgWydnc2ltJywgWzg4MTldXSwgWydnc2ltZScsIFsxMDg5NF1dLCBbJ2dzaW1sJywgWzEwODk2XV0sIFsnZ3RjYycsIFsxMDkxOV1dLCBbJ2d0Y2lyJywgWzEwODc0XV0sIFsnZ3QnLCBbNjJdXSwgWydHVCcsIFs2Ml1dLCBbJ0d0JywgWzg4MTFdXSwgWydndGRvdCcsIFs4OTE5XV0sIFsnZ3RsUGFyJywgWzEwNjQ1XV0sIFsnZ3RxdWVzdCcsIFsxMDg3Nl1dLCBbJ2d0cmFwcHJveCcsIFsxMDg4Nl1dLCBbJ2d0cmFycicsIFsxMDYxNl1dLCBbJ2d0cmRvdCcsIFs4OTE5XV0sIFsnZ3RyZXFsZXNzJywgWzg5MjNdXSwgWydndHJlcXFsZXNzJywgWzEwODkyXV0sIFsnZ3RybGVzcycsIFs4ODIzXV0sIFsnZ3Ryc2ltJywgWzg4MTldXSwgWydndmVydG5lcXEnLCBbODgwOSwgNjUwMjRdXSwgWydndm5FJywgWzg4MDksIDY1MDI0XV0sIFsnSGFjZWsnLCBbNzExXV0sIFsnaGFpcnNwJywgWzgyMDJdXSwgWydoYWxmJywgWzE4OV1dLCBbJ2hhbWlsdCcsIFs4NDU5XV0sIFsnSEFSRGN5JywgWzEwNjZdXSwgWydoYXJkY3knLCBbMTA5OF1dLCBbJ2hhcnJjaXInLCBbMTA1NjhdXSwgWydoYXJyJywgWzg1OTZdXSwgWydoQXJyJywgWzg2NjBdXSwgWydoYXJydycsIFs4NjIxXV0sIFsnSGF0JywgWzk0XV0sIFsnaGJhcicsIFs4NDYzXV0sIFsnSGNpcmMnLCBbMjkyXV0sIFsnaGNpcmMnLCBbMjkzXV0sIFsnaGVhcnRzJywgWzk4MjldXSwgWydoZWFydHN1aXQnLCBbOTgyOV1dLCBbJ2hlbGxpcCcsIFs4MjMwXV0sIFsnaGVyY29uJywgWzg4ODldXSwgWydoZnInLCBbMTIwMTAxXV0sIFsnSGZyJywgWzg0NjBdXSwgWydIaWxiZXJ0U3BhY2UnLCBbODQ1OV1dLCBbJ2hrc2Vhcm93JywgWzEwNTMzXV0sIFsnaGtzd2Fyb3cnLCBbMTA1MzRdXSwgWydob2FycicsIFs4NzAzXV0sIFsnaG9tdGh0JywgWzg3NjNdXSwgWydob29rbGVmdGFycm93JywgWzg2MTddXSwgWydob29rcmlnaHRhcnJvdycsIFs4NjE4XV0sIFsnaG9wZicsIFsxMjAxNTNdXSwgWydIb3BmJywgWzg0NjFdXSwgWydob3JiYXInLCBbODIxM11dLCBbJ0hvcml6b250YWxMaW5lJywgWzk0NzJdXSwgWydoc2NyJywgWzExOTk5N11dLCBbJ0hzY3InLCBbODQ1OV1dLCBbJ2hzbGFzaCcsIFs4NDYzXV0sIFsnSHN0cm9rJywgWzI5NF1dLCBbJ2hzdHJvaycsIFsyOTVdXSwgWydIdW1wRG93bkh1bXAnLCBbODc4Ml1dLCBbJ0h1bXBFcXVhbCcsIFs4NzgzXV0sIFsnaHlidWxsJywgWzgyNTldXSwgWydoeXBoZW4nLCBbODIwOF1dLCBbJ0lhY3V0ZScsIFsyMDVdXSwgWydpYWN1dGUnLCBbMjM3XV0sIFsnaWMnLCBbODI5MV1dLCBbJ0ljaXJjJywgWzIwNl1dLCBbJ2ljaXJjJywgWzIzOF1dLCBbJ0ljeScsIFsxMDQ4XV0sIFsnaWN5JywgWzEwODBdXSwgWydJZG90JywgWzMwNF1dLCBbJ0lFY3knLCBbMTA0NV1dLCBbJ2llY3knLCBbMTA3N11dLCBbJ2lleGNsJywgWzE2MV1dLCBbJ2lmZicsIFs4NjYwXV0sIFsnaWZyJywgWzEyMDEwMl1dLCBbJ0lmcicsIFs4NDY1XV0sIFsnSWdyYXZlJywgWzIwNF1dLCBbJ2lncmF2ZScsIFsyMzZdXSwgWydpaScsIFs4NTIwXV0sIFsnaWlpaW50JywgWzEwNzY0XV0sIFsnaWlpbnQnLCBbODc0OV1dLCBbJ2lpbmZpbicsIFsxMDcxNl1dLCBbJ2lpb3RhJywgWzg0ODldXSwgWydJSmxpZycsIFszMDZdXSwgWydpamxpZycsIFszMDddXSwgWydJbWFjcicsIFsyOThdXSwgWydpbWFjcicsIFsyOTldXSwgWydpbWFnZScsIFs4NDY1XV0sIFsnSW1hZ2luYXJ5SScsIFs4NTIwXV0sIFsnaW1hZ2xpbmUnLCBbODQ2NF1dLCBbJ2ltYWdwYXJ0JywgWzg0NjVdXSwgWydpbWF0aCcsIFszMDVdXSwgWydJbScsIFs4NDY1XV0sIFsnaW1vZicsIFs4ODg3XV0sIFsnaW1wZWQnLCBbNDM3XV0sIFsnSW1wbGllcycsIFs4NjU4XV0sIFsnaW5jYXJlJywgWzg0NTNdXSwgWydpbicsIFs4NzEyXV0sIFsnaW5maW4nLCBbODczNF1dLCBbJ2luZmludGllJywgWzEwNzE3XV0sIFsnaW5vZG90JywgWzMwNV1dLCBbJ2ludGNhbCcsIFs4ODkwXV0sIFsnaW50JywgWzg3NDddXSwgWydJbnQnLCBbODc0OF1dLCBbJ2ludGVnZXJzJywgWzg0ODRdXSwgWydJbnRlZ3JhbCcsIFs4NzQ3XV0sIFsnaW50ZXJjYWwnLCBbODg5MF1dLCBbJ0ludGVyc2VjdGlvbicsIFs4ODk4XV0sIFsnaW50bGFyaGsnLCBbMTA3NzVdXSwgWydpbnRwcm9kJywgWzEwODEyXV0sIFsnSW52aXNpYmxlQ29tbWEnLCBbODI5MV1dLCBbJ0ludmlzaWJsZVRpbWVzJywgWzgyOTBdXSwgWydJT2N5JywgWzEwMjVdXSwgWydpb2N5JywgWzExMDVdXSwgWydJb2dvbicsIFszMDJdXSwgWydpb2dvbicsIFszMDNdXSwgWydJb3BmJywgWzEyMDEyOF1dLCBbJ2lvcGYnLCBbMTIwMTU0XV0sIFsnSW90YScsIFs5MjFdXSwgWydpb3RhJywgWzk1M11dLCBbJ2lwcm9kJywgWzEwODEyXV0sIFsnaXF1ZXN0JywgWzE5MV1dLCBbJ2lzY3InLCBbMTE5OTk4XV0sIFsnSXNjcicsIFs4NDY0XV0sIFsnaXNpbicsIFs4NzEyXV0sIFsnaXNpbmRvdCcsIFs4OTQ5XV0sIFsnaXNpbkUnLCBbODk1M11dLCBbJ2lzaW5zJywgWzg5NDhdXSwgWydpc2luc3YnLCBbODk0N11dLCBbJ2lzaW52JywgWzg3MTJdXSwgWydpdCcsIFs4MjkwXV0sIFsnSXRpbGRlJywgWzI5Nl1dLCBbJ2l0aWxkZScsIFsyOTddXSwgWydJdWtjeScsIFsxMDMwXV0sIFsnaXVrY3knLCBbMTExMF1dLCBbJ0l1bWwnLCBbMjA3XV0sIFsnaXVtbCcsIFsyMzldXSwgWydKY2lyYycsIFszMDhdXSwgWydqY2lyYycsIFszMDldXSwgWydKY3knLCBbMTA0OV1dLCBbJ2pjeScsIFsxMDgxXV0sIFsnSmZyJywgWzEyMDA3N11dLCBbJ2pmcicsIFsxMjAxMDNdXSwgWydqbWF0aCcsIFs1NjddXSwgWydKb3BmJywgWzEyMDEyOV1dLCBbJ2pvcGYnLCBbMTIwMTU1XV0sIFsnSnNjcicsIFsxMTk5NzNdXSwgWydqc2NyJywgWzExOTk5OV1dLCBbJ0pzZXJjeScsIFsxMDMyXV0sIFsnanNlcmN5JywgWzExMTJdXSwgWydKdWtjeScsIFsxMDI4XV0sIFsnanVrY3knLCBbMTEwOF1dLCBbJ0thcHBhJywgWzkyMl1dLCBbJ2thcHBhJywgWzk1NF1dLCBbJ2thcHBhdicsIFsxMDA4XV0sIFsnS2NlZGlsJywgWzMxMF1dLCBbJ2tjZWRpbCcsIFszMTFdXSwgWydLY3knLCBbMTA1MF1dLCBbJ2tjeScsIFsxMDgyXV0sIFsnS2ZyJywgWzEyMDA3OF1dLCBbJ2tmcicsIFsxMjAxMDRdXSwgWydrZ3JlZW4nLCBbMzEyXV0sIFsnS0hjeScsIFsxMDYxXV0sIFsna2hjeScsIFsxMDkzXV0sIFsnS0pjeScsIFsxMDM2XV0sIFsna2pjeScsIFsxMTE2XV0sIFsnS29wZicsIFsxMjAxMzBdXSwgWydrb3BmJywgWzEyMDE1Nl1dLCBbJ0tzY3InLCBbMTE5OTc0XV0sIFsna3NjcicsIFsxMjAwMDBdXSwgWydsQWFycicsIFs4NjY2XV0sIFsnTGFjdXRlJywgWzMxM11dLCBbJ2xhY3V0ZScsIFszMTRdXSwgWydsYWVtcHR5dicsIFsxMDY3Nl1dLCBbJ2xhZ3JhbicsIFs4NDY2XV0sIFsnTGFtYmRhJywgWzkyM11dLCBbJ2xhbWJkYScsIFs5NTVdXSwgWydsYW5nJywgWzEwMjE2XV0sIFsnTGFuZycsIFsxMDIxOF1dLCBbJ2xhbmdkJywgWzEwNjQxXV0sIFsnbGFuZ2xlJywgWzEwMjE2XV0sIFsnbGFwJywgWzEwODg1XV0sIFsnTGFwbGFjZXRyZicsIFs4NDY2XV0sIFsnbGFxdW8nLCBbMTcxXV0sIFsnbGFycmInLCBbODY3Nl1dLCBbJ2xhcnJiZnMnLCBbMTA1MjddXSwgWydsYXJyJywgWzg1OTJdXSwgWydMYXJyJywgWzg2MDZdXSwgWydsQXJyJywgWzg2NTZdXSwgWydsYXJyZnMnLCBbMTA1MjVdXSwgWydsYXJyaGsnLCBbODYxN11dLCBbJ2xhcnJscCcsIFs4NjE5XV0sIFsnbGFycnBsJywgWzEwNTUzXV0sIFsnbGFycnNpbScsIFsxMDYxMV1dLCBbJ2xhcnJ0bCcsIFs4NjEwXV0sIFsnbGF0YWlsJywgWzEwNTIxXV0sIFsnbEF0YWlsJywgWzEwNTIzXV0sIFsnbGF0JywgWzEwOTIzXV0sIFsnbGF0ZScsIFsxMDkyNV1dLCBbJ2xhdGVzJywgWzEwOTI1LCA2NTAyNF1dLCBbJ2xiYXJyJywgWzEwNTA4XV0sIFsnbEJhcnInLCBbMTA1MTBdXSwgWydsYmJyaycsIFsxMDA5OF1dLCBbJ2xicmFjZScsIFsxMjNdXSwgWydsYnJhY2snLCBbOTFdXSwgWydsYnJrZScsIFsxMDYzNV1dLCBbJ2xicmtzbGQnLCBbMTA2MzldXSwgWydsYnJrc2x1JywgWzEwNjM3XV0sIFsnTGNhcm9uJywgWzMxN11dLCBbJ2xjYXJvbicsIFszMThdXSwgWydMY2VkaWwnLCBbMzE1XV0sIFsnbGNlZGlsJywgWzMxNl1dLCBbJ2xjZWlsJywgWzg5NjhdXSwgWydsY3ViJywgWzEyM11dLCBbJ0xjeScsIFsxMDUxXV0sIFsnbGN5JywgWzEwODNdXSwgWydsZGNhJywgWzEwNTUwXV0sIFsnbGRxdW8nLCBbODIyMF1dLCBbJ2xkcXVvcicsIFs4MjIyXV0sIFsnbGRyZGhhcicsIFsxMDU5OV1dLCBbJ2xkcnVzaGFyJywgWzEwNTcxXV0sIFsnbGRzaCcsIFs4NjI2XV0sIFsnbGUnLCBbODgwNF1dLCBbJ2xFJywgWzg4MDZdXSwgWydMZWZ0QW5nbGVCcmFja2V0JywgWzEwMjE2XV0sIFsnTGVmdEFycm93QmFyJywgWzg2NzZdXSwgWydsZWZ0YXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRBcnJvdycsIFs4NTkyXV0sIFsnTGVmdGFycm93JywgWzg2NTZdXSwgWydMZWZ0QXJyb3dSaWdodEFycm93JywgWzg2NDZdXSwgWydsZWZ0YXJyb3d0YWlsJywgWzg2MTBdXSwgWydMZWZ0Q2VpbGluZycsIFs4OTY4XV0sIFsnTGVmdERvdWJsZUJyYWNrZXQnLCBbMTAyMTRdXSwgWydMZWZ0RG93blRlZVZlY3RvcicsIFsxMDU5M11dLCBbJ0xlZnREb3duVmVjdG9yQmFyJywgWzEwNTg1XV0sIFsnTGVmdERvd25WZWN0b3InLCBbODY0M11dLCBbJ0xlZnRGbG9vcicsIFs4OTcwXV0sIFsnbGVmdGhhcnBvb25kb3duJywgWzg2MzddXSwgWydsZWZ0aGFycG9vbnVwJywgWzg2MzZdXSwgWydsZWZ0bGVmdGFycm93cycsIFs4NjQ3XV0sIFsnbGVmdHJpZ2h0YXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRSaWdodEFycm93JywgWzg1OTZdXSwgWydMZWZ0cmlnaHRhcnJvdycsIFs4NjYwXV0sIFsnbGVmdHJpZ2h0YXJyb3dzJywgWzg2NDZdXSwgWydsZWZ0cmlnaHRoYXJwb29ucycsIFs4NjUxXV0sIFsnbGVmdHJpZ2h0c3F1aWdhcnJvdycsIFs4NjIxXV0sIFsnTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc0XV0sIFsnTGVmdFRlZUFycm93JywgWzg2MTJdXSwgWydMZWZ0VGVlJywgWzg4NjddXSwgWydMZWZ0VGVlVmVjdG9yJywgWzEwNTg2XV0sIFsnbGVmdHRocmVldGltZXMnLCBbODkwN11dLCBbJ0xlZnRUcmlhbmdsZUJhcicsIFsxMDcwM11dLCBbJ0xlZnRUcmlhbmdsZScsIFs4ODgyXV0sIFsnTGVmdFRyaWFuZ2xlRXF1YWwnLCBbODg4NF1dLCBbJ0xlZnRVcERvd25WZWN0b3InLCBbMTA1NzddXSwgWydMZWZ0VXBUZWVWZWN0b3InLCBbMTA1OTJdXSwgWydMZWZ0VXBWZWN0b3JCYXInLCBbMTA1ODRdXSwgWydMZWZ0VXBWZWN0b3InLCBbODYzOV1dLCBbJ0xlZnRWZWN0b3JCYXInLCBbMTA1NzhdXSwgWydMZWZ0VmVjdG9yJywgWzg2MzZdXSwgWydsRWcnLCBbMTA4OTFdXSwgWydsZWcnLCBbODkyMl1dLCBbJ2xlcScsIFs4ODA0XV0sIFsnbGVxcScsIFs4ODA2XV0sIFsnbGVxc2xhbnQnLCBbMTA4NzddXSwgWydsZXNjYycsIFsxMDkyMF1dLCBbJ2xlcycsIFsxMDg3N11dLCBbJ2xlc2RvdCcsIFsxMDg3OV1dLCBbJ2xlc2RvdG8nLCBbMTA4ODFdXSwgWydsZXNkb3RvcicsIFsxMDg4M11dLCBbJ2xlc2cnLCBbODkyMiwgNjUwMjRdXSwgWydsZXNnZXMnLCBbMTA4OTldXSwgWydsZXNzYXBwcm94JywgWzEwODg1XV0sIFsnbGVzc2RvdCcsIFs4OTE4XV0sIFsnbGVzc2VxZ3RyJywgWzg5MjJdXSwgWydsZXNzZXFxZ3RyJywgWzEwODkxXV0sIFsnTGVzc0VxdWFsR3JlYXRlcicsIFs4OTIyXV0sIFsnTGVzc0Z1bGxFcXVhbCcsIFs4ODA2XV0sIFsnTGVzc0dyZWF0ZXInLCBbODgyMl1dLCBbJ2xlc3NndHInLCBbODgyMl1dLCBbJ0xlc3NMZXNzJywgWzEwOTEzXV0sIFsnbGVzc3NpbScsIFs4ODE4XV0sIFsnTGVzc1NsYW50RXF1YWwnLCBbMTA4NzddXSwgWydMZXNzVGlsZGUnLCBbODgxOF1dLCBbJ2xmaXNodCcsIFsxMDYyMF1dLCBbJ2xmbG9vcicsIFs4OTcwXV0sIFsnTGZyJywgWzEyMDA3OV1dLCBbJ2xmcicsIFsxMjAxMDVdXSwgWydsZycsIFs4ODIyXV0sIFsnbGdFJywgWzEwODk3XV0sIFsnbEhhcicsIFsxMDU5NF1dLCBbJ2xoYXJkJywgWzg2MzddXSwgWydsaGFydScsIFs4NjM2XV0sIFsnbGhhcnVsJywgWzEwNjAyXV0sIFsnbGhibGsnLCBbOTYwNF1dLCBbJ0xKY3knLCBbMTAzM11dLCBbJ2xqY3knLCBbMTExM11dLCBbJ2xsYXJyJywgWzg2NDddXSwgWydsbCcsIFs4ODEwXV0sIFsnTGwnLCBbODkyMF1dLCBbJ2xsY29ybmVyJywgWzg5OTBdXSwgWydMbGVmdGFycm93JywgWzg2NjZdXSwgWydsbGhhcmQnLCBbMTA2MDNdXSwgWydsbHRyaScsIFs5NzIyXV0sIFsnTG1pZG90JywgWzMxOV1dLCBbJ2xtaWRvdCcsIFszMjBdXSwgWydsbW91c3RhY2hlJywgWzkxMzZdXSwgWydsbW91c3QnLCBbOTEzNl1dLCBbJ2xuYXAnLCBbMTA4ODldXSwgWydsbmFwcHJveCcsIFsxMDg4OV1dLCBbJ2xuZScsIFsxMDg4N11dLCBbJ2xuRScsIFs4ODA4XV0sIFsnbG5lcScsIFsxMDg4N11dLCBbJ2xuZXFxJywgWzg4MDhdXSwgWydsbnNpbScsIFs4OTM0XV0sIFsnbG9hbmcnLCBbMTAyMjBdXSwgWydsb2FycicsIFs4NzAxXV0sIFsnbG9icmsnLCBbMTAyMTRdXSwgWydsb25nbGVmdGFycm93JywgWzEwMjI5XV0sIFsnTG9uZ0xlZnRBcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdsZWZ0YXJyb3cnLCBbMTAyMzJdXSwgWydsb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzFdXSwgWydMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzFdXSwgWydMb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzRdXSwgWydsb25nbWFwc3RvJywgWzEwMjM2XV0sIFsnbG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzBdXSwgWydMb25nUmlnaHRBcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdyaWdodGFycm93JywgWzEwMjMzXV0sIFsnbG9vcGFycm93bGVmdCcsIFs4NjE5XV0sIFsnbG9vcGFycm93cmlnaHQnLCBbODYyMF1dLCBbJ2xvcGFyJywgWzEwNjI5XV0sIFsnTG9wZicsIFsxMjAxMzFdXSwgWydsb3BmJywgWzEyMDE1N11dLCBbJ2xvcGx1cycsIFsxMDc5N11dLCBbJ2xvdGltZXMnLCBbMTA4MDRdXSwgWydsb3dhc3QnLCBbODcyN11dLCBbJ2xvd2JhcicsIFs5NV1dLCBbJ0xvd2VyTGVmdEFycm93JywgWzg2MDFdXSwgWydMb3dlclJpZ2h0QXJyb3cnLCBbODYwMF1dLCBbJ2xveicsIFs5Njc0XV0sIFsnbG96ZW5nZScsIFs5Njc0XV0sIFsnbG96ZicsIFsxMDczMV1dLCBbJ2xwYXInLCBbNDBdXSwgWydscGFybHQnLCBbMTA2NDNdXSwgWydscmFycicsIFs4NjQ2XV0sIFsnbHJjb3JuZXInLCBbODk5MV1dLCBbJ2xyaGFyJywgWzg2NTFdXSwgWydscmhhcmQnLCBbMTA2MDVdXSwgWydscm0nLCBbODIwNl1dLCBbJ2xydHJpJywgWzg4OTVdXSwgWydsc2FxdW8nLCBbODI0OV1dLCBbJ2xzY3InLCBbMTIwMDAxXV0sIFsnTHNjcicsIFs4NDY2XV0sIFsnbHNoJywgWzg2MjRdXSwgWydMc2gnLCBbODYyNF1dLCBbJ2xzaW0nLCBbODgxOF1dLCBbJ2xzaW1lJywgWzEwODkzXV0sIFsnbHNpbWcnLCBbMTA4OTVdXSwgWydsc3FiJywgWzkxXV0sIFsnbHNxdW8nLCBbODIxNl1dLCBbJ2xzcXVvcicsIFs4MjE4XV0sIFsnTHN0cm9rJywgWzMyMV1dLCBbJ2xzdHJvaycsIFszMjJdXSwgWydsdGNjJywgWzEwOTE4XV0sIFsnbHRjaXInLCBbMTA4NzNdXSwgWydsdCcsIFs2MF1dLCBbJ0xUJywgWzYwXV0sIFsnTHQnLCBbODgxMF1dLCBbJ2x0ZG90JywgWzg5MThdXSwgWydsdGhyZWUnLCBbODkwN11dLCBbJ2x0aW1lcycsIFs4OTA1XV0sIFsnbHRsYXJyJywgWzEwNjE0XV0sIFsnbHRxdWVzdCcsIFsxMDg3NV1dLCBbJ2x0cmknLCBbOTY2N11dLCBbJ2x0cmllJywgWzg4ODRdXSwgWydsdHJpZicsIFs5NjY2XV0sIFsnbHRyUGFyJywgWzEwNjQ2XV0sIFsnbHVyZHNoYXInLCBbMTA1NzBdXSwgWydsdXJ1aGFyJywgWzEwNTk4XV0sIFsnbHZlcnRuZXFxJywgWzg4MDgsIDY1MDI0XV0sIFsnbHZuRScsIFs4ODA4LCA2NTAyNF1dLCBbJ21hY3InLCBbMTc1XV0sIFsnbWFsZScsIFs5Nzk0XV0sIFsnbWFsdCcsIFsxMDAxNl1dLCBbJ21hbHRlc2UnLCBbMTAwMTZdXSwgWydNYXAnLCBbMTA1MDFdXSwgWydtYXAnLCBbODYxNF1dLCBbJ21hcHN0bycsIFs4NjE0XV0sIFsnbWFwc3RvZG93bicsIFs4NjE1XV0sIFsnbWFwc3RvbGVmdCcsIFs4NjEyXV0sIFsnbWFwc3RvdXAnLCBbODYxM11dLCBbJ21hcmtlcicsIFs5NjQ2XV0sIFsnbWNvbW1hJywgWzEwNzkzXV0sIFsnTWN5JywgWzEwNTJdXSwgWydtY3knLCBbMTA4NF1dLCBbJ21kYXNoJywgWzgyMTJdXSwgWydtRERvdCcsIFs4NzYyXV0sIFsnbWVhc3VyZWRhbmdsZScsIFs4NzM3XV0sIFsnTWVkaXVtU3BhY2UnLCBbODI4N11dLCBbJ01lbGxpbnRyZicsIFs4NDk5XV0sIFsnTWZyJywgWzEyMDA4MF1dLCBbJ21mcicsIFsxMjAxMDZdXSwgWydtaG8nLCBbODQ4N11dLCBbJ21pY3JvJywgWzE4MV1dLCBbJ21pZGFzdCcsIFs0Ml1dLCBbJ21pZGNpcicsIFsxMDk5Ml1dLCBbJ21pZCcsIFs4NzM5XV0sIFsnbWlkZG90JywgWzE4M11dLCBbJ21pbnVzYicsIFs4ODYzXV0sIFsnbWludXMnLCBbODcyMl1dLCBbJ21pbnVzZCcsIFs4NzYwXV0sIFsnbWludXNkdScsIFsxMDc5NF1dLCBbJ01pbnVzUGx1cycsIFs4NzIzXV0sIFsnbWxjcCcsIFsxMDk3MV1dLCBbJ21sZHInLCBbODIzMF1dLCBbJ21ucGx1cycsIFs4NzIzXV0sIFsnbW9kZWxzJywgWzg4NzFdXSwgWydNb3BmJywgWzEyMDEzMl1dLCBbJ21vcGYnLCBbMTIwMTU4XV0sIFsnbXAnLCBbODcyM11dLCBbJ21zY3InLCBbMTIwMDAyXV0sIFsnTXNjcicsIFs4NDk5XV0sIFsnbXN0cG9zJywgWzg3NjZdXSwgWydNdScsIFs5MjRdXSwgWydtdScsIFs5NTZdXSwgWydtdWx0aW1hcCcsIFs4ODg4XV0sIFsnbXVtYXAnLCBbODg4OF1dLCBbJ25hYmxhJywgWzg3MTFdXSwgWydOYWN1dGUnLCBbMzIzXV0sIFsnbmFjdXRlJywgWzMyNF1dLCBbJ25hbmcnLCBbODczNiwgODQwMl1dLCBbJ25hcCcsIFs4Nzc3XV0sIFsnbmFwRScsIFsxMDg2NCwgODI0XV0sIFsnbmFwaWQnLCBbODc3OSwgODI0XV0sIFsnbmFwb3MnLCBbMzI5XV0sIFsnbmFwcHJveCcsIFs4Nzc3XV0sIFsnbmF0dXJhbCcsIFs5ODM4XV0sIFsnbmF0dXJhbHMnLCBbODQ2OV1dLCBbJ25hdHVyJywgWzk4MzhdXSwgWyduYnNwJywgWzE2MF1dLCBbJ25idW1wJywgWzg3ODIsIDgyNF1dLCBbJ25idW1wZScsIFs4NzgzLCA4MjRdXSwgWyduY2FwJywgWzEwODE5XV0sIFsnTmNhcm9uJywgWzMyN11dLCBbJ25jYXJvbicsIFszMjhdXSwgWydOY2VkaWwnLCBbMzI1XV0sIFsnbmNlZGlsJywgWzMyNl1dLCBbJ25jb25nJywgWzg3NzVdXSwgWyduY29uZ2RvdCcsIFsxMDg2MSwgODI0XV0sIFsnbmN1cCcsIFsxMDgxOF1dLCBbJ05jeScsIFsxMDUzXV0sIFsnbmN5JywgWzEwODVdXSwgWyduZGFzaCcsIFs4MjExXV0sIFsnbmVhcmhrJywgWzEwNTMyXV0sIFsnbmVhcnInLCBbODU5OV1dLCBbJ25lQXJyJywgWzg2NjNdXSwgWyduZWFycm93JywgWzg1OTldXSwgWyduZScsIFs4ODAwXV0sIFsnbmVkb3QnLCBbODc4NCwgODI0XV0sIFsnTmVnYXRpdmVNZWRpdW1TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGlja1NwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJywgWzgyMDNdXSwgWyduZXF1aXYnLCBbODgwMl1dLCBbJ25lc2VhcicsIFsxMDUzNl1dLCBbJ25lc2ltJywgWzg3NzAsIDgyNF1dLCBbJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzg4MTFdXSwgWydOZXN0ZWRMZXNzTGVzcycsIFs4ODEwXV0sIFsnbmV4aXN0JywgWzg3MDhdXSwgWyduZXhpc3RzJywgWzg3MDhdXSwgWydOZnInLCBbMTIwMDgxXV0sIFsnbmZyJywgWzEyMDEwN11dLCBbJ25nRScsIFs4ODA3LCA4MjRdXSwgWyduZ2UnLCBbODgxN11dLCBbJ25nZXEnLCBbODgxN11dLCBbJ25nZXFxJywgWzg4MDcsIDgyNF1dLCBbJ25nZXFzbGFudCcsIFsxMDg3OCwgODI0XV0sIFsnbmdlcycsIFsxMDg3OCwgODI0XV0sIFsnbkdnJywgWzg5MjEsIDgyNF1dLCBbJ25nc2ltJywgWzg4MjFdXSwgWyduR3QnLCBbODgxMSwgODQwMl1dLCBbJ25ndCcsIFs4ODE1XV0sIFsnbmd0cicsIFs4ODE1XV0sIFsnbkd0dicsIFs4ODExLCA4MjRdXSwgWyduaGFycicsIFs4NjIyXV0sIFsnbmhBcnInLCBbODY1NF1dLCBbJ25ocGFyJywgWzEwOTk0XV0sIFsnbmknLCBbODcxNV1dLCBbJ25pcycsIFs4OTU2XV0sIFsnbmlzZCcsIFs4OTU0XV0sIFsnbml2JywgWzg3MTVdXSwgWydOSmN5JywgWzEwMzRdXSwgWyduamN5JywgWzExMTRdXSwgWydubGFycicsIFs4NjAyXV0sIFsnbmxBcnInLCBbODY1M11dLCBbJ25sZHInLCBbODIyOV1dLCBbJ25sRScsIFs4ODA2LCA4MjRdXSwgWydubGUnLCBbODgxNl1dLCBbJ25sZWZ0YXJyb3cnLCBbODYwMl1dLCBbJ25MZWZ0YXJyb3cnLCBbODY1M11dLCBbJ25sZWZ0cmlnaHRhcnJvdycsIFs4NjIyXV0sIFsnbkxlZnRyaWdodGFycm93JywgWzg2NTRdXSwgWydubGVxJywgWzg4MTZdXSwgWydubGVxcScsIFs4ODA2LCA4MjRdXSwgWydubGVxc2xhbnQnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXMnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXNzJywgWzg4MTRdXSwgWyduTGwnLCBbODkyMCwgODI0XV0sIFsnbmxzaW0nLCBbODgyMF1dLCBbJ25MdCcsIFs4ODEwLCA4NDAyXV0sIFsnbmx0JywgWzg4MTRdXSwgWydubHRyaScsIFs4OTM4XV0sIFsnbmx0cmllJywgWzg5NDBdXSwgWyduTHR2JywgWzg4MTAsIDgyNF1dLCBbJ25taWQnLCBbODc0MF1dLCBbJ05vQnJlYWsnLCBbODI4OF1dLCBbJ05vbkJyZWFraW5nU3BhY2UnLCBbMTYwXV0sIFsnbm9wZicsIFsxMjAxNTldXSwgWydOb3BmJywgWzg0NjldXSwgWydOb3QnLCBbMTA5ODhdXSwgWydub3QnLCBbMTcyXV0sIFsnTm90Q29uZ3J1ZW50JywgWzg4MDJdXSwgWydOb3RDdXBDYXAnLCBbODgxM11dLCBbJ05vdERvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDJdXSwgWydOb3RFbGVtZW50JywgWzg3MTNdXSwgWydOb3RFcXVhbCcsIFs4ODAwXV0sIFsnTm90RXF1YWxUaWxkZScsIFs4NzcwLCA4MjRdXSwgWydOb3RFeGlzdHMnLCBbODcwOF1dLCBbJ05vdEdyZWF0ZXInLCBbODgxNV1dLCBbJ05vdEdyZWF0ZXJFcXVhbCcsIFs4ODE3XV0sIFsnTm90R3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3LCA4MjRdXSwgWydOb3RHcmVhdGVyR3JlYXRlcicsIFs4ODExLCA4MjRdXSwgWydOb3RHcmVhdGVyTGVzcycsIFs4ODI1XV0sIFsnTm90R3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzgsIDgyNF1dLCBbJ05vdEdyZWF0ZXJUaWxkZScsIFs4ODIxXV0sIFsnTm90SHVtcERvd25IdW1wJywgWzg3ODIsIDgyNF1dLCBbJ05vdEh1bXBFcXVhbCcsIFs4NzgzLCA4MjRdXSwgWydub3RpbicsIFs4NzEzXV0sIFsnbm90aW5kb3QnLCBbODk0OSwgODI0XV0sIFsnbm90aW5FJywgWzg5NTMsIDgyNF1dLCBbJ25vdGludmEnLCBbODcxM11dLCBbJ25vdGludmInLCBbODk1MV1dLCBbJ25vdGludmMnLCBbODk1MF1dLCBbJ05vdExlZnRUcmlhbmdsZUJhcicsIFsxMDcwMywgODI0XV0sIFsnTm90TGVmdFRyaWFuZ2xlJywgWzg5MzhdXSwgWydOb3RMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4OTQwXV0sIFsnTm90TGVzcycsIFs4ODE0XV0sIFsnTm90TGVzc0VxdWFsJywgWzg4MTZdXSwgWydOb3RMZXNzR3JlYXRlcicsIFs4ODI0XV0sIFsnTm90TGVzc0xlc3MnLCBbODgxMCwgODI0XV0sIFsnTm90TGVzc1NsYW50RXF1YWwnLCBbMTA4NzcsIDgyNF1dLCBbJ05vdExlc3NUaWxkZScsIFs4ODIwXV0sIFsnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbMTA5MTQsIDgyNF1dLCBbJ05vdE5lc3RlZExlc3NMZXNzJywgWzEwOTEzLCA4MjRdXSwgWydub3RuaScsIFs4NzE2XV0sIFsnbm90bml2YScsIFs4NzE2XV0sIFsnbm90bml2YicsIFs4OTU4XV0sIFsnbm90bml2YycsIFs4OTU3XV0sIFsnTm90UHJlY2VkZXMnLCBbODgzMl1dLCBbJ05vdFByZWNlZGVzRXF1YWwnLCBbMTA5MjcsIDgyNF1dLCBbJ05vdFByZWNlZGVzU2xhbnRFcXVhbCcsIFs4OTI4XV0sIFsnTm90UmV2ZXJzZUVsZW1lbnQnLCBbODcxNl1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDQsIDgyNF1dLCBbJ05vdFJpZ2h0VHJpYW5nbGUnLCBbODkzOV1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4OTQxXV0sIFsnTm90U3F1YXJlU3Vic2V0JywgWzg4NDcsIDgyNF1dLCBbJ05vdFNxdWFyZVN1YnNldEVxdWFsJywgWzg5MzBdXSwgWydOb3RTcXVhcmVTdXBlcnNldCcsIFs4ODQ4LCA4MjRdXSwgWydOb3RTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg5MzFdXSwgWydOb3RTdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ05vdFN1YnNldEVxdWFsJywgWzg4NDBdXSwgWydOb3RTdWNjZWVkcycsIFs4ODMzXV0sIFsnTm90U3VjY2VlZHNFcXVhbCcsIFsxMDkyOCwgODI0XV0sIFsnTm90U3VjY2VlZHNTbGFudEVxdWFsJywgWzg5MjldXSwgWydOb3RTdWNjZWVkc1RpbGRlJywgWzg4MzEsIDgyNF1dLCBbJ05vdFN1cGVyc2V0JywgWzg4MzUsIDg0MDJdXSwgWydOb3RTdXBlcnNldEVxdWFsJywgWzg4NDFdXSwgWydOb3RUaWxkZScsIFs4NzY5XV0sIFsnTm90VGlsZGVFcXVhbCcsIFs4NzcyXV0sIFsnTm90VGlsZGVGdWxsRXF1YWwnLCBbODc3NV1dLCBbJ05vdFRpbGRlVGlsZGUnLCBbODc3N11dLCBbJ05vdFZlcnRpY2FsQmFyJywgWzg3NDBdXSwgWyducGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25wYXInLCBbODc0Ml1dLCBbJ25wYXJzbCcsIFsxMTAwNSwgODQyMV1dLCBbJ25wYXJ0JywgWzg3MDYsIDgyNF1dLCBbJ25wb2xpbnQnLCBbMTA3NzJdXSwgWyducHInLCBbODgzMl1dLCBbJ25wcmN1ZScsIFs4OTI4XV0sIFsnbnByZWMnLCBbODgzMl1dLCBbJ25wcmVjZXEnLCBbMTA5MjcsIDgyNF1dLCBbJ25wcmUnLCBbMTA5MjcsIDgyNF1dLCBbJ25yYXJyYycsIFsxMDU0NywgODI0XV0sIFsnbnJhcnInLCBbODYwM11dLCBbJ25yQXJyJywgWzg2NTVdXSwgWyducmFycncnLCBbODYwNSwgODI0XV0sIFsnbnJpZ2h0YXJyb3cnLCBbODYwM11dLCBbJ25SaWdodGFycm93JywgWzg2NTVdXSwgWyducnRyaScsIFs4OTM5XV0sIFsnbnJ0cmllJywgWzg5NDFdXSwgWyduc2MnLCBbODgzM11dLCBbJ25zY2N1ZScsIFs4OTI5XV0sIFsnbnNjZScsIFsxMDkyOCwgODI0XV0sIFsnTnNjcicsIFsxMTk5NzddXSwgWyduc2NyJywgWzEyMDAwM11dLCBbJ25zaG9ydG1pZCcsIFs4NzQwXV0sIFsnbnNob3J0cGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25zaW0nLCBbODc2OV1dLCBbJ25zaW1lJywgWzg3NzJdXSwgWyduc2ltZXEnLCBbODc3Ml1dLCBbJ25zbWlkJywgWzg3NDBdXSwgWyduc3BhcicsIFs4NzQyXV0sIFsnbnNxc3ViZScsIFs4OTMwXV0sIFsnbnNxc3VwZScsIFs4OTMxXV0sIFsnbnN1YicsIFs4ODM2XV0sIFsnbnN1YkUnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWJlJywgWzg4NDBdXSwgWyduc3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWyduc3Vic2V0ZXEnLCBbODg0MF1dLCBbJ25zdWJzZXRlcXEnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWNjJywgWzg4MzNdXSwgWyduc3VjY2VxJywgWzEwOTI4LCA4MjRdXSwgWyduc3VwJywgWzg4MzddXSwgWyduc3VwRScsIFsxMDk1MCwgODI0XV0sIFsnbnN1cGUnLCBbODg0MV1dLCBbJ25zdXBzZXQnLCBbODgzNSwgODQwMl1dLCBbJ25zdXBzZXRlcScsIFs4ODQxXV0sIFsnbnN1cHNldGVxcScsIFsxMDk1MCwgODI0XV0sIFsnbnRnbCcsIFs4ODI1XV0sIFsnTnRpbGRlJywgWzIwOV1dLCBbJ250aWxkZScsIFsyNDFdXSwgWydudGxnJywgWzg4MjRdXSwgWydudHJpYW5nbGVsZWZ0JywgWzg5MzhdXSwgWydudHJpYW5nbGVsZWZ0ZXEnLCBbODk0MF1dLCBbJ250cmlhbmdsZXJpZ2h0JywgWzg5MzldXSwgWydudHJpYW5nbGVyaWdodGVxJywgWzg5NDFdXSwgWydOdScsIFs5MjVdXSwgWydudScsIFs5NTddXSwgWydudW0nLCBbMzVdXSwgWydudW1lcm8nLCBbODQ3MF1dLCBbJ251bXNwJywgWzgxOTldXSwgWydudmFwJywgWzg3ODEsIDg0MDJdXSwgWydudmRhc2gnLCBbODg3Nl1dLCBbJ252RGFzaCcsIFs4ODc3XV0sIFsnblZkYXNoJywgWzg4NzhdXSwgWyduVkRhc2gnLCBbODg3OV1dLCBbJ252Z2UnLCBbODgwNSwgODQwMl1dLCBbJ252Z3QnLCBbNjIsIDg0MDJdXSwgWydudkhhcnInLCBbMTA1MDBdXSwgWydudmluZmluJywgWzEwNzE4XV0sIFsnbnZsQXJyJywgWzEwNDk4XV0sIFsnbnZsZScsIFs4ODA0LCA4NDAyXV0sIFsnbnZsdCcsIFs2MCwgODQwMl1dLCBbJ252bHRyaWUnLCBbODg4NCwgODQwMl1dLCBbJ252ckFycicsIFsxMDQ5OV1dLCBbJ252cnRyaWUnLCBbODg4NSwgODQwMl1dLCBbJ252c2ltJywgWzg3NjQsIDg0MDJdXSwgWydud2FyaGsnLCBbMTA1MzFdXSwgWydud2FycicsIFs4NTk4XV0sIFsnbndBcnInLCBbODY2Ml1dLCBbJ253YXJyb3cnLCBbODU5OF1dLCBbJ253bmVhcicsIFsxMDUzNV1dLCBbJ09hY3V0ZScsIFsyMTFdXSwgWydvYWN1dGUnLCBbMjQzXV0sIFsnb2FzdCcsIFs4ODU5XV0sIFsnT2NpcmMnLCBbMjEyXV0sIFsnb2NpcmMnLCBbMjQ0XV0sIFsnb2NpcicsIFs4ODU4XV0sIFsnT2N5JywgWzEwNTRdXSwgWydvY3knLCBbMTA4Nl1dLCBbJ29kYXNoJywgWzg4NjFdXSwgWydPZGJsYWMnLCBbMzM2XV0sIFsnb2RibGFjJywgWzMzN11dLCBbJ29kaXYnLCBbMTA4MDhdXSwgWydvZG90JywgWzg4NTddXSwgWydvZHNvbGQnLCBbMTA2ODRdXSwgWydPRWxpZycsIFszMzhdXSwgWydvZWxpZycsIFszMzldXSwgWydvZmNpcicsIFsxMDY4N11dLCBbJ09mcicsIFsxMjAwODJdXSwgWydvZnInLCBbMTIwMTA4XV0sIFsnb2dvbicsIFs3MzFdXSwgWydPZ3JhdmUnLCBbMjEwXV0sIFsnb2dyYXZlJywgWzI0Ml1dLCBbJ29ndCcsIFsxMDY4OV1dLCBbJ29oYmFyJywgWzEwNjc3XV0sIFsnb2htJywgWzkzN11dLCBbJ29pbnQnLCBbODc1MF1dLCBbJ29sYXJyJywgWzg2MzRdXSwgWydvbGNpcicsIFsxMDY4Nl1dLCBbJ29sY3Jvc3MnLCBbMTA2ODNdXSwgWydvbGluZScsIFs4MjU0XV0sIFsnb2x0JywgWzEwNjg4XV0sIFsnT21hY3InLCBbMzMyXV0sIFsnb21hY3InLCBbMzMzXV0sIFsnT21lZ2EnLCBbOTM3XV0sIFsnb21lZ2EnLCBbOTY5XV0sIFsnT21pY3JvbicsIFs5MjddXSwgWydvbWljcm9uJywgWzk1OV1dLCBbJ29taWQnLCBbMTA2NzhdXSwgWydvbWludXMnLCBbODg1NF1dLCBbJ09vcGYnLCBbMTIwMTM0XV0sIFsnb29wZicsIFsxMjAxNjBdXSwgWydvcGFyJywgWzEwNjc5XV0sIFsnT3BlbkN1cmx5RG91YmxlUXVvdGUnLCBbODIyMF1dLCBbJ09wZW5DdXJseVF1b3RlJywgWzgyMTZdXSwgWydvcGVycCcsIFsxMDY4MV1dLCBbJ29wbHVzJywgWzg4NTNdXSwgWydvcmFycicsIFs4NjM1XV0sIFsnT3InLCBbMTA4MzZdXSwgWydvcicsIFs4NzQ0XV0sIFsnb3JkJywgWzEwODQ1XV0sIFsnb3JkZXInLCBbODUwMF1dLCBbJ29yZGVyb2YnLCBbODUwMF1dLCBbJ29yZGYnLCBbMTcwXV0sIFsnb3JkbScsIFsxODZdXSwgWydvcmlnb2YnLCBbODg4Nl1dLCBbJ29yb3InLCBbMTA4MzhdXSwgWydvcnNsb3BlJywgWzEwODM5XV0sIFsnb3J2JywgWzEwODQzXV0sIFsnb1MnLCBbOTQxNl1dLCBbJ09zY3InLCBbMTE5OTc4XV0sIFsnb3NjcicsIFs4NTAwXV0sIFsnT3NsYXNoJywgWzIxNl1dLCBbJ29zbGFzaCcsIFsyNDhdXSwgWydvc29sJywgWzg4NTZdXSwgWydPdGlsZGUnLCBbMjEzXV0sIFsnb3RpbGRlJywgWzI0NV1dLCBbJ290aW1lc2FzJywgWzEwODA2XV0sIFsnT3RpbWVzJywgWzEwODA3XV0sIFsnb3RpbWVzJywgWzg4NTVdXSwgWydPdW1sJywgWzIxNF1dLCBbJ291bWwnLCBbMjQ2XV0sIFsnb3ZiYXInLCBbOTAyMV1dLCBbJ092ZXJCYXInLCBbODI1NF1dLCBbJ092ZXJCcmFjZScsIFs5MTgyXV0sIFsnT3ZlckJyYWNrZXQnLCBbOTE0MF1dLCBbJ092ZXJQYXJlbnRoZXNpcycsIFs5MTgwXV0sIFsncGFyYScsIFsxODJdXSwgWydwYXJhbGxlbCcsIFs4NzQxXV0sIFsncGFyJywgWzg3NDFdXSwgWydwYXJzaW0nLCBbMTA5OTVdXSwgWydwYXJzbCcsIFsxMTAwNV1dLCBbJ3BhcnQnLCBbODcwNl1dLCBbJ1BhcnRpYWxEJywgWzg3MDZdXSwgWydQY3knLCBbMTA1NV1dLCBbJ3BjeScsIFsxMDg3XV0sIFsncGVyY250JywgWzM3XV0sIFsncGVyaW9kJywgWzQ2XV0sIFsncGVybWlsJywgWzgyNDBdXSwgWydwZXJwJywgWzg4NjldXSwgWydwZXJ0ZW5rJywgWzgyNDFdXSwgWydQZnInLCBbMTIwMDgzXV0sIFsncGZyJywgWzEyMDEwOV1dLCBbJ1BoaScsIFs5MzRdXSwgWydwaGknLCBbOTY2XV0sIFsncGhpdicsIFs5ODFdXSwgWydwaG1tYXQnLCBbODQ5OV1dLCBbJ3Bob25lJywgWzk3NDJdXSwgWydQaScsIFs5MjhdXSwgWydwaScsIFs5NjBdXSwgWydwaXRjaGZvcmsnLCBbODkxNl1dLCBbJ3BpdicsIFs5ODJdXSwgWydwbGFuY2snLCBbODQ2M11dLCBbJ3BsYW5ja2gnLCBbODQ2Ml1dLCBbJ3BsYW5rdicsIFs4NDYzXV0sIFsncGx1c2FjaXInLCBbMTA3ODddXSwgWydwbHVzYicsIFs4ODYyXV0sIFsncGx1c2NpcicsIFsxMDc4Nl1dLCBbJ3BsdXMnLCBbNDNdXSwgWydwbHVzZG8nLCBbODcyNF1dLCBbJ3BsdXNkdScsIFsxMDc4OV1dLCBbJ3BsdXNlJywgWzEwODY2XV0sIFsnUGx1c01pbnVzJywgWzE3N11dLCBbJ3BsdXNtbicsIFsxNzddXSwgWydwbHVzc2ltJywgWzEwNzkwXV0sIFsncGx1c3R3bycsIFsxMDc5MV1dLCBbJ3BtJywgWzE3N11dLCBbJ1BvaW5jYXJlcGxhbmUnLCBbODQ2MF1dLCBbJ3BvaW50aW50JywgWzEwNzczXV0sIFsncG9wZicsIFsxMjAxNjFdXSwgWydQb3BmJywgWzg0NzNdXSwgWydwb3VuZCcsIFsxNjNdXSwgWydwcmFwJywgWzEwOTM1XV0sIFsnUHInLCBbMTA5MzldXSwgWydwcicsIFs4ODI2XV0sIFsncHJjdWUnLCBbODgyOF1dLCBbJ3ByZWNhcHByb3gnLCBbMTA5MzVdXSwgWydwcmVjJywgWzg4MjZdXSwgWydwcmVjY3VybHllcScsIFs4ODI4XV0sIFsnUHJlY2VkZXMnLCBbODgyNl1dLCBbJ1ByZWNlZGVzRXF1YWwnLCBbMTA5MjddXSwgWydQcmVjZWRlc1NsYW50RXF1YWwnLCBbODgyOF1dLCBbJ1ByZWNlZGVzVGlsZGUnLCBbODgzMF1dLCBbJ3ByZWNlcScsIFsxMDkyN11dLCBbJ3ByZWNuYXBwcm94JywgWzEwOTM3XV0sIFsncHJlY25lcXEnLCBbMTA5MzNdXSwgWydwcmVjbnNpbScsIFs4OTM2XV0sIFsncHJlJywgWzEwOTI3XV0sIFsncHJFJywgWzEwOTMxXV0sIFsncHJlY3NpbScsIFs4ODMwXV0sIFsncHJpbWUnLCBbODI0Ml1dLCBbJ1ByaW1lJywgWzgyNDNdXSwgWydwcmltZXMnLCBbODQ3M11dLCBbJ3BybmFwJywgWzEwOTM3XV0sIFsncHJuRScsIFsxMDkzM11dLCBbJ3BybnNpbScsIFs4OTM2XV0sIFsncHJvZCcsIFs4NzE5XV0sIFsnUHJvZHVjdCcsIFs4NzE5XV0sIFsncHJvZmFsYXInLCBbOTAwNl1dLCBbJ3Byb2ZsaW5lJywgWzg5NzhdXSwgWydwcm9mc3VyZicsIFs4OTc5XV0sIFsncHJvcCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbmFsJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uJywgWzg3NTldXSwgWydwcm9wdG8nLCBbODczM11dLCBbJ3Byc2ltJywgWzg4MzBdXSwgWydwcnVyZWwnLCBbODg4MF1dLCBbJ1BzY3InLCBbMTE5OTc5XV0sIFsncHNjcicsIFsxMjAwMDVdXSwgWydQc2knLCBbOTM2XV0sIFsncHNpJywgWzk2OF1dLCBbJ3B1bmNzcCcsIFs4MjAwXV0sIFsnUWZyJywgWzEyMDA4NF1dLCBbJ3FmcicsIFsxMjAxMTBdXSwgWydxaW50JywgWzEwNzY0XV0sIFsncW9wZicsIFsxMjAxNjJdXSwgWydRb3BmJywgWzg0NzRdXSwgWydxcHJpbWUnLCBbODI3OV1dLCBbJ1FzY3InLCBbMTE5OTgwXV0sIFsncXNjcicsIFsxMjAwMDZdXSwgWydxdWF0ZXJuaW9ucycsIFs4NDYxXV0sIFsncXVhdGludCcsIFsxMDc3NF1dLCBbJ3F1ZXN0JywgWzYzXV0sIFsncXVlc3RlcScsIFs4Nzk5XV0sIFsncXVvdCcsIFszNF1dLCBbJ1FVT1QnLCBbMzRdXSwgWydyQWFycicsIFs4NjY3XV0sIFsncmFjZScsIFs4NzY1LCA4MTddXSwgWydSYWN1dGUnLCBbMzQwXV0sIFsncmFjdXRlJywgWzM0MV1dLCBbJ3JhZGljJywgWzg3MzBdXSwgWydyYWVtcHR5dicsIFsxMDY3NV1dLCBbJ3JhbmcnLCBbMTAyMTddXSwgWydSYW5nJywgWzEwMjE5XV0sIFsncmFuZ2QnLCBbMTA2NDJdXSwgWydyYW5nZScsIFsxMDY2MV1dLCBbJ3JhbmdsZScsIFsxMDIxN11dLCBbJ3JhcXVvJywgWzE4N11dLCBbJ3JhcnJhcCcsIFsxMDYxM11dLCBbJ3JhcnJiJywgWzg2NzddXSwgWydyYXJyYmZzJywgWzEwNTI4XV0sIFsncmFycmMnLCBbMTA1NDddXSwgWydyYXJyJywgWzg1OTRdXSwgWydSYXJyJywgWzg2MDhdXSwgWydyQXJyJywgWzg2NThdXSwgWydyYXJyZnMnLCBbMTA1MjZdXSwgWydyYXJyaGsnLCBbODYxOF1dLCBbJ3JhcnJscCcsIFs4NjIwXV0sIFsncmFycnBsJywgWzEwNTY1XV0sIFsncmFycnNpbScsIFsxMDYxMl1dLCBbJ1JhcnJ0bCcsIFsxMDUxOF1dLCBbJ3JhcnJ0bCcsIFs4NjExXV0sIFsncmFycncnLCBbODYwNV1dLCBbJ3JhdGFpbCcsIFsxMDUyMl1dLCBbJ3JBdGFpbCcsIFsxMDUyNF1dLCBbJ3JhdGlvJywgWzg3NThdXSwgWydyYXRpb25hbHMnLCBbODQ3NF1dLCBbJ3JiYXJyJywgWzEwNTA5XV0sIFsnckJhcnInLCBbMTA1MTFdXSwgWydSQmFycicsIFsxMDUxMl1dLCBbJ3JiYnJrJywgWzEwMDk5XV0sIFsncmJyYWNlJywgWzEyNV1dLCBbJ3JicmFjaycsIFs5M11dLCBbJ3JicmtlJywgWzEwNjM2XV0sIFsncmJya3NsZCcsIFsxMDYzOF1dLCBbJ3JicmtzbHUnLCBbMTA2NDBdXSwgWydSY2Fyb24nLCBbMzQ0XV0sIFsncmNhcm9uJywgWzM0NV1dLCBbJ1JjZWRpbCcsIFszNDJdXSwgWydyY2VkaWwnLCBbMzQzXV0sIFsncmNlaWwnLCBbODk2OV1dLCBbJ3JjdWInLCBbMTI1XV0sIFsnUmN5JywgWzEwNTZdXSwgWydyY3knLCBbMTA4OF1dLCBbJ3JkY2EnLCBbMTA1NTFdXSwgWydyZGxkaGFyJywgWzEwNjAxXV0sIFsncmRxdW8nLCBbODIyMV1dLCBbJ3JkcXVvcicsIFs4MjIxXV0sIFsnQ2xvc2VDdXJseURvdWJsZVF1b3RlJywgWzgyMjFdXSwgWydyZHNoJywgWzg2MjddXSwgWydyZWFsJywgWzg0NzZdXSwgWydyZWFsaW5lJywgWzg0NzVdXSwgWydyZWFscGFydCcsIFs4NDc2XV0sIFsncmVhbHMnLCBbODQ3N11dLCBbJ1JlJywgWzg0NzZdXSwgWydyZWN0JywgWzk2NDVdXSwgWydyZWcnLCBbMTc0XV0sIFsnUkVHJywgWzE3NF1dLCBbJ1JldmVyc2VFbGVtZW50JywgWzg3MTVdXSwgWydSZXZlcnNlRXF1aWxpYnJpdW0nLCBbODY1MV1dLCBbJ1JldmVyc2VVcEVxdWlsaWJyaXVtJywgWzEwNjA3XV0sIFsncmZpc2h0JywgWzEwNjIxXV0sIFsncmZsb29yJywgWzg5NzFdXSwgWydyZnInLCBbMTIwMTExXV0sIFsnUmZyJywgWzg0NzZdXSwgWydySGFyJywgWzEwNTk2XV0sIFsncmhhcmQnLCBbODY0MV1dLCBbJ3JoYXJ1JywgWzg2NDBdXSwgWydyaGFydWwnLCBbMTA2MDRdXSwgWydSaG8nLCBbOTI5XV0sIFsncmhvJywgWzk2MV1dLCBbJ3Job3YnLCBbMTAwOV1dLCBbJ1JpZ2h0QW5nbGVCcmFja2V0JywgWzEwMjE3XV0sIFsnUmlnaHRBcnJvd0JhcicsIFs4Njc3XV0sIFsncmlnaHRhcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRhcnJvdycsIFs4NjU4XV0sIFsnUmlnaHRBcnJvd0xlZnRBcnJvdycsIFs4NjQ0XV0sIFsncmlnaHRhcnJvd3RhaWwnLCBbODYxMV1dLCBbJ1JpZ2h0Q2VpbGluZycsIFs4OTY5XV0sIFsnUmlnaHREb3VibGVCcmFja2V0JywgWzEwMjE1XV0sIFsnUmlnaHREb3duVGVlVmVjdG9yJywgWzEwNTg5XV0sIFsnUmlnaHREb3duVmVjdG9yQmFyJywgWzEwNTgxXV0sIFsnUmlnaHREb3duVmVjdG9yJywgWzg2NDJdXSwgWydSaWdodEZsb29yJywgWzg5NzFdXSwgWydyaWdodGhhcnBvb25kb3duJywgWzg2NDFdXSwgWydyaWdodGhhcnBvb251cCcsIFs4NjQwXV0sIFsncmlnaHRsZWZ0YXJyb3dzJywgWzg2NDRdXSwgWydyaWdodGxlZnRoYXJwb29ucycsIFs4NjUyXV0sIFsncmlnaHRyaWdodGFycm93cycsIFs4NjQ5XV0sIFsncmlnaHRzcXVpZ2Fycm93JywgWzg2MDVdXSwgWydSaWdodFRlZUFycm93JywgWzg2MTRdXSwgWydSaWdodFRlZScsIFs4ODY2XV0sIFsnUmlnaHRUZWVWZWN0b3InLCBbMTA1ODddXSwgWydyaWdodHRocmVldGltZXMnLCBbODkwOF1dLCBbJ1JpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDRdXSwgWydSaWdodFRyaWFuZ2xlJywgWzg4ODNdXSwgWydSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODg4NV1dLCBbJ1JpZ2h0VXBEb3duVmVjdG9yJywgWzEwNTc1XV0sIFsnUmlnaHRVcFRlZVZlY3RvcicsIFsxMDU4OF1dLCBbJ1JpZ2h0VXBWZWN0b3JCYXInLCBbMTA1ODBdXSwgWydSaWdodFVwVmVjdG9yJywgWzg2MzhdXSwgWydSaWdodFZlY3RvckJhcicsIFsxMDU3OV1dLCBbJ1JpZ2h0VmVjdG9yJywgWzg2NDBdXSwgWydyaW5nJywgWzczMF1dLCBbJ3Jpc2luZ2RvdHNlcScsIFs4Nzg3XV0sIFsncmxhcnInLCBbODY0NF1dLCBbJ3JsaGFyJywgWzg2NTJdXSwgWydybG0nLCBbODIwN11dLCBbJ3Jtb3VzdGFjaGUnLCBbOTEzN11dLCBbJ3Jtb3VzdCcsIFs5MTM3XV0sIFsncm5taWQnLCBbMTA5OTBdXSwgWydyb2FuZycsIFsxMDIyMV1dLCBbJ3JvYXJyJywgWzg3MDJdXSwgWydyb2JyaycsIFsxMDIxNV1dLCBbJ3JvcGFyJywgWzEwNjMwXV0sIFsncm9wZicsIFsxMjAxNjNdXSwgWydSb3BmJywgWzg0NzddXSwgWydyb3BsdXMnLCBbMTA3OThdXSwgWydyb3RpbWVzJywgWzEwODA1XV0sIFsnUm91bmRJbXBsaWVzJywgWzEwNjA4XV0sIFsncnBhcicsIFs0MV1dLCBbJ3JwYXJndCcsIFsxMDY0NF1dLCBbJ3JwcG9saW50JywgWzEwNzcwXV0sIFsncnJhcnInLCBbODY0OV1dLCBbJ1JyaWdodGFycm93JywgWzg2NjddXSwgWydyc2FxdW8nLCBbODI1MF1dLCBbJ3JzY3InLCBbMTIwMDA3XV0sIFsnUnNjcicsIFs4NDc1XV0sIFsncnNoJywgWzg2MjVdXSwgWydSc2gnLCBbODYyNV1dLCBbJ3JzcWInLCBbOTNdXSwgWydyc3F1bycsIFs4MjE3XV0sIFsncnNxdW9yJywgWzgyMTddXSwgWydDbG9zZUN1cmx5UXVvdGUnLCBbODIxN11dLCBbJ3J0aHJlZScsIFs4OTA4XV0sIFsncnRpbWVzJywgWzg5MDZdXSwgWydydHJpJywgWzk2NTddXSwgWydydHJpZScsIFs4ODg1XV0sIFsncnRyaWYnLCBbOTY1Nl1dLCBbJ3J0cmlsdHJpJywgWzEwNzAyXV0sIFsnUnVsZURlbGF5ZWQnLCBbMTA3NDBdXSwgWydydWx1aGFyJywgWzEwNjAwXV0sIFsncngnLCBbODQ3OF1dLCBbJ1NhY3V0ZScsIFszNDZdXSwgWydzYWN1dGUnLCBbMzQ3XV0sIFsnc2JxdW8nLCBbODIxOF1dLCBbJ3NjYXAnLCBbMTA5MzZdXSwgWydTY2Fyb24nLCBbMzUyXV0sIFsnc2Nhcm9uJywgWzM1M11dLCBbJ1NjJywgWzEwOTQwXV0sIFsnc2MnLCBbODgyN11dLCBbJ3NjY3VlJywgWzg4MjldXSwgWydzY2UnLCBbMTA5MjhdXSwgWydzY0UnLCBbMTA5MzJdXSwgWydTY2VkaWwnLCBbMzUwXV0sIFsnc2NlZGlsJywgWzM1MV1dLCBbJ1NjaXJjJywgWzM0OF1dLCBbJ3NjaXJjJywgWzM0OV1dLCBbJ3NjbmFwJywgWzEwOTM4XV0sIFsnc2NuRScsIFsxMDkzNF1dLCBbJ3NjbnNpbScsIFs4OTM3XV0sIFsnc2Nwb2xpbnQnLCBbMTA3NzFdXSwgWydzY3NpbScsIFs4ODMxXV0sIFsnU2N5JywgWzEwNTddXSwgWydzY3knLCBbMTA4OV1dLCBbJ3Nkb3RiJywgWzg4NjVdXSwgWydzZG90JywgWzg5MDFdXSwgWydzZG90ZScsIFsxMDg1NF1dLCBbJ3NlYXJoaycsIFsxMDUzM11dLCBbJ3NlYXJyJywgWzg2MDBdXSwgWydzZUFycicsIFs4NjY0XV0sIFsnc2VhcnJvdycsIFs4NjAwXV0sIFsnc2VjdCcsIFsxNjddXSwgWydzZW1pJywgWzU5XV0sIFsnc2Vzd2FyJywgWzEwNTM3XV0sIFsnc2V0bWludXMnLCBbODcyNl1dLCBbJ3NldG1uJywgWzg3MjZdXSwgWydzZXh0JywgWzEwMDM4XV0sIFsnU2ZyJywgWzEyMDA4Nl1dLCBbJ3NmcicsIFsxMjAxMTJdXSwgWydzZnJvd24nLCBbODk5NF1dLCBbJ3NoYXJwJywgWzk4MzldXSwgWydTSENIY3knLCBbMTA2NV1dLCBbJ3NoY2hjeScsIFsxMDk3XV0sIFsnU0hjeScsIFsxMDY0XV0sIFsnc2hjeScsIFsxMDk2XV0sIFsnU2hvcnREb3duQXJyb3cnLCBbODU5NV1dLCBbJ1Nob3J0TGVmdEFycm93JywgWzg1OTJdXSwgWydzaG9ydG1pZCcsIFs4NzM5XV0sIFsnc2hvcnRwYXJhbGxlbCcsIFs4NzQxXV0sIFsnU2hvcnRSaWdodEFycm93JywgWzg1OTRdXSwgWydTaG9ydFVwQXJyb3cnLCBbODU5M11dLCBbJ3NoeScsIFsxNzNdXSwgWydTaWdtYScsIFs5MzFdXSwgWydzaWdtYScsIFs5NjNdXSwgWydzaWdtYWYnLCBbOTYyXV0sIFsnc2lnbWF2JywgWzk2Ml1dLCBbJ3NpbScsIFs4NzY0XV0sIFsnc2ltZG90JywgWzEwODU4XV0sIFsnc2ltZScsIFs4NzcxXV0sIFsnc2ltZXEnLCBbODc3MV1dLCBbJ3NpbWcnLCBbMTA5MTBdXSwgWydzaW1nRScsIFsxMDkxMl1dLCBbJ3NpbWwnLCBbMTA5MDldXSwgWydzaW1sRScsIFsxMDkxMV1dLCBbJ3NpbW5lJywgWzg3NzRdXSwgWydzaW1wbHVzJywgWzEwNzg4XV0sIFsnc2ltcmFycicsIFsxMDYxMF1dLCBbJ3NsYXJyJywgWzg1OTJdXSwgWydTbWFsbENpcmNsZScsIFs4NzI4XV0sIFsnc21hbGxzZXRtaW51cycsIFs4NzI2XV0sIFsnc21hc2hwJywgWzEwODAzXV0sIFsnc21lcGFyc2wnLCBbMTA3MjRdXSwgWydzbWlkJywgWzg3MzldXSwgWydzbWlsZScsIFs4OTk1XV0sIFsnc210JywgWzEwOTIyXV0sIFsnc210ZScsIFsxMDkyNF1dLCBbJ3NtdGVzJywgWzEwOTI0LCA2NTAyNF1dLCBbJ1NPRlRjeScsIFsxMDY4XV0sIFsnc29mdGN5JywgWzExMDBdXSwgWydzb2xiYXInLCBbOTAyM11dLCBbJ3NvbGInLCBbMTA2OTJdXSwgWydzb2wnLCBbNDddXSwgWydTb3BmJywgWzEyMDEzOF1dLCBbJ3NvcGYnLCBbMTIwMTY0XV0sIFsnc3BhZGVzJywgWzk4MjRdXSwgWydzcGFkZXN1aXQnLCBbOTgyNF1dLCBbJ3NwYXInLCBbODc0MV1dLCBbJ3NxY2FwJywgWzg4NTFdXSwgWydzcWNhcHMnLCBbODg1MSwgNjUwMjRdXSwgWydzcWN1cCcsIFs4ODUyXV0sIFsnc3FjdXBzJywgWzg4NTIsIDY1MDI0XV0sIFsnU3FydCcsIFs4NzMwXV0sIFsnc3FzdWInLCBbODg0N11dLCBbJ3Nxc3ViZScsIFs4ODQ5XV0sIFsnc3FzdWJzZXQnLCBbODg0N11dLCBbJ3Nxc3Vic2V0ZXEnLCBbODg0OV1dLCBbJ3Nxc3VwJywgWzg4NDhdXSwgWydzcXN1cGUnLCBbODg1MF1dLCBbJ3Nxc3Vwc2V0JywgWzg4NDhdXSwgWydzcXN1cHNldGVxJywgWzg4NTBdXSwgWydzcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlSW50ZXJzZWN0aW9uJywgWzg4NTFdXSwgWydTcXVhcmVTdWJzZXQnLCBbODg0N11dLCBbJ1NxdWFyZVN1YnNldEVxdWFsJywgWzg4NDldXSwgWydTcXVhcmVTdXBlcnNldCcsIFs4ODQ4XV0sIFsnU3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4ODUwXV0sIFsnU3F1YXJlVW5pb24nLCBbODg1Ml1dLCBbJ3NxdWFyZicsIFs5NjQyXV0sIFsnc3F1JywgWzk2MzNdXSwgWydzcXVmJywgWzk2NDJdXSwgWydzcmFycicsIFs4NTk0XV0sIFsnU3NjcicsIFsxMTk5ODJdXSwgWydzc2NyJywgWzEyMDAwOF1dLCBbJ3NzZXRtbicsIFs4NzI2XV0sIFsnc3NtaWxlJywgWzg5OTVdXSwgWydzc3RhcmYnLCBbODkwMl1dLCBbJ1N0YXInLCBbODkwMl1dLCBbJ3N0YXInLCBbOTczNF1dLCBbJ3N0YXJmJywgWzk3MzNdXSwgWydzdHJhaWdodGVwc2lsb24nLCBbMTAxM11dLCBbJ3N0cmFpZ2h0cGhpJywgWzk4MV1dLCBbJ3N0cm5zJywgWzE3NV1dLCBbJ3N1YicsIFs4ODM0XV0sIFsnU3ViJywgWzg5MTJdXSwgWydzdWJkb3QnLCBbMTA5NDFdXSwgWydzdWJFJywgWzEwOTQ5XV0sIFsnc3ViZScsIFs4ODM4XV0sIFsnc3ViZWRvdCcsIFsxMDk0N11dLCBbJ3N1Ym11bHQnLCBbMTA5NDVdXSwgWydzdWJuRScsIFsxMDk1NV1dLCBbJ3N1Ym5lJywgWzg4NDJdXSwgWydzdWJwbHVzJywgWzEwOTQzXV0sIFsnc3VicmFycicsIFsxMDYxN11dLCBbJ3N1YnNldCcsIFs4ODM0XV0sIFsnU3Vic2V0JywgWzg5MTJdXSwgWydzdWJzZXRlcScsIFs4ODM4XV0sIFsnc3Vic2V0ZXFxJywgWzEwOTQ5XV0sIFsnU3Vic2V0RXF1YWwnLCBbODgzOF1dLCBbJ3N1YnNldG5lcScsIFs4ODQyXV0sIFsnc3Vic2V0bmVxcScsIFsxMDk1NV1dLCBbJ3N1YnNpbScsIFsxMDk1MV1dLCBbJ3N1YnN1YicsIFsxMDk2NV1dLCBbJ3N1YnN1cCcsIFsxMDk2M11dLCBbJ3N1Y2NhcHByb3gnLCBbMTA5MzZdXSwgWydzdWNjJywgWzg4MjddXSwgWydzdWNjY3VybHllcScsIFs4ODI5XV0sIFsnU3VjY2VlZHMnLCBbODgyN11dLCBbJ1N1Y2NlZWRzRXF1YWwnLCBbMTA5MjhdXSwgWydTdWNjZWVkc1NsYW50RXF1YWwnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzVGlsZGUnLCBbODgzMV1dLCBbJ3N1Y2NlcScsIFsxMDkyOF1dLCBbJ3N1Y2NuYXBwcm94JywgWzEwOTM4XV0sIFsnc3VjY25lcXEnLCBbMTA5MzRdXSwgWydzdWNjbnNpbScsIFs4OTM3XV0sIFsnc3VjY3NpbScsIFs4ODMxXV0sIFsnU3VjaFRoYXQnLCBbODcxNV1dLCBbJ3N1bScsIFs4NzIxXV0sIFsnU3VtJywgWzg3MjFdXSwgWydzdW5nJywgWzk4MzRdXSwgWydzdXAxJywgWzE4NV1dLCBbJ3N1cDInLCBbMTc4XV0sIFsnc3VwMycsIFsxNzldXSwgWydzdXAnLCBbODgzNV1dLCBbJ1N1cCcsIFs4OTEzXV0sIFsnc3VwZG90JywgWzEwOTQyXV0sIFsnc3VwZHN1YicsIFsxMDk2OF1dLCBbJ3N1cEUnLCBbMTA5NTBdXSwgWydzdXBlJywgWzg4MzldXSwgWydzdXBlZG90JywgWzEwOTQ4XV0sIFsnU3VwZXJzZXQnLCBbODgzNV1dLCBbJ1N1cGVyc2V0RXF1YWwnLCBbODgzOV1dLCBbJ3N1cGhzb2wnLCBbMTAxODVdXSwgWydzdXBoc3ViJywgWzEwOTY3XV0sIFsnc3VwbGFycicsIFsxMDYxOV1dLCBbJ3N1cG11bHQnLCBbMTA5NDZdXSwgWydzdXBuRScsIFsxMDk1Nl1dLCBbJ3N1cG5lJywgWzg4NDNdXSwgWydzdXBwbHVzJywgWzEwOTQ0XV0sIFsnc3Vwc2V0JywgWzg4MzVdXSwgWydTdXBzZXQnLCBbODkxM11dLCBbJ3N1cHNldGVxJywgWzg4MzldXSwgWydzdXBzZXRlcXEnLCBbMTA5NTBdXSwgWydzdXBzZXRuZXEnLCBbODg0M11dLCBbJ3N1cHNldG5lcXEnLCBbMTA5NTZdXSwgWydzdXBzaW0nLCBbMTA5NTJdXSwgWydzdXBzdWInLCBbMTA5NjRdXSwgWydzdXBzdXAnLCBbMTA5NjZdXSwgWydzd2FyaGsnLCBbMTA1MzRdXSwgWydzd2FycicsIFs4NjAxXV0sIFsnc3dBcnInLCBbODY2NV1dLCBbJ3N3YXJyb3cnLCBbODYwMV1dLCBbJ3N3bndhcicsIFsxMDUzOF1dLCBbJ3N6bGlnJywgWzIyM11dLCBbJ1RhYicsIFs5XV0sIFsndGFyZ2V0JywgWzg5ODJdXSwgWydUYXUnLCBbOTMyXV0sIFsndGF1JywgWzk2NF1dLCBbJ3RicmsnLCBbOTE0MF1dLCBbJ1RjYXJvbicsIFszNTZdXSwgWyd0Y2Fyb24nLCBbMzU3XV0sIFsnVGNlZGlsJywgWzM1NF1dLCBbJ3RjZWRpbCcsIFszNTVdXSwgWydUY3knLCBbMTA1OF1dLCBbJ3RjeScsIFsxMDkwXV0sIFsndGRvdCcsIFs4NDExXV0sIFsndGVscmVjJywgWzg5ODFdXSwgWydUZnInLCBbMTIwMDg3XV0sIFsndGZyJywgWzEyMDExM11dLCBbJ3RoZXJlNCcsIFs4NzU2XV0sIFsndGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXRhJywgWzkyMF1dLCBbJ3RoZXRhJywgWzk1Ml1dLCBbJ3RoZXRhc3ltJywgWzk3N11dLCBbJ3RoZXRhdicsIFs5NzddXSwgWyd0aGlja2FwcHJveCcsIFs4Nzc2XV0sIFsndGhpY2tzaW0nLCBbODc2NF1dLCBbJ1RoaWNrU3BhY2UnLCBbODI4NywgODIwMl1dLCBbJ1RoaW5TcGFjZScsIFs4MjAxXV0sIFsndGhpbnNwJywgWzgyMDFdXSwgWyd0aGthcCcsIFs4Nzc2XV0sIFsndGhrc2ltJywgWzg3NjRdXSwgWydUSE9STicsIFsyMjJdXSwgWyd0aG9ybicsIFsyNTRdXSwgWyd0aWxkZScsIFs3MzJdXSwgWydUaWxkZScsIFs4NzY0XV0sIFsnVGlsZGVFcXVhbCcsIFs4NzcxXV0sIFsnVGlsZGVGdWxsRXF1YWwnLCBbODc3M11dLCBbJ1RpbGRlVGlsZGUnLCBbODc3Nl1dLCBbJ3RpbWVzYmFyJywgWzEwODAxXV0sIFsndGltZXNiJywgWzg4NjRdXSwgWyd0aW1lcycsIFsyMTVdXSwgWyd0aW1lc2QnLCBbMTA4MDBdXSwgWyd0aW50JywgWzg3NDldXSwgWyd0b2VhJywgWzEwNTM2XV0sIFsndG9wYm90JywgWzkwMTRdXSwgWyd0b3BjaXInLCBbMTA5OTNdXSwgWyd0b3AnLCBbODg2OF1dLCBbJ1RvcGYnLCBbMTIwMTM5XV0sIFsndG9wZicsIFsxMjAxNjVdXSwgWyd0b3Bmb3JrJywgWzEwOTcwXV0sIFsndG9zYScsIFsxMDUzN11dLCBbJ3RwcmltZScsIFs4MjQ0XV0sIFsndHJhZGUnLCBbODQ4Ml1dLCBbJ1RSQURFJywgWzg0ODJdXSwgWyd0cmlhbmdsZScsIFs5NjUzXV0sIFsndHJpYW5nbGVkb3duJywgWzk2NjNdXSwgWyd0cmlhbmdsZWxlZnQnLCBbOTY2N11dLCBbJ3RyaWFuZ2xlbGVmdGVxJywgWzg4ODRdXSwgWyd0cmlhbmdsZXEnLCBbODc5Nl1dLCBbJ3RyaWFuZ2xlcmlnaHQnLCBbOTY1N11dLCBbJ3RyaWFuZ2xlcmlnaHRlcScsIFs4ODg1XV0sIFsndHJpZG90JywgWzk3MDhdXSwgWyd0cmllJywgWzg3OTZdXSwgWyd0cmltaW51cycsIFsxMDgxMF1dLCBbJ1RyaXBsZURvdCcsIFs4NDExXV0sIFsndHJpcGx1cycsIFsxMDgwOV1dLCBbJ3RyaXNiJywgWzEwNzAxXV0sIFsndHJpdGltZScsIFsxMDgxMV1dLCBbJ3RycGV6aXVtJywgWzkxODZdXSwgWydUc2NyJywgWzExOTk4M11dLCBbJ3RzY3InLCBbMTIwMDA5XV0sIFsnVFNjeScsIFsxMDYyXV0sIFsndHNjeScsIFsxMDk0XV0sIFsnVFNIY3knLCBbMTAzNV1dLCBbJ3RzaGN5JywgWzExMTVdXSwgWydUc3Ryb2snLCBbMzU4XV0sIFsndHN0cm9rJywgWzM1OV1dLCBbJ3R3aXh0JywgWzg4MTJdXSwgWyd0d29oZWFkbGVmdGFycm93JywgWzg2MDZdXSwgWyd0d29oZWFkcmlnaHRhcnJvdycsIFs4NjA4XV0sIFsnVWFjdXRlJywgWzIxOF1dLCBbJ3VhY3V0ZScsIFsyNTBdXSwgWyd1YXJyJywgWzg1OTNdXSwgWydVYXJyJywgWzg2MDddXSwgWyd1QXJyJywgWzg2NTddXSwgWydVYXJyb2NpcicsIFsxMDU2OV1dLCBbJ1VicmN5JywgWzEwMzhdXSwgWyd1YnJjeScsIFsxMTE4XV0sIFsnVWJyZXZlJywgWzM2NF1dLCBbJ3VicmV2ZScsIFszNjVdXSwgWydVY2lyYycsIFsyMTldXSwgWyd1Y2lyYycsIFsyNTFdXSwgWydVY3knLCBbMTA1OV1dLCBbJ3VjeScsIFsxMDkxXV0sIFsndWRhcnInLCBbODY0NV1dLCBbJ1VkYmxhYycsIFszNjhdXSwgWyd1ZGJsYWMnLCBbMzY5XV0sIFsndWRoYXInLCBbMTA2MDZdXSwgWyd1ZmlzaHQnLCBbMTA2MjJdXSwgWydVZnInLCBbMTIwMDg4XV0sIFsndWZyJywgWzEyMDExNF1dLCBbJ1VncmF2ZScsIFsyMTddXSwgWyd1Z3JhdmUnLCBbMjQ5XV0sIFsndUhhcicsIFsxMDU5NV1dLCBbJ3VoYXJsJywgWzg2MzldXSwgWyd1aGFycicsIFs4NjM4XV0sIFsndWhibGsnLCBbOTYwMF1dLCBbJ3VsY29ybicsIFs4OTg4XV0sIFsndWxjb3JuZXInLCBbODk4OF1dLCBbJ3VsY3JvcCcsIFs4OTc1XV0sIFsndWx0cmknLCBbOTcyMF1dLCBbJ1VtYWNyJywgWzM2Ml1dLCBbJ3VtYWNyJywgWzM2M11dLCBbJ3VtbCcsIFsxNjhdXSwgWydVbmRlckJhcicsIFs5NV1dLCBbJ1VuZGVyQnJhY2UnLCBbOTE4M11dLCBbJ1VuZGVyQnJhY2tldCcsIFs5MTQxXV0sIFsnVW5kZXJQYXJlbnRoZXNpcycsIFs5MTgxXV0sIFsnVW5pb24nLCBbODg5OV1dLCBbJ1VuaW9uUGx1cycsIFs4ODQ2XV0sIFsnVW9nb24nLCBbMzcwXV0sIFsndW9nb24nLCBbMzcxXV0sIFsnVW9wZicsIFsxMjAxNDBdXSwgWyd1b3BmJywgWzEyMDE2Nl1dLCBbJ1VwQXJyb3dCYXInLCBbMTA1MTRdXSwgWyd1cGFycm93JywgWzg1OTNdXSwgWydVcEFycm93JywgWzg1OTNdXSwgWydVcGFycm93JywgWzg2NTddXSwgWydVcEFycm93RG93bkFycm93JywgWzg2NDVdXSwgWyd1cGRvd25hcnJvdycsIFs4NTk3XV0sIFsnVXBEb3duQXJyb3cnLCBbODU5N11dLCBbJ1VwZG93bmFycm93JywgWzg2NjFdXSwgWydVcEVxdWlsaWJyaXVtJywgWzEwNjA2XV0sIFsndXBoYXJwb29ubGVmdCcsIFs4NjM5XV0sIFsndXBoYXJwb29ucmlnaHQnLCBbODYzOF1dLCBbJ3VwbHVzJywgWzg4NDZdXSwgWydVcHBlckxlZnRBcnJvdycsIFs4NTk4XV0sIFsnVXBwZXJSaWdodEFycm93JywgWzg1OTldXSwgWyd1cHNpJywgWzk2NV1dLCBbJ1Vwc2knLCBbOTc4XV0sIFsndXBzaWgnLCBbOTc4XV0sIFsnVXBzaWxvbicsIFs5MzNdXSwgWyd1cHNpbG9uJywgWzk2NV1dLCBbJ1VwVGVlQXJyb3cnLCBbODYxM11dLCBbJ1VwVGVlJywgWzg4NjldXSwgWyd1cHVwYXJyb3dzJywgWzg2NDhdXSwgWyd1cmNvcm4nLCBbODk4OV1dLCBbJ3VyY29ybmVyJywgWzg5ODldXSwgWyd1cmNyb3AnLCBbODk3NF1dLCBbJ1VyaW5nJywgWzM2Nl1dLCBbJ3VyaW5nJywgWzM2N11dLCBbJ3VydHJpJywgWzk3MjFdXSwgWydVc2NyJywgWzExOTk4NF1dLCBbJ3VzY3InLCBbMTIwMDEwXV0sIFsndXRkb3QnLCBbODk0NF1dLCBbJ1V0aWxkZScsIFszNjBdXSwgWyd1dGlsZGUnLCBbMzYxXV0sIFsndXRyaScsIFs5NjUzXV0sIFsndXRyaWYnLCBbOTY1Ml1dLCBbJ3V1YXJyJywgWzg2NDhdXSwgWydVdW1sJywgWzIyMF1dLCBbJ3V1bWwnLCBbMjUyXV0sIFsndXdhbmdsZScsIFsxMDY2M11dLCBbJ3ZhbmdydCcsIFsxMDY1Ml1dLCBbJ3ZhcmVwc2lsb24nLCBbMTAxM11dLCBbJ3ZhcmthcHBhJywgWzEwMDhdXSwgWyd2YXJub3RoaW5nJywgWzg3MDldXSwgWyd2YXJwaGknLCBbOTgxXV0sIFsndmFycGknLCBbOTgyXV0sIFsndmFycHJvcHRvJywgWzg3MzNdXSwgWyd2YXJyJywgWzg1OTddXSwgWyd2QXJyJywgWzg2NjFdXSwgWyd2YXJyaG8nLCBbMTAwOV1dLCBbJ3ZhcnNpZ21hJywgWzk2Ml1dLCBbJ3ZhcnN1YnNldG5lcScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZhcnN1YnNldG5lcXEnLCBbMTA5NTUsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxJywgWzg4NDMsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxcScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2YXJ0aGV0YScsIFs5NzddXSwgWyd2YXJ0cmlhbmdsZWxlZnQnLCBbODg4Ml1dLCBbJ3ZhcnRyaWFuZ2xlcmlnaHQnLCBbODg4M11dLCBbJ3ZCYXInLCBbMTA5ODRdXSwgWydWYmFyJywgWzEwOTg3XV0sIFsndkJhcnYnLCBbMTA5ODVdXSwgWydWY3knLCBbMTA0Ml1dLCBbJ3ZjeScsIFsxMDc0XV0sIFsndmRhc2gnLCBbODg2Nl1dLCBbJ3ZEYXNoJywgWzg4NzJdXSwgWydWZGFzaCcsIFs4ODczXV0sIFsnVkRhc2gnLCBbODg3NV1dLCBbJ1ZkYXNobCcsIFsxMDk4Ml1dLCBbJ3ZlZWJhcicsIFs4ODkxXV0sIFsndmVlJywgWzg3NDRdXSwgWydWZWUnLCBbODg5N11dLCBbJ3ZlZWVxJywgWzg3OTRdXSwgWyd2ZWxsaXAnLCBbODk0Ml1dLCBbJ3ZlcmJhcicsIFsxMjRdXSwgWydWZXJiYXInLCBbODIxNF1dLCBbJ3ZlcnQnLCBbMTI0XV0sIFsnVmVydCcsIFs4MjE0XV0sIFsnVmVydGljYWxCYXInLCBbODczOV1dLCBbJ1ZlcnRpY2FsTGluZScsIFsxMjRdXSwgWydWZXJ0aWNhbFNlcGFyYXRvcicsIFsxMDA3Ml1dLCBbJ1ZlcnRpY2FsVGlsZGUnLCBbODc2OF1dLCBbJ1ZlcnlUaGluU3BhY2UnLCBbODIwMl1dLCBbJ1ZmcicsIFsxMjAwODldXSwgWyd2ZnInLCBbMTIwMTE1XV0sIFsndmx0cmknLCBbODg4Ml1dLCBbJ3Zuc3ViJywgWzg4MzQsIDg0MDJdXSwgWyd2bnN1cCcsIFs4ODM1LCA4NDAyXV0sIFsnVm9wZicsIFsxMjAxNDFdXSwgWyd2b3BmJywgWzEyMDE2N11dLCBbJ3Zwcm9wJywgWzg3MzNdXSwgWyd2cnRyaScsIFs4ODgzXV0sIFsnVnNjcicsIFsxMTk5ODVdXSwgWyd2c2NyJywgWzEyMDAxMV1dLCBbJ3ZzdWJuRScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2c3VibmUnLCBbODg0MiwgNjUwMjRdXSwgWyd2c3VwbkUnLCBbMTA5NTYsIDY1MDI0XV0sIFsndnN1cG5lJywgWzg4NDMsIDY1MDI0XV0sIFsnVnZkYXNoJywgWzg4NzRdXSwgWyd2emlnemFnJywgWzEwNjUwXV0sIFsnV2NpcmMnLCBbMzcyXV0sIFsnd2NpcmMnLCBbMzczXV0sIFsnd2VkYmFyJywgWzEwODQ3XV0sIFsnd2VkZ2UnLCBbODc0M11dLCBbJ1dlZGdlJywgWzg4OTZdXSwgWyd3ZWRnZXEnLCBbODc5M11dLCBbJ3dlaWVycCcsIFs4NDcyXV0sIFsnV2ZyJywgWzEyMDA5MF1dLCBbJ3dmcicsIFsxMjAxMTZdXSwgWydXb3BmJywgWzEyMDE0Ml1dLCBbJ3dvcGYnLCBbMTIwMTY4XV0sIFsnd3AnLCBbODQ3Ml1dLCBbJ3dyJywgWzg3NjhdXSwgWyd3cmVhdGgnLCBbODc2OF1dLCBbJ1dzY3InLCBbMTE5OTg2XV0sIFsnd3NjcicsIFsxMjAwMTJdXSwgWyd4Y2FwJywgWzg4OThdXSwgWyd4Y2lyYycsIFs5NzExXV0sIFsneGN1cCcsIFs4ODk5XV0sIFsneGR0cmknLCBbOTY2MV1dLCBbJ1hmcicsIFsxMjAwOTFdXSwgWyd4ZnInLCBbMTIwMTE3XV0sIFsneGhhcnInLCBbMTAyMzFdXSwgWyd4aEFycicsIFsxMDIzNF1dLCBbJ1hpJywgWzkyNl1dLCBbJ3hpJywgWzk1OF1dLCBbJ3hsYXJyJywgWzEwMjI5XV0sIFsneGxBcnInLCBbMTAyMzJdXSwgWyd4bWFwJywgWzEwMjM2XV0sIFsneG5pcycsIFs4OTU1XV0sIFsneG9kb3QnLCBbMTA3NTJdXSwgWydYb3BmJywgWzEyMDE0M11dLCBbJ3hvcGYnLCBbMTIwMTY5XV0sIFsneG9wbHVzJywgWzEwNzUzXV0sIFsneG90aW1lJywgWzEwNzU0XV0sIFsneHJhcnInLCBbMTAyMzBdXSwgWyd4ckFycicsIFsxMDIzM11dLCBbJ1hzY3InLCBbMTE5OTg3XV0sIFsneHNjcicsIFsxMjAwMTNdXSwgWyd4c3FjdXAnLCBbMTA3NThdXSwgWyd4dXBsdXMnLCBbMTA3NTZdXSwgWyd4dXRyaScsIFs5NjUxXV0sIFsneHZlZScsIFs4ODk3XV0sIFsneHdlZGdlJywgWzg4OTZdXSwgWydZYWN1dGUnLCBbMjIxXV0sIFsneWFjdXRlJywgWzI1M11dLCBbJ1lBY3knLCBbMTA3MV1dLCBbJ3lhY3knLCBbMTEwM11dLCBbJ1ljaXJjJywgWzM3NF1dLCBbJ3ljaXJjJywgWzM3NV1dLCBbJ1ljeScsIFsxMDY3XV0sIFsneWN5JywgWzEwOTldXSwgWyd5ZW4nLCBbMTY1XV0sIFsnWWZyJywgWzEyMDA5Ml1dLCBbJ3lmcicsIFsxMjAxMThdXSwgWydZSWN5JywgWzEwMzFdXSwgWyd5aWN5JywgWzExMTFdXSwgWydZb3BmJywgWzEyMDE0NF1dLCBbJ3lvcGYnLCBbMTIwMTcwXV0sIFsnWXNjcicsIFsxMTk5ODhdXSwgWyd5c2NyJywgWzEyMDAxNF1dLCBbJ1lVY3knLCBbMTA3MF1dLCBbJ3l1Y3knLCBbMTEwMl1dLCBbJ3l1bWwnLCBbMjU1XV0sIFsnWXVtbCcsIFszNzZdXSwgWydaYWN1dGUnLCBbMzc3XV0sIFsnemFjdXRlJywgWzM3OF1dLCBbJ1pjYXJvbicsIFszODFdXSwgWyd6Y2Fyb24nLCBbMzgyXV0sIFsnWmN5JywgWzEwNDddXSwgWyd6Y3knLCBbMTA3OV1dLCBbJ1pkb3QnLCBbMzc5XV0sIFsnemRvdCcsIFszODBdXSwgWyd6ZWV0cmYnLCBbODQ4OF1dLCBbJ1plcm9XaWR0aFNwYWNlJywgWzgyMDNdXSwgWydaZXRhJywgWzkxOF1dLCBbJ3pldGEnLCBbOTUwXV0sIFsnemZyJywgWzEyMDExOV1dLCBbJ1pmcicsIFs4NDg4XV0sIFsnWkhjeScsIFsxMDQ2XV0sIFsnemhjeScsIFsxMDc4XV0sIFsnemlncmFycicsIFs4NjY5XV0sIFsnem9wZicsIFsxMjAxNzFdXSwgWydab3BmJywgWzg0ODRdXSwgWydac2NyJywgWzExOTk4OV1dLCBbJ3pzY3InLCBbMTIwMDE1XV0sIFsnendqJywgWzgyMDVdXSwgWyd6d25qJywgWzgyMDRdXV07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5cbmNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDVFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbY107XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHBoYUluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhckluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gICAgdmFyIF9yZXN1bHRzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZSA9IEVOVElUSUVTW2ldO1xuICAgICAgICB2YXIgYWxwaGEgPSBlWzBdO1xuICAgICAgICB2YXIgY2hhcnMgPSBlWzFdO1xuICAgICAgICB2YXIgY2hyID0gY2hhcnNbMF07XG4gICAgICAgIHZhciBhZGRDaGFyID0gKGNociA8IDMyIHx8IGNociA+IDEyNikgfHwgY2hyID09PSA2MiB8fCBjaHIgPT09IDYwIHx8IGNociA9PT0gMzggfHwgY2hyID09PSAzNCB8fCBjaHIgPT09IDM5O1xuICAgICAgICB2YXIgY2hhckluZm87XG4gICAgICAgIGlmIChhZGRDaGFyKSB7XG4gICAgICAgICAgICBjaGFySW5mbyA9IGNoYXJJbmRleFtjaHJdID0gY2hhckluZGV4W2Nocl0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJzWzFdKSB7XG4gICAgICAgICAgICB2YXIgY2hyMiA9IGNoYXJzWzFdO1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1tjaHIyXSA9IGFscGhhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bJyddID0gYWxwaGEpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNUVudGl0aWVzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/html5-entities.js\n");

/***/ }),

/***/ "./node_modules/html-entities/lib/xml-entities.js":
/*!********************************************************!*\
  !*** ./node_modules/html-entities/lib/xml-entities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ALPHA_INDEX = {\n    '&lt': '<',\n    '&gt': '>',\n    '&quot': '\"',\n    '&apos': '\\'',\n    '&amp': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&apos;': '\\'',\n    '&amp;': '&'\n};\n\nvar CHAR_INDEX = {\n    60: 'lt',\n    62: 'gt',\n    34: 'quot',\n    39: 'apos',\n    38: 'amp'\n};\n\nvar CHAR_S_INDEX = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&apos;',\n    '&': '&amp;'\n};\n\n/**\n * @constructor\n */\nfunction XmlEntities() {}\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.encode = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    return str.replace(/<|>|\"|'|&/g, function(s) {\n        return CHAR_S_INDEX[s];\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.encode = function(str) {\n    return new XmlEntities().encode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.decode = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {\n        if (s.charAt(1) === '#') {\n            var code = s.charAt(2).toLowerCase() === 'x' ?\n                parseInt(s.substr(3), 16) :\n                parseInt(s.substr(2));\n\n            if (isNaN(code) || code < -32768 || code > 65535) {\n                return '';\n            }\n            return String.fromCharCode(code);\n        }\n        return ALPHA_INDEX[s] || s;\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.decode = function(str) {\n    return new XmlEntities().decode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.encodeNonUTF = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLength = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        var alpha = CHAR_INDEX[c];\n        if (alpha) {\n            result += \"&\" + alpha + \";\";\n            i++;\n            continue;\n        }\n        if (c < 32 || c > 126) {\n            result += '&#' + c + ';';\n        } else {\n            result += str.charAt(i);\n        }\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.encodeNonUTF = function(str) {\n    return new XmlEntities().encodeNonUTF(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.encodeNonASCII = function(str) {\n    if (!str || !str.length) {\n        return '';\n    }\n    var strLenght = str.length;\n    var result = '';\n    var i = 0;\n    while (i < strLenght) {\n        var c = str.charCodeAt(i);\n        if (c <= 255) {\n            result += str[i++];\n            continue;\n        }\n        result += '&#' + c + ';';\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.encodeNonASCII = function(str) {\n    return new XmlEntities().encodeNonASCII(str);\n };\n\nmodule.exports = XmlEntities;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIveG1sLWVudGl0aWVzLmpzPzUwMjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxXQUFXO0FBQ1gsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBBTFBIQV9JTkRFWCA9IHtcbiAgICAnJmx0JzogJzwnLFxuICAgICcmZ3QnOiAnPicsXG4gICAgJyZxdW90JzogJ1wiJyxcbiAgICAnJmFwb3MnOiAnXFwnJyxcbiAgICAnJmFtcCc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnXG59O1xuXG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xuXG52YXIgQ0hBUl9TX0lOREVYID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzx8PnxcInwnfCYvZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gQ0hBUl9TX0lOREVYW3NdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIz9bMC05YS16QS1aXSs7Py9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMyksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBYbWxFbnRpdGllcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/xml-entities.js\n");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          )\n\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz9hMTVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgIClcblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcz85MWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/querystring-es3/decode.js\n");

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcz9lMDk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/querystring-es3/encode.js\n");

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/querystring-es3/decode.js\");\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/querystring-es3/encode.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzP2IzODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/querystring-es3/index.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.4.1\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar ExecutionEnvironment = __webpack_require__(/*! fbjs/lib/ExecutionEnvironment */ \"./node_modules/fbjs/lib/ExecutionEnvironment.js\");\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\nvar getActiveElement = __webpack_require__(/*! fbjs/lib/getActiveElement */ \"./node_modules/fbjs/lib/getActiveElement.js\");\nvar shallowEqual = __webpack_require__(/*! fbjs/lib/shallowEqual */ \"./node_modules/fbjs/lib/shallowEqual.js\");\nvar containsNode = __webpack_require__(/*! fbjs/lib/containsNode */ \"./node_modules/fbjs/lib/containsNode.js\");\nvar emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\nvar hyphenateStyleName = __webpack_require__(/*! fbjs/lib/hyphenateStyleName */ \"./node_modules/fbjs/lib/hyphenateStyleName.js\");\nvar camelizeStyleName = __webpack_require__(/*! fbjs/lib/camelizeStyleName */ \"./node_modules/fbjs/lib/camelizeStyleName.js\");\n\n// Relying on the `invariant()` implementation lets us\n// have preserve the format and params in the www builds.\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\nvar invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n  this._hasCaughtError = false;\n  this._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this._caughtError = error;\n    this._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      !(typeof document !== 'undefined') ? invariant(false, 'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.') : void 0;\n      var evt = document.createEvent('Event');\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        this._hasCaughtError = true;\n        this._caughtError = error;\n      } else {\n        this._hasCaughtError = false;\n        this._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallback$1 = invokeGuardedCallback;\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar EventPluginRegistry = Object.freeze({\n\tplugins: plugins,\n\teventNameDispatchConfigs: eventNameDispatchConfigs,\n\tregistrationNameModules: registrationNameModules,\n\tregistrationNameDependencies: registrationNameDependencies,\n\tpossibleRegistrationNames: possibleRegistrationNames,\n\tinjectEventPluginOrder: injectEventPluginOrder,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$1 = {\n  injectComponentTree: function (Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      !(getNodeFromInstance && getInstanceFromNode) ? warning(false, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n    }\n  }\n};\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warning(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventsInBatch(events, false);\n}\n\nvar EventPluginHub = Object.freeze({\n\tinjection: injection,\n\tgetListener: getListener,\n\trunEventsInBatch: runEventsInBatch,\n\trunExtractedEventsInBatch: runExtractedEventsInBatch\n});\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\n\n\n\nvar Fragment = 10;\nvar Mode = 11;\nvar ContextConsumer = 12;\nvar ContextProvider = 13;\nvar ForwardRef = 14;\nvar Profiler = 15;\nvar TimeoutComponent = 16;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  while (!node[internalInstanceKey]) {\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nvar ReactDOMComponentTree = Object.freeze({\n\tprecacheFiberNode: precacheFiberNode,\n\tgetClosestInstanceFromNode: getClosestInstanceFromNode,\n\tgetInstanceFromNode: getInstanceFromNode$1,\n\tgetNodeFromInstance: getNodeFromInstance$1,\n\tgetFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n\tupdateFiberProps: updateFiberProps\n});\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warning(false, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar EventPropagators = Object.freeze({\n\taccumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n\taccumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n\taccumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n\taccumulateDirectDispatches: accumulateDirectDispatches\n});\n\n// Do not uses the below two methods directly!\n// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.\n// (It is the only module that is allowed to access these methods.)\n\nfunction unsafeCastStringToDOMTopLevelType(topLevelType) {\n  return topLevelType;\n}\n\nfunction unsafeCastDOMTopLevelTypeToString(topLevelType) {\n  return topLevelType;\n}\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n  prefixes['ms' + styleProp] = 'MS' + eventName;\n  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (ExecutionEnvironment.canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return eventName;\n}\n\n/**\n * To identify top level events in ReactDOM, we use constants defined by this\n * module. This is the only module that uses the unsafe* methods to express\n * that the constants actually correspond to the browser event names. This lets\n * us save some bundle size by avoiding a top level type -> event name map.\n * The rest of ReactDOM code should import top level types from this file.\n */\nvar TOP_ABORT = unsafeCastStringToDOMTopLevelType('abort');\nvar TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));\nvar TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));\nvar TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));\nvar TOP_BLUR = unsafeCastStringToDOMTopLevelType('blur');\nvar TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType('canplay');\nvar TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType('canplaythrough');\nvar TOP_CANCEL = unsafeCastStringToDOMTopLevelType('cancel');\nvar TOP_CHANGE = unsafeCastStringToDOMTopLevelType('change');\nvar TOP_CLICK = unsafeCastStringToDOMTopLevelType('click');\nvar TOP_CLOSE = unsafeCastStringToDOMTopLevelType('close');\nvar TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType('compositionend');\nvar TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType('compositionstart');\nvar TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType('compositionupdate');\nvar TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType('contextmenu');\nvar TOP_COPY = unsafeCastStringToDOMTopLevelType('copy');\nvar TOP_CUT = unsafeCastStringToDOMTopLevelType('cut');\nvar TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType('dblclick');\nvar TOP_DRAG = unsafeCastStringToDOMTopLevelType('drag');\nvar TOP_DRAG_END = unsafeCastStringToDOMTopLevelType('dragend');\nvar TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType('dragenter');\nvar TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType('dragexit');\nvar TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType('dragleave');\nvar TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType('dragover');\nvar TOP_DRAG_START = unsafeCastStringToDOMTopLevelType('dragstart');\nvar TOP_DROP = unsafeCastStringToDOMTopLevelType('drop');\nvar TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType('durationchange');\nvar TOP_EMPTIED = unsafeCastStringToDOMTopLevelType('emptied');\nvar TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType('encrypted');\nvar TOP_ENDED = unsafeCastStringToDOMTopLevelType('ended');\nvar TOP_ERROR = unsafeCastStringToDOMTopLevelType('error');\nvar TOP_FOCUS = unsafeCastStringToDOMTopLevelType('focus');\nvar TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('gotpointercapture');\nvar TOP_INPUT = unsafeCastStringToDOMTopLevelType('input');\nvar TOP_INVALID = unsafeCastStringToDOMTopLevelType('invalid');\nvar TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType('keydown');\nvar TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType('keypress');\nvar TOP_KEY_UP = unsafeCastStringToDOMTopLevelType('keyup');\nvar TOP_LOAD = unsafeCastStringToDOMTopLevelType('load');\nvar TOP_LOAD_START = unsafeCastStringToDOMTopLevelType('loadstart');\nvar TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType('loadeddata');\nvar TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType('loadedmetadata');\nvar TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('lostpointercapture');\nvar TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType('mousedown');\nvar TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType('mousemove');\nvar TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType('mouseout');\nvar TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType('mouseover');\nvar TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType('mouseup');\nvar TOP_PASTE = unsafeCastStringToDOMTopLevelType('paste');\nvar TOP_PAUSE = unsafeCastStringToDOMTopLevelType('pause');\nvar TOP_PLAY = unsafeCastStringToDOMTopLevelType('play');\nvar TOP_PLAYING = unsafeCastStringToDOMTopLevelType('playing');\nvar TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType('pointercancel');\nvar TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType('pointerdown');\n\n\nvar TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType('pointermove');\nvar TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType('pointerout');\nvar TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType('pointerover');\nvar TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType('pointerup');\nvar TOP_PROGRESS = unsafeCastStringToDOMTopLevelType('progress');\nvar TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType('ratechange');\nvar TOP_RESET = unsafeCastStringToDOMTopLevelType('reset');\nvar TOP_SCROLL = unsafeCastStringToDOMTopLevelType('scroll');\nvar TOP_SEEKED = unsafeCastStringToDOMTopLevelType('seeked');\nvar TOP_SEEKING = unsafeCastStringToDOMTopLevelType('seeking');\nvar TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType('selectionchange');\nvar TOP_STALLED = unsafeCastStringToDOMTopLevelType('stalled');\nvar TOP_SUBMIT = unsafeCastStringToDOMTopLevelType('submit');\nvar TOP_SUSPEND = unsafeCastStringToDOMTopLevelType('suspend');\nvar TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType('textInput');\nvar TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType('timeupdate');\nvar TOP_TOGGLE = unsafeCastStringToDOMTopLevelType('toggle');\nvar TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType('touchcancel');\nvar TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType('touchend');\nvar TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType('touchmove');\nvar TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType('touchstart');\nvar TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));\nvar TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType('volumechange');\nvar TOP_WAITING = unsafeCastStringToDOMTopLevelType('waiting');\nvar TOP_WHEEL = unsafeCastStringToDOMTopLevelType('wheel');\n\n// List of events that need to be individually attached to media elements.\n// Note that events in this list will *not* be listened to at the top level\n// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.\nvar mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];\n\nfunction getRawEventName(topLevelType) {\n  return unsafeCastDOMTopLevelTypeToString(topLevelType);\n}\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\n/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\nvar compositionState = {\n  _root: null,\n  _startText: null,\n  _fallbackText: null\n};\n\nfunction initialize(nativeEventTarget) {\n  compositionState._root = nativeEventTarget;\n  compositionState._startText = getText();\n  return true;\n}\n\nfunction reset() {\n  compositionState._root = null;\n  compositionState._startText = null;\n  compositionState._fallbackText = null;\n}\n\nfunction getData() {\n  if (compositionState._fallbackText) {\n    return compositionState._fallbackText;\n  }\n\n  var start = void 0;\n  var startValue = compositionState._startText;\n  var startLength = startValue.length;\n  var end = void 0;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  compositionState._fallbackText = endValue.slice(start, sliceTail);\n  return compositionState._fallbackText;\n}\n\nfunction getText() {\n  if ('value' in compositionState._root) {\n    return compositionState._root.value;\n  }\n  return compositionState._root[getTextContentAccessor()];\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  var isProxySupported = typeof Proxy === 'function' &&\n  // https://github.com/facebook/react/issues/12011\n  !Object.isSealed(new Proxy({}, {}));\n\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              !(didWarnForAddedNewProperty || target.isPersistent()) ? warning(false, \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition ? warning(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar SyntheticCompositionEvent = SyntheticEvent$1.extend({\n  data: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar SyntheticInputEvent = SyntheticEvent$1.extend({\n  data: null\n});\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_START:\n      return eventTypes.compositionStart;\n    case TOP_COMPOSITION_END:\n      return eventTypes.compositionEnd;\n    case TOP_COMPOSITION_UPDATE:\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_KEY_UP:\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case TOP_KEY_DOWN:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case TOP_KEY_PRESS:\n    case TOP_MOUSE_DOWN:\n    case TOP_BLUR:\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType = void 0;\n  var fallbackData = void 0;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelType} topLevelType Number from `TopLevelType`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_END:\n      return getDataFromCustomEvent(nativeEvent);\n    case TOP_KEY_PRESS:\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case TOP_TEXT_INPUT:\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case TOP_PASTE:\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case TOP_KEY_PRESS:\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case TOP_COMPOSITION_END:\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars = void 0;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    if (composition === null) {\n      return beforeInput;\n    }\n\n    if (beforeInput === null) {\n      return composition;\n    }\n\n    return [composition, beforeInput];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar ReactControlledComponentInjection = {\n  injectFiberControlledHostComponent: function (hostComponentImpl) {\n    // The fiber implementation doesn't use dynamic dispatch so we need to\n    // inject the implementation.\n    fiberHostComponent = hostComponentImpl;\n  }\n};\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n}\n\nvar injection$2 = ReactControlledComponentInjection;\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\nvar ReactControlledComponent = Object.freeze({\n\tinjection: injection$2,\n\tenqueueStateRestore: enqueueStateRestore,\n\tneedsStateRestore: needsStateRestore,\n\trestoreStateIfNeeded: restoreStateIfNeeded\n});\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdates = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdates = function (fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdates = function () {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdates();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nfunction interactiveUpdates(fn, a, b) {\n  return _interactiveUpdates(fn, a, b);\n}\n\n\n\nvar injection$3 = {\n  injectRenderer: function (renderer) {\n    _batchedUpdates = renderer.batchedUpdates;\n    _interactiveUpdates = renderer.interactiveUpdates;\n    _flushInteractiveUpdates = renderer.flushInteractiveUpdates;\n  }\n};\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  // Fallback to nativeEvent.srcElement for IE9\n  // https://github.com/facebook/react/issues/12506\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n  var get = descriptor.get,\n      set = descriptor.set;\n\n  Object.defineProperty(node, valueField, {\n    configurable: true,\n    get: function () {\n      return get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      set.call(this, value);\n    }\n  });\n  // We could've passed this the first time\n  // but it triggers a bug in IE11 and Edge 14/15.\n  // Calling defineProperty() again should be equivalent.\n  // https://github.com/facebook/react/issues/11768\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for('react.timeout') : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return 'AsyncMode';\n    case REACT_CONTEXT_TYPE:\n      return 'Context.Consumer';\n    case REACT_FRAGMENT_TYPE:\n      return 'ReactFragment';\n    case REACT_PORTAL_TYPE:\n      return 'ReactPortal';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler(' + fiber.pendingProps.id + ')';\n    case REACT_PROVIDER_TYPE:\n      return 'Context.Provider';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_TIMEOUT_TYPE:\n      return 'Timeout';\n  }\n  if (typeof type === 'object' && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        var functionName = type.render.displayName || type.render.name || '';\n        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    }\n  }\n  return null;\n}\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node.return;\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName$1() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum$1() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum$1;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName$1,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum$1\n};\n\n// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED = 0;\n\n// A simple string attribute.\n// Attributes that aren't in the whitelist are presumed to have this type.\nvar STRING = 1;\n\n// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING = 2;\n\n// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN = 3;\n\n// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN = 4;\n\n// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC = 5;\n\n// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC = 6;\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\n\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\nfunction shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null) {\n    return propertyInfo.type === RESERVED;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return true;\n  }\n  return false;\n}\n\nfunction shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n    return false;\n  }\n  switch (typeof value) {\n    case 'function':\n    // $FlowIssue symbol is perfectly valid here\n    case 'symbol':\n      // eslint-disable-line\n      return true;\n    case 'boolean':\n      {\n        if (isCustomComponentTag) {\n          return false;\n        }\n        if (propertyInfo !== null) {\n          return !propertyInfo.acceptsBooleans;\n        } else {\n          var prefix = name.toLowerCase().slice(0, 5);\n          return prefix !== 'data-' && prefix !== 'aria-';\n        }\n      }\n    default:\n      return false;\n  }\n}\n\nfunction shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n  if (value === null || typeof value === 'undefined') {\n    return true;\n  }\n  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n    return true;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (propertyInfo !== null) {\n    switch (propertyInfo.type) {\n      case BOOLEAN:\n        return !value;\n      case OVERLOADED_BOOLEAN:\n        return value === false;\n      case NUMERIC:\n        return isNaN(value);\n      case POSITIVE_NUMERIC:\n        return isNaN(value) || value < 1;\n    }\n  }\n  return false;\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {\n  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n  this.attributeName = attributeName;\n  this.attributeNamespace = attributeNamespace;\n  this.mustUseProperty = mustUseProperty;\n  this.propertyName = name;\n  this.type = type;\n}\n\n// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties = {};\n\n// These props are reserved by React. They shouldn't be written to the DOM.\n['children', 'dangerouslySetInnerHTML',\n// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {\n  var name = _ref[0],\n      attributeName = _ref[1];\n\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse', 'externalResourcesRequired', 'preserveAlpha'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML boolean attributes.\n['allowFullScreen', 'async',\n// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',\n// Microdata\n'itemScope'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',\n// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple', 'muted', 'selected'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture', 'download'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that must be positive numbers.\n['cols', 'rows', 'size', 'span'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that must be numbers.\n['rowSpan', 'start'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\n// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML whitelist.\n// Some of these attributes can be hard to find. This list was created by\n// scrapping the MDN documentation.\n['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, null);\n} // attributeNamespace\n);\n\n// String SVG attributes with the xlink namespace.\n['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/1999/xlink');\n});\n\n// String SVG attributes with the xml namespace.\n['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/XML/1998/namespace');\n});\n\n// Special case: this attribute exists both in HTML and SVG.\n// Its \"tabindex\" attribute name is case-sensitive in SVG so we can't just use\n// its React `tabIndex` name, like we do for attributes that exist only in HTML.\nproperties.tabIndex = new PropertyInfoRecord('tabIndex', STRING, false, // mustUseProperty\n'tabindex', // attributeName\nnull);\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected, propertyInfo) {\n  {\n    if (propertyInfo.mustUseProperty) {\n      var propertyName = propertyInfo.propertyName;\n\n      return node[propertyName];\n    } else {\n      var attributeName = propertyInfo.attributeName;\n\n      var stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          var value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + expected) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value, isCustomComponentTag) {\n  var propertyInfo = getPropertyInfo(name);\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n  // If the prop isn't in the special list, treat it as a simple attribute.\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      var _attributeName = name;\n      if (value === null) {\n        node.removeAttribute(_attributeName);\n      } else {\n        node.setAttribute(_attributeName, '' + value);\n      }\n    }\n    return;\n  }\n  var mustUseProperty = propertyInfo.mustUseProperty;\n\n  if (mustUseProperty) {\n    var propertyName = propertyInfo.propertyName;\n\n    if (value === null) {\n      var type = propertyInfo.type;\n\n      node[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyName] = value;\n    }\n    return;\n  }\n  // The rest are treated as attributes with special cases.\n  var attributeName = propertyInfo.attributeName,\n      attributeNamespace = propertyInfo.attributeNamespace;\n\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    var _type = propertyInfo.type;\n\n    var attributeValue = void 0;\n    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      attributeValue = '' + value;\n    }\n    if (attributeNamespace) {\n      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n    } else {\n      node.setAttribute(attributeName, attributeValue);\n    }\n  }\n}\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n    checkPropTypes(propTypes, props, 'prop', tagName, getStack);\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var checked = props.checked;\n\n  var hostProps = _assign({}, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: undefined,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var node = element;\n  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;\n\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: getSafeValue(props.value != null ? props.value : defaultValue),\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateChecked(element, props) {\n  var node = element;\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked, false);\n  }\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var _controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {\n      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum());\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {\n      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum());\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  var value = getSafeValue(props.value);\n\n  if (value != null) {\n    if (props.type === 'number') {\n      if (value === 0 && node.value === '' ||\n      // eslint-disable-next-line\n      node.value != value) {\n        node.value = '' + value;\n      }\n    } else if (node.value !== '' + value) {\n      node.value = '' + value;\n    }\n  }\n\n  if (props.hasOwnProperty('value')) {\n    setDefaultValue(node, props.type, value);\n  } else if (props.hasOwnProperty('defaultValue')) {\n    setDefaultValue(node, props.type, getSafeValue(props.defaultValue));\n  }\n\n  if (props.checked == null && props.defaultChecked != null) {\n    node.defaultChecked = !!props.defaultChecked;\n  }\n}\n\nfunction postMountWrapper(element, props, isHydrating) {\n  var node = element;\n\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\n    var _initialValue = '' + node._wrapperState.initialValue;\n    var currentValue = node.value;\n\n    // Do not assign value if it is already set. This prevents user text input\n    // from being lost during SSR hydration.\n    if (!isHydrating) {\n      // Do not re-assign the value property if there is no change. This\n      // potentially avoids a DOM write and prevents Firefox (~60.0.1) from\n      // prematurely marking required inputs as invalid\n      if (_initialValue !== currentValue) {\n        node.value = _initialValue;\n      }\n    }\n\n    // value must be assigned before defaultValue. This fixes an issue where the\n    // visually displayed value of date inputs disappears on mobile Safari and Chrome:\n    // https://github.com/facebook/react/issues/7233\n    node.defaultValue = _initialValue;\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n  node.defaultChecked = !node.defaultChecked;\n  node.defaultChecked = !node.defaultChecked;\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\n// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node, type, value) {\n  if (\n  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n  type !== 'number' || node.ownerDocument.activeElement !== node) {\n    if (value == null) {\n      node.defaultValue = '' + node._wrapperState.initialValue;\n    } else if (node.defaultValue !== '' + value) {\n      node.defaultValue = '' + value;\n    }\n  }\n}\n\nfunction getSafeValue(value) {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'object':\n    case 'string':\n    case 'undefined':\n      return value;\n    default:\n      // function, symbol are assigned as empty strings\n      return '';\n  }\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  runEventsInBatch(event, false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CHANGE) {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === TOP_FOCUS) {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === TOP_BLUR) {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CLICK) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node) {\n  var state = node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  setDefaultValue(node, 'number', node.value);\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc = void 0,\n        handleEventFunc = void 0;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === TOP_BLUR) {\n      handleControlledInputBlur(targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\nvar SyntheticUIEvent = SyntheticEvent$1.extend({\n  view: null,\n  detail: null\n});\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticMouseEvent = SyntheticUIEvent.extend({\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  }\n});\n\n/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */\nvar SyntheticPointerEvent = SyntheticMouseEvent.extend({\n  pointerId: null,\n  width: null,\n  height: null,\n  pressure: null,\n  tiltX: null,\n  tiltY: null,\n  pointerType: null,\n  isPrimary: null\n});\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  pointerEnter: {\n    registrationName: 'onPointerEnter',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  },\n  pointerLeave: {\n    registrationName: 'onPointerLeave',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\n    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\n\n    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n\n    if (!isOutEvent && !isOverEvent) {\n      // Must not be a mouse or pointer in or out - ignoring.\n      return null;\n    }\n\n    var win = void 0;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from = void 0;\n    var to = void 0;\n    if (isOutEvent) {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var eventInterface = void 0,\n        leaveEventType = void 0,\n        enterEventType = void 0,\n        eventTypePrefix = void 0;\n\n    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\n      eventInterface = SyntheticMouseEvent;\n      leaveEventType = eventTypes$2.mouseLeave;\n      enterEventType = eventTypes$2.mouseEnter;\n      eventTypePrefix = 'mouse';\n    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {\n      eventInterface = SyntheticPointerEvent;\n      leaveEventType = eventTypes$2.pointerLeave;\n      enterEventType = eventTypes$2.pointerEnter;\n      eventTypePrefix = 'pointer';\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);\n    leave.type = eventTypePrefix + 'leave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);\n    enter.type = eventTypePrefix + 'enter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */0;\nvar PerformedWork = /*         */1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */2;\nvar Update = /*                */4;\nvar PlacementAndUpdate = /*    */6;\nvar Deletion = /*              */8;\nvar ContentReset = /*          */16;\nvar Callback = /*              */32;\nvar DidCapture = /*            */64;\nvar Ref = /*                   */128;\nvar Snapshot = /*              */256;\n\n// Union of all host effects\nvar HostEffectMask = /*        */511;\n\nvar Incomplete = /*            */512;\nvar ShouldCapture = /*         */1024;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender ? warning(false, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component') : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a.return;\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction addEventBubbleListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, false);\n}\n\nfunction addEventCaptureListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, true);\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar SyntheticAnimationEvent = SyntheticEvent$1.extend({\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar SyntheticClipboardEvent = SyntheticEvent$1.extend({\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n});\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticFocusEvent = SyntheticUIEvent.extend({\n  relatedTarget: null\n});\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode = void 0;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n  // report Enter as charCode 10 when ctrl is pressed.\n  if (charCode === 10) {\n    charCode = 13;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticKeyboardEvent = SyntheticUIEvent.extend({\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n});\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticDragEvent = SyntheticMouseEvent.extend({\n  dataTransfer: null\n});\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar SyntheticTouchEvent = SyntheticUIEvent.extend({\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar SyntheticTransitionEvent = SyntheticEvent$1.extend({\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticWheelEvent = SyntheticMouseEvent.extend({\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n});\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: [TOP_ABORT],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = new Map([\n *   [TOP_ABORT, { sameConfig }],\n * ]);\n */\n\nvar interactiveEventTypeNames = [[TOP_BLUR, 'blur'], [TOP_CANCEL, 'cancel'], [TOP_CLICK, 'click'], [TOP_CLOSE, 'close'], [TOP_CONTEXT_MENU, 'contextMenu'], [TOP_COPY, 'copy'], [TOP_CUT, 'cut'], [TOP_DOUBLE_CLICK, 'doubleClick'], [TOP_DRAG_END, 'dragEnd'], [TOP_DRAG_START, 'dragStart'], [TOP_DROP, 'drop'], [TOP_FOCUS, 'focus'], [TOP_INPUT, 'input'], [TOP_INVALID, 'invalid'], [TOP_KEY_DOWN, 'keyDown'], [TOP_KEY_PRESS, 'keyPress'], [TOP_KEY_UP, 'keyUp'], [TOP_MOUSE_DOWN, 'mouseDown'], [TOP_MOUSE_UP, 'mouseUp'], [TOP_PASTE, 'paste'], [TOP_PAUSE, 'pause'], [TOP_PLAY, 'play'], [TOP_POINTER_CANCEL, 'pointerCancel'], [TOP_POINTER_DOWN, 'pointerDown'], [TOP_POINTER_UP, 'pointerUp'], [TOP_RATE_CHANGE, 'rateChange'], [TOP_RESET, 'reset'], [TOP_SEEKED, 'seeked'], [TOP_SUBMIT, 'submit'], [TOP_TOUCH_CANCEL, 'touchCancel'], [TOP_TOUCH_END, 'touchEnd'], [TOP_TOUCH_START, 'touchStart'], [TOP_VOLUME_CHANGE, 'volumeChange']];\nvar nonInteractiveEventTypeNames = [[TOP_ABORT, 'abort'], [TOP_ANIMATION_END, 'animationEnd'], [TOP_ANIMATION_ITERATION, 'animationIteration'], [TOP_ANIMATION_START, 'animationStart'], [TOP_CAN_PLAY, 'canPlay'], [TOP_CAN_PLAY_THROUGH, 'canPlayThrough'], [TOP_DRAG, 'drag'], [TOP_DRAG_ENTER, 'dragEnter'], [TOP_DRAG_EXIT, 'dragExit'], [TOP_DRAG_LEAVE, 'dragLeave'], [TOP_DRAG_OVER, 'dragOver'], [TOP_DURATION_CHANGE, 'durationChange'], [TOP_EMPTIED, 'emptied'], [TOP_ENCRYPTED, 'encrypted'], [TOP_ENDED, 'ended'], [TOP_ERROR, 'error'], [TOP_GOT_POINTER_CAPTURE, 'gotPointerCapture'], [TOP_LOAD, 'load'], [TOP_LOADED_DATA, 'loadedData'], [TOP_LOADED_METADATA, 'loadedMetadata'], [TOP_LOAD_START, 'loadStart'], [TOP_LOST_POINTER_CAPTURE, 'lostPointerCapture'], [TOP_MOUSE_MOVE, 'mouseMove'], [TOP_MOUSE_OUT, 'mouseOut'], [TOP_MOUSE_OVER, 'mouseOver'], [TOP_PLAYING, 'playing'], [TOP_POINTER_MOVE, 'pointerMove'], [TOP_POINTER_OUT, 'pointerOut'], [TOP_POINTER_OVER, 'pointerOver'], [TOP_PROGRESS, 'progress'], [TOP_SCROLL, 'scroll'], [TOP_SEEKING, 'seeking'], [TOP_STALLED, 'stalled'], [TOP_SUSPEND, 'suspend'], [TOP_TIME_UPDATE, 'timeUpdate'], [TOP_TOGGLE, 'toggle'], [TOP_TOUCH_MOVE, 'touchMove'], [TOP_TRANSITION_END, 'transitionEnd'], [TOP_WAITING, 'waiting'], [TOP_WHEEL, 'wheel']];\n\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n\nfunction addEventTypeNameToConfig(_ref, isInteractive) {\n  var topEvent = _ref[0],\n      event = _ref[1];\n\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent],\n    isInteractive: isInteractive\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n}\n\ninteractiveEventTypeNames.forEach(function (eventTuple) {\n  addEventTypeNameToConfig(eventTuple, true);\n});\nnonInteractiveEventTypeNames.forEach(function (eventTuple) {\n  addEventTypeNameToConfig(eventTuple, false);\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  isInteractiveTopLevelEventType: function (topLevelType) {\n    var config = topLevelEventsToDispatchConfig[topLevelType];\n    return config !== undefined && config.isInteractive === true;\n  },\n\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor = void 0;\n    switch (topLevelType) {\n      case TOP_KEY_PRESS:\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case TOP_BLUR:\n      case TOP_FOCUS:\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case TOP_CLICK:\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case TOP_DOUBLE_CLICK:\n      case TOP_MOUSE_DOWN:\n      case TOP_MOUSE_MOVE:\n      case TOP_MOUSE_UP:\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case TOP_MOUSE_OUT:\n      case TOP_MOUSE_OVER:\n      case TOP_CONTEXT_MENU:\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case TOP_DRAG:\n      case TOP_DRAG_END:\n      case TOP_DRAG_ENTER:\n      case TOP_DRAG_EXIT:\n      case TOP_DRAG_LEAVE:\n      case TOP_DRAG_OVER:\n      case TOP_DRAG_START:\n      case TOP_DROP:\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case TOP_TOUCH_CANCEL:\n      case TOP_TOUCH_END:\n      case TOP_TOUCH_MOVE:\n      case TOP_TOUCH_START:\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case TOP_ANIMATION_END:\n      case TOP_ANIMATION_ITERATION:\n      case TOP_ANIMATION_START:\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case TOP_TRANSITION_END:\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case TOP_SCROLL:\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case TOP_WHEEL:\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case TOP_COPY:\n      case TOP_CUT:\n      case TOP_PASTE:\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      case TOP_GOT_POINTER_CAPTURE:\n      case TOP_LOST_POINTER_CAPTURE:\n      case TOP_POINTER_CANCEL:\n      case TOP_POINTER_DOWN:\n      case TOP_POINTER_MOVE:\n      case TOP_POINTER_OUT:\n      case TOP_POINTER_OVER:\n      case TOP_POINTER_UP:\n        EventConstructor = SyntheticPointerEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent$1;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nvar isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;\n\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst.return) {\n    inst = inst.return;\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventBubbleListener(element, getRawEventName(topLevelType),\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventCaptureListener(element, getRawEventName(topLevelType),\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\nfunction dispatchInteractiveEvent(topLevelType, nativeEvent) {\n  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nvar ReactDOMEventListener = Object.freeze({\n\tget _enabled () { return _enabled; },\n\tsetEnabled: setEnabled,\n\tisEnabled: isEnabled,\n\ttrapBubbledEvent: trapBubbledEvent,\n\ttrapCapturedEvent: trapCapturedEvent,\n\tdispatchEvent: dispatchEvent\n});\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */\nfunction listenTo(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      switch (dependency) {\n        case TOP_SCROLL:\n          trapCapturedEvent(TOP_SCROLL, mountAt);\n          break;\n        case TOP_FOCUS:\n        case TOP_BLUR:\n          trapCapturedEvent(TOP_FOCUS, mountAt);\n          trapCapturedEvent(TOP_BLUR, mountAt);\n          // We set the flag for a single dependency later in this function,\n          // but this ensures we mark both as attached rather than just one.\n          isListening[TOP_BLUR] = true;\n          isListening[TOP_FOCUS] = true;\n          break;\n        case TOP_CANCEL:\n        case TOP_CLOSE:\n          if (isEventSupported(getRawEventName(dependency), true)) {\n            trapCapturedEvent(dependency, mountAt);\n          }\n          break;\n        case TOP_INVALID:\n        case TOP_SUBMIT:\n        case TOP_RESET:\n          // We listen to them on the target DOM elements.\n          // Some of them bubble so we don't want them to fire twice.\n          break;\n        default:\n          // By default, listen on the top level to all non-media events.\n          // Media events don't bubble so adding the listener wouldn't do anything.\n          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;\n          if (!isMediaEvent) {\n            trapBubbledEvent(dependency, mountAt);\n          }\n          break;\n      }\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode,\n      anchorOffset = selection.anchorOffset,\n      focusNode = selection.focusNode,\n      focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\n/**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElement();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElement();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    if (typeof priorFocusedElem.focus === 'function') {\n      priorFocusedElem.focus();\n    }\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case TOP_FOCUS:\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case TOP_BLUR:\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case TOP_MOUSE_DOWN:\n        mouseDown = true;\n        break;\n      case TOP_CONTEXT_MENU:\n      case TOP_MOUSE_UP:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case TOP_SELECTION_CHANGE:\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(DOMEventPluginOrder);\ninjection$1.injectComponentTree(ReactDOMComponentTree);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\n\nvar localRequestAnimationFrame$1 = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n\n/**\n * A scheduling library to allow scheduling work with more granular priority and\n * control than requestAnimationFrame and requestIdleCallback.\n * Current TODO items:\n * X- Pull out the scheduleWork polyfill built into React\n * X- Initial test coverage\n * X- Support for multiple callbacks\n * - Support for two priorities; serial and deferred\n * - Better test coverage\n * - Better docblock\n * - Polish documentation, API\n */\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\nvar localDate = Date;\nvar localSetTimeout = setTimeout;\nvar localClearTimeout = clearTimeout;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar now$1 = void 0;\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  now$1 = function () {\n    return Performance.now();\n  };\n} else {\n  now$1 = function () {\n    return localDate.now();\n  };\n}\n\nvar scheduleWork = void 0;\nvar cancelScheduledWork = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  var timeoutIds = new Map();\n\n  scheduleWork = function (callback, options) {\n    // keeping return type consistent\n    var callbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: 0,\n      next: null,\n      prev: null\n    };\n    var timeoutId = localSetTimeout(function () {\n      callback({\n        timeRemaining: function () {\n          return Infinity;\n        },\n\n        didTimeout: false\n      });\n    });\n    timeoutIds.set(callback, timeoutId);\n    return callbackConfig;\n  };\n  cancelScheduledWork = function (callbackId) {\n    var callback = callbackId.scheduledCallback;\n    var timeoutId = timeoutIds.get(callback);\n    timeoutIds.delete(callbackId);\n    localClearTimeout(timeoutId);\n  };\n} else {\n  {\n    if (typeof localRequestAnimationFrame$1 !== 'function') {\n      warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var localRequestAnimationFrame = typeof localRequestAnimationFrame$1 === 'function' ? localRequestAnimationFrame$1 : function (callback) {\n    invariant(false, 'React depends on requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills');\n  };\n\n  var headOfPendingCallbacksLinkedList = null;\n  var tailOfPendingCallbacksLinkedList = null;\n\n  // We track what the next soonest timeoutTime is, to be able to quickly tell\n  // if none of the scheduled callbacks have timed out.\n  var nextSoonestTimeoutTime = -1;\n\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = {\n    didTimeout: false,\n    timeRemaining: function () {\n      var remaining = frameDeadline - now$1();\n      return remaining > 0 ? remaining : 0;\n    }\n  };\n\n  /**\n   * Handles the case where a callback errors:\n   * - don't catch the error, because this changes debugging behavior\n   * - do start a new postMessage callback, to call any remaining callbacks,\n   * - but only if there is an error, so there is not extra overhead.\n   */\n  var callUnsafely = function (callbackConfig, arg) {\n    var callback = callbackConfig.scheduledCallback;\n    var finishedCalling = false;\n    try {\n      callback(arg);\n      finishedCalling = true;\n    } finally {\n      // always remove it from linked list\n      cancelScheduledWork(callbackConfig);\n\n      if (!finishedCalling) {\n        // an error must have been thrown\n        isIdleScheduled = true;\n        window.postMessage(messageKey, '*');\n      }\n    }\n  };\n\n  /**\n   * Checks for timed out callbacks, runs them, and then checks again to see if\n   * any more have timed out.\n   * Keeps doing this until there are none which have currently timed out.\n   */\n  var callTimedOutCallbacks = function () {\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    var currentTime = now$1();\n    // TODO: this would be more efficient if deferred callbacks are stored in\n    // min heap.\n    // Or in a linked list with links for both timeoutTime order and insertion\n    // order.\n    // For now an easy compromise is the current approach:\n    // Keep a pointer to the soonest timeoutTime, and check that first.\n    // If it has not expired, we can skip traversing the whole list.\n    // If it has expired, then we step through all the callbacks.\n    if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n      // We know that none of them have timed out yet.\n      return;\n    }\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    // If a timed out callback throws an error, we could get stuck in a state\n    // where the nextSoonestTimeoutTime was set wrong.\n    var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n    var timedOutCallbacks = [];\n\n    // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n    var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n    while (currentCallbackConfig !== null) {\n      var _timeoutTime = currentCallbackConfig.timeoutTime;\n      if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n        // it has timed out!\n        timedOutCallbacks.push(currentCallbackConfig);\n      } else {\n        if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n          updatedNextSoonestTimeoutTime = _timeoutTime;\n        }\n      }\n      currentCallbackConfig = currentCallbackConfig.next;\n    }\n\n    if (timedOutCallbacks.length > 0) {\n      frameDeadlineObject.didTimeout = true;\n      for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n        callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n      }\n    }\n\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    // First call anything which has timed out, until we have caught up.\n    callTimedOutCallbacks();\n\n    var currentTime = now$1();\n    // Next, as long as we have idle time, try calling more callbacks.\n    while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n      var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n      frameDeadlineObject.didTimeout = false;\n      // callUnsafely will remove it from the head of the linked list\n      callUnsafely(latestCallbackConfig, frameDeadlineObject);\n      currentTime = now$1();\n    }\n    if (headOfPendingCallbacksLinkedList !== null) {\n      if (!isAnimationFrameScheduled) {\n        // Schedule another animation callback so we retry later.\n        isAnimationFrameScheduled = true;\n        localRequestAnimationFrame(animationTick);\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  scheduleWork = function (callback, options) /* CallbackConfigType */{\n    var timeoutTime = -1;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = now$1() + options.timeout;\n    }\n    if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n      nextSoonestTimeoutTime = timeoutTime;\n    }\n\n    var scheduledCallbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: timeoutTime,\n      prev: null,\n      next: null\n    };\n    if (headOfPendingCallbacksLinkedList === null) {\n      // Make this callback the head and tail of our list\n      headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    } else {\n      // Add latest callback as the new tail of the list\n      scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList;\n      // renaming for clarity\n      var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n      if (oldTailOfPendingCallbacksLinkedList !== null) {\n        oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n      }\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    }\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      localRequestAnimationFrame(animationTick);\n    }\n    return scheduledCallbackConfig;\n  };\n\n  cancelScheduledWork = function (callbackConfig /* CallbackConfigType */\n  ) {\n    if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n      // this callbackConfig has already been cancelled.\n      // cancelScheduledWork should be idempotent, a no-op after first call.\n      return;\n    }\n\n    /**\n     * There are four possible cases:\n     * - Head/nodeToRemove/Tail -> null\n     *   In this case we set Head and Tail to null.\n     * - Head -> ... middle nodes... -> Tail/nodeToRemove\n     *   In this case we point the middle.next to null and put middle as the new\n     *   Tail.\n     * - Head/nodeToRemove -> ...middle nodes... -> Tail\n     *   In this case we point the middle.prev at null and move the Head to\n     *   middle.\n     * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n     *   In this case we point the Head.next to the Tail and the Tail.prev to\n     *   the Head.\n     */\n    var next = callbackConfig.next;\n    var prev = callbackConfig.prev;\n    callbackConfig.next = null;\n    callbackConfig.prev = null;\n    if (next !== null) {\n      // we have a next\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n        prev.next = next;\n        next.prev = prev;\n        return;\n      } else {\n        // there is a next but not a previous one;\n        // callbackConfig is the head of a list of 2 or more other nodes.\n        next.prev = null;\n        headOfPendingCallbacksLinkedList = next;\n        return;\n      }\n    } else {\n      // there is no next callback config; this must the tail of the list\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is the tail of a list of 2 or more other nodes.\n        prev.next = null;\n        tailOfPendingCallbacksLinkedList = prev;\n        return;\n      } else {\n        // there is no previous callback config;\n        // callbackConfig is the only thing in the linked list,\n        // so both head and tail point to it.\n        headOfPendingCallbacksLinkedList = null;\n        tailOfPendingCallbacksLinkedList = null;\n        return;\n      }\n    }\n  };\n}\n\nvar didWarnSelectedSetOnOption = false;\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children and warn if they aren't strings or numbers;\n  // invalid types are ignored.\n  // We can silently skip them because invalid DOM nesting warning\n  // catches these cases in Fiber.\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    if (typeof child === 'string' || typeof child === 'number') {\n      content += child;\n    }\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  // TODO (yungsters): Remove support for `selected` in <option>.\n  {\n    if (props.selected != null && !didWarnSelectedSetOnOption) {\n      warning(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n      didWarnSelectedSetOnOption = true;\n    }\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', props.value);\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\nvar didWarnValueDefaultValue$1 = void 0;\n\n{\n  didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerName$3();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$3);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = '' + propValue;\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  var value = props.value;\n  node._wrapperState = {\n    initialValue: value != null ? value : props.defaultValue,\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  // After the initial mount, we control selected-ness manually so don't pass\n  // this value down\n  node._wrapperState.initialValue = undefined;\n\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: '' + node._wrapperState.initialValue\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$4);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: '' + initialValue\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = props.value;\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = '' + value;\n\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (props.defaultValue != null) {\n    node.defaultValue = props.defaultValue;\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar warnValidStyle = emptyFunction;\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var warnHyphenatedStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());\n  };\n\n  var warnBadVendoredStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value, getStack) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());\n  };\n\n  var warnStyleValueIsNaN = function (name, value, getStack) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  var warnStyleValueIsInfinity = function (name, value, getStack) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  warnValidStyle = function (name, value, getStack) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name, getStack);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name, getStack);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value, getStack);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value, getStack);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value, getStack);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles, getStack) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName], getStack);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n  // NOTE: menuitem's close tag should be omitted, but that causes problems.\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\nvar HTML$1 = '__html';\n\nfunction assertValidProps(tag, props, getStack) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack()) : void 0;\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getStack()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  class: 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  default: 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  for: 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nomodule: 'noModule',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  in: 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  typeof: 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getStackAddendum() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  } else if (invalidProps.length > 1) {\n    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction getStackAddendum$1() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());\n    } else {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());\n    }\n  }\n}\n\nfunction getStackAddendum$2() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nvar validateProperty$1 = function () {};\n\n{\n  var warnedProperties$1 = {};\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on./;\n  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\n    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // We can't rely on the event system being injected on the server.\n    if (canUseEventSystem) {\n      if (registrationNameModules.hasOwnProperty(name)) {\n        return true;\n      }\n      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n      if (registrationName != null) {\n        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n      if (EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we are in a server environment.\n      // So we can't tell if the event name is correct for sure, but we can filter\n      // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n      if (INVALID_EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var propertyInfo = getPropertyInfo(name);\n    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      if (value) {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());\n      } else {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, canUseEventSystem) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  } else if (unknownProps.length > 1) {\n    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  }\n};\n\nfunction validateProperties$2(type, props, canUseEventSystem) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, canUseEventSystem);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar getStack = emptyFunction.thatReturns('');\n\nvar warnedUnknownTags = void 0;\nvar suppressHydrationWarning = void 0;\n\nvar validatePropertiesInDevelopment = void 0;\nvar warnForTextDifference = void 0;\nvar warnForPropDifference = void 0;\nvar warnForExtraAttributes = void 0;\nvar warnForInvalidEventListener = void 0;\n\nvar normalizeMarkupForTextOrAttribute = void 0;\nvar normalizeHTML = void 0;\n\n{\n  getStack = getCurrentFiberStackAddendum$2;\n\n  warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true\n  };\n\n  validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props, /* canUseEventSystem */true);\n  };\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warning(false, 'Extra attributes from the server: %s', names);\n  };\n\n  warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());\n    } else {\n      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = emptyFunction;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We blacklist it here rather than in the property list because we emit it in SSR.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (nextProp != null) {\n      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {\n      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n    }\n  }\n}\n\nfunction createElement$1(type, props, rootContainerElement, parentNamespace) {\n  var isCustomComponentTag = void 0;\n\n  // We create tags in the namespace of their parent container, except HTML\n  // tags get no namespace.\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement = void 0;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      !(isCustomComponentTag || type === type.toLowerCase()) ? warning(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type) : void 0;\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode$1(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$2() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props = void 0;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent(TOP_LOAD, domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var i = 0; i < mediaEventTypes.length; i++) {\n        trapBubbledEvent(mediaEventTypes[i], domElement);\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      trapBubbledEvent(TOP_LOAD, domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent(TOP_RESET, domElement);\n      trapBubbledEvent(TOP_SUBMIT, domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent(TOP_TOGGLE, domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props, getStack);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps, false);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps = void 0;\n  var nextProps = void 0;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps, getStack);\n\n  var propKey = void 0;\n  var styleName = void 0;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  // Update checked *before* name.\n  // In the middle of an update, it is possible to have multiple checked.\n  // When a checked radio tries to change name, browser makes another radio's checked false.\n  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\n    updateChecked(domElement, nextRawProps);\n  }\n\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction getPossibleStandardName(propName) {\n  {\n    var lowerCasedName = propName.toLowerCase();\n    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      return null;\n    }\n    return possibleStandardNames[lowerCasedName] || null;\n  }\n  return null;\n}\n\nfunction diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  var isCustomComponentTag = void 0;\n  var extraAttributeNames = void 0;\n\n  {\n    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$2() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent(TOP_LOAD, domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var i = 0; i < mediaEventTypes.length; i++) {\n        trapBubbledEvent(mediaEventTypes[i], domElement);\n      }\n      break;\n    case 'source':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      trapBubbledEvent(TOP_LOAD, domElement);\n      break;\n    case 'form':\n      trapBubbledEvent(TOP_RESET, domElement);\n      trapBubbledEvent(TOP_SUBMIT, domElement);\n      break;\n    case 'details':\n      trapBubbledEvent(TOP_TOGGLE, domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps, getStack);\n\n  {\n    extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var _i = 0; _i < attributes.length; _i++) {\n      var name = attributes[_i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[_i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (true &&\n    // Convince Flow we've calculated it (it's DEV-only in this method.)\n    typeof isCustomComponentTag === 'boolean') {\n      // Validate that the properties correspond to their expected values.\n      var serverValue = void 0;\n      var propertyInfo = getPropertyInfo(propKey);\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n        var serverHTML = domElement.innerHTML;\n        var expectedHTML = normalizeHTML(domElement, rawHtml);\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames.delete(propKey);\n        var expectedStyle = createDangerousStringForStyles(nextProp);\n        serverValue = domElement.getAttribute('style');\n        if (expectedStyle !== serverValue) {\n          warnForPropDifference(propKey, serverValue, expectedStyle);\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames.delete(propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n        var isMismatchDueToBadCasing = false;\n        if (propertyInfo !== null) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames.delete(propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames.delete(propKey.toLowerCase());\n          } else {\n            var standardName = getPossibleStandardName(propKey);\n            if (standardName !== null && standardName !== propKey) {\n              // If an SVG prop is supplied with bad casing, it will\n              // be successfully parsed from HTML, but will produce a mismatch\n              // (and would be incorrectly rendered on the client).\n              // However, we already warn about bad casing elsewhere.\n              // So we'll skip the misleading extra mismatch warning in this case.\n              isMismatchDueToBadCasing = true;\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames.delete(standardName);\n            }\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames.delete(propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps, true);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText$1(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText$1(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement$1(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText$1(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState$1(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\nvar ReactDOMFiberComponent = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateTextNode: createTextNode$1,\n\tsetInitialProperties: setInitialProperties$1,\n\tdiffProperties: diffProperties$1,\n\tupdateProperties: updateProperties$1,\n\tdiffHydratedProperties: diffHydratedProperties$1,\n\tdiffHydratedText: diffHydratedText$1,\n\twarnForUnmatchedText: warnForUnmatchedText$1,\n\twarnForDeletedHydratableElement: warnForDeletedHydratableElement$1,\n\twarnForDeletedHydratableText: warnForDeletedHydratableText$1,\n\twarnForInsertedHydratedElement: warnForInsertedHydratedElement$1,\n\twarnForInsertedHydratedText: warnForInsertedHydratedText$1,\n\trestoreControlledState: restoreControlledState$1\n});\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar validateDOMNesting = emptyFunction;\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      !(childTag == null) ? warning(false, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackAddendum$5();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n\n  // TODO: turn this into a named export\n  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;\n}\n\nvar validateDOMNesting$1 = validateDOMNesting;\n\n// Renderers that don't support persistence\n// can re-export everything from this module.\n\nfunction shim() {\n  invariant(false, 'The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.');\n}\n\n// Persistence (when unsupported)\nvar supportsPersistence = false;\nvar cloneInstance = shim;\nvar createContainerChildSet = shim;\nvar appendChildToContainerChildSet = shim;\nvar finalizeContainerChildren = shim;\nvar replaceContainerChildren = shim;\n\n// Unused\n\nvar createElement = createElement$1;\nvar createTextNode = createTextNode$1;\nvar setInitialProperties = setInitialProperties$1;\nvar diffProperties = diffProperties$1;\nvar updateProperties = updateProperties$1;\nvar diffHydratedProperties = diffHydratedProperties$1;\nvar diffHydratedText = diffHydratedText$1;\nvar warnForUnmatchedText = warnForUnmatchedText$1;\nvar warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;\nvar warnForDeletedHydratableText = warnForDeletedHydratableText$1;\nvar warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;\nvar warnForInsertedHydratedText = warnForInsertedHydratedText$1;\nvar updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;\nvar precacheFiberNode$1 = precacheFiberNode;\nvar updateFiberProps$1 = updateFiberProps;\n\n\nvar SUPPRESS_HYDRATION_WARNING = void 0;\n{\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nfunction getRootHostContext(rootContainerInstance) {\n  var type = void 0;\n  var namespace = void 0;\n  var nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        var root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n    default:\n      {\n        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        var ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n  {\n    var validatedTag = type.toLowerCase();\n    var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n    return { namespace: namespace, ancestorInfo: _ancestorInfo };\n  }\n  return namespace;\n}\n\nfunction getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  {\n    var parentHostContextDev = parentHostContext;\n    var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n    return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n  }\n  var parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\n\nfunction getPublicInstance(instance) {\n  return instance;\n}\n\nfunction prepareForCommit(containerInfo) {\n  eventsEnabled = isEnabled();\n  selectionInformation = getSelectionInformation();\n  setEnabled(false);\n}\n\nfunction resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  selectionInformation = null;\n  setEnabled(eventsEnabled);\n  eventsEnabled = null;\n}\n\nfunction createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  var parentNamespace = void 0;\n  {\n    // TODO: take namespace into account when validating.\n    var hostContextDev = hostContext;\n    validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      var string = '' + props.children;\n      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n      validateDOMNesting$1(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  }\n  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode$1(internalInstanceHandle, domElement);\n  updateFiberProps$1(domElement, props);\n  return domElement;\n}\n\nfunction appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\n\nfunction finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\n\nfunction prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n  {\n    var hostContextDev = hostContext;\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      var string = '' + newProps.children;\n      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n      validateDOMNesting$1(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n}\n\nfunction shouldSetTextContent(type, props) {\n  return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n}\n\nfunction shouldDeprioritizeSubtree(type, props) {\n  return !!props.hidden;\n}\n\nfunction createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  {\n    var hostContextDev = hostContext;\n    validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);\n  }\n  var textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode$1(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nvar now = now$1;\nvar isPrimaryRenderer = true;\nvar scheduleDeferredCallback = scheduleWork;\nvar cancelDeferredCallback = cancelScheduledWork;\n\n// -------------------\n//     Mutation\n// -------------------\n\nvar supportsMutation = true;\n\nfunction commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    domElement.focus();\n  }\n}\n\nfunction commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps$1(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n\nfunction resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\n\nfunction commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\n\nfunction appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\n\nfunction appendChildToContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, container);\n  } else {\n    container.appendChild(child);\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nfunction insertInContainerBefore(container, child, beforeChild) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\n\nfunction removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nvar supportsHydration = true;\n\nfunction canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return instance;\n}\n\nfunction canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return instance;\n}\n\nfunction getNextHydratableSibling(instance) {\n  var node = instance.nextSibling;\n  // Skip non-hydratable nodes.\n  while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n    node = node.nextSibling;\n  }\n  return node;\n}\n\nfunction getFirstHydratableChild(parentInstance) {\n  var next = parentInstance.firstChild;\n  // Skip non-hydratable nodes.\n  while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n    next = next.nextSibling;\n  }\n  return next;\n}\n\nfunction hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  precacheFiberNode$1(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps$1(instance, props);\n  var parentNamespace = void 0;\n  {\n    var hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  }\n  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n}\n\nfunction hydrateTextInstance(textInstance, text, internalInstanceHandle) {\n  precacheFiberNode$1(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\n\nfunction didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\n  {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nfunction didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nfunction didNotHydrateContainerInstance(parentContainer, instance) {\n  {\n    if (instance.nodeType === 1) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\n\nfunction didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === 1) {\n      warnForDeletedHydratableElement(parentInstance, instance);\n    } else {\n      warnForDeletedHydratableText(parentInstance, instance);\n    }\n  }\n}\n\nfunction didNotFindHydratableContainerInstance(parentContainer, type, props) {\n  {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nfunction didNotFindHydratableContainerTextInstance(parentContainer, text) {\n  {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nfunction didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\n\nfunction didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\n\n// Exports ReactDOM.createRoot\nvar enableUserTimingAPI = true;\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\nvar enableGetDerivedStateFromCatch = false;\n// Suspense\nvar enableSuspense = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\nvar debugRenderPhaseSideEffectsForStrictMode = true;\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\nvar warnAboutDeprecatedLifecycles = false;\n\n// Warn about legacy context API\nvar warnAboutLegacyContextAPI = false;\n\n// Gather advanced timing metrics for Profiler subtrees.\nvar enableProfilerTimer = true;\n\n// Only used in www builds.\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber.return;\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning$$1);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy) || 'Unknown';\n        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, '(React Tree Reconciliation)', warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Snapshot Effects)');\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\nvar valueStack = [];\n\nvar fiberStack = void 0;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction checkThatStackIsEmpty() {\n  {\n    if (index !== -1) {\n      warning(false, 'Expected an empty stack. Something was not reset properly.');\n    }\n  }\n}\n\nfunction resetStackAfterFatalErrorInDev() {\n  {\n    index = -1;\n    valueStack.length = 0;\n    fiberStack.length = 0;\n  }\n}\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.current === emptyObject) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n  }\n  startPhaseTimer(fiber, 'getChildContext');\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(fiber) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node.return;\n    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\n\n// TODO: Use an opaque type once ESLint et al support the syntax\n\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = MAX_SIGNED_31_BIT_INT;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return MAGIC_NUMBER_OFFSET + ceiling(currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\nvar ProfileMode = 4;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = 0;\n    this.actualStartTime = 0;\n    this.selfBaseTime = 0;\n    this.treeBaseTime = 0;\n  }\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = 0;\n    }\n  }\n\n  workInProgress.expirationTime = expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseTime = current.selfBaseTime;\n    workInProgress.treeBaseTime = current.treeBaseTime;\n  }\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === 'function') {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_TIMEOUT_TYPE:\n        fiberTag = TimeoutComponent;\n        // Suspense does not require async, but its children should be strict\n        // mode compatible.\n        mode |= StrictMode;\n        break;\n      default:\n        fiberTag = getFiberTagFromObjectType(type, owner);\n        break;\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction getFiberTagFromObjectType(type, owner) {\n  var $$typeof = typeof type === 'object' && type !== null ? type.$$typeof : null;\n\n  switch ($$typeof) {\n    case REACT_PROVIDER_TYPE:\n      return ContextProvider;\n    case REACT_CONTEXT_TYPE:\n      // This is a consumer\n      return ContextConsumer;\n    case REACT_FORWARD_REF_TYPE:\n      return ForwardRef;\n    default:\n      {\n        var info = '';\n        {\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n          }\n          var ownerName = owner ? getComponentName(owner) : null;\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n      }\n  }\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\n  {\n    if (typeof pendingProps.id !== 'string' || typeof pendingProps.onRender !== 'function') {\n      invariant(false, 'Profiler must specify an \"id\" string and \"onRender\" function as props');\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.type = REACT_PROFILER_TYPE;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseTime = source.selfBaseTime;\n    target.treeBaseTime = source.treeBaseTime;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n// TODO: This should be lifted into the renderer.\n\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n\n    earliestPendingTime: NoWork,\n    latestPendingTime: NoWork,\n    earliestSuspendedTime: NoWork,\n    latestSuspendedTime: NoWork,\n    latestPingedTime: NoWork,\n\n    pendingCommitExpirationTime: NoWork,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    remainingExpirationTime: NoWork,\n    firstBatch: null,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function () {},\n  flushPendingDeprecationWarnings: function () {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordDeprecationWarnings: function (fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\n  recordLegacyContextWarning: function (fiber, instance) {},\n  flushLegacyContextWarning: function () {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: 'componentDidMount',\n    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',\n    UNSAFE_componentWillUpdate: 'componentDidUpdate'\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n  var pendingLegacyContextWarning = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n  var didWarnAboutLegacyContext = new Set();\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n    pendingLegacyContextWarning = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function (fiber) {\n            componentNames.add(getComponentName(fiber) || 'Component');\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace('UNSAFE_', '');\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(strictRoot);\n\n        warning(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\\n\\n%s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMesages.join('\\n\\n'));\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var findStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n\n    var node = fiber;\n    while (node !== null) {\n      if (node.mode & StrictMode) {\n        maybeStrictRoot = node;\n      }\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        _uniqueNames.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        _uniqueNames2.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warning(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillMount');\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillUpdate');\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function (lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warning(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n      var uniqueNames = new Set();\n      fiberArray.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber) || 'Component');\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n      var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(strictRoot);\n\n      warning(false, 'Legacy context API has been detected within a strict-mode tree: %s' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, sortedNames);\n    });\n  };\n}\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n// TODO: Offscreen updates\n\nfunction markPendingPriorityLevel(root, expirationTime) {\n  if (enableSuspense) {\n    // Update the latest and earliest pending times\n    var earliestPendingTime = root.earliestPendingTime;\n    if (earliestPendingTime === NoWork) {\n      // No other pending updates.\n      root.earliestPendingTime = root.latestPendingTime = expirationTime;\n    } else {\n      if (earliestPendingTime > expirationTime) {\n        // This is the earliest pending update.\n        root.earliestPendingTime = expirationTime;\n      } else {\n        var latestPendingTime = root.latestPendingTime;\n        if (latestPendingTime < expirationTime) {\n          // This is the latest pending update\n          root.latestPendingTime = expirationTime;\n        }\n      }\n    }\n  }\n}\n\nfunction markCommittedPriorityLevels(root, currentTime, earliestRemainingTime) {\n  if (enableSuspense) {\n    if (earliestRemainingTime === NoWork) {\n      // Fast path. There's no remaining work. Clear everything.\n      root.earliestPendingTime = NoWork;\n      root.latestPendingTime = NoWork;\n      root.earliestSuspendedTime = NoWork;\n      root.latestSuspendedTime = NoWork;\n      root.latestPingedTime = NoWork;\n      return;\n    }\n\n    // Let's see if the previous latest known pending level was just flushed.\n    var latestPendingTime = root.latestPendingTime;\n    if (latestPendingTime !== NoWork) {\n      if (latestPendingTime < earliestRemainingTime) {\n        // We've flushed all the known pending levels.\n        root.earliestPendingTime = root.latestPendingTime = NoWork;\n      } else {\n        var earliestPendingTime = root.earliestPendingTime;\n        if (earliestPendingTime < earliestRemainingTime) {\n          // We've flushed the earliest known pending level. Set this to the\n          // latest pending time.\n          root.earliestPendingTime = root.latestPendingTime;\n        }\n      }\n    }\n\n    // Now let's handle the earliest remaining level in the whole tree. We need to\n    // decide whether to treat it as a pending level or as suspended. Check\n    // it falls within the range of known suspended levels.\n\n    var earliestSuspendedTime = root.earliestSuspendedTime;\n    if (earliestSuspendedTime === NoWork) {\n      // There's no suspended work. Treat the earliest remaining level as a\n      // pending level.\n      markPendingPriorityLevel(root, earliestRemainingTime);\n      return;\n    }\n\n    var latestSuspendedTime = root.latestSuspendedTime;\n    if (earliestRemainingTime > latestSuspendedTime) {\n      // The earliest remaining level is later than all the suspended work. That\n      // means we've flushed all the suspended work.\n      root.earliestSuspendedTime = NoWork;\n      root.latestSuspendedTime = NoWork;\n      root.latestPingedTime = NoWork;\n\n      // There's no suspended work. Treat the earliest remaining level as a\n      // pending level.\n      markPendingPriorityLevel(root, earliestRemainingTime);\n      return;\n    }\n\n    if (earliestRemainingTime < earliestSuspendedTime) {\n      // The earliest remaining time is earlier than all the suspended work.\n      // Treat it as a pending update.\n      markPendingPriorityLevel(root, earliestRemainingTime);\n      return;\n    }\n\n    // The earliest remaining time falls within the range of known suspended\n    // levels. We should treat this as suspended work.\n  }\n}\n\nfunction markSuspendedPriorityLevel(root, suspendedTime) {\n  if (enableSuspense) {\n    // First, check the known pending levels and update them if needed.\n    var earliestPendingTime = root.earliestPendingTime;\n    var latestPendingTime = root.latestPendingTime;\n    if (earliestPendingTime === suspendedTime) {\n      if (latestPendingTime === suspendedTime) {\n        // Both known pending levels were suspended. Clear them.\n        root.earliestPendingTime = root.latestPendingTime = NoWork;\n      } else {\n        // The earliest pending level was suspended. Clear by setting it to the\n        // latest pending level.\n        root.earliestPendingTime = latestPendingTime;\n      }\n    } else if (latestPendingTime === suspendedTime) {\n      // The latest pending level was suspended. Clear by setting it to the\n      // latest pending level.\n      root.latestPendingTime = earliestPendingTime;\n    }\n\n    // Next, if we're working on the lowest known suspended level, clear the ping.\n    // TODO: What if a promise suspends and pings before the root completes?\n    var latestSuspendedTime = root.latestSuspendedTime;\n    if (latestSuspendedTime === suspendedTime) {\n      root.latestPingedTime = NoWork;\n    }\n\n    // Finally, update the known suspended levels.\n    var earliestSuspendedTime = root.earliestSuspendedTime;\n    if (earliestSuspendedTime === NoWork) {\n      // No other suspended levels.\n      root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\n    } else {\n      if (earliestSuspendedTime > suspendedTime) {\n        // This is the earliest suspended level.\n        root.earliestSuspendedTime = suspendedTime;\n      } else if (latestSuspendedTime < suspendedTime) {\n        // This is the latest suspended level\n        root.latestSuspendedTime = suspendedTime;\n      }\n    }\n  }\n}\n\nfunction markPingedPriorityLevel(root, pingedTime) {\n  if (enableSuspense) {\n    var latestSuspendedTime = root.latestSuspendedTime;\n    if (latestSuspendedTime !== NoWork && latestSuspendedTime <= pingedTime) {\n      var latestPingedTime = root.latestPingedTime;\n      if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {\n        root.latestPingedTime = pingedTime;\n      }\n    }\n  }\n}\n\nfunction findNextPendingPriorityLevel(root) {\n  if (enableSuspense) {\n    var earliestSuspendedTime = root.earliestSuspendedTime;\n    var earliestPendingTime = root.earliestPendingTime;\n    if (earliestSuspendedTime === NoWork) {\n      // Fast path. There's no suspended work.\n      return earliestPendingTime;\n    }\n\n    // First, check if there's known pending work.\n    if (earliestPendingTime !== NoWork) {\n      return earliestPendingTime;\n    }\n\n    // Finally, if a suspended level was pinged, work on that. Otherwise there's\n    // nothing to work on.\n    return root.latestPingedTime;\n  } else {\n    return root.current.expirationTime;\n  }\n}\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which is\n// can be mutated and processed asynchronously before it is committed — a form\n// of double buffering. If a work-in-progress render is discarded before\n// finishing, we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate = false;\n\nvar didWarnUpdateInsideUpdate = void 0;\nvar currentlyProcessingQueue = void 0;\nvar resetCurrentlyProcessingQueue = void 0;\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = function () {\n    currentlyProcessingQueue = null;\n  };\n}\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    expirationTime: NoWork,\n    baseState: baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue(currentQueue) {\n  var queue = {\n    expirationTime: currentQueue.expirationTime,\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction createUpdate(expirationTime) {\n  return {\n    expirationTime: expirationTime,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n    nextEffect: null\n  };\n}\n\nfunction appendUpdateToQueue(queue, update, expirationTime) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > expirationTime) {\n    // The incoming update has the earliest expiration of any update in the\n    // queue. Update the queue's expiration time.\n    queue.expirationTime = expirationTime;\n  }\n}\n\nfunction enqueueUpdate(fiber, update, expirationTime) {\n  // Update queues are created lazily.\n  var alternate = fiber.alternate;\n  var queue1 = void 0;\n  var queue2 = void 0;\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update, expirationTime);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list — we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update, expirationTime);\n      appendUpdateToQueue(queue2, update, expirationTime);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update, expirationTime);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  {\n    if (fiber.tag === ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nfunction enqueueCapturedUpdate(workInProgress, update, renderExpirationTime) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  var workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n  if (workInProgressQueue.expirationTime === NoWork || workInProgressQueue.expirationTime > renderExpirationTime) {\n    // The incoming update has the earliest expiration of any update in the\n    // queue. Update the queue's expiration time.\n    workInProgressQueue.expirationTime = renderExpirationTime;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n  var current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        var _payload = update.payload;\n        if (typeof _payload === 'function') {\n          // Updater function\n          {\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              _payload.call(instance, prevState, nextProps);\n            }\n          }\n          return _payload.call(instance, prevState, nextProps);\n        }\n        // State object\n        return _payload;\n      }\n    case CaptureUpdate:\n      {\n        workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n    case UpdateState:\n      {\n        var _payload2 = update.payload;\n        var partialState = void 0;\n        if (typeof _payload2 === 'function') {\n          // Updater function\n          {\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              _payload2.call(instance, prevState, nextProps);\n            }\n          }\n          partialState = _payload2.call(instance, prevState, nextProps);\n        } else {\n          // Partial state object\n          partialState = _payload2;\n        }\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        }\n        // Merge the partial state and the previous state.\n        return _assign({}, prevState, partialState);\n      }\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n  return prevState;\n}\n\nfunction processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {\n  hasForceUpdate = false;\n\n  if (queue.expirationTime === NoWork || queue.expirationTime > renderExpirationTime) {\n    // Insufficient priority. Bailout.\n    return;\n  }\n\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  var newBaseState = queue.baseState;\n  var newFirstUpdate = null;\n  var newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  var update = queue.firstUpdate;\n  var resultState = newBaseState;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime === NoWork || newExpirationTime > updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      var _callback = update.callback;\n      if (_callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  var newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    var _updateExpirationTime = update.expirationTime;\n    if (_updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime === NoWork || newExpirationTime > _updateExpirationTime) {\n        newExpirationTime = _updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      var _callback2 = update.callback;\n      if (_callback2 !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n  queue.expirationTime = newExpirationTime;\n\n  workInProgress.memoizedState = resultState;\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  !(typeof callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', callback) : void 0;\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\n\nfunction commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  var effect = finishedQueue.firstEffect;\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n  while (effect !== null) {\n    var _callback3 = effect.callback;\n    if (_callback3 !== null) {\n      effect.callback = null;\n      callCallback(_callback3, instance);\n    }\n    effect = effect.nextEffect;\n  }\n\n  effect = finishedQueue.firstCapturedEffect;\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n  while (effect !== null) {\n    var _callback4 = effect.callback;\n    if (_callback4 !== null) {\n      effect.callback = null;\n      callCallback(_callback4, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackAddendumByWorkInProgressFiber(source)\n  };\n}\n\nvar providerCursor = createCursor(null);\nvar valueCursor = createCursor(null);\nvar changedBitsCursor = createCursor(0);\n\nvar rendererSigil = void 0;\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nfunction pushProvider(providerFiber) {\n  var context = providerFiber.type._context;\n\n  if (isPrimaryRenderer) {\n    push(changedBitsCursor, context._changedBits, providerFiber);\n    push(valueCursor, context._currentValue, providerFiber);\n    push(providerCursor, providerFiber, providerFiber);\n\n    context._currentValue = providerFiber.pendingProps.value;\n    context._changedBits = providerFiber.stateNode;\n    {\n      !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warning(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(changedBitsCursor, context._changedBits2, providerFiber);\n    push(valueCursor, context._currentValue2, providerFiber);\n    push(providerCursor, providerFiber, providerFiber);\n\n    context._currentValue2 = providerFiber.pendingProps.value;\n    context._changedBits2 = providerFiber.stateNode;\n    {\n      !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warning(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\n\nfunction popProvider(providerFiber) {\n  var changedBits = changedBitsCursor.current;\n  var currentValue = valueCursor.current;\n\n  pop(providerCursor, providerFiber);\n  pop(valueCursor, providerFiber);\n  pop(changedBitsCursor, providerFiber);\n\n  var context = providerFiber.type._context;\n  if (isPrimaryRenderer) {\n    context._currentValue = currentValue;\n    context._changedBits = changedBits;\n  } else {\n    context._currentValue2 = currentValue;\n    context._changedBits2 = changedBits;\n  }\n}\n\nfunction getContextCurrentValue(context) {\n  return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n}\n\nfunction getContextChangedBits(context) {\n  return isPrimaryRenderer ? context._changedBits : context._changedBits2;\n}\n\nvar NO_CONTEXT = {};\n\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar commitTime = 0;\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = now();\n}\n\n/**\n * The \"actual\" render time is total time required to render the descendants of a Profiler component.\n * This time is stored as a stack, since Profilers can be nested.\n * This time is started during the \"begin\" phase and stopped during the \"complete\" phase.\n * It is paused (and accumulated) in the event of an interruption or an aborted render.\n */\n\nvar fiberStack$1 = void 0;\n\n{\n  fiberStack$1 = [];\n}\n\nvar timerPausedAt = 0;\nvar totalElapsedPauseTime = 0;\n\nfunction checkActualRenderTimeStackEmpty() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    !(fiberStack$1.length === 0) ? warning(false, 'Expected an empty stack. Something was not reset properly.') : void 0;\n  }\n}\n\nfunction markActualRenderTimeStarted(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    fiberStack$1.push(fiber);\n  }\n\n  fiber.actualDuration = now() - fiber.actualDuration - totalElapsedPauseTime;\n  fiber.actualStartTime = now();\n}\n\nfunction pauseActualRenderTimerIfRunning() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  if (timerPausedAt === 0) {\n    timerPausedAt = now();\n  }\n}\n\nfunction recordElapsedActualRenderTime(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    !(fiber === fiberStack$1.pop()) ? warning(false, 'Unexpected Fiber (%s) popped.', getComponentName(fiber)) : void 0;\n  }\n\n  fiber.actualDuration = now() - totalElapsedPauseTime - fiber.actualDuration;\n}\n\nfunction resetActualRenderTimer() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  totalElapsedPauseTime = 0;\n}\n\nfunction resumeActualRenderTimerIfPaused() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  if (timerPausedAt > 0) {\n    totalElapsedPauseTime += now() - timerPausedAt;\n    timerPausedAt = 0;\n  }\n}\n\n/**\n * The \"base\" render time is the duration of the “begin” phase of work for a particular fiber.\n * This time is measured and stored on each fiber.\n * The time for all sibling fibers are accumulated and stored on their parent during the \"complete\" phase.\n * If a fiber bails out (sCU false) then its \"base\" timer is cancelled and the fiber is not updated.\n */\n\nvar baseStartTime = -1;\n\nfunction recordElapsedBaseRenderTimeIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  if (baseStartTime !== -1) {\n    fiber.selfBaseTime = now() - baseStartTime;\n  }\n}\n\nfunction startBaseRenderTimer() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    if (baseStartTime !== -1) {\n      warning(false, 'Cannot start base timer that is already running. ' + 'This error is likely caused by a bug in React. ' + 'Please file an issue.');\n    }\n  }\n  baseStartTime = now();\n}\n\nfunction stopBaseRenderTimerIfRunning() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  baseStartTime = -1;\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar warnOnUndefinedDerivedState = void 0;\nvar warnOnInvalidCallback$1 = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback$1 = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    var key = callerName + '_' + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warning(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (workInProgress, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentName(workInProgress) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warning(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, getDerivedStateFromProps, nextProps) {\n  var prevState = workInProgress.memoizedState;\n\n  {\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    warnOnUndefinedDerivedState(workInProgress, partialState);\n  }\n  // Merge the partial state and the previous state.\n  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && updateQueue.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var currentTime = recalculateCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, expirationTime);\n    scheduleWork$1(fiber, expirationTime);\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var currentTime = recalculateCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'replaceState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, expirationTime);\n    scheduleWork$1(fiber, expirationTime);\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    var fiber = get(inst);\n    var currentTime = recalculateCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'forceUpdate');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, expirationTime);\n    scheduleWork$1(fiber, expirationTime);\n  }\n};\n\nfunction checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n  var instance = workInProgress.stateNode;\n  var ctor = workInProgress.type;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n    stopPhaseTimer();\n\n    {\n      !(shouldUpdate !== undefined) ? warning(false, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Component') : void 0;\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress) {\n  var instance = workInProgress.stateNode;\n  var type = workInProgress.type;\n  {\n    var name = getComponentName(workInProgress) || 'Component';\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (type.prototype && typeof type.prototype.render === 'function') {\n        warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n    !noGetInitialStateOnES6 ? warning(false, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name) : void 0;\n    var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n    !noGetDefaultPropsOnES6 ? warning(false, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name) : void 0;\n    var noInstancePropTypes = !instance.propTypes;\n    !noInstancePropTypes ? warning(false, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name) : void 0;\n    var noInstanceContextTypes = !instance.contextTypes;\n    !noInstanceContextTypes ? warning(false, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name) : void 0;\n    var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n    !noComponentShouldUpdate ? warning(false, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name) : void 0;\n    if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n    }\n    var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n    !noComponentDidUnmount ? warning(false, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name) : void 0;\n    var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n    !noComponentDidReceiveProps ? warning(false, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name) : void 0;\n    var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n    !noComponentWillRecieveProps ? warning(false, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name) : void 0;\n    var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n    !noUnsafeComponentWillRecieveProps ? warning(false, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name) : void 0;\n    var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n    !(instance.props === undefined || !hasMutatedProps) ? warning(false, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name) : void 0;\n    var noInstanceDefaultProps = !instance.defaultProps;\n    !noInstanceDefaultProps ? warning(false, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name) : void 0;\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type);\n      warning(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(workInProgress));\n    }\n\n    var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';\n    !noInstanceGetDerivedStateFromProps ? warning(false, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n    var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromCatch !== 'function';\n    !noInstanceGetDerivedStateFromCatch ? warning(false, '%s: getDerivedStateFromCatch() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n    var noStaticGetSnapshotBeforeUpdate = typeof type.getSnapshotBeforeUpdate !== 'function';\n    !noStaticGetSnapshotBeforeUpdate ? warning(false, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name) : void 0;\n    var _state = instance.state;\n    if (_state && (typeof _state !== 'object' || isArray(_state))) {\n      warning(false, '%s.state: must be set to an object or null', name);\n    }\n    if (typeof instance.getChildContext === 'function') {\n      !(typeof type.childContextTypes === 'object') ? warning(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name) : void 0;\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  set(instance, workInProgress);\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, props, renderExpirationTime) {\n  var ctor = workInProgress.type;\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n  var needsContext = isContextConsumer(workInProgress);\n  var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n\n  // Instantiate twice to help detect side-effects.\n  {\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  var instance = new ctor(props, context);\n  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      var componentName = getComponentName(workInProgress) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warning(false, '%s: Did not properly initialize state during construction. ' + 'Expected state to be an object, but it was %s.', componentName, instance.state === null ? 'null' : 'undefined');\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        var _componentName = getComponentName(workInProgress) || 'Component';\n        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n          warning(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '');\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (needsContext) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    {\n      warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress) || 'Component');\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n  var oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, newContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, newContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentName(workInProgress) || 'Component';\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress, renderExpirationTime) {\n  var ctor = workInProgress.type;\n\n  {\n    checkClassInstance(workInProgress);\n  }\n\n  var instance = workInProgress.stateNode;\n  var props = workInProgress.pendingProps;\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n\n  instance.props = props;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyObject;\n  instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n  {\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);\n    }\n  }\n\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, props, instance, renderExpirationTime);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  var getDerivedStateFromProps = workInProgress.type.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, getDerivedStateFromProps, props);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(workInProgress, updateQueue, props, instance, renderExpirationTime);\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, renderExpirationTime) {\n  var ctor = workInProgress.type;\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  var newProps = workInProgress.pendingProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var newUnmaskedContext = getUnmaskedContext(workInProgress);\n  var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== newContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = newContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current, workInProgress, renderExpirationTime) {\n  var ctor = workInProgress.type;\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  var newProps = workInProgress.pendingProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var newUnmaskedContext = getUnmaskedContext(workInProgress);\n  var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== newContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, newContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = newContext;\n\n  return shouldUpdate;\n}\n\nvar getCurrentFiberStackAddendum$7 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function (child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$7() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$7());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber) || 'Component';\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warning(false, 'A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\\n%s' + '\\n\\nLearn more about using refs safely here:' + '\\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, getStackAddendumByWorkInProgressFiber(returnFiber));\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a functional component\\n2. You may be adding a ref to a component that was not created inside a component\\'s render method\\n3. You have multiple copies of React loaded\\nSee https://fb.me/react-refs-must-have-owner for more information.', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$7() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$7() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$7() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing.return = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      created.ref = coerceRef(returnFiber, current, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created.return = returnFiber;\n            return _created;\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n            _created2.return = returnFiber;\n            return _created2;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$7());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (newChildrenIterable.entries === iteratorFn) {\n        !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$7()) : void 0;\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false;\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n        break;\n      case HostComponent:\n        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n        break;\n    }\n  }\n\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.effectTag |= Placement;\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableContainerInstance(parentContainer, type, props);\n              break;\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableContainerTextInstance(parentContainer, text);\n              break;\n          }\n          break;\n        }\n      case HostComponent:\n        {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n          switch (fiber.tag) {\n            case HostComponent:\n              var _type = fiber.type;\n              var _props = fiber.pendingProps;\n              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n              break;\n            case HostText:\n              var _text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n              break;\n          }\n          break;\n        }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          return true;\n        }\n        return false;\n      }\n    case HostText:\n      {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          return true;\n        }\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n  var nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  var firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild(nextInstance);\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var instance = fiber.stateNode;\n  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = updatePayload;\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      var returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot:\n            {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n              break;\n            }\n          case HostComponent:\n            {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n              break;\n            }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  var type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n    var nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nvar getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\n// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\nfunction reconcileChildren(current, workInProgress, nextChildren) {\n  reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n}\n\nfunction reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n  }\n}\n\nfunction updateForwardRef(current, workInProgress) {\n  var render = workInProgress.type.render;\n  var nextProps = workInProgress.pendingProps;\n  var ref = workInProgress.ref;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextProps) {\n    var currentRef = current !== null ? current.ref : null;\n    if (ref === currentRef) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n  }\n\n  var nextChildren = void 0;\n  {\n    ReactCurrentOwner.current = workInProgress;\n    ReactDebugCurrentFiber.setCurrentPhase('render');\n    nextChildren = render(nextProps, ref);\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current, workInProgress) {\n  var nextChildren = workInProgress.pendingProps;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextChildren) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress) {\n  var nextChildren = workInProgress.pendingProps.children;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress) {\n  var nextProps = workInProgress.pendingProps;\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  if (workInProgress.memoizedProps === nextProps) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  var nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionalComponent(current, workInProgress) {\n  var fn = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else {\n    if (workInProgress.memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    // TODO: consider bringing fn.shouldComponentUpdate() back.\n    // It used to be here.\n  }\n\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var nextChildren = void 0;\n\n  {\n    ReactCurrentOwner.current = workInProgress;\n    ReactDebugCurrentFiber.setCurrentPhase('render');\n    nextChildren = fn(nextProps, context);\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, renderExpirationTime) {\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  var hasContext = pushContextProvider(workInProgress);\n  var shouldUpdate = void 0;\n  if (current === null) {\n    if (workInProgress.stateNode === null) {\n      // In the initial pass we might need to construct the instance.\n      constructClassInstance(workInProgress, workInProgress.pendingProps, renderExpirationTime);\n      mountClassInstance(workInProgress, renderExpirationTime);\n\n      shouldUpdate = true;\n    } else {\n      // In a resume, we'll already have an instance we can reuse.\n      shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n    }\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n  }\n  return finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);\n}\n\nfunction finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n\n  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  var ctor = workInProgress.type;\n  var instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner.current = workInProgress;\n  var nextChildren = void 0;\n  if (didCaptureError && (!enableGetDerivedStateFromCatch || typeof ctor.getDerivedStateFromCatch !== 'function')) {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopBaseRenderTimerIfRunning();\n    }\n  } else {\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = instance.render();\n      if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        instance.render();\n      }\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (didCaptureError) {\n    // If we're recovering from an error, reconcile twice: first to delete\n    // all the existing children.\n    reconcileChildrenAtExpirationTime(current, workInProgress, null, renderExpirationTime);\n    workInProgress.child = null;\n    // Now we can continue reconciling like normal. This has the effect of\n    // remounting all children regardless of whether their their\n    // identity matches.\n  }\n  reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n  // Memoize props and state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  memoizeState(workInProgress, instance.state);\n  memoizeProps(workInProgress, instance.props);\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    var nextProps = workInProgress.pendingProps;\n    var prevState = workInProgress.memoizedState;\n    var prevChildren = prevState !== null ? prevState.element : null;\n    processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);\n    var nextState = workInProgress.memoizedState;\n    // Caution: React DevTools currently depends on this property\n    // being called \"element\".\n    var nextChildren = nextState.element;\n\n    if (nextChildren === prevChildren) {\n      // If the state is the same as before, that's a bailout because we had\n      // no work that expires at this time.\n      resetHydrationState();\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    var root = workInProgress.stateNode;\n    if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n      // If we don't have any current children this might be the first pass.\n      // We always try to hydrate. If this isn't a hydration pass there won't\n      // be any children to hydrate which is effectively the same thing as\n      // not hydrating.\n\n      // This is a bit of a hack. We track the host root as a placement to\n      // know that we're currently in a mounting state. That way isMounted\n      // works as expected. We must reset this before committing.\n      // TODO: Delete this when we delete isMounted and findDOMNode.\n      workInProgress.effectTag |= Placement;\n\n      // Ensure that children mount into this root without tracking\n      // side-effects. This ensures that we don't store Placement effects on\n      // nodes that will be hydrated.\n      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    } else {\n      // Otherwise reset hydration state in case we aborted and resumed another\n      // root.\n      resetHydrationState();\n      reconcileChildren(current, workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n  resetHydrationState();\n  // If there is no update queue, that's a bailout because the root has no props.\n  return bailoutOnAlreadyFinishedWork(current, workInProgress);\n}\n\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var memoizedProps = workInProgress.memoizedProps;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current !== null ? current.memoizedProps : null;\n\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (memoizedProps === nextProps) {\n    var isHidden = workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps);\n    if (isHidden) {\n      // Before bailing out, make sure we've deprioritized a hidden component.\n      workInProgress.expirationTime = Never;\n    }\n    if (!isHidden || renderExpirationTime !== Never) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    // If we're rendering a hidden node at hidden priority, don't bailout. The\n    // parent is complete, but the children may not be.\n  }\n\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (renderExpirationTime !== Never && workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps)) {\n    // Down-prioritize the children.\n    workInProgress.expirationTime = Never;\n    // Bailout and come back to this fiber later.\n    workInProgress.memoizedProps = nextProps;\n    return null;\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  var nextProps = workInProgress.pendingProps;\n  memoizeProps(workInProgress, nextProps);\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n  !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var fn = workInProgress.type;\n  var props = workInProgress.pendingProps;\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var value = void 0;\n\n  {\n    if (fn.prototype && typeof fn.prototype.render === 'function') {\n      var componentName = getComponentName(workInProgress) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner.current = workInProgress;\n    value = fn(props, context);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    var Component = workInProgress.type;\n\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === 'function') {\n      applyDerivedStateFromProps(workInProgress, getDerivedStateFromProps, props);\n    }\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, renderExpirationTime);\n    return finishClassComponent(current, workInProgress, true, hasContext, renderExpirationTime);\n  } else {\n    // Proceed under the assumption that this is a functional component\n    workInProgress.tag = FunctionalComponent;\n    {\n      var _Component = workInProgress.type;\n\n      if (_Component) {\n        !!_Component.childContextTypes ? warning(false, '%s(...): childContextTypes cannot be defined on a functional component.', _Component.displayName || _Component.name || 'Component') : void 0;\n      }\n      if (workInProgress.ref !== null) {\n        var info = '';\n        var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n        if (ownerName) {\n          info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n        }\n\n        var warningKey = ownerName || workInProgress._debugID || '';\n        var debugSource = workInProgress._debugSource;\n        if (debugSource) {\n          warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n        }\n        if (!didWarnAboutStatelessRefs[warningKey]) {\n          didWarnAboutStatelessRefs[warningKey] = true;\n          warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n        }\n      }\n\n      if (typeof fn.getDerivedStateFromProps === 'function') {\n        var _componentName = getComponentName(workInProgress) || 'Unknown';\n\n        if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n          warning(false, '%s: Stateless functional components do not support getDerivedStateFromProps.', _componentName);\n          didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName] = true;\n        }\n      }\n    }\n    reconcileChildren(current, workInProgress, value);\n    memoizeProps(workInProgress, props);\n    return workInProgress.child;\n  }\n}\n\nfunction updateTimeoutComponent(current, workInProgress, renderExpirationTime) {\n  if (enableSuspense) {\n    var nextProps = workInProgress.pendingProps;\n    var prevProps = workInProgress.memoizedProps;\n\n    var prevDidTimeout = workInProgress.memoizedState;\n\n    // Check if we already attempted to render the normal state. If we did,\n    // and we timed out, render the placeholder state.\n    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;\n    var nextDidTimeout = !alreadyCaptured;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === prevProps && nextDidTimeout === prevDidTimeout) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var render = nextProps.children;\n    var nextChildren = render(nextDidTimeout);\n    workInProgress.memoizedProps = nextProps;\n    workInProgress.memoizedState = nextDidTimeout;\n    reconcileChildren(current, workInProgress, nextChildren);\n    return workInProgress.child;\n  } else {\n    return null;\n  }\n}\n\nfunction updatePortalComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextChildren) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    memoizeProps(workInProgress, nextChildren);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n  }\n  return workInProgress.child;\n}\n\nfunction propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {\n  var fiber = workInProgress.child;\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n  while (fiber !== null) {\n    var nextFiber = void 0;\n    // Visit this fiber.\n    switch (fiber.tag) {\n      case ContextConsumer:\n        // Check if the context matches.\n        var observedBits = fiber.stateNode | 0;\n        if (fiber.type === context && (observedBits & changedBits) !== 0) {\n          // Update the expiration time of all the ancestors, including\n          // the alternates.\n          var node = fiber;\n          while (node !== null) {\n            var alternate = node.alternate;\n            if (node.expirationTime === NoWork || node.expirationTime > renderExpirationTime) {\n              node.expirationTime = renderExpirationTime;\n              if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n                alternate.expirationTime = renderExpirationTime;\n              }\n            } else if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n              alternate.expirationTime = renderExpirationTime;\n            } else {\n              // Neither alternate was updated, which means the rest of the\n              // ancestor path already has sufficient priority.\n              break;\n            }\n            node = node.return;\n          }\n          // Don't scan deeper than a matching consumer. When we render the\n          // consumer, we'll continue scanning from that point. This way the\n          // scanning work is time-sliced.\n          nextFiber = null;\n        } else {\n          // Traverse down.\n          nextFiber = fiber.child;\n        }\n        break;\n      case ContextProvider:\n        // Don't scan deeper if this is a matching provider\n        nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n        break;\n      default:\n        // Traverse down.\n        nextFiber = fiber.child;\n        break;\n    }\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n        var sibling = nextFiber.sibling;\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        }\n        // No more siblings. Traverse up.\n        nextFiber = nextFiber.return;\n      }\n    }\n    fiber = nextFiber;\n  }\n}\n\nfunction updateContextProvider(current, workInProgress, renderExpirationTime) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n  var canBailOnProps = true;\n\n  if (hasContextChanged()) {\n    canBailOnProps = false;\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (oldProps === newProps) {\n    workInProgress.stateNode = 0;\n    pushProvider(workInProgress);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  var newValue = newProps.value;\n  workInProgress.memoizedProps = newProps;\n\n  {\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackAddendum$6);\n    }\n  }\n\n  var changedBits = void 0;\n  if (oldProps === null) {\n    // Initial render\n    changedBits = MAX_SIGNED_31_BIT_INT;\n  } else {\n    if (oldProps.value === newProps.value) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && canBailOnProps) {\n        workInProgress.stateNode = 0;\n        pushProvider(workInProgress);\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      changedBits = 0;\n    } else {\n      var oldValue = oldProps.value;\n      // Use Object.is to compare the new context value to the old value.\n      // Inlined Object.is polyfill.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n      if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue // eslint-disable-line no-self-compare\n      ) {\n          // No change. Bailout early if children are the same.\n          if (oldProps.children === newProps.children && canBailOnProps) {\n            workInProgress.stateNode = 0;\n            pushProvider(workInProgress);\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n          changedBits = 0;\n        } else {\n        changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\n        {\n          !((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits) ? warning(false, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits) : void 0;\n        }\n        changedBits |= 0;\n\n        if (changedBits === 0) {\n          // No change. Bailout early if children are the same.\n          if (oldProps.children === newProps.children && canBailOnProps) {\n            workInProgress.stateNode = 0;\n            pushProvider(workInProgress);\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n        } else {\n          propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n        }\n      }\n    }\n  }\n\n  workInProgress.stateNode = changedBits;\n  pushProvider(workInProgress);\n\n  var newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren);\n  return workInProgress.child;\n}\n\nfunction updateContextConsumer(current, workInProgress, renderExpirationTime) {\n  var context = workInProgress.type;\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n\n  var newValue = getContextCurrentValue(context);\n  var changedBits = getContextChangedBits(context);\n\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (changedBits === 0 && oldProps === newProps) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  workInProgress.memoizedProps = newProps;\n\n  var observedBits = newProps.unstable_observedBits;\n  if (observedBits === undefined || observedBits === null) {\n    // Subscribe to all changes by default\n    observedBits = MAX_SIGNED_31_BIT_INT;\n  }\n  // Store the observedBits on the fiber's stateNode for quick access.\n  workInProgress.stateNode = observedBits;\n\n  if ((changedBits & observedBits) !== 0) {\n    // Context change propagation stops at matching consumers, for time-\n    // slicing. Continue the propagation here.\n    propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n  } else if (oldProps === newProps) {\n    // Skip over a memoized parent with a bitmask bailout even\n    // if we began working on it because of a deeper matching child.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  // There is no bailout on `children` equality because we expect people\n  // to often pass a bound method as a child, but it may reference\n  // `this.state` or `this.props` (and thus needs to re-render on `setState`).\n\n  var render = newProps.children;\n\n  {\n    !(typeof render === 'function') ? warning(false, 'A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.') : void 0;\n  }\n\n  var newChildren = void 0;\n  {\n    ReactCurrentOwner.current = workInProgress;\n    ReactDebugCurrentFiber.setCurrentPhase('render');\n    newChildren = render(newValue);\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren);\n  return workInProgress.child;\n}\n\n/*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress) {\n  cancelWorkTimer(workInProgress);\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopBaseRenderTimerIfRunning();\n  }\n\n  // TODO: We should ideally be able to bail out early if the children have no\n  // more work to do. However, since we don't have a separation of this\n  // Fiber's priority and its children yet - we don't know without doing lots\n  // of the same work we do anyway. Once we have that separation we can just\n  // bail out here if the children has no more work at this priority level.\n  // if (workInProgress.priorityOfChildren <= priorityLevel) {\n  //   // If there are side-effects in these children that have not yet been\n  //   // committed we need to ensure that they get properly transferred up.\n  //   if (current && current.child !== workInProgress.child) {\n  //     reuseChildrenEffects(workInProgress, child);\n  //   }\n  //   return null;\n  // }\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction bailoutOnLowPriority(current, workInProgress) {\n  cancelWorkTimer(workInProgress);\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopBaseRenderTimerIfRunning();\n  }\n\n  // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n  // See PR 8590 discussion for context\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      break;\n    case ClassComponent:\n      pushContextProvider(workInProgress);\n      break;\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case ContextProvider:\n      pushProvider(workInProgress);\n      break;\n  }\n  // TODO: What if this is currently in progress?\n  // How can that happen? How is this not being cloned?\n  return null;\n}\n\n// TODO: Delete memoizeProps/State and move to reconcile/bailout instead\nfunction memoizeProps(workInProgress, nextProps) {\n  workInProgress.memoizedProps = nextProps;\n}\n\nfunction memoizeState(workInProgress, nextState) {\n  workInProgress.memoizedState = nextState;\n  // Don't reset the updateQueue, in case there are pending updates. Resetting\n  // is handled by processUpdateQueue.\n}\n\nfunction beginWork(current, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      markActualRenderTimeStarted(workInProgress);\n    }\n  }\n\n  if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n    return bailoutOnLowPriority(current, workInProgress);\n  }\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n    case FunctionalComponent:\n      return updateFunctionalComponent(current, workInProgress);\n    case ClassComponent:\n      return updateClassComponent(current, workInProgress, renderExpirationTime);\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case TimeoutComponent:\n      return updateTimeoutComponent(current, workInProgress, renderExpirationTime);\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderExpirationTime);\n    case ForwardRef:\n      return updateForwardRef(current, workInProgress);\n    case Fragment:\n      return updateFragment(current, workInProgress);\n    case Mode:\n      return updateMode(current, workInProgress);\n    case Profiler:\n      return updateProfiler(current, workInProgress);\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderExpirationTime);\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderExpirationTime);\n    default:\n      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.effectTag |= Ref;\n}\n\nfunction appendAllChildren(parent, workInProgress) {\n  // We only have the top Fiber that was created but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = workInProgress.child;\n  while (node !== null) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      appendInitialChild(parent, node.stateNode);\n    } else if (node.tag === HostPortal) {\n      // If we have a portal child, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nvar updateHostContainer = void 0;\nvar updateHostComponent$1 = void 0;\nvar updateHostText$1 = void 0;\nif (supportsMutation) {\n  // Mutation mode\n\n  updateHostContainer = function (workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function (workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent$1 = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    var currentInstance = current.stateNode;\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n    } else {\n      var recyclableInstance = workInProgress.stateNode;\n      var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n      if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n        markUpdate(workInProgress);\n      }\n      workInProgress.stateNode = newInstance;\n      if (childrenUnchanged) {\n        // If there are no other effects in this tree, we need to flag this node as having one.\n        // Even though we're not going to use it for anything.\n        // Otherwise parents won't know that there are new children to propagate upwards.\n        markUpdate(workInProgress);\n      } else {\n        // If children might have changed, we have to add them all to the set.\n        appendAllChildren(newInstance, workInProgress);\n      }\n    }\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n    // Noop\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // Noop\n  };\n}\n\nfunction completeWork(current, workInProgress, renderExpirationTime) {\n  var newProps = workInProgress.pendingProps;\n\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      recordElapsedActualRenderTime(workInProgress);\n    }\n  }\n\n  switch (workInProgress.tag) {\n    case FunctionalComponent:\n      return null;\n    case ClassComponent:\n      {\n        // We are leaving this subtree, so pop context if any.\n        popContextProvider(workInProgress);\n        return null;\n      }\n    case HostRoot:\n      {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var fiberRoot = workInProgress.stateNode;\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          popHydrationState(workInProgress);\n          // This resets the hacky state to fix isMounted before committing.\n          // TODO: Delete this when we delete isMounted and findDOMNode.\n          workInProgress.effectTag &= ~Placement;\n        }\n        updateHostContainer(workInProgress);\n        return null;\n      }\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          // If we have an alternate, that means this is an update and we need to\n          // schedule a side-effect to do the updates.\n          var oldProps = current.memoizedProps;\n          // If we get updated because one of our children updated, we don't\n          // have newProps so we'll have to reuse them.\n          // TODO: Split the update API as separate for the props vs. children.\n          // Even better would be if children weren't special cased at all tho.\n          var instance = workInProgress.stateNode;\n          var currentHostContext = getHostContext();\n          // TODO: Experiencing an error where oldProps is null. Suggests a host\n          // component is hitting the resume path. Figure out why. Possibly\n          // related to `hidden`.\n          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n          updateHostComponent$1(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef$1(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            // This can happen when we abort work.\n            return null;\n          }\n\n          var _currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          var wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n            appendAllChildren(_instance, workInProgress);\n\n            // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance, _currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n            workInProgress.stateNode = _instance;\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef$1(workInProgress);\n          }\n        }\n        return null;\n      }\n    case HostText:\n      {\n        var newText = newProps;\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          updateHostText$1(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            // This can happen when we abort work.\n            return null;\n          }\n          var _rootContainerInstance = getRootHostContainer();\n          var _currentHostContext2 = getHostContext();\n          var _wasHydrated = popHydrationState(workInProgress);\n          if (_wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n          }\n        }\n        return null;\n      }\n    case ForwardRef:\n      return null;\n    case TimeoutComponent:\n      return null;\n    case Fragment:\n      return null;\n    case Mode:\n      return null;\n    case Profiler:\n      return null;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      return null;\n    case ContextConsumer:\n      return null;\n    // Error cases\n    case IndeterminateComponent:\n      invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n    // eslint-disable-next-line no-fallthrough\n    default:\n      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(capturedError) {\n  return true;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$3 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackAddendumByWorkInProgressFiber(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // Prevent cycle if logCapturedError() throws.\n    // A cycle may still occur if logCapturedError renders a component that throws.\n    var suppressLogging = e && e.suppressReactErrorLogging;\n    if (!suppressLogging) {\n      console.error(e);\n    }\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function (current, instance) {\n  startPhaseTimer(current, 'componentWillUnmount');\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current, instance) {\n  {\n    invokeGuardedCallback$3(null, callComponentWillUnmountWithTimer, null, current, instance);\n    if (hasCaughtError$1()) {\n      var unmountError = clearCaughtError$1();\n      captureCommitPhaseError(current, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current) {\n  var ref = current.ref;\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      {\n        invokeGuardedCallback$3(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureCommitPhaseError(current, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current, finishedWork) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n      {\n        if (finishedWork.effectTag & Snapshot) {\n          if (current !== null) {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n            var instance = finishedWork.stateNode;\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n            {\n              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                warning(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork));\n              }\n            }\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n            stopPhaseTimer();\n          }\n        }\n        return;\n      }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n      // Nothing to do for these component types\n      return;\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitLifeCycles(finishedRoot, current, finishedWork, currentTime, committedExpirationTime) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n      {\n        var instance = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current === null) {\n            startPhaseTimer(finishedWork, 'componentDidMount');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, 'componentDidUpdate');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n            stopPhaseTimer();\n          }\n        }\n        var updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);\n        }\n        return;\n      }\n    case HostRoot:\n      {\n        var _updateQueue = finishedWork.updateQueue;\n        if (_updateQueue !== null) {\n          var _instance = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                _instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n                _instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);\n        }\n        return;\n      }\n    case HostComponent:\n      {\n        var _instance2 = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current === null && finishedWork.effectTag & Update) {\n          var type = finishedWork.type;\n          var props = finishedWork.memoizedProps;\n          commitMount(_instance2, type, props, finishedWork);\n        }\n\n        return;\n      }\n    case HostText:\n      {\n        // We have no life-cycles associated with text.\n        return;\n      }\n    case HostPortal:\n      {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n    case Profiler:\n      {\n        // We have no life-cycles associated with Profiler.\n        return;\n      }\n    case TimeoutComponent:\n      {\n        // We have no life-cycles associated with Timeouts.\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse = void 0;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      {\n        if (!ref.hasOwnProperty('current')) {\n          warning(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork), getStackAddendumByWorkInProgressFiber(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current) {\n  var currentRef = current.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current) {\n  if (typeof onCommitUnmount === 'function') {\n    onCommitUnmount(current);\n  }\n\n  switch (current.tag) {\n    case ClassComponent:\n      {\n        safelyDetachRef(current);\n        var instance = current.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current, instance);\n        }\n        return;\n      }\n    case HostComponent:\n      {\n        safelyDetachRef(current);\n        return;\n      }\n    case HostPortal:\n      {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (supportsMutation) {\n          unmountHostComponents(current);\n        } else if (supportsPersistence) {\n          emptyPortalContainer(current);\n        }\n        return;\n      }\n  }\n}\n\nfunction commitNestedUnmounts(root) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  var node = root;\n  while (true) {\n    commitUnmount(node);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (node.child !== null && (\n    // If we use mutation we drill down into portals using commitUnmount above.\n    // If we don't use mutation we drill down into portals here instead.\n    !supportsMutation || node.tag !== HostPortal)) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current.return = null;\n  current.child = null;\n  if (current.alternate) {\n    current.alternate.child = null;\n    current.alternate.return = null;\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current.stateNode;\n  var containerInfo = portal.containerInfo;\n\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n      {\n        return;\n      }\n    case HostComponent:\n      {\n        return;\n      }\n    case HostText:\n      {\n        return;\n      }\n    case HostRoot:\n    case HostPortal:\n      {\n        var portalOrRoot = finishedWork.stateNode;\n        var containerInfo = portalOrRoot.containerInfo,\n            _pendingChildren = portalOrRoot.pendingChildren;\n\n        replaceContainerChildren(containerInfo, _pendingChildren);\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  var node = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (node.tag !== HostComponent && node.tag !== HostText) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  var parentFiber = getHostParentFiber(finishedWork);\n  var parent = void 0;\n  var isContainer = void 0;\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentFiber.stateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    default:\n      invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent);\n    // Clear ContentReset from the effect tag\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  var before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = finishedWork;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, node.stateNode, before);\n        } else {\n          insertBefore(parent, node.stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, node.stateNode);\n        } else {\n          appendChild(parent, node.stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(current) {\n  // We only have the top Fiber that was inserted but we need recurse down its\n  var node = current;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  var currentParentIsValid = false;\n  var currentParent = void 0;\n  var currentParentIsContainer = void 0;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      var parent = node.return;\n      findParent: while (true) {\n        !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parent.stateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(node);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      }\n      // Don't visit children because we already visited them.\n    } else if (node.tag === HostPortal) {\n      // When we go into a portal, it becomes the parent to remove from.\n      // We will reassign it back when we pop the portal on the way up.\n      currentParent = node.stateNode.containerInfo;\n      // Visit children because portals might contain host components.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(node);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(current) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(current);\n  }\n  detachFiber(current);\n}\n\nfunction commitWork(current, finishedWork) {\n  if (!supportsMutation) {\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n      {\n        return;\n      }\n    case HostComponent:\n      {\n        var instance = finishedWork.stateNode;\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          var newProps = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldProps = current !== null ? current.memoizedProps : newProps;\n          var type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          var updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n          }\n        }\n        return;\n      }\n    case HostText:\n      {\n        !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var textInstance = finishedWork.stateNode;\n        var newText = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n    case HostRoot:\n      {\n        return;\n      }\n    case Profiler:\n      {\n        if (enableProfilerTimer) {\n          var onRender = finishedWork.memoizedProps.onRender;\n          onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseTime, finishedWork.actualStartTime, getCommitTime());\n        }\n        return;\n      }\n    case TimeoutComponent:\n      {\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitResetTextContent(current) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current.stateNode);\n}\n\nfunction createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: null };\n  var error = errorInfo.value;\n  update.callback = function () {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;\n  if (enableGetDerivedStateFromCatch && typeof getDerivedStateFromCatch === 'function') {\n    var error = errorInfo.value;\n    update.payload = function () {\n      return getDerivedStateFromCatch(error);\n    };\n  }\n\n  var inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (!enableGetDerivedStateFromCatch || getDerivedStateFromCatch !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromCatch is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      var error = errorInfo.value;\n      var stack = errorInfo.stack;\n      logError(fiber, errorInfo);\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : ''\n      });\n    };\n  }\n  return update;\n}\n\nfunction schedulePing(finishedWork) {\n  // Once the promise resolves, we should try rendering the non-\n  // placeholder state again.\n  var currentTime = recalculateCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, finishedWork);\n  var recoveryUpdate = createUpdate(expirationTime);\n  enqueueUpdate(finishedWork, recoveryUpdate, expirationTime);\n  scheduleWork$1(finishedWork, expirationTime);\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, renderIsExpired, renderExpirationTime, currentTimeMs) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (enableSuspense && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a thenable.\n    var thenable = value;\n\n    var expirationTimeMs = expirationTimeToMs(renderExpirationTime);\n    var startTimeMs = expirationTimeMs - 5000;\n    var elapsedMs = currentTimeMs - startTimeMs;\n    if (elapsedMs < 0) {\n      elapsedMs = 0;\n    }\n    var remainingTimeMs = expirationTimeMs - currentTimeMs;\n\n    // Find the earliest timeout of all the timeouts in the ancestor path.\n    // TODO: Alternatively, we could store the earliest timeout on the context\n    // stack, rather than searching on every suspend.\n    var _workInProgress = returnFiber;\n    var earliestTimeoutMs = -1;\n    searchForEarliestTimeout: do {\n      if (_workInProgress.tag === TimeoutComponent) {\n        var current = _workInProgress.alternate;\n        if (current !== null && current.memoizedState === true) {\n          // A parent Timeout already committed in a placeholder state. We\n          // need to handle this promise immediately. In other words, we\n          // should never suspend inside a tree that already expired.\n          earliestTimeoutMs = 0;\n          break searchForEarliestTimeout;\n        }\n        var timeoutPropMs = _workInProgress.pendingProps.ms;\n        if (typeof timeoutPropMs === 'number') {\n          if (timeoutPropMs <= 0) {\n            earliestTimeoutMs = 0;\n            break searchForEarliestTimeout;\n          } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {\n            earliestTimeoutMs = timeoutPropMs;\n          }\n        } else if (earliestTimeoutMs === -1) {\n          earliestTimeoutMs = remainingTimeMs;\n        }\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n\n    // Compute the remaining time until the timeout.\n    var msUntilTimeout = earliestTimeoutMs - elapsedMs;\n\n    if (renderExpirationTime === Never || msUntilTimeout > 0) {\n      // There's still time remaining.\n      suspendRoot(root, thenable, msUntilTimeout, renderExpirationTime);\n      var onResolveOrReject = function () {\n        retrySuspendedRoot(root, renderExpirationTime);\n      };\n      thenable.then(onResolveOrReject, onResolveOrReject);\n      return;\n    } else {\n      // No time remaining. Need to fallback to placeholder.\n      // Find the nearest timeout that can be retried.\n      _workInProgress = returnFiber;\n      do {\n        switch (_workInProgress.tag) {\n          case HostRoot:\n            {\n              // The root expired, but no fallback was provided. Throw a\n              // helpful error.\n              var message = renderExpirationTime === Sync ? 'A synchronous update was suspended, but no fallback UI ' + 'was provided.' : 'An update was suspended for longer than the timeout, ' + 'but no fallback UI was provided.';\n              value = new Error(message);\n              break;\n            }\n          case TimeoutComponent:\n            {\n              if ((_workInProgress.effectTag & DidCapture) === NoEffect) {\n                _workInProgress.effectTag |= ShouldCapture;\n                var _onResolveOrReject = schedulePing.bind(null, _workInProgress);\n                thenable.then(_onResolveOrReject, _onResolveOrReject);\n                return;\n              }\n              // Already captured during this render. Continue to the next\n              // Timeout ancestor.\n              break;\n            }\n        }\n        _workInProgress = _workInProgress.return;\n      } while (_workInProgress !== null);\n    }\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  value = createCapturedValue(value, sourceFiber);\n  var workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          var _errorInfo = value;\n          workInProgress.effectTag |= ShouldCapture;\n          var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);\n          return;\n        }\n      case ClassComponent:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n        if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromCatch === 'function' && enableGetDerivedStateFromCatch || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.effectTag |= ShouldCapture;\n          // Schedule the error boundary to re-render using updated state\n          var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, _update, renderExpirationTime);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction unwindWork(workInProgress, renderIsExpired, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      recordElapsedActualRenderTime(workInProgress);\n    }\n  }\n\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        popContextProvider(workInProgress);\n        var effectTag = workInProgress.effectTag;\n        if (effectTag & ShouldCapture) {\n          workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case HostRoot:\n      {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var _effectTag = workInProgress.effectTag;\n        if (_effectTag & ShouldCapture) {\n          workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        return null;\n      }\n    case TimeoutComponent:\n      {\n        var _effectTag2 = workInProgress.effectTag;\n        if (_effectTag2 & ShouldCapture) {\n          workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      popProvider(workInProgress);\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork) {\n  if (enableProfilerTimer) {\n    if (interruptedWork.mode & ProfileMode) {\n      // Resume in case we're picking up on work that was paused.\n      resumeActualRenderTimerIfPaused();\n      recordElapsedActualRenderTime(interruptedWork);\n    }\n  }\n\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        popContextProvider(interruptedWork);\n        break;\n      }\n    case HostRoot:\n      {\n        popHostContainer(interruptedWork);\n        popTopLevelContextObject(interruptedWork);\n        break;\n      }\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case ContextProvider:\n      popProvider(interruptedWork);\n      break;\n    default:\n      break;\n  }\n}\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function (fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, \"Can't call setState (or forceUpdate) on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in the ' + 'componentWillUnmount method.%s', getStackAddendumByWorkInProgressFiber(fiber));\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\n// Represents the current time in ms.\nvar originalStartTimeMs = now();\nvar mostRecentCurrentTime = msToExpirationTime(0);\nvar mostRecentCurrentTimeMs = originalStartTimeMs;\n\n// Used to ensure computeUniqueAsyncExpiration is monotonically increases.\nvar lastUniqueAsyncExpiration = 0;\n\n// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nvar expirationContext = NoWork;\n\nvar isWorking = false;\n\n// The next work in progress fiber that we're currently working on.\nvar nextUnitOfWork = null;\nvar nextRoot = null;\n// The time at which we're currently rendering work.\nvar nextRenderExpirationTime = NoWork;\nvar nextLatestTimeoutMs = -1;\nvar nextRenderIsExpired = false;\n\n// The next fiber with an effect that we're currently committing.\nvar nextEffect = null;\n\nvar isCommitting$1 = false;\n\nvar isRootReadyForCommit = false;\n\nvar legacyErrorBoundariesThatAlreadyFailed = null;\n\n// Used for performance tracking.\nvar interruptedBy = null;\n\nvar stashedWorkInProgressProperties = void 0;\nvar replayUnitOfWork = void 0;\nvar isReplayingFailedUnitOfWork = void 0;\nvar originalReplayError = void 0;\nvar rethrowOriginalError = void 0;\nif (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  stashedWorkInProgressProperties = null;\n  isReplayingFailedUnitOfWork = false;\n  originalReplayError = null;\n  replayUnitOfWork = function (failedUnitOfWork, thrownValue, isAsync) {\n    if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n      // Don't replay promises. Treat everything else like an error.\n      // TODO: Need to figure out a different strategy if/when we add\n      // support for catching other types.\n      return;\n    }\n\n    // Restore the original state of the work-in-progress\n    if (stashedWorkInProgressProperties === null) {\n      // This should never happen. Don't throw because this code is DEV-only.\n      warning(false, 'Could not replay rendering after an error. This is likely a bug in React. ' + 'Please file an issue.');\n      return;\n    }\n    assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);\n\n    switch (failedUnitOfWork.tag) {\n      case HostRoot:\n        popHostContainer(failedUnitOfWork);\n        popTopLevelContextObject(failedUnitOfWork);\n        break;\n      case HostComponent:\n        popHostContext(failedUnitOfWork);\n        break;\n      case ClassComponent:\n        popContextProvider(failedUnitOfWork);\n        break;\n      case HostPortal:\n        popHostContainer(failedUnitOfWork);\n        break;\n      case ContextProvider:\n        popProvider(failedUnitOfWork);\n        break;\n    }\n    // Replay the begin phase.\n    isReplayingFailedUnitOfWork = true;\n    originalReplayError = thrownValue;\n    invokeGuardedCallback$2(null, workLoop, null, isAsync);\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    if (hasCaughtError()) {\n      clearCaughtError();\n\n      if (enableProfilerTimer) {\n        if (failedUnitOfWork.mode & ProfileMode) {\n          recordElapsedActualRenderTime(failedUnitOfWork);\n        }\n\n        // Stop \"base\" render timer again (after the re-thrown error).\n        stopBaseRenderTimerIfRunning();\n      }\n    } else {\n      // If the begin phase did not fail the second time, set this pointer\n      // back to the original value.\n      nextUnitOfWork = failedUnitOfWork;\n    }\n  };\n  rethrowOriginalError = function () {\n    throw originalReplayError;\n  };\n}\n\nfunction resetStack() {\n  if (nextUnitOfWork !== null) {\n    var interruptedWork = nextUnitOfWork.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    checkThatStackIsEmpty();\n  }\n\n  nextRoot = null;\n  nextRenderExpirationTime = NoWork;\n  nextLatestTimeoutMs = -1;\n  nextRenderIsExpired = false;\n  nextUnitOfWork = null;\n\n  isRootReadyForCommit = false;\n}\n\nfunction commitAllHostEffects() {\n  while (nextEffect !== null) {\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n    }\n    recordEffect();\n\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      var current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every\n    // possible bitmap value, we remove the secondary effects from the\n    // effect tag and switch on that value.\n    var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement:\n        {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n      case PlacementAndUpdate:\n        {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          var _current = nextEffect.alternate;\n          commitWork(_current, nextEffect);\n          break;\n        }\n      case Update:\n        {\n          var _current2 = nextEffect.alternate;\n          commitWork(_current2, nextEffect);\n          break;\n        }\n      case Deletion:\n        {\n          commitDeletion(nextEffect);\n          break;\n        }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    ReactDebugCurrentFiber.resetCurrentFiber();\n  }\n}\n\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & Snapshot) {\n      recordEffect();\n      var current = nextEffect.alternate;\n      commitBeforeMutationLifeCycles(current, nextEffect);\n    }\n\n    // Don't cleanup effects yet;\n    // This will be done by commitAllLifeCycles()\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitAllLifeCycles(finishedRoot, currentTime, committedExpirationTime) {\n  {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n\n    if (warnAboutLegacyContextAPI) {\n      ReactStrictModeWarnings.flushLegacyContextWarning();\n    }\n  }\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      var current = nextEffect.alternate;\n      commitLifeCycles(finishedRoot, current, nextEffect, currentTime, committedExpirationTime);\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    var next = nextEffect.nextEffect;\n    // Ensure that we clean these up so that we don't accidentally keep them.\n    // I'm not actually sure this matters because we can't reset firstEffect\n    // and lastEffect since they're on every node, not just the effectful\n    // ones. So we have to clean everything as we reuse nodes anyway.\n    nextEffect.nextEffect = null;\n    // Ensure that we reset the effectTag here so that we can rely on effect\n    // tags to reason about the current life-cycle.\n    nextEffect = next;\n  }\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\n\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction commitRoot(finishedWork) {\n  isWorking = true;\n  isCommitting$1 = true;\n  startCommitTimer();\n\n  var root = finishedWork.stateNode;\n  !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var committedExpirationTime = root.pendingCommitExpirationTime;\n  !(committedExpirationTime !== NoWork) ? invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  root.pendingCommitExpirationTime = NoWork;\n\n  var currentTime = recalculateCurrentTime();\n\n  // Reset this to null before calling lifecycles\n  ReactCurrentOwner.current = null;\n\n  var firstEffect = void 0;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if\n    // it had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  prepareForCommit(root.containerInfo);\n\n  // Invoke instances of getSnapshotBeforeUpdate before mutation.\n  nextEffect = firstEffect;\n  startCommitSnapshotEffectsTimer();\n  while (nextEffect !== null) {\n    var didError = false;\n    var error = void 0;\n    {\n      invokeGuardedCallback$2(null, commitBeforeMutationLifecycles, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n    if (didError) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitSnapshotEffectsTimer();\n\n  if (enableProfilerTimer) {\n    // Mark the current commit time to be shared by all Profilers in this batch.\n    // This enables them to be grouped later.\n    recordCommitTime();\n  }\n\n  // Commit all the side-effects within a tree. We'll do this in two passes.\n  // The first pass performs all the host insertions, updates, deletions and\n  // ref unmounts.\n  nextEffect = firstEffect;\n  startCommitHostEffectsTimer();\n  while (nextEffect !== null) {\n    var _didError = false;\n    var _error = void 0;\n    {\n      invokeGuardedCallback$2(null, commitAllHostEffects, null);\n      if (hasCaughtError()) {\n        _didError = true;\n        _error = clearCaughtError();\n      }\n    }\n    if (_didError) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, _error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitHostEffectsTimer();\n\n  resetAfterCommit(root.containerInfo);\n\n  // The work-in-progress tree is now the current tree. This must come after\n  // the first pass of the commit phase, so that the previous tree is still\n  // current during componentWillUnmount, but before the second pass, so that\n  // the finished work is current during componentDidMount/Update.\n  root.current = finishedWork;\n\n  // In the second pass we'll perform all life-cycles and ref callbacks.\n  // Life-cycles happen as a separate pass so that all placements, updates,\n  // and deletions in the entire tree have already been invoked.\n  // This pass also triggers any renderer-specific initial effects.\n  nextEffect = firstEffect;\n  startCommitLifeCyclesTimer();\n  while (nextEffect !== null) {\n    var _didError2 = false;\n    var _error2 = void 0;\n    {\n      invokeGuardedCallback$2(null, commitAllLifeCycles, null, root, currentTime, committedExpirationTime);\n      if (hasCaughtError()) {\n        _didError2 = true;\n        _error2 = clearCaughtError();\n      }\n    }\n    if (_didError2) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, _error2);\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n\n  if (enableProfilerTimer) {\n    {\n      checkActualRenderTimeStackEmpty();\n    }\n    resetActualRenderTimer();\n  }\n\n  isCommitting$1 = false;\n  isWorking = false;\n  stopCommitLifeCyclesTimer();\n  stopCommitTimer();\n  if (typeof onCommitRoot === 'function') {\n    onCommitRoot(finishedWork.stateNode);\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n  }\n\n  markCommittedPriorityLevels(root, currentTime, root.current.expirationTime);\n  var remainingTime = findNextPendingPriorityLevel(root);\n  if (remainingTime === NoWork) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n  return remainingTime;\n}\n\nfunction resetExpirationTime(workInProgress, renderTime) {\n  if (renderTime !== Never && workInProgress.expirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  // Check for pending updates.\n  var newExpirationTime = NoWork;\n  switch (workInProgress.tag) {\n    case HostRoot:\n    case ClassComponent:\n      {\n        var updateQueue = workInProgress.updateQueue;\n        if (updateQueue !== null) {\n          newExpirationTime = updateQueue.expirationTime;\n        }\n      }\n  }\n\n  // TODO: Calls need to visit stateNode\n\n  // Bubble up the earliest expiration time.\n  // (And \"base\" render timers if that feature flag is enabled)\n  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n    var treeBaseTime = workInProgress.selfBaseTime;\n    var child = workInProgress.child;\n    while (child !== null) {\n      treeBaseTime += child.treeBaseTime;\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.treeBaseTime = treeBaseTime;\n  } else {\n    var _child = workInProgress.child;\n    while (_child !== null) {\n      if (_child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > _child.expirationTime)) {\n        newExpirationTime = _child.expirationTime;\n      }\n      _child = _child.sibling;\n    }\n  }\n\n  workInProgress.expirationTime = newExpirationTime;\n}\n\nfunction completeUnitOfWork(workInProgress) {\n  // Attempt to complete the current unit of work, then move to the\n  // next sibling. If there are no more siblings, return to the\n  // parent fiber.\n  while (true) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    var returnFiber = workInProgress.return;\n    var siblingFiber = workInProgress.sibling;\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // This fiber completed.\n      var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n      stopWorkTimer(workInProgress);\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null &&\n      // Do not append effects to parents if a sibling failed to complete\n      (returnFiber.effectTag & Incomplete) === NoEffect) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        isRootReadyForCommit = true;\n        return null;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(workInProgress, nextRenderIsExpired, nextRenderExpirationTime);\n      // Because this fiber did not complete, don't reset its expiration time.\n      if (workInProgress.effectTag & DidCapture) {\n        // Restarting an error boundary\n        stopFailedWorkTimer(workInProgress);\n      } else {\n        stopWorkTimer(workInProgress);\n      }\n\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      if (_next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.effectTag &= HostEffectMask;\n        return _next;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  // Without this explicit null return Flow complains of invalid return type\n  // TODO Remove the above while(true) loop\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction performUnitOfWork(workInProgress) {\n  // The current, flushed, state of this fiber is the alternate.\n  // Ideally nothing should rely on this, but relying on it here\n  // means that we don't need an additional field on the work in\n  // progress.\n  var current = workInProgress.alternate;\n\n  // See if beginning this work spawns more work.\n  startWorkTimer(workInProgress);\n  {\n    ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n  }\n\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);\n  }\n\n  var next = void 0;\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      startBaseRenderTimer();\n    }\n\n    next = beginWork(current, workInProgress, nextRenderExpirationTime);\n\n    if (workInProgress.mode & ProfileMode) {\n      // Update \"base\" time if the render wasn't bailed out on.\n      recordElapsedBaseRenderTimeIfRunning(workInProgress);\n      stopBaseRenderTimerIfRunning();\n    }\n  } else {\n    next = beginWork(current, workInProgress, nextRenderExpirationTime);\n  }\n\n  {\n    ReactDebugCurrentFiber.resetCurrentFiber();\n    if (isReplayingFailedUnitOfWork) {\n      // Currently replaying a failed unit of work. This should be unreachable,\n      // because the render phase is meant to be idempotent, and it should\n      // have thrown again. Since it didn't, rethrow the original error, so\n      // React's internal stack is not misaligned.\n      rethrowOriginalError();\n    }\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n  }\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(workInProgress);\n  }\n\n  ReactCurrentOwner.current = null;\n\n  return next;\n}\n\nfunction workLoop(isAsync) {\n  if (!isAsync) {\n    // Flush all expired work.\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {\n    // Flush asynchronous work until the deadline runs out of time.\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n\n    if (enableProfilerTimer) {\n      // If we didn't finish, pause the \"actual\" render timer.\n      // We'll restart it when we resume work.\n      pauseActualRenderTimerIfRunning();\n    }\n  }\n}\n\nfunction renderRoot(root, expirationTime, isAsync) {\n  !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  isWorking = true;\n\n  // Check if we're starting from a fresh stack, or if we're resuming from\n  // previously yielded work.\n  if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {\n    // Reset the stack and start working from the root.\n    resetStack();\n    nextRoot = root;\n    nextRenderExpirationTime = expirationTime;\n    nextLatestTimeoutMs = -1;\n    nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);\n    root.pendingCommitExpirationTime = NoWork;\n  }\n\n  var didFatal = false;\n\n  nextRenderIsExpired = !isAsync || nextRenderExpirationTime <= mostRecentCurrentTime;\n\n  startWorkLoopTimer(nextUnitOfWork);\n\n  do {\n    try {\n      workLoop(isAsync);\n    } catch (thrownValue) {\n      if (enableProfilerTimer) {\n        // Stop \"base\" render timer in the event of an error.\n        stopBaseRenderTimerIfRunning();\n      }\n\n      if (nextUnitOfWork === null) {\n        // This is a fatal error.\n        didFatal = true;\n        onUncaughtError(thrownValue);\n      } else {\n        {\n          // Reset global debug state\n          // We assume this is defined in DEV\n          resetCurrentlyProcessingQueue();\n        }\n\n        var failedUnitOfWork = nextUnitOfWork;\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);\n        }\n\n        // TODO: we already know this isn't true in some cases.\n        // At least this shows a nicer error message until we figure out the cause.\n        // https://github.com/facebook/react/issues/12449#issuecomment-386727431\n        !(nextUnitOfWork !== null) ? invariant(false, 'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.') : void 0;\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber.return;\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n        throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderIsExpired, nextRenderExpirationTime, mostRecentCurrentTimeMs);\n        nextUnitOfWork = completeUnitOfWork(sourceFiber);\n      }\n    }\n    break;\n  } while (true);\n\n  // We're done performing work. Time to clean up.\n  var didCompleteRoot = false;\n  isWorking = false;\n\n  // Yield back to main thread.\n  if (didFatal) {\n    stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n    interruptedBy = null;\n    // There was a fatal error.\n    {\n      resetStackAfterFatalErrorInDev();\n    }\n    return null;\n  } else if (nextUnitOfWork === null) {\n    // We reached the root.\n    if (isRootReadyForCommit) {\n      didCompleteRoot = true;\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      // The root successfully completed. It's ready for commit.\n      root.pendingCommitExpirationTime = expirationTime;\n      var finishedWork = root.current.alternate;\n      return finishedWork;\n    } else {\n      // The root did not complete.\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      !!nextRenderIsExpired ? invariant(false, 'Expired work should have completed. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      markSuspendedPriorityLevel(root, expirationTime);\n      if (nextLatestTimeoutMs >= 0) {\n        setTimeout(function () {\n          retrySuspendedRoot(root, expirationTime);\n        }, nextLatestTimeoutMs);\n      }\n      var firstUnblockedExpirationTime = findNextPendingPriorityLevel(root);\n      onBlock(firstUnblockedExpirationTime);\n      return null;\n    }\n  } else {\n    stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n    interruptedBy = null;\n    // There's more work to do, but we ran out of time. Yield back to\n    // the renderer.\n    return null;\n  }\n}\n\nfunction dispatch(sourceFiber, value, expirationTime) {\n  !(!isWorking || isCommitting$1) ? invariant(false, 'dispatch: Cannot dispatch during the render phase.') : void 0;\n\n  var fiber = sourceFiber.return;\n  while (fiber !== null) {\n    switch (fiber.tag) {\n      case ClassComponent:\n        var ctor = fiber.type;\n        var instance = fiber.stateNode;\n        if (typeof ctor.getDerivedStateFromCatch === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n          var errorInfo = createCapturedValue(value, sourceFiber);\n          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);\n          enqueueUpdate(fiber, update, expirationTime);\n          scheduleWork$1(fiber, expirationTime);\n          return;\n        }\n        break;\n      case HostRoot:\n        {\n          var _errorInfo = createCapturedValue(value, sourceFiber);\n          var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);\n          enqueueUpdate(fiber, _update, expirationTime);\n          scheduleWork$1(fiber, expirationTime);\n          return;\n        }\n    }\n    fiber = fiber.return;\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    var rootFiber = sourceFiber;\n    var _errorInfo2 = createCapturedValue(value, rootFiber);\n    var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);\n    enqueueUpdate(rootFiber, _update2, expirationTime);\n    scheduleWork$1(rootFiber, expirationTime);\n  }\n}\n\nfunction captureCommitPhaseError(fiber, error) {\n  return dispatch(fiber, error, Sync);\n}\n\nfunction computeAsyncExpiration(currentTime) {\n  // Given the current clock time, returns an expiration time. We use rounding\n  // to batch like updates together.\n  // Should complete within ~5000ms. 5250ms max.\n  var expirationMs = 5000;\n  var bucketSizeMs = 250;\n  return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n}\n\nfunction computeInteractiveExpiration(currentTime) {\n  var expirationMs = void 0;\n  // We intentionally set a higher expiration time for interactive updates in\n  // dev than in production.\n  // If the main thread is being blocked so long that you hit the expiration,\n  // it's a problem that could be solved with better scheduling.\n  // People will be more likely to notice this and fix it with the long\n  // expiration time in development.\n  // In production we opt for better UX at the risk of masking scheduling\n  // problems, by expiring fast.\n  {\n    // Should complete within ~500ms. 600ms max.\n    expirationMs = 500;\n  }\n  var bucketSizeMs = 100;\n  return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n}\n\n// Creates a unique async expiration time.\nfunction computeUniqueAsyncExpiration() {\n  var currentTime = recalculateCurrentTime();\n  var result = computeAsyncExpiration(currentTime);\n  if (result <= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result = lastUniqueAsyncExpiration + 1;\n  }\n  lastUniqueAsyncExpiration = result;\n  return lastUniqueAsyncExpiration;\n}\n\nfunction computeExpirationForFiber(currentTime, fiber) {\n  var expirationTime = void 0;\n  if (expirationContext !== NoWork) {\n    // An explicit expiration context was set;\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting$1) {\n      // Updates that occur during the commit phase should have sync priority\n      // by default.\n      expirationTime = Sync;\n    } else {\n      // Updates during the render phase should expire at the same time as\n      // the work that is being rendered.\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // No explicit expiration context was set, and we're not currently\n    // performing work. Calculate a new expiration time.\n    if (fiber.mode & AsyncMode) {\n      if (isBatchingInteractiveUpdates) {\n        // This is an interactive update\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n    } else {\n      // This is a sync update\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // This is an interactive update. Keep track of the lowest pending\n    // interactive expiration time. This allows us to synchronously flush\n    // all interactive updates when needed.\n    if (lowestPendingInteractiveExpirationTime === NoWork || expirationTime > lowestPendingInteractiveExpirationTime) {\n      lowestPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\n// TODO: Rename this to scheduleTimeout or something\nfunction suspendRoot(root, thenable, timeoutMs, suspendedTime) {\n  // Schedule the timeout.\n  if (timeoutMs >= 0 && nextLatestTimeoutMs < timeoutMs) {\n    nextLatestTimeoutMs = timeoutMs;\n  }\n}\n\nfunction retrySuspendedRoot(root, suspendedTime) {\n  markPingedPriorityLevel(root, suspendedTime);\n  var retryTime = findNextPendingPriorityLevel(root);\n  if (retryTime !== NoWork) {\n    requestRetry(root, retryTime);\n  }\n}\n\nfunction scheduleWork$1(fiber, expirationTime) {\n  recordScheduleUpdate();\n\n  {\n    if (fiber.tag === ClassComponent) {\n      var instance = fiber.stateNode;\n      warnAboutInvalidUpdates(instance);\n    }\n  }\n\n  var node = fiber;\n  while (node !== null) {\n    // Walk the parent path to the root and update each node's\n    // expiration time.\n    if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n      node.expirationTime = expirationTime;\n    }\n    if (node.alternate !== null) {\n      if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n        node.alternate.expirationTime = expirationTime;\n      }\n    }\n    if (node.return === null) {\n      if (node.tag === HostRoot) {\n        var root = node.stateNode;\n        if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {\n          // This is an interruption. (Used for performance tracking.)\n          interruptedBy = fiber;\n          resetStack();\n        }\n        markPendingPriorityLevel(root, expirationTime);\n        var nextExpirationTimeToWorkOn = findNextPendingPriorityLevel(root);\n        if (\n        // If we're in the render phase, we don't need to schedule this root\n        // for an update, because we'll do it before we exit...\n        !isWorking || isCommitting$1 ||\n        // ...unless this is a different root than the one we're rendering.\n        nextRoot !== root) {\n          requestWork(root, nextExpirationTimeToWorkOn);\n        }\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n        }\n      } else {\n        {\n          if (fiber.tag === ClassComponent) {\n            warnAboutUpdateOnUnmounted(fiber);\n          }\n        }\n        return;\n      }\n    }\n    node = node.return;\n  }\n}\n\nfunction recalculateCurrentTime() {\n  // Subtract initial time so it fits inside 32bits\n  mostRecentCurrentTimeMs = now() - originalStartTimeMs;\n  mostRecentCurrentTime = msToExpirationTime(mostRecentCurrentTimeMs);\n  return mostRecentCurrentTime;\n}\n\nfunction deferredUpdates(fn) {\n  var previousExpirationContext = expirationContext;\n  var currentTime = recalculateCurrentTime();\n  expirationContext = computeAsyncExpiration(currentTime);\n  try {\n    return fn();\n  } finally {\n    expirationContext = previousExpirationContext;\n  }\n}\nfunction syncUpdates(fn, a, b, c, d) {\n  var previousExpirationContext = expirationContext;\n  expirationContext = Sync;\n  try {\n    return fn(a, b, c, d);\n  } finally {\n    expirationContext = previousExpirationContext;\n  }\n}\n\n// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n\n// Linked-list of roots\nvar firstScheduledRoot = null;\nvar lastScheduledRoot = null;\n\nvar callbackExpirationTime = NoWork;\nvar callbackID = void 0;\nvar isRendering = false;\nvar nextFlushedRoot = null;\nvar nextFlushedExpirationTime = NoWork;\nvar lowestPendingInteractiveExpirationTime = NoWork;\nvar deadlineDidExpire = false;\nvar hasUnhandledError = false;\nvar unhandledError = null;\nvar deadline = null;\n\nvar isBatchingUpdates = false;\nvar isUnbatchingUpdates = false;\nvar isBatchingInteractiveUpdates = false;\n\nvar completedBatches = null;\n\n// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT = 1000;\nvar nestedUpdateCount = 0;\n\nvar timeHeuristicForUnitOfWork = 1;\n\nfunction scheduleCallbackWithExpiration(expirationTime) {\n  if (callbackExpirationTime !== NoWork) {\n    // A callback is already scheduled. Check its expiration time (timeout).\n    if (expirationTime > callbackExpirationTime) {\n      // Existing callback has sufficient timeout. Exit.\n      return;\n    } else {\n      if (callbackID !== null) {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n    }\n    // The request callback timer is already running. Don't start a new one.\n  } else {\n    startRequestCallbackTimer();\n  }\n\n  // Compute a timeout for the given expiration time.\n  var currentMs = now() - originalStartTimeMs;\n  var expirationMs = expirationTimeToMs(expirationTime);\n  var timeout = expirationMs - currentMs;\n\n  callbackExpirationTime = expirationTime;\n  callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n}\n\nfunction requestRetry(root, expirationTime) {\n  if (root.remainingExpirationTime === NoWork || root.remainingExpirationTime < expirationTime) {\n    // For a retry, only update the remaining expiration time if it has a\n    // *lower priority* than the existing value. This is because, on a retry,\n    // we should attempt to coalesce as much as possible.\n    requestWork(root, expirationTime);\n  }\n}\n\n// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root, expirationTime) {\n  addRootToSchedule(root, expirationTime);\n\n  if (isRendering) {\n    // Prevent reentrancy. Remaining work will be scheduled at the end of\n    // the currently rendering batch.\n    return;\n  }\n\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, false);\n    }\n    return;\n  }\n\n  // TODO: Get rid of Sync and use current time?\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    scheduleCallbackWithExpiration(expirationTime);\n  }\n}\n\nfunction addRootToSchedule(root, expirationTime) {\n  // Add the root to the schedule.\n  // Check if this root is already part of the schedule.\n  if (root.nextScheduledRoot === null) {\n    // This root is not already scheduled. Add it.\n    root.remainingExpirationTime = expirationTime;\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n      root.nextScheduledRoot = root;\n    } else {\n      lastScheduledRoot.nextScheduledRoot = root;\n      lastScheduledRoot = root;\n      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n    }\n  } else {\n    // This root is already scheduled, but its priority may have increased.\n    var remainingExpirationTime = root.remainingExpirationTime;\n    if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n      // Update the priority.\n      root.remainingExpirationTime = expirationTime;\n    }\n  }\n}\n\nfunction findHighestPriorityRoot() {\n  var highestPriorityWork = NoWork;\n  var highestPriorityRoot = null;\n  if (lastScheduledRoot !== null) {\n    var previousScheduledRoot = lastScheduledRoot;\n    var root = firstScheduledRoot;\n    while (root !== null) {\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork) {\n        // This root no longer has work. Remove it from the scheduler.\n\n        // TODO: This check is redudant, but Flow is confused by the branch\n        // below where we set lastScheduledRoot to null, even though we break\n        // from the loop right after.\n        !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        if (root === root.nextScheduledRoot) {\n          // This is the only root in the list.\n          root.nextScheduledRoot = null;\n          firstScheduledRoot = lastScheduledRoot = null;\n          break;\n        } else if (root === firstScheduledRoot) {\n          // This is the first root in the list.\n          var next = root.nextScheduledRoot;\n          firstScheduledRoot = next;\n          lastScheduledRoot.nextScheduledRoot = next;\n          root.nextScheduledRoot = null;\n        } else if (root === lastScheduledRoot) {\n          // This is the last root in the list.\n          lastScheduledRoot = previousScheduledRoot;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          root.nextScheduledRoot = null;\n          break;\n        } else {\n          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n          root.nextScheduledRoot = null;\n        }\n        root = previousScheduledRoot.nextScheduledRoot;\n      } else {\n        if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n          // Update the priority, if it's higher\n          highestPriorityWork = remainingExpirationTime;\n          highestPriorityRoot = root;\n        }\n        if (root === lastScheduledRoot) {\n          break;\n        }\n        previousScheduledRoot = root;\n        root = root.nextScheduledRoot;\n      }\n    }\n  }\n\n  // If the next root is the same as the previous root, this is a nested\n  // update. To prevent an infinite loop, increment the nested update count.\n  var previousFlushedRoot = nextFlushedRoot;\n  if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot && highestPriorityWork === Sync) {\n    nestedUpdateCount++;\n  } else {\n    // Reset whenever we switch roots.\n    nestedUpdateCount = 0;\n  }\n  nextFlushedRoot = highestPriorityRoot;\n  nextFlushedExpirationTime = highestPriorityWork;\n}\n\nfunction performAsyncWork(dl) {\n  performWork(NoWork, true, dl);\n}\n\nfunction performSyncWork() {\n  performWork(Sync, false, null);\n}\n\nfunction performWork(minExpirationTime, isAsync, dl) {\n  deadline = dl;\n\n  // Keep working on roots until there's no more work, or until the we reach\n  // the deadline.\n  findHighestPriorityRoot();\n\n  if (enableProfilerTimer) {\n    resumeActualRenderTimerIfPaused();\n  }\n\n  if (enableUserTimingAPI && deadline !== null) {\n    var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n    var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n    stopRequestCallbackTimer(didExpire, timeout);\n  }\n\n  if (isAsync) {\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || recalculateCurrentTime() >= nextFlushedExpirationTime)) {\n      recalculateCurrentTime();\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !deadlineDidExpire);\n      findHighestPriorityRoot();\n    }\n  } else {\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n      findHighestPriorityRoot();\n    }\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If we're inside a callback, set this to false since we just completed it.\n  if (deadline !== null) {\n    callbackExpirationTime = NoWork;\n    callbackID = null;\n  }\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n  }\n\n  // Clean-up.\n  deadline = null;\n  deadlineDidExpire = false;\n\n  finishRendering();\n}\n\nfunction flushRoot(root, expirationTime) {\n  !!isRendering ? invariant(false, 'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.') : void 0;\n  // Perform work on root as if the given expiration time is the current time.\n  // This has the effect of synchronously flushing all work up to and\n  // including the given time.\n  nextFlushedRoot = root;\n  nextFlushedExpirationTime = expirationTime;\n  performWorkOnRoot(root, expirationTime, false);\n  // Flush any sync work that was scheduled by lifecycles\n  performSyncWork();\n  finishRendering();\n}\n\nfunction finishRendering() {\n  nestedUpdateCount = 0;\n\n  if (completedBatches !== null) {\n    var batches = completedBatches;\n    completedBatches = null;\n    for (var i = 0; i < batches.length; i++) {\n      var batch = batches[i];\n      try {\n        batch._onComplete();\n      } catch (error) {\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n    }\n  }\n\n  if (hasUnhandledError) {\n    var error = unhandledError;\n    unhandledError = null;\n    hasUnhandledError = false;\n    throw error;\n  }\n}\n\nfunction performWorkOnRoot(root, expirationTime, isAsync) {\n  !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  if (!isAsync) {\n    // Flush sync work.\n    var finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      finishedWork = renderRoot(root, expirationTime, false);\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // Flush async work.\n    var _finishedWork = root.finishedWork;\n    if (_finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, _finishedWork, expirationTime);\n    } else {\n      _finishedWork = renderRoot(root, expirationTime, true);\n      if (_finishedWork !== null) {\n        // We've completed the root. Check the deadline one more time\n        // before committing.\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, _finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = _finishedWork;\n\n          if (enableProfilerTimer) {\n            // If we didn't finish, pause the \"actual\" render timer.\n            // We'll restart it when we resume work.\n            pauseActualRenderTimerIfRunning();\n          }\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\nfunction completeRoot(root, finishedWork, expirationTime) {\n  // Check if there's a batch that matches this expiration time.\n  var firstBatch = root.firstBatch;\n  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n    if (completedBatches === null) {\n      completedBatches = [firstBatch];\n    } else {\n      completedBatches.push(firstBatch);\n    }\n    if (firstBatch._defer) {\n      // This root is blocked from committing by a batch. Unschedule it until\n      // we receive another update.\n      root.finishedWork = finishedWork;\n      root.remainingExpirationTime = NoWork;\n      return;\n    }\n  }\n\n  // Commit the root.\n  root.finishedWork = null;\n  root.remainingExpirationTime = commitRoot(finishedWork);\n}\n\n// When working on async work, the reconciler asks the renderer if it should\n// yield execution. For DOM, we implement this with requestIdleCallback.\nfunction shouldYield() {\n  if (deadline === null) {\n    return false;\n  }\n  if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n    // Disregard deadline.didTimeout. Only expired work should be flushed\n    // during a timeout. This path is only hit for non-expired work.\n    return false;\n  }\n  deadlineDidExpire = true;\n  return true;\n}\n\nfunction onUncaughtError(error) {\n  !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  // Unschedule this root so we don't work on it again until there's\n  // another update.\n  nextFlushedRoot.remainingExpirationTime = NoWork;\n  if (!hasUnhandledError) {\n    hasUnhandledError = true;\n    unhandledError = error;\n  }\n}\n\nfunction onBlock(remainingExpirationTime) {\n  !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  // This root was blocked. Unschedule it until there's another update.\n  nextFlushedRoot.remainingExpirationTime = remainingExpirationTime;\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates$1(fn, a) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction unbatchedUpdates(fn, a) {\n  if (isBatchingUpdates && !isUnbatchingUpdates) {\n    isUnbatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isUnbatchingUpdates = false;\n    }\n  }\n  return fn(a);\n}\n\n// TODO: Batching should be implemented at the renderer level, not within\n// the reconciler.\nfunction flushSync(fn, a) {\n  !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return syncUpdates(fn, a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    performSyncWork();\n  }\n}\n\nfunction interactiveUpdates$1(fn, a, b) {\n  if (isBatchingInteractiveUpdates) {\n    return fn(a, b);\n  }\n  // If there are any pending interactive updates, synchronously flush them.\n  // This needs to happen before we read any handlers, because the effect of\n  // the previous event may influence which handlers are called during\n  // this event.\n  if (!isBatchingUpdates && !isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPendingInteractiveExpirationTime, false, null);\n    lowestPendingInteractiveExpirationTime = NoWork;\n  }\n  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingInteractiveUpdates = true;\n  isBatchingUpdates = true;\n  try {\n    return fn(a, b);\n  } finally {\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction flushInteractiveUpdates$1() {\n  if (!isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPendingInteractiveExpirationTime, false, null);\n    lowestPendingInteractiveExpirationTime = NoWork;\n  }\n}\n\nfunction flushControlled(fn) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    syncUpdates(fn);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performWork(Sync, false, null);\n    }\n  }\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\nfunction scheduleRootUpdate(current, element, expirationTime, callback) {\n  {\n    if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n    }\n  }\n\n  var update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: element };\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    !(typeof callback === 'function') ? warning(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0;\n    update.callback = callback;\n  }\n  enqueueUpdate(current, update, expirationTime);\n\n  scheduleWork$1(current, expirationTime);\n  return expirationTime;\n}\n\nfunction updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {\n  // TODO: If this is a nested container, this won't be the root.\n  var current = container.current;\n\n  {\n    if (ReactFiberInstrumentation_1.debugTool) {\n      if (current.alternate === null) {\n        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  var context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current, element, expirationTime, callback);\n}\n\nfunction findHostInstance(component) {\n  var fiber = get(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n    }\n  }\n  var hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction createContainer(containerInfo, isAsync, hydrate) {\n  return createFiberRoot(containerInfo, isAsync, hydrate);\n}\n\nfunction updateContainer(element, container, parentComponent, callback) {\n  var current = container.current;\n  var currentTime = recalculateCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, current);\n  return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);\n}\n\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nfunction findHostInstanceWithNoPortals(fiber) {\n  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n  return injectInternals(_assign({}, devToolsConfig, {\n    findHostInstanceByFiber: function (fiber) {\n      var hostFiber = findCurrentHostFiber(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findFiberByHostInstance: function (instance) {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n      return findFiberByHostInstance(instance);\n    }\n  }));\n}\n\n// This file intentionally does *not* have the Flow annotation.\n// Don't add it. See `./inline-typed.js` for an explanation.\n\n\n\nvar DOMRenderer = Object.freeze({\n\tupdateContainerAtExpirationTime: updateContainerAtExpirationTime,\n\tcreateContainer: createContainer,\n\tupdateContainer: updateContainer,\n\tflushRoot: flushRoot,\n\trequestWork: requestWork,\n\tcomputeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n\tbatchedUpdates: batchedUpdates$1,\n\tunbatchedUpdates: unbatchedUpdates,\n\tdeferredUpdates: deferredUpdates,\n\tsyncUpdates: syncUpdates,\n\tinteractiveUpdates: interactiveUpdates$1,\n\tflushInteractiveUpdates: flushInteractiveUpdates$1,\n\tflushControlled: flushControlled,\n\tflushSync: flushSync,\n\tgetPublicRootInstance: getPublicRootInstance,\n\tfindHostInstance: findHostInstance,\n\tfindHostInstanceWithNoPortals: findHostInstanceWithNoPortals,\n\tinjectIntoDevTools: injectIntoDevTools\n});\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.4.1';\n\n// TODO: This type is shared between the reconciler and ReactDOM, but will\n// eventually be lifted out to the renderer.\nvar topLevelUpdateWarnings = void 0;\nvar warnOnInvalidCallback = void 0;\nvar didWarnAboutUnstableCreatePortal = false;\n\n{\n  if (typeof Map !== 'function' ||\n  // $FlowIssue Flow incorrectly thinks Map has no prototype\n  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' ||\n  // $FlowIssue Flow incorrectly thinks Set has no prototype\n  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n  }\n\n  topLevelUpdateWarnings = function (container) {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\n      if (hostInstance) {\n        !(hostInstance.parentNode === container) ? warning(false, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.') : void 0;\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    !(!hasNonRootReactChild || isRootRenderedBySomeReact) ? warning(false, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;\n\n    !(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY') ? warning(false, 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;\n  };\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    !(callback === null || typeof callback === 'function') ? warning(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback) : void 0;\n  };\n}\n\ninjection$2.injectFiberControlledHostComponent(ReactDOMFiberComponent);\n\nfunction ReactBatch(root) {\n  var expirationTime = computeUniqueAsyncExpiration();\n  this._expirationTime = expirationTime;\n  this._root = root;\n  this._next = null;\n  this._callbacks = null;\n  this._didComplete = false;\n  this._hasChildren = false;\n  this._children = null;\n  this._defer = true;\n}\nReactBatch.prototype.render = function (children) {\n  !this._defer ? invariant(false, 'batch.render: Cannot render a batch that already committed.') : void 0;\n  this._hasChildren = true;\n  this._children = children;\n  var internalRoot = this._root._internalRoot;\n  var expirationTime = this._expirationTime;\n  var work = new ReactWork();\n  updateContainerAtExpirationTime(children, internalRoot, null, expirationTime, work._onCommit);\n  return work;\n};\nReactBatch.prototype.then = function (onComplete) {\n  if (this._didComplete) {\n    onComplete();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onComplete);\n};\nReactBatch.prototype.commit = function () {\n  var internalRoot = this._root._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  !(this._defer && firstBatch !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n\n  if (!this._hasChildren) {\n    // This batch is empty. Return.\n    this._next = null;\n    this._defer = false;\n    return;\n  }\n\n  var expirationTime = this._expirationTime;\n\n  // Ensure this is the first batch in the list.\n  if (firstBatch !== this) {\n    // This batch is not the earliest batch. We need to move it to the front.\n    // Update its expiration time to be the expiration time of the earliest\n    // batch, so that we can flush it without flushing the other batches.\n    if (this._hasChildren) {\n      expirationTime = this._expirationTime = firstBatch._expirationTime;\n      // Rendering this batch again ensures its children will be the final state\n      // when we flush (updates are processed in insertion order: last\n      // update wins).\n      // TODO: This forces a restart. Should we print a warning?\n      this.render(this._children);\n    }\n\n    // Remove the batch from the list.\n    var previous = null;\n    var batch = firstBatch;\n    while (batch !== this) {\n      previous = batch;\n      batch = batch._next;\n    }\n    !(previous !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n    previous._next = batch._next;\n\n    // Add it to the front.\n    this._next = firstBatch;\n    firstBatch = internalRoot.firstBatch = this;\n  }\n\n  // Synchronously flush all the work up to this batch's expiration time.\n  this._defer = false;\n  flushRoot(internalRoot, expirationTime);\n\n  // Pop the batch from the list.\n  var next = this._next;\n  this._next = null;\n  firstBatch = internalRoot.firstBatch = next;\n\n  // Append the next earliest batch's children to the update queue.\n  if (firstBatch !== null && firstBatch._hasChildren) {\n    firstBatch.render(firstBatch._children);\n  }\n};\nReactBatch.prototype._onComplete = function () {\n  if (this._didComplete) {\n    return;\n  }\n  this._didComplete = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback = callbacks[i];\n    _callback();\n  }\n};\n\nfunction ReactWork() {\n  this._callbacks = null;\n  this._didCommit = false;\n  // TODO: Avoid need to bind by replacing callbacks in the update queue with\n  // list of Work objects.\n  this._onCommit = this._onCommit.bind(this);\n}\nReactWork.prototype.then = function (onCommit) {\n  if (this._didCommit) {\n    onCommit();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onCommit);\n};\nReactWork.prototype._onCommit = function () {\n  if (this._didCommit) {\n    return;\n  }\n  this._didCommit = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback2 = callbacks[i];\n    !(typeof _callback2 === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback2) : void 0;\n    _callback2();\n  }\n};\n\nfunction ReactRoot(container, isAsync, hydrate) {\n  var root = createContainer(container, isAsync, hydrate);\n  this._internalRoot = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(children, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(null, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(children, root, parentComponent, work._onCommit);\n  return work;\n};\nReactRoot.prototype.createBatch = function () {\n  var batch = new ReactBatch(this);\n  var expirationTime = batch._expirationTime;\n\n  var internalRoot = this._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  if (firstBatch === null) {\n    internalRoot.firstBatch = batch;\n    batch._next = null;\n  } else {\n    // Insert sorted by expiration time then insertion order\n    var insertAfter = null;\n    var insertBefore = firstBatch;\n    while (insertBefore !== null && insertBefore._expirationTime <= expirationTime) {\n      insertAfter = insertBefore;\n      insertBefore = insertBefore._next;\n    }\n    batch._next = insertBefore;\n    if (insertAfter !== null) {\n      insertAfter._next = batch;\n    }\n  }\n\n  return batch;\n};\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\ninjection$3.injectRenderer(DOMRenderer);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction legacyCreateRootFromDOMContainer(container, forceHydrate) {\n  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    var warned = false;\n    var rootSibling = void 0;\n    while (rootSibling = container.lastChild) {\n      {\n        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n          warned = true;\n          warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n    }\n  }\n  // Legacy roots are not async by default.\n  var isAsync = false;\n  return new ReactRoot(container, isAsync, shouldHydrate);\n}\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  // TODO: Ensure all entry points contain this check\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    topLevelUpdateWarnings(container);\n  }\n\n  // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n  var root = container._reactRootContainer;\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    if (typeof callback === 'function') {\n      var originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(root._internalRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(function () {\n      if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    if (typeof callback === 'function') {\n      var _originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(root._internalRoot);\n        _originalCallback.call(instance);\n      };\n    }\n    // Update\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n    } else {\n      root.render(children, callback);\n    }\n  }\n  return getPublicRootInstance(root._internalRoot);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null && owner.stateNode !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        !warnedAboutRefsInRender ? warning(false, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component') : void 0;\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    return findHostInstance(componentOrElement);\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        !!renderedByDifferentReact ? warning(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.') : void 0;\n      }\n\n      // Unmount should not be batched.\n      unbatchedUpdates(function () {\n        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        !!hasNonRootReactChild ? warning(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: function () {\n    if (!didWarnAboutUnstableCreatePortal) {\n      didWarnAboutUnstableCreatePortal = true;\n      lowPriorityWarning$1(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the \"unstable_\" prefix.');\n    }\n    return createPortal.apply(undefined, arguments);\n  },\n\n\n  unstable_batchedUpdates: batchedUpdates$1,\n\n  unstable_deferredUpdates: deferredUpdates,\n\n  unstable_interactiveUpdates: interactiveUpdates$1,\n\n  flushSync: flushSync,\n\n  unstable_flushControlled: flushControlled,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // For TapEventPlugin which is popular in open source\n    EventPluginHub: EventPluginHub,\n    // Used by test-utils\n    EventPluginRegistry: EventPluginRegistry,\n    EventPropagators: EventPropagators,\n    ReactControlledComponent: ReactControlledComponent,\n    ReactDOMComponentTree: ReactDOMComponentTree,\n    ReactDOMEventListener: ReactDOMEventListener\n  }\n};\n\nReactDOM.unstable_createRoot = function createRoot(container, options) {\n  var hydrate = options != null && options.hydrate === true;\n  return new ReactRoot(container, true, hydrate);\n};\n\nvar foundDevTools = injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3.default ? ReactDOM$3.default : ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanM/NjFiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVDQUF1QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUM7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQixFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEtBQThLLFlBQVk7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TEFBdUwsK0JBQStCO0FBQ3ROOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtKQUErSixpQkFBaUI7QUFDaEwsT0FBTztBQUNQLCtKQUErSixpQkFBaUIsd0RBQXdELG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQ3pTO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMElBQTBJLG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQzNNLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDLGlEQUFpRDtBQUNqRCxxREFBcUQ7QUFDckQsMERBQTBEO0FBQzFELDhEQUE4RDtBQUM5RCwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0tBQWtLLHlDQUF5QztBQUMzTTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4TUFBOE07QUFDOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsbUJBQW1CO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi40LjFcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gaGF2ZSBwcmVzZXJ2ZSB0aGUgZm9ybWF0IGFuZCBwYXJhbXMgaW4gdGhlIHd3dyBidWlsZHMuXG5cbiFSZWFjdCA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uJykgOiB2b2lkIDA7XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gIH1cbn07XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW50aW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbiAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbiAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4gIC8vIERPTSBub2RlLCBhbmQgY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayBmcm9tIGluc2lkZSBhbiBldmVudCBoYW5kbGVyXG4gIC8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbiAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbiAgLy8gZXZlbnQgbG9vcCBjb250ZXh0LCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIG5vcm1hbCBwcm9ncmFtIGZsb3cuXG4gIC8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4gIC8vIHRyeS1jYXRjaC4gTmVhdCFcblxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIHZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgISh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCBkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgc2NoZWR1bGVzIGFuIHVwZGF0ZSBmcm9tIGFuIGFzeW5jaHJvbm91cyBjYWxsYmFjaywgYnV0IHRoZSB0ZXN0IGhhcyBhbHJlYWR5IGZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCB0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgY2FuY2VsZWQgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YCksIG9yIHlvdSBjYW4gY2hhbmdlIHRoZSB0ZXN0IGl0c2VsZiB0byBiZSBhc3luY2hyb25vdXMuJykgOiB2b2lkIDA7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTtcblxuICAgICAgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IGludm9rZUd1YXJkZWRDYWxsYmFjaztcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAgICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICAgKlxuICAgKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gICAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICAgKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDEgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgIShnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUpID8gd2FybmluZyhmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSB2b2lkIDA7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgIShpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4pID8gd2FybmluZyhmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHMgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudHNJbkJhdGNoKGV2ZW50cywgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudHMgIT09IG51bGwpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxuXG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnRzLCBmYWxzZSk7XG59XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbixcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRydW5FdmVudHNJbkJhdGNoOiBydW5FdmVudHNJbkJhdGNoLFxuXHRydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoOiBydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG5cblxuXG52YXIgRnJhZ21lbnQgPSAxMDtcbnZhciBNb2RlID0gMTE7XG52YXIgQ29udGV4dENvbnN1bWVyID0gMTI7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTM7XG52YXIgRm9yd2FyZFJlZiA9IDE0O1xudmFyIFByb2ZpbGVyID0gMTU7XG52YXIgVGltZW91dENvbXBvbmVudCA9IDE2O1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdCkge1xuICAgIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UkMShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gIGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wc1xufSk7XG5cbmZ1bmN0aW9uIGdldFBhcmVudChpbnN0KSB7XG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47XG4gICAgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gZ2V0UGFyZW50KHRlbXBBKSkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0QiB8fCBpbnN0QSA9PT0gaW5zdEIuYWx0ZXJuYXRlKSB7XG4gICAgICByZXR1cm4gaW5zdEE7XG4gICAgfVxuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICByZXR1cm4gZ2V0UGFyZW50KGluc3QpO1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBnZXRQYXJlbnQoaW5zdCk7XG4gIH1cbiAgdmFyIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWZyb20pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZnJvbSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZyb20uYWx0ZXJuYXRlO1xuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBnZXRQYXJlbnQoZnJvbSk7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghdG8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodG8gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBfYWx0ZXJuYXRlID0gdG8uYWx0ZXJuYXRlO1xuICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsICYmIF9hbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IGdldFBhcmVudCh0byk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCAnYnViYmxlZCcsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAodmFyIF9pID0gcGF0aFRvLmxlbmd0aDsgX2ktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW19pXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVuIGFcbiAqIHNpbmdsZSBvbmUuXG4gKi9cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIHtcbiAgICAhaW5zdCA/IHdhcm5pbmcoZmFsc2UsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IGdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChpbnN0ICYmIGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IE9iamVjdC5mcmVlemUoe1xuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG5cdGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNcbn0pO1xuXG4vLyBEbyBub3QgdXNlcyB0aGUgYmVsb3cgdHdvIG1ldGhvZHMgZGlyZWN0bHkhXG4vLyBJbnN0ZWFkIHVzZSBjb25zdGFudHMgZXhwb3J0ZWQgZnJvbSBET01Ub3BMZXZlbEV2ZW50VHlwZXMgaW4gUmVhY3RET00uXG4vLyAoSXQgaXMgdGhlIG9ubHkgbW9kdWxlIHRoYXQgaXMgYWxsb3dlZCB0byBhY2Nlc3MgdGhlc2UgbWV0aG9kcy4pXG5cbmZ1bmN0aW9uIHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZTtcbn1cblxuZnVuY3Rpb24gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydPJyArIHN0eWxlUHJvcF0gPSAnbycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcblxuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xudmFyIHN0eWxlID0ge307XG5cbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfVxuXG4gIC8vIFNhbWUgYXMgYWJvdmVcbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50TmFtZTtcbn1cblxuLyoqXG4gKiBUbyBpZGVudGlmeSB0b3AgbGV2ZWwgZXZlbnRzIGluIFJlYWN0RE9NLCB3ZSB1c2UgY29uc3RhbnRzIGRlZmluZWQgYnkgdGhpc1xuICogbW9kdWxlLiBUaGlzIGlzIHRoZSBvbmx5IG1vZHVsZSB0aGF0IHVzZXMgdGhlIHVuc2FmZSogbWV0aG9kcyB0byBleHByZXNzXG4gKiB0aGF0IHRoZSBjb25zdGFudHMgYWN0dWFsbHkgY29ycmVzcG9uZCB0byB0aGUgYnJvd3NlciBldmVudCBuYW1lcy4gVGhpcyBsZXRzXG4gKiB1cyBzYXZlIHNvbWUgYnVuZGxlIHNpemUgYnkgYXZvaWRpbmcgYSB0b3AgbGV2ZWwgdHlwZSAtPiBldmVudCBuYW1lIG1hcC5cbiAqIFRoZSByZXN0IG9mIFJlYWN0RE9NIGNvZGUgc2hvdWxkIGltcG9ydCB0b3AgbGV2ZWwgdHlwZXMgZnJvbSB0aGlzIGZpbGUuXG4gKi9cbnZhciBUT1BfQUJPUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Fib3J0Jyk7XG52YXIgVE9QX0FOSU1BVElPTl9FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpKTtcbnZhciBUT1BfQU5JTUFUSU9OX0lURVJBVElPTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykpO1xudmFyIFRPUF9BTklNQVRJT05fU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykpO1xudmFyIFRPUF9CTFVSID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdibHVyJyk7XG52YXIgVE9QX0NBTl9QTEFZID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjYW5wbGF5Jyk7XG52YXIgVE9QX0NBTl9QTEFZX1RIUk9VR0ggPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NhbnBsYXl0aHJvdWdoJyk7XG52YXIgVE9QX0NBTkNFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2FuY2VsJyk7XG52YXIgVE9QX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2hhbmdlJyk7XG52YXIgVE9QX0NMSUNLID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjbGljaycpO1xudmFyIFRPUF9DTE9TRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2xvc2UnKTtcbnZhciBUT1BfQ09NUE9TSVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb21wb3NpdGlvbmVuZCcpO1xudmFyIFRPUF9DT01QT1NJVElPTl9TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29tcG9zaXRpb25zdGFydCcpO1xudmFyIFRPUF9DT01QT1NJVElPTl9VUERBVEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NvbXBvc2l0aW9udXBkYXRlJyk7XG52YXIgVE9QX0NPTlRFWFRfTUVOVSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29udGV4dG1lbnUnKTtcbnZhciBUT1BfQ09QWSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29weScpO1xudmFyIFRPUF9DVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2N1dCcpO1xudmFyIFRPUF9ET1VCTEVfQ0xJQ0sgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RibGNsaWNrJyk7XG52YXIgVE9QX0RSQUcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWcnKTtcbnZhciBUT1BfRFJBR19FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdlbmQnKTtcbnZhciBUT1BfRFJBR19FTlRFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2VudGVyJyk7XG52YXIgVE9QX0RSQUdfRVhJVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2V4aXQnKTtcbnZhciBUT1BfRFJBR19MRUFWRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2xlYXZlJyk7XG52YXIgVE9QX0RSQUdfT1ZFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ292ZXInKTtcbnZhciBUT1BfRFJBR19TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ3N0YXJ0Jyk7XG52YXIgVE9QX0RST1AgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Ryb3AnKTtcbnZhciBUT1BfRFVSQVRJT05fQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkdXJhdGlvbmNoYW5nZScpO1xudmFyIFRPUF9FTVBUSUVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbXB0aWVkJyk7XG52YXIgVE9QX0VOQ1JZUFRFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW5jcnlwdGVkJyk7XG52YXIgVE9QX0VOREVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbmRlZCcpO1xudmFyIFRPUF9FUlJPUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZXJyb3InKTtcbnZhciBUT1BfRk9DVVMgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2ZvY3VzJyk7XG52YXIgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2dvdHBvaW50ZXJjYXB0dXJlJyk7XG52YXIgVE9QX0lOUFVUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdpbnB1dCcpO1xudmFyIFRPUF9JTlZBTElEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdpbnZhbGlkJyk7XG52YXIgVE9QX0tFWV9ET1dOID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdrZXlkb3duJyk7XG52YXIgVE9QX0tFWV9QUkVTUyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5cHJlc3MnKTtcbnZhciBUT1BfS0VZX1VQID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdrZXl1cCcpO1xudmFyIFRPUF9MT0FEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2FkJyk7XG52YXIgVE9QX0xPQURfU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRzdGFydCcpO1xudmFyIFRPUF9MT0FERURfREFUQSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9hZGVkZGF0YScpO1xudmFyIFRPUF9MT0FERURfTUVUQURBVEEgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRlZG1ldGFkYXRhJyk7XG52YXIgVE9QX0xPU1RfUE9JTlRFUl9DQVBUVVJFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb3N0cG9pbnRlcmNhcHR1cmUnKTtcbnZhciBUT1BfTU9VU0VfRE9XTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2Vkb3duJyk7XG52YXIgVE9QX01PVVNFX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlbW92ZScpO1xudmFyIFRPUF9NT1VTRV9PVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3V0Jyk7XG52YXIgVE9QX01PVVNFX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3ZlcicpO1xudmFyIFRPUF9NT1VTRV9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2V1cCcpO1xudmFyIFRPUF9QQVNURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGFzdGUnKTtcbnZhciBUT1BfUEFVU0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BhdXNlJyk7XG52YXIgVE9QX1BMQVkgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BsYXknKTtcbnZhciBUT1BfUExBWUlORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGxheWluZycpO1xudmFyIFRPUF9QT0lOVEVSX0NBTkNFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcmNhbmNlbCcpO1xudmFyIFRPUF9QT0lOVEVSX0RPV04gPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJkb3duJyk7XG5cblxudmFyIFRPUF9QT0lOVEVSX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJtb3ZlJyk7XG52YXIgVE9QX1BPSU5URVJfT1VUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVyb3V0Jyk7XG52YXIgVE9QX1BPSU5URVJfT1ZFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcm92ZXInKTtcbnZhciBUT1BfUE9JTlRFUl9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcnVwJyk7XG52YXIgVE9QX1BST0dSRVNTID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwcm9ncmVzcycpO1xudmFyIFRPUF9SQVRFX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncmF0ZWNoYW5nZScpO1xudmFyIFRPUF9SRVNFVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncmVzZXQnKTtcbnZhciBUT1BfU0NST0xMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzY3JvbGwnKTtcbnZhciBUT1BfU0VFS0VEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzZWVrZWQnKTtcbnZhciBUT1BfU0VFS0lORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Vla2luZycpO1xudmFyIFRPUF9TRUxFQ1RJT05fQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzZWxlY3Rpb25jaGFuZ2UnKTtcbnZhciBUT1BfU1RBTExFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc3RhbGxlZCcpO1xudmFyIFRPUF9TVUJNSVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3N1Ym1pdCcpO1xudmFyIFRPUF9TVVNQRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzdXNwZW5kJyk7XG52YXIgVE9QX1RFWFRfSU5QVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RleHRJbnB1dCcpO1xudmFyIFRPUF9USU1FX1VQREFURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndGltZXVwZGF0ZScpO1xudmFyIFRPUF9UT0dHTEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvZ2dsZScpO1xudmFyIFRPUF9UT1VDSF9DQU5DRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvdWNoY2FuY2VsJyk7XG52YXIgVE9QX1RPVUNIX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2hlbmQnKTtcbnZhciBUT1BfVE9VQ0hfTU9WRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2htb3ZlJyk7XG52YXIgVE9QX1RPVUNIX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b3VjaHN0YXJ0Jyk7XG52YXIgVE9QX1RSQU5TSVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykpO1xudmFyIFRPUF9WT0xVTUVfQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd2b2x1bWVjaGFuZ2UnKTtcbnZhciBUT1BfV0FJVElORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnd2FpdGluZycpO1xudmFyIFRPUF9XSEVFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnd2hlZWwnKTtcblxuLy8gTGlzdCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIGluZGl2aWR1YWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50cy5cbi8vIE5vdGUgdGhhdCBldmVudHMgaW4gdGhpcyBsaXN0IHdpbGwgKm5vdCogYmUgbGlzdGVuZWQgdG8gYXQgdGhlIHRvcCBsZXZlbFxuLy8gdW5sZXNzIHRoZXkncmUgZXhwbGljaXRseSB3aGl0ZWxpc3RlZCBpbiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvYC5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSBbVE9QX0FCT1JULCBUT1BfQ0FOX1BMQVksIFRPUF9DQU5fUExBWV9USFJPVUdILCBUT1BfRFVSQVRJT05fQ0hBTkdFLCBUT1BfRU1QVElFRCwgVE9QX0VOQ1JZUFRFRCwgVE9QX0VOREVELCBUT1BfRVJST1IsIFRPUF9MT0FERURfREFUQSwgVE9QX0xPQURFRF9NRVRBREFUQSwgVE9QX0xPQURfU1RBUlQsIFRPUF9QQVVTRSwgVE9QX1BMQVksIFRPUF9QTEFZSU5HLCBUT1BfUFJPR1JFU1MsIFRPUF9SQVRFX0NIQU5HRSwgVE9QX1NFRUtFRCwgVE9QX1NFRUtJTkcsIFRPUF9TVEFMTEVELCBUT1BfU1VTUEVORCwgVE9QX1RJTUVfVVBEQVRFLCBUT1BfVk9MVU1FX0NIQU5HRSwgVE9QX1dBSVRJTkddO1xuXG5mdW5jdGlvbiBnZXRSYXdFdmVudE5hbWUodG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB1bnNhZmVDYXN0RE9NVG9wTGV2ZWxUeXBlVG9TdHJpbmcodG9wTGV2ZWxUeXBlKTtcbn1cblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHZvaWQgMDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICovXG5TeW50aGV0aWNFdmVudC5leHRlbmQgPSBmdW5jdGlvbiAoSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIGZ1bmN0aW9uIENsYXNzKCkge1xuICAgIHJldHVybiBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG5cbiAgcmV0dXJuIENsYXNzO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIHZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nICYmXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTIwMTFcbiAgIU9iamVjdC5pc1NlYWxlZChuZXcgUHJveHkoe30sIHt9KSk7XG5cbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICAhKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSkgPyB3YXJuaW5nKGZhbHNlLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIFwiICsgXCJzZWVpbmcgdGhpcywgeW91J3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gXCIgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICAhd2FybmluZ0NvbmRpdGlvbiA/IHdhcm5pbmcoZmFsc2UsIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICsgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb29sZWRFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucG9wKCk7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gbmV3IEV2ZW50Q29uc3RydWN0b3IoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVBvb2xlZEV2ZW50KGV2ZW50KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgIShldmVudCBpbnN0YW5jZW9mIEV2ZW50Q29uc3RydWN0b3IpID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gZXZlbnQgaW5zdGFuY2UgIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmRlc3RydWN0b3IoKTtcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCA8IEVWRU5UX1BPT0xfU0laRSkge1xuICAgIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnB1c2goZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50UG9vbGluZ1RvKEV2ZW50Q29uc3RydWN0b3IpIHtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wgPSBbXTtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQgPSBnZXRQb29sZWRFdmVudDtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5yZWxlYXNlID0gcmVsZWFzZVBvb2xlZEV2ZW50O1xufVxuXG52YXIgU3ludGhldGljRXZlbnQkMSA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0NPTVBPU0lUSU9OX0VORCwgVE9QX0tFWV9QUkVTUywgVE9QX1RFWFRfSU5QVVQsIFRPUF9QQVNURV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fRU5ELCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DT01QT1NJVElPTl9TVEFSVCwgVE9QX0tFWV9ET1dOLCBUT1BfS0VZX1BSRVNTLCBUT1BfS0VZX1VQLCBUT1BfTU9VU0VfRE9XTl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fVVBEQVRFLCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX1NUQVJUOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9FTkQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9VUERBVEU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSBUT1BfS0VZX0RPV04gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgVE9QX0tFWV9QUkVTUzpcbiAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGUgPSB2b2lkIDA7XG4gIHZhciBmYWxsYmFja0RhdGEgPSB2b2lkIDA7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGV9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxUeXBlYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgVE9QX1RFWFRfSU5QVVQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BMZXZlbFR5cGUgTnVtYmVyIGZyb20gYFRvcExldmVsRXZlbnRUeXBlc2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NPTVBPU0lUSU9OX0VORCB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGdldERhdGEoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSBUT1BfUEFTVEU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycyA9IHZvaWQgMDtcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgY29tcG9zaXRpb24gPSBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICB2YXIgYmVmb3JlSW5wdXQgPSBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBpZiAoY29tcG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBiZWZvcmVJbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoYmVmb3JlSW5wdXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gW2NvbXBvc2l0aW9uLCBiZWZvcmVJbnB1dF07XG4gIH1cbn07XG5cbi8vIFVzZSB0byByZXN0b3JlIGNvbnRyb2xsZWQgc3RhdGUgYWZ0ZXIgYSBjaGFuZ2UgZXZlbnQgaGFzIGZpcmVkLlxuXG52YXIgZmliZXJIb3N0Q29tcG9uZW50ID0gbnVsbDtcblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDogZnVuY3Rpb24gKGhvc3RDb21wb25lbnRJbXBsKSB7XG4gICAgLy8gVGhlIGZpYmVyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgdXNlIGR5bmFtaWMgZGlzcGF0Y2ggc28gd2UgbmVlZCB0b1xuICAgIC8vIGluamVjdCB0aGUgaW1wbGVtZW50YXRpb24uXG4gICAgZmliZXJIb3N0Q29tcG9uZW50ID0gaG9zdENvbXBvbmVudEltcGw7XG4gIH1cbn07XG5cbnZhciByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbnZhciByZXN0b3JlUXVldWUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgLy8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuICAvLyBhbHdheXMgcmVjZWl2ZSB0aGUgY29ycmVjdCBmaWJlciBoZXJlXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cbiAgIShmaWJlckhvc3RDb21wb25lbnQgJiYgdHlwZW9mIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ZpYmVyIG5lZWRzIHRvIGJlIGluamVjdGVkIHRvIGhhbmRsZSBhIGZpYmVyIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpO1xuICBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlLCBwcm9wcyk7XG59XG5cbnZhciBpbmplY3Rpb24kMiA9IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbjtcblxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkc1N0YXRlUmVzdG9yZSgpIHtcbiAgcmV0dXJuIHJlc3RvcmVUYXJnZXQgIT09IG51bGwgfHwgcmVzdG9yZVF1ZXVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVJZk5lZWRlZCgpIHtcbiAgaWYgKCFyZXN0b3JlVGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0YXJnZXQgPSByZXN0b3JlVGFyZ2V0O1xuICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbiAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDIsXG5cdGVucXVldWVTdGF0ZVJlc3RvcmU6IGVucXVldWVTdGF0ZVJlc3RvcmUsXG5cdG5lZWRzU3RhdGVSZXN0b3JlOiBuZWVkc1N0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgX2JhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcbnZhciBfaW50ZXJhY3RpdmVVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhLCBiKSB7XG4gIHJldHVybiBmbihhLCBiKTtcbn07XG52YXIgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBpc0JhdGNoaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzQmF0Y2hpbmcpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzQmF0Y2hpbmcgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBfYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNCYXRjaGluZyA9IGZhbHNlO1xuICAgIHZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyA9IG5lZWRzU3RhdGVSZXN0b3JlKCk7XG4gICAgaWYgKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBJZiBhIGNvbnRyb2xsZWQgZXZlbnQgd2FzIGZpcmVkLCB3ZSBtYXkgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZlxuICAgICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAgIC8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICAgIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlcygpO1xuICAgICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzKGZuLCBhLCBiKSB7XG4gIHJldHVybiBfaW50ZXJhY3RpdmVVcGRhdGVzKGZuLCBhLCBiKTtcbn1cblxuXG5cbnZhciBpbmplY3Rpb24kMyA9IHtcbiAgaW5qZWN0UmVuZGVyZXI6IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgIF9iYXRjaGVkVXBkYXRlcyA9IHJlbmRlcmVyLmJhdGNoZWRVcGRhdGVzO1xuICAgIF9pbnRlcmFjdGl2ZVVwZGF0ZXMgPSByZW5kZXJlci5pbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gICAgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzID0gcmVuZGVyZXIuZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gIH1cbn07XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgLy8gV2UgY291bGQndmUgcGFzc2VkIHRoaXMgdGhlIGZpcnN0IHRpbWVcbiAgLy8gYnV0IGl0IHRyaWdnZXJzIGEgYnVnIGluIElFMTEgYW5kIEVkZ2UgMTQvMTUuXG4gIC8vIENhbGxpbmcgZGVmaW5lUHJvcGVydHkoKSBhZ2FpbiBzaG91bGQgYmUgZXF1aXZhbGVudC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTc2OFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUmVhY3RJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfVElNRU9VVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QudGltZW91dCcpIDogMHhlYWQxO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdBc3luY01vZGUnO1xuICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgcmV0dXJuICdDb250ZXh0LkNvbnN1bWVyJztcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0RnJhZ21lbnQnO1xuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UG9ydGFsJztcbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyKCcgKyBmaWJlci5wZW5kaW5nUHJvcHMuaWQgKyAnKSc7XG4gICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgcmV0dXJuICdDb250ZXh0LlByb3ZpZGVyJztcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgIGNhc2UgUkVBQ1RfVElNRU9VVF9UWVBFOlxuICAgICAgcmV0dXJuICdUaW1lb3V0JztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEsXG4gIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW06IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMVxufTtcblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwO1xuXG4vLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd2hpdGVsaXN0IGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cbnZhciBTVFJJTkcgPSAxO1xuXG4vLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7XG5cbi8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxudmFyIEJPT0xFQU4gPSAzO1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0O1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG52YXIgTlVNRVJJQyA9IDU7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuICAgICAgY2FzZSBPVkVSTE9BREVEX0JPT0xFQU46XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICB0aGlzLmFjY2VwdHNCb29sZWFucyA9IHR5cGUgPT09IEJPT0xFQU5JU0hfU1RSSU5HIHx8IHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgdGhpcy5tdXN0VXNlUHJvcGVydHkgPSBtdXN0VXNlUHJvcGVydHk7XG4gIHRoaXMucHJvcGVydHlOYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblsnY2hpbGRyZW4nLCAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcblxuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsXG4vLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywgJ2F1dG9QbGF5JywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsXG4vLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuWydjaGVja2VkJyxcbi8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbiddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCB3aGl0ZWxpc3QuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcHBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG59KTtcblxuLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScpO1xufSk7XG5cbi8vIFNwZWNpYWwgY2FzZTogdGhpcyBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gSXRzIFwidGFiaW5kZXhcIiBhdHRyaWJ1dGUgbmFtZSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBTVkcgc28gd2UgY2FuJ3QganVzdCB1c2Vcbi8vIGl0cyBSZWFjdCBgdGFiSW5kZXhgIG5hbWUsIGxpa2Ugd2UgZG8gZm9yIGF0dHJpYnV0ZXMgdGhhdCBleGlzdCBvbmx5IGluIEhUTUwuXG5wcm9wZXJ0aWVzLnRhYkluZGV4ID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgndGFiSW5kZXgnLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbid0YWJpbmRleCcsIC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwpO1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gKiBTb21lIHByb3BlcnRpZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvKSB7XG4gIHtcbiAgICBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8udHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOKSB7XG4gICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy4gU29tZVxuICogYXR0cmlidXRlcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cbiAgLy8gSWYgdGhlIHByb3AgaXNuJ3QgaW4gdGhlIHNwZWNpYWwgbGlzdCwgdHJlYXQgaXQgYXMgYSBzaW1wbGUgYXR0cmlidXRlLlxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgcHJvcGVydHlJbmZvID09PSBudWxsKSB7XG4gICAgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHZhciBfYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuXG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0eXBlID09PSBCT09MRUFOID8gZmFsc2UgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSB2b2lkIDA7XG4gICAgaWYgKF90eXBlID09PSBCT09MRUFOIHx8IF90eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyaWJ1dGVOYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIGdldFN0YWNrKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0gPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPSBudWxsIDogcHJvcHMudmFsdWUgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsID8gJycgOiBwcm9wcy5kZWZhdWx0VmFsdWU7XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBnZXRTYWZlVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIF9jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgX2NvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIV9jb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpO1xuXG4gIHZhciB2YWx1ZSA9IGdldFNhZmVWYWx1ZShwcm9wcy52YWx1ZSk7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAocHJvcHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBub2RlLnZhbHVlID09PSAnJyB8fFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0U2FmZVZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO1xuICB9XG5cbiAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcywgaXNIeWRyYXRpbmcpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICB2YXIgX2luaXRpYWxWYWx1ZSA9ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gbm9kZS52YWx1ZTtcblxuICAgIC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gICAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIC8vIERvIG5vdCByZS1hc3NpZ24gdGhlIHZhbHVlIHByb3BlcnR5IGlmIHRoZXJlIGlzIG5vIGNoYW5nZS4gVGhpc1xuICAgICAgLy8gcG90ZW50aWFsbHkgYXZvaWRzIGEgRE9NIHdyaXRlIGFuZCBwcmV2ZW50cyBGaXJlZm94ICh+NjAuMC4xKSBmcm9tXG4gICAgICAvLyBwcmVtYXR1cmVseSBtYXJraW5nIHJlcXVpcmVkIGlucHV0cyBhcyBpbnZhbGlkXG4gICAgICBpZiAoX2luaXRpYWxWYWx1ZSAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBfaW5pdGlhbFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHZhbHVlIG11c3QgYmUgYXNzaWduZWQgYmVmb3JlIGRlZmF1bHRWYWx1ZS4gVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aGVyZSB0aGVcbiAgICAvLyB2aXN1YWxseSBkaXNwbGF5ZWQgdmFsdWUgb2YgZGF0ZSBpbnB1dHMgZGlzYXBwZWFycyBvbiBtb2JpbGUgU2FmYXJpIGFuZCBDaHJvbWU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBfaW5pdGlhbFZhbHVlO1xuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbi8vXG4vLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gIGlmIChcbiAgLy8gRm9jdXNlZCBudW1iZXIgaW5wdXRzIHN5bmNocm9uaXplIG9uIGJsdXIuIFNlZSBDaGFuZ2VFdmVudFBsdWdpbi5qc1xuICB0eXBlICE9PSAnbnVtYmVyJyB8fCBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNhZmVWYWx1ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DSEFOR0UsIFRPUF9DTElDSywgVE9QX0ZPQ1VTLCBUT1BfSU5QVVQsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9VUCwgVE9QX1NFTEVDVElPTl9DSEFOR0VdXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnQsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NIQU5HRSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpIHtcbiAgICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0ZPQ1VTKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0JMVVIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9TRUxFQ1RJT05fQ0hBTkdFIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX0tFWV9VUCB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9LRVlfRE9XTikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQ0xJQ0spIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9JTlBVVCB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9DSEFOR0UpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIobm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gdm9pZCAwLFxuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSB2b2lkIDA7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0JMVVIpIHtcbiAgICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRE9NRXZlbnRQbHVnaW5PcmRlciA9IFsnUmVzcG9uZGVyRXZlbnRQbHVnaW4nLCAnU2ltcGxlRXZlbnRQbHVnaW4nLCAnVGFwRXZlbnRQbHVnaW4nLCAnRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJywgJ0NoYW5nZUV2ZW50UGx1Z2luJywgJ1NlbGVjdEV2ZW50UGx1Z2luJywgJ0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nXTtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufSk7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICBBbHQ6ICdhbHRLZXknLFxuICBDb250cm9sOiAnY3RybEtleScsXG4gIE1ldGE6ICdtZXRhS2V5JyxcbiAgU2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIHBhZ2VYOiBudWxsLFxuICBwYWdlWTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IG51bGwsXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZXh0ZW5kKHtcbiAgcG9pbnRlcklkOiBudWxsLFxuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsLFxuICBwcmVzc3VyZTogbnVsbCxcbiAgdGlsdFg6IG51bGwsXG4gIHRpbHRZOiBudWxsLFxuICBwb2ludGVyVHlwZTogbnVsbCxcbiAgaXNQcmltYXJ5OiBudWxsXG59KTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9NT1VTRV9PVVQsIFRPUF9NT1VTRV9PVkVSXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX01PVVNFX09VVCwgVE9QX01PVVNFX09WRVJdXG4gIH0sXG4gIHBvaW50ZXJFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvblBvaW50ZXJFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX1BPSU5URVJfT1VULCBUT1BfUE9JTlRFUl9PVkVSXVxuICB9LFxuICBwb2ludGVyTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Qb2ludGVyTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9QT0lOVEVSX09VVCwgVE9QX1BPSU5URVJfT1ZFUl1cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgaXNPdmVyRXZlbnQgPSB0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVkVSIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1ZFUjtcbiAgICB2YXIgaXNPdXRFdmVudCA9IHRvcExldmVsVHlwZSA9PT0gVE9QX01PVVNFX09VVCB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9QT0lOVEVSX09VVDtcblxuICAgIGlmIChpc092ZXJFdmVudCAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2Ugb3IgcG9pbnRlciBpbiBvciBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW4gPSB2b2lkIDA7XG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IHZvaWQgMDtcbiAgICB2YXIgdG8gPSB2b2lkIDA7XG4gICAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SW50ZXJmYWNlID0gdm9pZCAwLFxuICAgICAgICBsZWF2ZUV2ZW50VHlwZSA9IHZvaWQgMCxcbiAgICAgICAgZW50ZXJFdmVudFR5cGUgPSB2b2lkIDAsXG4gICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHZvaWQgMDtcblxuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1ZFUikge1xuICAgICAgZXZlbnRJbnRlcmZhY2UgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgbGVhdmVFdmVudFR5cGUgPSBldmVudFR5cGVzJDIubW91c2VMZWF2ZTtcbiAgICAgIGVudGVyRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLm1vdXNlRW50ZXI7XG4gICAgICBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVkVSKSB7XG4gICAgICBldmVudEludGVyZmFjZSA9IFN5bnRoZXRpY1BvaW50ZXJFdmVudDtcbiAgICAgIGxlYXZlRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLnBvaW50ZXJMZWF2ZTtcbiAgICAgIGVudGVyRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLnBvaW50ZXJFbnRlcjtcbiAgICAgIGV2ZW50VHlwZVByZWZpeCA9ICdwb2ludGVyJztcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gZXZlbnRJbnRlcmZhY2UuZ2V0UG9vbGVkKGxlYXZlRXZlbnRUeXBlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBldmVudEludGVyZmFjZS5nZXRQb29sZWQoZW50ZXJFdmVudFR5cGUsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSBldmVudFR5cGVQcmVmaXggKyAnZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8wO1xudmFyIFBlcmZvcm1lZFdvcmsgPSAvKiAgICAgICAgICovMTtcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gLyogICAgICAgICAgICAgKi8yO1xudmFyIFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSAvKiAgICAqLzY7XG52YXIgRGVsZXRpb24gPSAvKiAgICAgICAgICAgICAgKi84O1xudmFyIENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovMTY7XG52YXIgQ2FsbGJhY2sgPSAvKiAgICAgICAgICAgICAgKi8zMjtcbnZhciBEaWRDYXB0dXJlID0gLyogICAgICAgICAgICAqLzY0O1xudmFyIFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovMTI4O1xudmFyIFNuYXBzaG90ID0gLyogICAgICAgICAgICAgICovMjU2O1xuXG4vLyBVbmlvbiBvZiBhbGwgaG9zdCBlZmZlY3RzXG52YXIgSG9zdEVmZmVjdE1hc2sgPSAvKiAgICAgICAgKi81MTE7XG5cbnZhciBJbmNvbXBsZXRlID0gLyogICAgICAgICAgICAqLzUxMjtcbnZhciBTaG91bGRDYXB0dXJlID0gLyogICAgICAgICAqLzEwMjQ7XG5cbnZhciBNT1VOVElORyA9IDE7XG52YXIgTU9VTlRFRCA9IDI7XG52YXIgVU5NT1VOVEVEID0gMztcblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gTU9VTlRFRDtcbiAgfVxuICAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gIHJldHVybiBVTk1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAhaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXJGaWJlcikgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgIShpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIHN0YXRlID0gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKTtcbiAgICAhKHN0YXRlICE9PSBVTk1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgIGlmIChzdGF0ZSA9PT0gTU9VTlRJTkcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEgPyBwYXJlbnRBLmFsdGVybmF0ZSA6IG51bGw7XG4gICAgaWYgKCFwYXJlbnRBIHx8ICFwYXJlbnRCKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgIWRpZEZpbmRDaGlsZCA/IGludmFyaWFudChmYWxzZSwgJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGEuYWx0ZXJuYXRlID09PSBiKSA/IGludmFyaWFudChmYWxzZSwgJ1JldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVyc1xcJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgIShhLnRhZyA9PT0gSG9zdFJvb3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgJiYgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcihlbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59KTtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGUgPSB2b2lkIDA7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIElFIGFuZCBFZGdlIChvbiBXaW5kb3dzKSBhbmQgQ2hyb21lIC8gU2FmYXJpIChvbiBXaW5kb3dzIGFuZCBMaW51eClcbiAgLy8gcmVwb3J0IEVudGVyIGFzIGNoYXJDb2RlIDEwIHdoZW4gY3RybCBpcyBwcmVzc2VkLlxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZXh0ZW5kKHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG5cbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59KTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQUJPUlRdLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSBuZXcgTWFwKFtcbiAqICAgW1RPUF9BQk9SVCwgeyBzYW1lQ29uZmlnIH1dLFxuICogXSk7XG4gKi9cblxudmFyIGludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMgPSBbW1RPUF9CTFVSLCAnYmx1ciddLCBbVE9QX0NBTkNFTCwgJ2NhbmNlbCddLCBbVE9QX0NMSUNLLCAnY2xpY2snXSwgW1RPUF9DTE9TRSwgJ2Nsb3NlJ10sIFtUT1BfQ09OVEVYVF9NRU5VLCAnY29udGV4dE1lbnUnXSwgW1RPUF9DT1BZLCAnY29weSddLCBbVE9QX0NVVCwgJ2N1dCddLCBbVE9QX0RPVUJMRV9DTElDSywgJ2RvdWJsZUNsaWNrJ10sIFtUT1BfRFJBR19FTkQsICdkcmFnRW5kJ10sIFtUT1BfRFJBR19TVEFSVCwgJ2RyYWdTdGFydCddLCBbVE9QX0RST1AsICdkcm9wJ10sIFtUT1BfRk9DVVMsICdmb2N1cyddLCBbVE9QX0lOUFVULCAnaW5wdXQnXSwgW1RPUF9JTlZBTElELCAnaW52YWxpZCddLCBbVE9QX0tFWV9ET1dOLCAna2V5RG93biddLCBbVE9QX0tFWV9QUkVTUywgJ2tleVByZXNzJ10sIFtUT1BfS0VZX1VQLCAna2V5VXAnXSwgW1RPUF9NT1VTRV9ET1dOLCAnbW91c2VEb3duJ10sIFtUT1BfTU9VU0VfVVAsICdtb3VzZVVwJ10sIFtUT1BfUEFTVEUsICdwYXN0ZSddLCBbVE9QX1BBVVNFLCAncGF1c2UnXSwgW1RPUF9QTEFZLCAncGxheSddLCBbVE9QX1BPSU5URVJfQ0FOQ0VMLCAncG9pbnRlckNhbmNlbCddLCBbVE9QX1BPSU5URVJfRE9XTiwgJ3BvaW50ZXJEb3duJ10sIFtUT1BfUE9JTlRFUl9VUCwgJ3BvaW50ZXJVcCddLCBbVE9QX1JBVEVfQ0hBTkdFLCAncmF0ZUNoYW5nZSddLCBbVE9QX1JFU0VULCAncmVzZXQnXSwgW1RPUF9TRUVLRUQsICdzZWVrZWQnXSwgW1RPUF9TVUJNSVQsICdzdWJtaXQnXSwgW1RPUF9UT1VDSF9DQU5DRUwsICd0b3VjaENhbmNlbCddLCBbVE9QX1RPVUNIX0VORCwgJ3RvdWNoRW5kJ10sIFtUT1BfVE9VQ0hfU1RBUlQsICd0b3VjaFN0YXJ0J10sIFtUT1BfVk9MVU1FX0NIQU5HRSwgJ3ZvbHVtZUNoYW5nZSddXTtcbnZhciBub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gW1tUT1BfQUJPUlQsICdhYm9ydCddLCBbVE9QX0FOSU1BVElPTl9FTkQsICdhbmltYXRpb25FbmQnXSwgW1RPUF9BTklNQVRJT05fSVRFUkFUSU9OLCAnYW5pbWF0aW9uSXRlcmF0aW9uJ10sIFtUT1BfQU5JTUFUSU9OX1NUQVJULCAnYW5pbWF0aW9uU3RhcnQnXSwgW1RPUF9DQU5fUExBWSwgJ2NhblBsYXknXSwgW1RPUF9DQU5fUExBWV9USFJPVUdILCAnY2FuUGxheVRocm91Z2gnXSwgW1RPUF9EUkFHLCAnZHJhZyddLCBbVE9QX0RSQUdfRU5URVIsICdkcmFnRW50ZXInXSwgW1RPUF9EUkFHX0VYSVQsICdkcmFnRXhpdCddLCBbVE9QX0RSQUdfTEVBVkUsICdkcmFnTGVhdmUnXSwgW1RPUF9EUkFHX09WRVIsICdkcmFnT3ZlciddLCBbVE9QX0RVUkFUSU9OX0NIQU5HRSwgJ2R1cmF0aW9uQ2hhbmdlJ10sIFtUT1BfRU1QVElFRCwgJ2VtcHRpZWQnXSwgW1RPUF9FTkNSWVBURUQsICdlbmNyeXB0ZWQnXSwgW1RPUF9FTkRFRCwgJ2VuZGVkJ10sIFtUT1BfRVJST1IsICdlcnJvciddLCBbVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUsICdnb3RQb2ludGVyQ2FwdHVyZSddLCBbVE9QX0xPQUQsICdsb2FkJ10sIFtUT1BfTE9BREVEX0RBVEEsICdsb2FkZWREYXRhJ10sIFtUT1BfTE9BREVEX01FVEFEQVRBLCAnbG9hZGVkTWV0YWRhdGEnXSwgW1RPUF9MT0FEX1NUQVJULCAnbG9hZFN0YXJ0J10sIFtUT1BfTE9TVF9QT0lOVEVSX0NBUFRVUkUsICdsb3N0UG9pbnRlckNhcHR1cmUnXSwgW1RPUF9NT1VTRV9NT1ZFLCAnbW91c2VNb3ZlJ10sIFtUT1BfTU9VU0VfT1VULCAnbW91c2VPdXQnXSwgW1RPUF9NT1VTRV9PVkVSLCAnbW91c2VPdmVyJ10sIFtUT1BfUExBWUlORywgJ3BsYXlpbmcnXSwgW1RPUF9QT0lOVEVSX01PVkUsICdwb2ludGVyTW92ZSddLCBbVE9QX1BPSU5URVJfT1VULCAncG9pbnRlck91dCddLCBbVE9QX1BPSU5URVJfT1ZFUiwgJ3BvaW50ZXJPdmVyJ10sIFtUT1BfUFJPR1JFU1MsICdwcm9ncmVzcyddLCBbVE9QX1NDUk9MTCwgJ3Njcm9sbCddLCBbVE9QX1NFRUtJTkcsICdzZWVraW5nJ10sIFtUT1BfU1RBTExFRCwgJ3N0YWxsZWQnXSwgW1RPUF9TVVNQRU5ELCAnc3VzcGVuZCddLCBbVE9QX1RJTUVfVVBEQVRFLCAndGltZVVwZGF0ZSddLCBbVE9QX1RPR0dMRSwgJ3RvZ2dsZSddLCBbVE9QX1RPVUNIX01PVkUsICd0b3VjaE1vdmUnXSwgW1RPUF9UUkFOU0lUSU9OX0VORCwgJ3RyYW5zaXRpb25FbmQnXSwgW1RPUF9XQUlUSU5HLCAnd2FpdGluZyddLCBbVE9QX1dIRUVMLCAnd2hlZWwnXV07XG5cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblxuZnVuY3Rpb24gYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKF9yZWYsIGlzSW50ZXJhY3RpdmUpIHtcbiAgdmFyIHRvcEV2ZW50ID0gX3JlZlswXSxcbiAgICAgIGV2ZW50ID0gX3JlZlsxXTtcblxuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF0sXG4gICAgaXNJbnRlcmFjdGl2ZTogaXNJbnRlcmFjdGl2ZVxuICB9O1xuICBldmVudFR5cGVzJDRbZXZlbnRdID0gdHlwZTtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XG59XG5cbmludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgdHJ1ZSk7XG59KTtcbm5vbkludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgZmFsc2UpO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFtUT1BfQUJPUlQsIFRPUF9DQU5DRUwsIFRPUF9DQU5fUExBWSwgVE9QX0NBTl9QTEFZX1RIUk9VR0gsIFRPUF9DTE9TRSwgVE9QX0RVUkFUSU9OX0NIQU5HRSwgVE9QX0VNUFRJRUQsIFRPUF9FTkNSWVBURUQsIFRPUF9FTkRFRCwgVE9QX0VSUk9SLCBUT1BfSU5QVVQsIFRPUF9JTlZBTElELCBUT1BfTE9BRCwgVE9QX0xPQURFRF9EQVRBLCBUT1BfTE9BREVEX01FVEFEQVRBLCBUT1BfTE9BRF9TVEFSVCwgVE9QX1BBVVNFLCBUT1BfUExBWSwgVE9QX1BMQVlJTkcsIFRPUF9QUk9HUkVTUywgVE9QX1JBVEVfQ0hBTkdFLCBUT1BfUkVTRVQsIFRPUF9TRUVLRUQsIFRPUF9TRUVLSU5HLCBUT1BfU1RBTExFRCwgVE9QX1NVQk1JVCwgVE9QX1NVU1BFTkQsIFRPUF9USU1FX1VQREFURSwgVE9QX1RPR0dMRSwgVE9QX1ZPTFVNRV9DSEFOR0UsIFRPUF9XQUlUSU5HXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIHJldHVybiBjb25maWcgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuaXNJbnRlcmFjdGl2ZSA9PT0gdHJ1ZTtcbiAgfSxcblxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSBUT1BfS0VZX1BSRVNTOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICBjYXNlIFRPUF9GT0NVUzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQ0xJQ0s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfRE9VQkxFX0NMSUNLOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfRE9XTjpcbiAgICAgIGNhc2UgVE9QX01PVVNFX01PVkU6XG4gICAgICBjYXNlIFRPUF9NT1VTRV9VUDpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVE9QX01PVVNFX09VVDpcbiAgICAgIGNhc2UgVE9QX01PVVNFX09WRVI6XG4gICAgICBjYXNlIFRPUF9DT05URVhUX01FTlU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0RSQUc6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VORDpcbiAgICAgIGNhc2UgVE9QX0RSQUdfRU5URVI6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VYSVQ6XG4gICAgICBjYXNlIFRPUF9EUkFHX0xFQVZFOlxuICAgICAgY2FzZSBUT1BfRFJBR19PVkVSOlxuICAgICAgY2FzZSBUT1BfRFJBR19TVEFSVDpcbiAgICAgIGNhc2UgVE9QX0RST1A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfVE9VQ0hfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfRU5EOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfTU9WRTpcbiAgICAgIGNhc2UgVE9QX1RPVUNIX1NUQVJUOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9BTklNQVRJT05fRU5EOlxuICAgICAgY2FzZSBUT1BfQU5JTUFUSU9OX0lURVJBVElPTjpcbiAgICAgIGNhc2UgVE9QX0FOSU1BVElPTl9TVEFSVDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1RSQU5TSVRJT05fRU5EOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1NDUk9MTDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfV0hFRUw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0NPUFk6XG4gICAgICBjYXNlIFRPUF9DVVQ6XG4gICAgICBjYXNlIFRPUF9QQVNURTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkU6XG4gICAgICBjYXNlIFRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRTpcbiAgICAgIGNhc2UgVE9QX1BPSU5URVJfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9ET1dOOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9NT1ZFOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9PVVQ6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX09WRVI6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX1VQOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLiBUaGlzIHdhcm5pbmcgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCB0b3BMZXZlbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnZhciBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUgPSBTaW1wbGVFdmVudFBsdWdpbi5pc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGU7XG5cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QucmV0dXJuKSB7XG4gICAgaW5zdCA9IGluc3QucmV0dXJuO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHJ1bkV4dHJhY3RlZEV2ZW50c0luQmF0Y2goYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgcmV0dXJuIF9lbmFibGVkO1xufVxuXG4vKipcbiAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxFdmVudFR5cGVzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSksXG4gIC8vIENoZWNrIGlmIGludGVyYWN0aXZlIGFuZCB3cmFwIGluIGludGVyYWN0aXZlVXBkYXRlc1xuICBkaXNwYXRjaC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wTGV2ZWxUeXBlIE51bWJlciBmcm9tIGBUb3BMZXZlbEV2ZW50VHlwZXNgLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKGVsZW1lbnQsIGdldFJhd0V2ZW50TmFtZSh0b3BMZXZlbFR5cGUpLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaW50ZXJhY3RpdmVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRJbnN0LnRhZyA9PT0gJ251bWJlcicgJiYgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgIHRhcmdldEluc3QgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb3VudEF0IENvbnRhaW5lciB3aGVyZSB0byBtb3VudCB0aGUgbGlzdGVuZXJcbiAqL1xuZnVuY3Rpb24gbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHN3aXRjaCAoZGVwZW5kZW5jeSkge1xuICAgICAgICBjYXNlIFRPUF9TQ1JPTEw6XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoVE9QX1NDUk9MTCwgbW91bnRBdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVE9QX0ZPQ1VTOlxuICAgICAgICBjYXNlIFRPUF9CTFVSOlxuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KFRPUF9GT0NVUywgbW91bnRBdCk7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoVE9QX0JMVVIsIG1vdW50QXQpO1xuICAgICAgICAgIC8vIFdlIHNldCB0aGUgZmxhZyBmb3IgYSBzaW5nbGUgZGVwZW5kZW5jeSBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uLFxuICAgICAgICAgIC8vIGJ1dCB0aGlzIGVuc3VyZXMgd2UgbWFyayBib3RoIGFzIGF0dGFjaGVkIHJhdGhlciB0aGFuIGp1c3Qgb25lLlxuICAgICAgICAgIGlzTGlzdGVuaW5nW1RPUF9CTFVSXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbVE9QX0ZPQ1VTXSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVE9QX0NBTkNFTDpcbiAgICAgICAgY2FzZSBUT1BfQ0xPU0U6XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoZ2V0UmF3RXZlbnROYW1lKGRlcGVuZGVuY3kpLCB0cnVlKSkge1xuICAgICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoZGVwZW5kZW5jeSwgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRPUF9JTlZBTElEOlxuICAgICAgICBjYXNlIFRPUF9TVUJNSVQ6XG4gICAgICAgIGNhc2UgVE9QX1JFU0VUOlxuICAgICAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVtIG9uIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnRzLlxuICAgICAgICAgIC8vIFNvbWUgb2YgdGhlbSBidWJibGUgc28gd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGZpcmUgdHdpY2UuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gQnkgZGVmYXVsdCwgbGlzdGVuIG9uIHRoZSB0b3AgbGV2ZWwgdG8gYWxsIG5vbi1tZWRpYSBldmVudHMuXG4gICAgICAgICAgLy8gTWVkaWEgZXZlbnRzIGRvbid0IGJ1YmJsZSBzbyBhZGRpbmcgdGhlIGxpc3RlbmVyIHdvdWxkbid0IGRvIGFueXRoaW5nLlxuICAgICAgICAgIHZhciBpc01lZGlhRXZlbnQgPSBtZWRpYUV2ZW50VHlwZXMuaW5kZXhPZihkZXBlbmRlbmN5KSAhPT0gLTE7XG4gICAgICAgICAgaWYgKCFpc01lZGlhRXZlbnQpIHtcbiAgICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKHJlZ2lzdHJhdGlvbk5hbWUsIG1vdW50QXQpIHtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIC8vIEluIEZpcmVmb3gsIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBjYW4gYmUgXCJhbm9ueW1vdXMgZGl2c1wiLCBlLmcuIHRoZVxuICAvLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4gIC8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbiAgLy8gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZSB3YXkgdG8gYXZvaWQgZXJyb3JpbmdcbiAgLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbiAgLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuXG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgYW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICBmb2N1c05vZGUubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgaW5kZXhXaXRoaW5BbmNob3IgPSAwO1xuICB2YXIgaW5kZXhXaXRoaW5Gb2N1cyA9IDA7XG4gIHZhciBub2RlID0gb3V0ZXJOb2RlO1xuICB2YXIgcGFyZW50Tm9kZSA9IG51bGw7XG5cbiAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHQgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBhbmNob3JOb2RlICYmIChhbmNob3JPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSAmJiArK2luZGV4V2l0aGluRm9jdXMgPT09IGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgbmV4dCBzaWJsaW5nIGBuZXh0YC5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbi8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBlbGVtLnR5cGUgPT09ICdzZWFyY2gnIHx8IGVsZW0udHlwZSA9PT0gJ3RlbCcgfHwgZWxlbS50eXBlID09PSAndXJsJyB8fCBlbGVtLnR5cGUgPT09ICdwYXNzd29yZCcpIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKHByaW9yU2VsZWN0aW9uUmFuZ2UgIT09IG51bGwgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBzZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgfVxuXG4gICAgLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgdmFyIGFuY2VzdG9yID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShpbnB1dCkge1xuICB2YXIgc2VsZWN0aW9uID0gdm9pZCAwO1xuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSB7XG4gICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0gZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xufVxuXG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydCxcbiAgICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMkMyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09OVEVYVF9NRU5VLCBUT1BfRk9DVVMsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9VUCwgVE9QX01PVVNFX0RPV04sIFRPUF9NT1VTRV9VUCwgVE9QX1NFTEVDVElPTl9DSEFOR0VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgVE9QX0ZPQ1VTOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQkxVUjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0NPTlRFWFRfTUVOVTpcbiAgICAgIGNhc2UgVE9QX01PVVNFX1VQOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIFRPUF9TRUxFQ1RJT05fQ0hBTkdFOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgVE9QX0tFWV9ET1dOOlxuICAgICAgY2FzZSBUT1BfS0VZX1VQOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMS5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG59KTtcblxuLy8gV2UgY2FwdHVyZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBhbnkgZ2xvYmFsLCBpbiBjYXNlIGl0IGdldHMgcG9seWZpbGxlZCBhZnRlclxuLy8gdGhpcyBtb2R1bGUgaXMgaW5pdGlhbGx5IGV2YWx1YXRlZC5cbi8vIFdlIHdhbnQgdG8gYmUgdXNpbmcgYSBjb25zaXN0ZW50IGltcGxlbWVudGF0aW9uLlxuXG52YXIgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzY2hlZHVsaW5nIGxpYnJhcnkgdG8gYWxsb3cgc2NoZWR1bGluZyB3b3JrIHdpdGggbW9yZSBncmFudWxhciBwcmlvcml0eSBhbmRcbiAqIGNvbnRyb2wgdGhhbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIHJlcXVlc3RJZGxlQ2FsbGJhY2suXG4gKiBDdXJyZW50IFRPRE8gaXRlbXM6XG4gKiBYLSBQdWxsIG91dCB0aGUgc2NoZWR1bGVXb3JrIHBvbHlmaWxsIGJ1aWx0IGludG8gUmVhY3RcbiAqIFgtIEluaXRpYWwgdGVzdCBjb3ZlcmFnZVxuICogWC0gU3VwcG9ydCBmb3IgbXVsdGlwbGUgY2FsbGJhY2tzXG4gKiAtIFN1cHBvcnQgZm9yIHR3byBwcmlvcml0aWVzOyBzZXJpYWwgYW5kIGRlZmVycmVkXG4gKiAtIEJldHRlciB0ZXN0IGNvdmVyYWdlXG4gKiAtIEJldHRlciBkb2NibG9ja1xuICogLSBQb2xpc2ggZG9jdW1lbnRhdGlvbiwgQVBJXG4gKi9cblxuLy8gVGhpcyBpcyBhIGJ1aWx0LWluIHBvbHlmaWxsIGZvciByZXF1ZXN0SWRsZUNhbGxiYWNrLiBJdCB3b3JrcyBieSBzY2hlZHVsaW5nXG4vLyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZSwgdGhlblxuLy8gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LiBXaXRoaW4gdGhlXG4vLyBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWUgcmF0ZS5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxuLy8gV2UgY2FwdHVyZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBhbnkgZ2xvYmFsLCBpbiBjYXNlIGl0IGdldHMgcG9seWZpbGxlZCBhZnRlclxuLy8gdGhpcyBtb2R1bGUgaXMgaW5pdGlhbGx5IGV2YWx1YXRlZC5cbi8vIFdlIHdhbnQgdG8gYmUgdXNpbmcgYSBjb25zaXN0ZW50IGltcGxlbWVudGF0aW9uLlxudmFyIGxvY2FsRGF0ZSA9IERhdGU7XG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblxudmFyIGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgbm93JDEgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gIG5vdyQxID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyQxID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCk7XG4gIH07XG59XG5cbnZhciBzY2hlZHVsZVdvcmsgPSB2b2lkIDA7XG52YXIgY2FuY2VsU2NoZWR1bGVkV29yayA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRpbWVvdXRJZHMgPSBuZXcgTWFwKCk7XG5cbiAgc2NoZWR1bGVXb3JrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgLy8ga2VlcGluZyByZXR1cm4gdHlwZSBjb25zaXN0ZW50XG4gICAgdmFyIGNhbGxiYWNrQ29uZmlnID0ge1xuICAgICAgc2NoZWR1bGVkQ2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgdGltZW91dFRpbWU6IDAsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAgcHJldjogbnVsbFxuICAgIH07XG4gICAgdmFyIHRpbWVvdXRJZCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlkVGltZW91dDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRpbWVvdXRJZHMuc2V0KGNhbGxiYWNrLCB0aW1lb3V0SWQpO1xuICAgIHJldHVybiBjYWxsYmFja0NvbmZpZztcbiAgfTtcbiAgY2FuY2VsU2NoZWR1bGVkV29yayA9IGZ1bmN0aW9uIChjYWxsYmFja0lkKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tJZC5zY2hlZHVsZWRDYWxsYmFjaztcbiAgICB2YXIgdGltZW91dElkID0gdGltZW91dElkcy5nZXQoY2FsbGJhY2spO1xuICAgIHRpbWVvdXRJZHMuZGVsZXRlKGNhbGxiYWNrSWQpO1xuICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG59IGVsc2Uge1xuICB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFJlcXVlc3RBbmltYXRpb25GcmFtZSQxICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB0eXBlb2YgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9PT0gJ2Z1bmN0aW9uJyA/IGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfTtcblxuICB2YXIgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBudWxsO1xuICB2YXIgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBudWxsO1xuXG4gIC8vIFdlIHRyYWNrIHdoYXQgdGhlIG5leHQgc29vbmVzdCB0aW1lb3V0VGltZSBpcywgdG8gYmUgYWJsZSB0byBxdWlja2x5IHRlbGxcbiAgLy8gaWYgbm9uZSBvZiB0aGUgc2NoZWR1bGVkIGNhbGxiYWNrcyBoYXZlIHRpbWVkIG91dC5cbiAgdmFyIG5leHRTb29uZXN0VGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gbm93JDEoKTtcbiAgICAgIHJldHVybiByZW1haW5pbmcgPiAwID8gcmVtYWluaW5nIDogMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBjYWxsYmFjayBlcnJvcnM6XG4gICAqIC0gZG9uJ3QgY2F0Y2ggdGhlIGVycm9yLCBiZWNhdXNlIHRoaXMgY2hhbmdlcyBkZWJ1Z2dpbmcgYmVoYXZpb3JcbiAgICogLSBkbyBzdGFydCBhIG5ldyBwb3N0TWVzc2FnZSBjYWxsYmFjaywgdG8gY2FsbCBhbnkgcmVtYWluaW5nIGNhbGxiYWNrcyxcbiAgICogLSBidXQgb25seSBpZiB0aGVyZSBpcyBhbiBlcnJvciwgc28gdGhlcmUgaXMgbm90IGV4dHJhIG92ZXJoZWFkLlxuICAgKi9cbiAgdmFyIGNhbGxVbnNhZmVseSA9IGZ1bmN0aW9uIChjYWxsYmFja0NvbmZpZywgYXJnKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tDb25maWcuc2NoZWR1bGVkQ2FsbGJhY2s7XG4gICAgdmFyIGZpbmlzaGVkQ2FsbGluZyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjayhhcmcpO1xuICAgICAgZmluaXNoZWRDYWxsaW5nID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gYWx3YXlzIHJlbW92ZSBpdCBmcm9tIGxpbmtlZCBsaXN0XG4gICAgICBjYW5jZWxTY2hlZHVsZWRXb3JrKGNhbGxiYWNrQ29uZmlnKTtcblxuICAgICAgaWYgKCFmaW5pc2hlZENhbGxpbmcpIHtcbiAgICAgICAgLy8gYW4gZXJyb3IgbXVzdCBoYXZlIGJlZW4gdGhyb3duXG4gICAgICAgIGlzSWRsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGZvciB0aW1lZCBvdXQgY2FsbGJhY2tzLCBydW5zIHRoZW0sIGFuZCB0aGVuIGNoZWNrcyBhZ2FpbiB0byBzZWUgaWZcbiAgICogYW55IG1vcmUgaGF2ZSB0aW1lZCBvdXQuXG4gICAqIEtlZXBzIGRvaW5nIHRoaXMgdW50aWwgdGhlcmUgYXJlIG5vbmUgd2hpY2ggaGF2ZSBjdXJyZW50bHkgdGltZWQgb3V0LlxuICAgKi9cbiAgdmFyIGNhbGxUaW1lZE91dENhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3ckMSgpO1xuICAgIC8vIFRPRE86IHRoaXMgd291bGQgYmUgbW9yZSBlZmZpY2llbnQgaWYgZGVmZXJyZWQgY2FsbGJhY2tzIGFyZSBzdG9yZWQgaW5cbiAgICAvLyBtaW4gaGVhcC5cbiAgICAvLyBPciBpbiBhIGxpbmtlZCBsaXN0IHdpdGggbGlua3MgZm9yIGJvdGggdGltZW91dFRpbWUgb3JkZXIgYW5kIGluc2VydGlvblxuICAgIC8vIG9yZGVyLlxuICAgIC8vIEZvciBub3cgYW4gZWFzeSBjb21wcm9taXNlIGlzIHRoZSBjdXJyZW50IGFwcHJvYWNoOlxuICAgIC8vIEtlZXAgYSBwb2ludGVyIHRvIHRoZSBzb29uZXN0IHRpbWVvdXRUaW1lLCBhbmQgY2hlY2sgdGhhdCBmaXJzdC5cbiAgICAvLyBJZiBpdCBoYXMgbm90IGV4cGlyZWQsIHdlIGNhbiBza2lwIHRyYXZlcnNpbmcgdGhlIHdob2xlIGxpc3QuXG4gICAgLy8gSWYgaXQgaGFzIGV4cGlyZWQsIHRoZW4gd2Ugc3RlcCB0aHJvdWdoIGFsbCB0aGUgY2FsbGJhY2tzLlxuICAgIGlmIChuZXh0U29vbmVzdFRpbWVvdXRUaW1lID09PSAtMSB8fCBuZXh0U29vbmVzdFRpbWVvdXRUaW1lID4gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCBub25lIG9mIHRoZW0gaGF2ZSB0aW1lZCBvdXQgeWV0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBOT1RFOiB3ZSBpbnRlbnRpb25hbGx5IHdhaXQgdG8gdXBkYXRlIHRoZSBuZXh0U29vbmVzdFRpbWVvdXRUaW1lIHVudGlsXG4gICAgLy8gYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNhbGxpbmcgYW55IHRpbWVkIG91dCBjYWxsYmFja3MuXG4gICAgLy8gSWYgYSB0aW1lZCBvdXQgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yLCB3ZSBjb3VsZCBnZXQgc3R1Y2sgaW4gYSBzdGF0ZVxuICAgIC8vIHdoZXJlIHRoZSBuZXh0U29vbmVzdFRpbWVvdXRUaW1lIHdhcyBzZXQgd3JvbmcuXG4gICAgdmFyIHVwZGF0ZWROZXh0U29vbmVzdFRpbWVvdXRUaW1lID0gLTE7IC8vIHdlIHdpbGwgdXBkYXRlIG5leHRTb29uZXN0VGltZW91dFRpbWUgYmVsb3dcbiAgICB2YXIgdGltZWRPdXRDYWxsYmFja3MgPSBbXTtcblxuICAgIC8vIGl0ZXJhdGUgb25jZSB0byBmaW5kIHRpbWVkIG91dCBjYWxsYmFja3MgYW5kIGZpbmQgbmV4dFNvb25lc3RUaW1lb3V0VGltZVxuICAgIHZhciBjdXJyZW50Q2FsbGJhY2tDb25maWcgPSBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdDtcbiAgICB3aGlsZSAoY3VycmVudENhbGxiYWNrQ29uZmlnICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3RpbWVvdXRUaW1lID0gY3VycmVudENhbGxiYWNrQ29uZmlnLnRpbWVvdXRUaW1lO1xuICAgICAgaWYgKF90aW1lb3V0VGltZSAhPT0gLTEgJiYgX3RpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIGl0IGhhcyB0aW1lZCBvdXQhXG4gICAgICAgIHRpbWVkT3V0Q2FsbGJhY2tzLnB1c2goY3VycmVudENhbGxiYWNrQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdGltZW91dFRpbWUgIT09IC0xICYmICh1cGRhdGVkTmV4dFNvb25lc3RUaW1lb3V0VGltZSA9PT0gLTEgfHwgX3RpbWVvdXRUaW1lIDwgdXBkYXRlZE5leHRTb29uZXN0VGltZW91dFRpbWUpKSB7XG4gICAgICAgICAgdXBkYXRlZE5leHRTb29uZXN0VGltZW91dFRpbWUgPSBfdGltZW91dFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDYWxsYmFja0NvbmZpZyA9IGN1cnJlbnRDYWxsYmFja0NvbmZpZy5uZXh0O1xuICAgIH1cblxuICAgIGlmICh0aW1lZE91dENhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRpbWVkT3V0Q2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNhbGxVbnNhZmVseSh0aW1lZE91dENhbGxiYWNrc1tpXSwgZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogd2UgaW50ZW50aW9uYWxseSB3YWl0IHRvIHVwZGF0ZSB0aGUgbmV4dFNvb25lc3RUaW1lb3V0VGltZSB1bnRpbFxuICAgIC8vIGFmdGVyIHN1Y2Nlc3NmdWxseSBjYWxsaW5nIGFueSB0aW1lZCBvdXQgY2FsbGJhY2tzLlxuICAgIG5leHRTb29uZXN0VGltZW91dFRpbWUgPSB1cGRhdGVkTmV4dFNvb25lc3RUaW1lb3V0VGltZTtcbiAgfTtcblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmlyc3QgY2FsbCBhbnl0aGluZyB3aGljaCBoYXMgdGltZWQgb3V0LCB1bnRpbCB3ZSBoYXZlIGNhdWdodCB1cC5cbiAgICBjYWxsVGltZWRPdXRDYWxsYmFja3MoKTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdyQxKCk7XG4gICAgLy8gTmV4dCwgYXMgbG9uZyBhcyB3ZSBoYXZlIGlkbGUgdGltZSwgdHJ5IGNhbGxpbmcgbW9yZSBjYWxsYmFja3MuXG4gICAgd2hpbGUgKGZyYW1lRGVhZGxpbmUgLSBjdXJyZW50VGltZSA+IDAgJiYgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBsYXRlc3RDYWxsYmFja0NvbmZpZyA9IGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0O1xuICAgICAgZnJhbWVEZWFkbGluZU9iamVjdC5kaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAvLyBjYWxsVW5zYWZlbHkgd2lsbCByZW1vdmUgaXQgZnJvbSB0aGUgaGVhZCBvZiB0aGUgbGlua2VkIGxpc3RcbiAgICAgIGNhbGxVbnNhZmVseShsYXRlc3RDYWxsYmFja0NvbmZpZywgZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgICBjdXJyZW50VGltZSA9IG5vdyQxKCk7XG4gICAgfVxuICAgIGlmIChoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIFNjaGVkdWxlIGFub3RoZXIgYW5pbWF0aW9uIGNhbGxiYWNrIHNvIHdlIHJldHJ5IGxhdGVyLlxuICAgICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBzY2hlZHVsZVdvcmsgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIC8qIENhbGxiYWNrQ29uZmlnVHlwZSAqL3tcbiAgICB2YXIgdGltZW91dFRpbWUgPSAtMTtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aW1lb3V0VGltZSA9IG5vdyQxKCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmIChuZXh0U29vbmVzdFRpbWVvdXRUaW1lID09PSAtMSB8fCB0aW1lb3V0VGltZSAhPT0gLTEgJiYgdGltZW91dFRpbWUgPCBuZXh0U29vbmVzdFRpbWVvdXRUaW1lKSB7XG4gICAgICBuZXh0U29vbmVzdFRpbWVvdXRUaW1lID0gdGltZW91dFRpbWU7XG4gICAgfVxuXG4gICAgdmFyIHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnID0ge1xuICAgICAgc2NoZWR1bGVkQ2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgdGltZW91dFRpbWU6IHRpbWVvdXRUaW1lLFxuICAgICAgcHJldjogbnVsbCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9PT0gbnVsbCkge1xuICAgICAgLy8gTWFrZSB0aGlzIGNhbGxiYWNrIHRoZSBoZWFkIGFuZCB0YWlsIG9mIG91ciBsaXN0XG4gICAgICBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnO1xuICAgICAgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIGxhdGVzdCBjYWxsYmFjayBhcyB0aGUgbmV3IHRhaWwgb2YgdGhlIGxpc3RcbiAgICAgIHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnLnByZXYgPSB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdDtcbiAgICAgIC8vIHJlbmFtaW5nIGZvciBjbGFyaXR5XG4gICAgICB2YXIgb2xkVGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdDtcbiAgICAgIGlmIChvbGRUYWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gbnVsbCkge1xuICAgICAgICBvbGRUYWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdC5uZXh0ID0gc2NoZWR1bGVkQ2FsbGJhY2tDb25maWc7XG4gICAgICB9XG4gICAgICB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnO1xuICAgIH1cblxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgc2NoZWR1bGVXb3JrIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZztcbiAgfTtcblxuICBjYW5jZWxTY2hlZHVsZWRXb3JrID0gZnVuY3Rpb24gKGNhbGxiYWNrQ29uZmlnIC8qIENhbGxiYWNrQ29uZmlnVHlwZSAqL1xuICApIHtcbiAgICBpZiAoY2FsbGJhY2tDb25maWcucHJldiA9PT0gbnVsbCAmJiBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gY2FsbGJhY2tDb25maWcpIHtcbiAgICAgIC8vIHRoaXMgY2FsbGJhY2tDb25maWcgaGFzIGFscmVhZHkgYmVlbiBjYW5jZWxsZWQuXG4gICAgICAvLyBjYW5jZWxTY2hlZHVsZWRXb3JrIHNob3VsZCBiZSBpZGVtcG90ZW50LCBhIG5vLW9wIGFmdGVyIGZpcnN0IGNhbGwuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIGZvdXIgcG9zc2libGUgY2FzZXM6XG4gICAgICogLSBIZWFkL25vZGVUb1JlbW92ZS9UYWlsIC0+IG51bGxcbiAgICAgKiAgIEluIHRoaXMgY2FzZSB3ZSBzZXQgSGVhZCBhbmQgVGFpbCB0byBudWxsLlxuICAgICAqIC0gSGVhZCAtPiAuLi4gbWlkZGxlIG5vZGVzLi4uIC0+IFRhaWwvbm9kZVRvUmVtb3ZlXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIG1pZGRsZS5uZXh0IHRvIG51bGwgYW5kIHB1dCBtaWRkbGUgYXMgdGhlIG5ld1xuICAgICAqICAgVGFpbC5cbiAgICAgKiAtIEhlYWQvbm9kZVRvUmVtb3ZlIC0+IC4uLm1pZGRsZSBub2Rlcy4uLiAtPiBUYWlsXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIG1pZGRsZS5wcmV2IGF0IG51bGwgYW5kIG1vdmUgdGhlIEhlYWQgdG9cbiAgICAgKiAgIG1pZGRsZS5cbiAgICAgKiAtIEhlYWQgLT4gLi4uID9zb21lIG5vZGVzIC4uLiAtPiBub2RlVG9SZW1vdmUgLT4gLi4uID9zb21lIG5vZGVzIC4uLiAtPiBUYWlsXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIEhlYWQubmV4dCB0byB0aGUgVGFpbCBhbmQgdGhlIFRhaWwucHJldiB0b1xuICAgICAqICAgdGhlIEhlYWQuXG4gICAgICovXG4gICAgdmFyIG5leHQgPSBjYWxsYmFja0NvbmZpZy5uZXh0O1xuICAgIHZhciBwcmV2ID0gY2FsbGJhY2tDb25maWcucHJldjtcbiAgICBjYWxsYmFja0NvbmZpZy5uZXh0ID0gbnVsbDtcbiAgICBjYWxsYmFja0NvbmZpZy5wcmV2ID0gbnVsbDtcbiAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgLy8gd2UgaGF2ZSBhIG5leHRcblxuICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXZcblxuICAgICAgICAvLyBjYWxsYmFja0NvbmZpZyBpcyBzb21ld2hlcmUgaW4gdGhlIG1pZGRsZSBvZiBhIGxpc3Qgb2YgMyBvciBtb3JlIG5vZGVzLlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG5leHQgYnV0IG5vdCBhIHByZXZpb3VzIG9uZTtcbiAgICAgICAgLy8gY2FsbGJhY2tDb25maWcgaXMgdGhlIGhlYWQgb2YgYSBsaXN0IG9mIDIgb3IgbW9yZSBvdGhlciBub2Rlcy5cbiAgICAgICAgbmV4dC5wcmV2ID0gbnVsbDtcbiAgICAgICAgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBuZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5leHQgY2FsbGJhY2sgY29uZmlnOyB0aGlzIG11c3QgdGhlIHRhaWwgb2YgdGhlIGxpc3RcblxuICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXZcblxuICAgICAgICAvLyBjYWxsYmFja0NvbmZpZyBpcyB0aGUgdGFpbCBvZiBhIGxpc3Qgb2YgMiBvciBtb3JlIG90aGVyIG5vZGVzLlxuICAgICAgICBwcmV2Lm5leHQgPSBudWxsO1xuICAgICAgICB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IHByZXY7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNhbGxiYWNrIGNvbmZpZztcbiAgICAgICAgLy8gY2FsbGJhY2tDb25maWcgaXMgdGhlIG9ubHkgdGhpbmcgaW4gdGhlIGxpbmtlZCBsaXN0LFxuICAgICAgICAvLyBzbyBib3RoIGhlYWQgYW5kIHRhaWwgcG9pbnQgdG8gaXQuXG4gICAgICAgIGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIC8vIFdlIGNhbiBzaWxlbnRseSBza2lwIHRoZW0gYmVjYXVzZSBpbnZhbGlkIERPTSBuZXN0aW5nIHdhcm5pbmdcbiAgLy8gY2F0Y2hlcyB0aGVzZSBjYXNlcyBpbiBGaWJlci5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gIHtcbiAgICBpZiAocHJvcHMuc2VsZWN0ZWQgIT0gbnVsbCAmJiAhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJXMnLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzLCBnZXRTdGFjaykge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgc3R5bGVOYW1lID0gJ2Nzc0Zsb2F0JztcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWVcbiAgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MJDEgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjaykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCB0YWcsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MJDEgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICAhKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgd2hpdGVsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBjb3JyZWN0TmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDEoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDIoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcblxuICAgIC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4lcycsIG5hbWUsIGxvd2VyQ2FzZWROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGNhblVzZUV2ZW50U3lzdGVtKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuU2hhZHlET00gPSBmYWxzZTtcblxudmFyIERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MID0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJztcbnZhciBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgPSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJztcbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9IE5hbWVzcGFjZXMuaHRtbDtcblxuXG52YXIgZ2V0U3RhY2sgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKCcnKTtcblxudmFyIHdhcm5lZFVua25vd25UYWdzID0gdm9pZCAwO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHZvaWQgMDtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSB2b2lkIDA7XG52YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IHZvaWQgMDtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IHZvaWQgMDtcblxudmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IHZvaWQgMDtcbnZhciBub3JtYWxpemVIVE1MID0gdm9pZCAwO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZSxcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWVcbiAgfTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIC8qIGNhblVzZUV2ZW50U3lzdGVtICovdHJ1ZSk7XG4gIH07XG5cbiAgLy8gSFRNTCBwYXJzaW5nIG5vcm1hbGl6ZXMgQ1IgYW5kIENSTEYgdG8gTEYuXG4gIC8vIEl0IGFsc28gY2FuIHR1cm4gXFx1MDAwMCBpbnRvIFxcdUZGRkQgaW5zaWRlIGF0dHJpYnV0ZXMuXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuICAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2gsIGl0IG1pZ2h0IGJlIGNhdXNlZCBieSB0aGF0LlxuICAvLyBXZSB3aWxsIHN0aWxsIHBhdGNoIHVwIGluIHRoaXMgY2FzZSBidXQgbm90IGZpcmUgdGhlIHdhcm5pbmcuXG4gIHZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVggPSAvXFxyXFxuPy9nO1xuICB2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuXG4gIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLCBwcm9wTmFtZSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZFNlcnZlclZhbHVlKSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7XG4gIH07XG5cbiAgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIG5vcm1hbGl6ZUhUTUwgPSBmdW5jdGlvbiAocGFyZW50LCBodG1sKSB7XG4gICAgLy8gV2UgY291bGQgaGF2ZSBjcmVhdGVkIGEgc2VwYXJhdGUgZG9jdW1lbnQgaGVyZSB0byBhdm9pZFxuICAgIC8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4gICAgLy8gaG93IDxub3NjcmlwdD4gaXMgYmVpbmcgaGFuZGxlZC4gU28gd2UgdXNlIHRoZSBzYW1lIGRvY3VtZW50LlxuICAgIC8vIFNlZSB0aGUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMTE1Ny5cbiAgICB2YXIgdGVzdEVsZW1lbnQgPSBwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBpc0RvY3VtZW50T3JGcmFnbWVudCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudE9yRnJhZ21lbnQgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IHZvaWQgMDtcblxuICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgICEoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpKSA/IHdhcm5pbmcoZmFsc2UsICc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcyA9IHZvaWQgMDtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9MT0FELCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfUkVTRVQsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfU1VCTUlULCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1RPR0dMRSwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spO1xuXG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzID0gdm9pZCAwO1xuICB2YXIgbmV4dFByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5ID0gdm9pZCAwO1xuICB2YXIgc3R5bGVOYW1lID0gdm9pZCAwO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSB2b2lkIDA7XG4gIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuXG4gIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9MT0FELCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9FUlJPUiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9SRVNFVCwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9TVUJNSVQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9UT0dHTEUsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW19pXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbX2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRydWUgJiZcbiAgICAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgIHR5cGVvZiBpc0N1c3RvbUNvbXBvbmVudFRhZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhwcm9wS2V5KTtcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNob3VsZElnbm9yZUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSAmJiAhc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgICAgICB2YXIgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG51bGwgJiYgc3RhbmRhcmROYW1lICE9PSBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIC8vIElmIGFuIFNWRyBwcm9wIGlzIHN1cHBsaWVkIHdpdGggYmFkIGNhc2luZywgaXQgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGZyb20gSFRNTCwgYnV0IHdpbGwgcHJvZHVjZSBhIG1pc21hdGNoXG4gICAgICAgICAgICAgIC8vIChhbmQgd291bGQgYmUgaW5jb3JyZWN0bHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCkuXG4gICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIGFscmVhZHkgd2FybiBhYm91dCBiYWQgY2FzaW5nIGVsc2V3aGVyZS5cbiAgICAgICAgICAgICAgLy8gU28gd2UnbGwgc2tpcCB0aGUgbWlzbGVhZGluZyBleHRyYSBtaXNtYXRjaCB3YXJuaW5nIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMVxufSk7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyQxID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICAhKGNoaWxkVGFnID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpIDogdm9pZCAwO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyQxID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG4vLyBSZW5kZXJlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHBlcnNpc3RlbmNlXG4vLyBjYW4gcmUtZXhwb3J0IGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIG1vZHVsZS5cblxuZnVuY3Rpb24gc2hpbSgpIHtcbiAgaW52YXJpYW50KGZhbHNlLCAnVGhlIGN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBwZXJzaXN0ZW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuLy8gUGVyc2lzdGVuY2UgKHdoZW4gdW5zdXBwb3J0ZWQpXG52YXIgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9IGZhbHNlO1xudmFyIGNsb25lSW5zdGFuY2UgPSBzaGltO1xudmFyIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gc2hpbTtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBzaGltO1xudmFyIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4gPSBzaGltO1xudmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHNoaW07XG5cbi8vIFVudXNlZFxuXG52YXIgY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbnZhciBjcmVhdGVUZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlJDE7XG52YXIgc2V0SW5pdGlhbFByb3BlcnRpZXMgPSBzZXRJbml0aWFsUHJvcGVydGllcyQxO1xudmFyIGRpZmZQcm9wZXJ0aWVzID0gZGlmZlByb3BlcnRpZXMkMTtcbnZhciB1cGRhdGVQcm9wZXJ0aWVzID0gdXBkYXRlUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMgPSBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkVGV4dCA9IGRpZmZIeWRyYXRlZFRleHQkMTtcbnZhciB3YXJuRm9yVW5tYXRjaGVkVGV4dCA9IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxO1xudmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmckMS51cGRhdGVkQW5jZXN0b3JJbmZvO1xudmFyIHByZWNhY2hlRmliZXJOb2RlJDEgPSBwcmVjYWNoZUZpYmVyTm9kZTtcbnZhciB1cGRhdGVGaWJlclByb3BzJDEgPSB1cGRhdGVGaWJlclByb3BzO1xuXG5cbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9IHZvaWQgMDtcbntcbiAgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbn1cblxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICB7XG4gICAgICAgIHR5cGUgPSBub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/ICcjZG9jdW1lbnQnIDogJyNmcmFnbWVudCc7XG4gICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgbmFtZXNwYWNlID0gcm9vdCA/IHJvb3QubmFtZXNwYWNlVVJJIDogZ2V0Q2hpbGROYW1lc3BhY2UobnVsbCwgJycpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgIHJldHVybiB7IG5hbWVzcGFjZTogbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8gfTtcbiAgfVxuICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICB2YXIgX2FuY2VzdG9ySW5mbzIgPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gIH1cbiAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHBhcmVudEhvc3RDb250ZXh0O1xuICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHNldEVuYWJsZWQoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiByZXNldEFmdGVyQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHtcbiAgICAvLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cbiAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlJDEoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgZG9tRWxlbWVudCk7XG4gIHVwZGF0ZUZpYmVyUHJvcHMkMShkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICB9XG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlJDEoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICByZXR1cm4gdGV4dE5vZGU7XG59XG5cbnZhciBub3cgPSBub3ckMTtcbnZhciBpc1ByaW1hcnlSZW5kZXJlciA9IHRydWU7XG52YXIgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrID0gc2NoZWR1bGVXb3JrO1xudmFyIGNhbmNlbERlZmVycmVkQ2FsbGJhY2sgPSBjYW5jZWxTY2hlZHVsZWRXb3JrO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgTXV0YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzTXV0YXRpb24gPSB0cnVlO1xuXG5mdW5jdGlvbiBjb21taXRNb3VudChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbiAgLy8gZmlyZXMgaWYgdGhlcmUgaXMgYW4gYFVwZGF0ZWAgZWZmZWN0IHNjaGVkdWxlZCBkdXJpbmcgbW91bnRpbmcuXG4gIC8vIFRoaXMgaGFwcGVucyBpZiBgZmluYWxpemVJbml0aWFsQ2hpbGRyZW5gIHJldHVybnMgYHRydWVgICh3aGljaCBpdFxuICAvLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbiAgLy8gdGhlcmUgYXJlIGFsc28gb3RoZXIgY2FzZXMgd2hlbiB0aGlzIG1pZ2h0IGhhcHBlbiAoc3VjaCBhcyBwYXRjaGluZ1xuICAvLyB1cCB0ZXh0IGNvbnRlbnQgZHVyaW5nIGh5ZHJhdGlvbiBtaXNtYXRjaCkuIFNvIHdlJ2xsIGNoZWNrIHRoaXMgYWdhaW4uXG4gIGlmIChzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIG5ld1Byb3BzKSkge1xuICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRVcGRhdGUoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIFVwZGF0ZSB0aGUgcHJvcHMgaGFuZGxlIHNvIHRoYXQgd2Uga25vdyB3aGljaCBwcm9wcyBhcmUgdGhlIG9uZXMgd2l0aFxuICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gIHVwZGF0ZUZpYmVyUHJvcHMkMShkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuXG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuXG5mdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIEh5ZHJhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNIeWRyYXRpb24gPSB0cnVlO1xuXG5mdW5jdGlvbiBjYW5IeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSkge1xuICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBuZXh0Lm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZSQxKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gIC8vIGdldCBhdHRhY2hlZC5cbiAgdXBkYXRlRmliZXJQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHByZWNhY2hlRmliZXJOb2RlJDEoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cblxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIEV4cGVyaW1lbnRhbCBlcnJvci1ib3VuZGFyeSBBUEkgdGhhdCBjYW4gcmVjb3ZlciBmcm9tIGVycm9ycyB3aXRoaW4gYSBzaW5nbGVcbi8vIHJlbmRlciBwaGFzZVxudmFyIGVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IGZhbHNlO1xuLy8gU3VzcGVuc2VcbnZhciBlbmFibGVTdXNwZW5zZSA9IGZhbHNlO1xuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgPSB0cnVlO1xuXG4vLyBUbyBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBkZWJ1Z2dlciwgd2Vcbi8vIHJlcGxheSB0aGUgYmVnaW4gcGhhc2Ugb2YgYSBmYWlsZWQgY29tcG9uZW50IGluc2lkZSBpbnZva2VHdWFyZGVkQ2FsbGJhY2suXG52YXIgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSB0cnVlO1xuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcbnZhciB3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IGZhbHNlO1xuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxudmFyIHdhcm5BYm91dExlZ2FjeUNvbnRleHRBUEkgPSBmYWxzZTtcblxuLy8gR2F0aGVyIGFkdmFuY2VkIHRpbWluZyBtZXRyaWNzIGZvciBQcm9maWxlciBzdWJ0cmVlcy5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTtcblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbi8vIFByZWZpeCBtZWFzdXJlbWVudHMgc28gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIGZpbHRlciB0aGVtLlxuLy8gTG9uZ2VyIHByZWZpeGVzIGFyZSBoYXJkIHRvIHJlYWQgaW4gRGV2VG9vbHMuXG52YXIgcmVhY3RFbW9qaSA9ICdcXHUyNjlCJztcbnZhciB3YXJuaW5nRW1vamkgPSAnXFx1MjZENCc7XG52YXIgc3VwcG9ydHNVc2VyVGltaW5nID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gS2VlcCB0cmFjayBvZiBjdXJyZW50IGZpYmVyIHNvIHRoYXQgd2Uga25vdyB0aGUgcGF0aCB0byB1bndpbmQgb24gcGF1c2UuXG4vLyBUT0RPOiB0aGlzIGxvb2tzIHRoZSBzYW1lIGFzIG5leHRVbml0T2ZXb3JrIGluIHNjaGVkdWxlci4gQ2FuIHdlIHVuaWZ5IHRoZW0/XG52YXIgY3VycmVudEZpYmVyID0gbnVsbDtcbi8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgdXNlciBjb2RlLCB3aGljaCBmaWJlciBhbmQgbWV0aG9kIGlzIGl0P1xuLy8gUmV1c2luZyBgY3VycmVudEZpYmVyYCB3b3VsZCBiZSBjb25mdXNpbmcgZm9yIHRoaXMgYmVjYXVzZSB1c2VyIGNvZGUgZmliZXJcbi8vIGNhbiBjaGFuZ2UgZHVyaW5nIGNvbW1pdCBwaGFzZSB0b28sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHVud2luZCBpdCAoc2luY2Vcbi8vIGxpZmVjeWNsZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSBkb24ndCByZXNlbWJsZSBhIHRyZWUpLlxudmFyIGN1cnJlbnRQaGFzZSA9IG51bGw7XG52YXIgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuLy8gRGlkIGxpZmVjeWNsZSBob29rIHNjaGVkdWxlIGFuIHVwZGF0ZT8gVGhpcyBpcyBvZnRlbiBhIHBlcmZvcm1hbmNlIHByb2JsZW0sXG4vLyBzbyB3ZSB3aWxsIGtlZXAgdHJhY2sgb2YgaXQsIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXBvcnQuXG4vLyBUcmFjayBjb21taXRzIGNhdXNlZCBieSBjYXNjYWRpbmcgdXBkYXRlcy5cbnZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xudmFyIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xudmFyIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbnZhciBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuLy8gRHVyaW5nIGNvbW1pdHMsIHdlIG9ubHkgc2hvdyBhIG1lYXN1cmVtZW50IG9uY2UgcGVyIG1ldGhvZCBuYW1lXG4vLyB0byBhdm9pZCBzdHJldGNoIHRoZSBjb21taXQgcGhhc2Ugd2l0aCBtZWFzdXJlbWVudCBvdmVyaGVhZC5cbnZhciBsYWJlbHNJbkN1cnJlbnRDb21taXQgPSBuZXcgU2V0KCk7XG5cbnZhciBmb3JtYXRNYXJrTmFtZSA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICByZXR1cm4gcmVhY3RFbW9qaSArICcgJyArIG1hcmtOYW1lO1xufTtcblxudmFyIGZvcm1hdExhYmVsID0gZnVuY3Rpb24gKGxhYmVsLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBwcmVmaXggPSB3YXJuaW5nJCQxID8gd2FybmluZ0Vtb2ppICsgJyAnIDogcmVhY3RFbW9qaSArICcgJztcbiAgdmFyIHN1ZmZpeCA9IHdhcm5pbmckJDEgPyAnIFdhcm5pbmc6ICcgKyB3YXJuaW5nJCQxIDogJyc7XG4gIHJldHVybiAnJyArIHByZWZpeCArIGxhYmVsICsgc3VmZml4O1xufTtcblxudmFyIGJlZ2luTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5tYXJrKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgY2xlYXJNYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBlbmRNYXJrID0gZnVuY3Rpb24gKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSkge1xuICB2YXIgZm9ybWF0dGVkTWFya05hbWUgPSBmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSk7XG4gIHZhciBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsLCB3YXJuaW5nJCQxKTtcbiAgdHJ5IHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGZvcm1hdHRlZExhYmVsLCBmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge31cbiAgLy8gSWYgcHJldmlvdXMgbWFyayB3YXMgbWlzc2luZyBmb3Igc29tZSByZWFzb24sIHRoaXMgd2lsbCB0aHJvdy5cbiAgLy8gVGhpcyBjb3VsZCBvbmx5IGhhcHBlbiBpZiBSZWFjdCBjcmFzaGVkIGluIGFuIHVuZXhwZWN0ZWQgcGxhY2UgZWFybGllci5cbiAgLy8gRG9uJ3QgcGlsZSBvbiB3aXRoIG1vcmUgZXJyb3JzLlxuXG4gIC8vIENsZWFyIG1hcmtzIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGdyb3dpbmcgYnVmZmVyLlxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhmb3JtYXR0ZWRMYWJlbCk7XG59O1xuXG52YXIgZ2V0RmliZXJNYXJrTmFtZSA9IGZ1bmN0aW9uIChsYWJlbCwgZGVidWdJRCkge1xuICByZXR1cm4gbGFiZWwgKyAnICgjJyArIGRlYnVnSUQgKyAnKSc7XG59O1xuXG52YXIgZ2V0RmliZXJMYWJlbCA9IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKSB7XG4gIGlmIChwaGFzZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXNlIGFyZSBjb21wb3NpdGUgY29tcG9uZW50IHRvdGFsIHRpbWUgbWVhc3VyZW1lbnRzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJyBbJyArIChpc01vdW50ZWQgPyAndXBkYXRlJyA6ICdtb3VudCcpICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBvc2l0ZSBjb21wb25lbnQgbWV0aG9kcy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcuJyArIHBoYXNlO1xuICB9XG59O1xuXG52YXIgYmVnaW5GaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuXG4gIGlmIChpc0NvbW1pdHRpbmcgJiYgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmhhcyhsYWJlbCkpIHtcbiAgICAvLyBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgd2UgZG9uJ3Qgc2hvdyBkdXBsaWNhdGUgbGFiZWxzIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBhIGZpeGVkIG92ZXJoZWFkIGZvciBldmVyeSBtZWFzdXJlbWVudCwgYW5kIHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBzdHJldGNoIHRoZSBjb21taXQgcGhhc2UgYmV5b25kIG5lY2Vzc2FyeS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmFkZChsYWJlbCk7XG5cbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGJlZ2luTWFyayhtYXJrTmFtZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGNsZWFyRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGNsZWFyTWFyayhtYXJrTmFtZSk7XG59O1xuXG52YXIgZW5kRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSwgd2FybmluZyQkMSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGVuZE1hcmsobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKTtcbn07XG5cbnZhciBzaG91bGRJZ25vcmVGaWJlciA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAvLyBIb3N0IGNvbXBvbmVudHMgc2hvdWxkIGJlIHNraXBwZWQgaW4gdGhlIHRpbWVsaW5lLlxuICAvLyBXZSBjb3VsZCBjaGVjayB0eXBlb2YgZmliZXIudHlwZSwgYnV0IGRvZXMgdGhpcyB3b3JrIHdpdGggUk4/XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlci5yZXR1cm4gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlci5yZXR1cm4pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4gd2lsbCBmb3JjZSBmbHVzaCBpbiAnICsgZXhwaXJhdGlvblRpbWUgKyAnIG1zKScsICcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgd2FybmluZyQkMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCB0aGlzIGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FybmluZyQkMSA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyQkMSk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgdmFyIGxhYmVsID0gZGlkQ29tcGxldGVSb290ID8gJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBDb21wbGV0ZWQgUm9vdCknIDogJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBZaWVsZGVkKSc7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyayhsYWJlbCwgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG52YXIgZmliZXJTdGFjayA9IHZvaWQgMDtcblxue1xuICBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCkge1xuICB7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGFuIGVtcHR5IHN0YWNrLiBTb21ldGhpbmcgd2FzIG5vdCByZXNldCBwcm9wZXJseS4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdGFja0FmdGVyRmF0YWxFcnJvckluRGV2KCkge1xuICB7XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YWx1ZVN0YWNrLmxlbmd0aCA9IDA7XG4gICAgZmliZXJTdGFjay5sZW5ndGggPSAwO1xuICB9XG59XG5cbnZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB2b2lkIDA7XG5cbntcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZW1wdHlPYmplY3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG4gICAgIXBhcmVudCA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbn1cblxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxudmFyIE1BWF9TSUdORURfMzFfQklUX0lOVCA9IDEwNzM3NDE4MjM7XG5cbi8vIFRPRE86IFVzZSBhbiBvcGFxdWUgdHlwZSBvbmNlIEVTTGludCBldCBhbCBzdXBwb3J0IHRoZSBzeW50YXhcblxuXG52YXIgTm9Xb3JrID0gMDtcbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxudmFyIFVOSVRfU0laRSA9IDEwO1xudmFyIE1BR0lDX05VTUJFUl9PRkZTRVQgPSAyO1xuXG4vLyAxIHVuaXQgb2YgZXhwaXJhdGlvbiB0aW1lIHJlcHJlc2VudHMgMTBtcy5cbmZ1bmN0aW9uIG1zVG9FeHBpcmF0aW9uVGltZShtcykge1xuICAvLyBBbHdheXMgYWRkIGFuIG9mZnNldCBzbyB0aGF0IHdlIGRvbid0IGNsYXNoIHdpdGggdGhlIG1hZ2ljIG51bWJlciBmb3IgTm9Xb3JrLlxuICByZXR1cm4gKG1zIC8gVU5JVF9TSVpFIHwgMCkgKyBNQUdJQ19OVU1CRVJfT0ZGU0VUO1xufVxuXG5mdW5jdGlvbiBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIChleHBpcmF0aW9uVGltZSAtIE1BR0lDX05VTUJFUl9PRkZTRVQpICogVU5JVF9TSVpFO1xufVxuXG5mdW5jdGlvbiBjZWlsaW5nKG51bSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiAoKG51bSAvIHByZWNpc2lvbiB8IDApICsgMSkgKiBwcmVjaXNpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uSW5NcywgYnVja2V0U2l6ZU1zKSB7XG4gIHJldHVybiBNQUdJQ19OVU1CRVJfT0ZGU0VUICsgY2VpbGluZyhjdXJyZW50VGltZSAtIE1BR0lDX05VTUJFUl9PRkZTRVQgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNNb2RlID0gMTtcbnZhciBTdHJpY3RNb2RlID0gMjtcbnZhciBQcm9maWxlTW9kZSA9IDQ7XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IHZvaWQgMDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICB2YXIgdGVzdE1hcCA9IG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgIHZhciB0ZXN0U2V0ID0gbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBSb2xsdXAgdG8gbm90IGNvbnNpZGVyIHRoZXNlIHVudXNlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTc3MVxuICAgIC8vIFRPRE86IHdlIGNhbiByZW1vdmUgdGhlc2UgaWYgUm9sbHVwIGZpeGVzIHRoZSBidWcuXG4gICAgdGVzdE1hcC5zZXQoMCwgMCk7XG4gICAgdGVzdFNldC5hZGQoMCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBGaWJlciBpcyB3b3JrIG9uIGEgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBvciB3YXMgZG9uZS4gVGhlcmUgY2FuXG4vLyBiZSBtb3JlIHRoYW4gb25lIHBlciBjb21wb25lbnQuXG5cblxudmFyIGRlYnVnQ291bnRlciA9IHZvaWQgMDtcblxue1xuICBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgLy8gRWZmZWN0c1xuICB0aGlzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuc2VsZkJhc2VUaW1lID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlVGltZSA9IDA7XG4gIH1cblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgcGVuZGluZ1Byb3BzLCBjdXJyZW50LmtleSwgY3VycmVudC5tb2RlKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgcmVzZXQsIHJhdGhlciB0aGFuIGNvcHksIGFjdHVhbER1cmF0aW9uICYgYWN0dWFsU3RhcnRUaW1lLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aW1lIGZyb20gZW5kbGVzc2x5IGFjY3VtdWxhdGluZyBpbiBuZXcgY29tbWl0cy5cbiAgICAgIC8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcbiAgICAgIC8vIEJ1dCB3b3JrcyBmb3IgeWllbGRpbmcgKHRoZSBjb21tb24gY2FzZSkgYW5kIHNob3VsZCBzdXBwb3J0IHJlc3VtaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gMDtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZVRpbWUgPSBjdXJyZW50LnNlbGZCYXNlVGltZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZVRpbWUgPSBjdXJyZW50LnRyZWVCYXNlVGltZTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0FzeW5jKSB7XG4gIHZhciBtb2RlID0gaXNBc3luYyA/IEFzeW5jTW9kZSB8IFN0cmljdE1vZGUgOiBOb0NvbnRleHQ7XG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gIHZhciBmaWJlclRhZyA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXJUYWcgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBDbGFzc0NvbXBvbmVudCA6IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXJUYWcgPSBIb3N0Q29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gQXN5bmNNb2RlIHwgU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBTdHJpY3RNb2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX1RJTUVPVVRfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBUaW1lb3V0Q29tcG9uZW50O1xuICAgICAgICAvLyBTdXNwZW5zZSBkb2VzIG5vdCByZXF1aXJlIGFzeW5jLCBidXQgaXRzIGNoaWxkcmVuIHNob3VsZCBiZSBzdHJpY3RcbiAgICAgICAgLy8gbW9kZSBjb21wYXRpYmxlLlxuICAgICAgICBtb2RlIHw9IFN0cmljdE1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmliZXJUYWcgPSBnZXRGaWJlclRhZ0Zyb21PYmplY3RUeXBlKHR5cGUsIG93bmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZmliZXIgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci50eXBlID0gdHlwZTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyVGFnRnJvbU9iamVjdFR5cGUodHlwZSwgb3duZXIpIHtcbiAgdmFyICQkdHlwZW9mID0gdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgPyB0eXBlLiQkdHlwZW9mIDogbnVsbDtcblxuICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgcmV0dXJuIENvbnRleHRQcm92aWRlcjtcbiAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgIC8vIFRoaXMgaXMgYSBjb25zdW1lclxuICAgICAgcmV0dXJuIENvbnRleHRDb25zdW1lcjtcbiAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwZW5kaW5nUHJvcHMub25SZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgc3RyaW5nIGFuZCBcIm9uUmVuZGVyXCIgZnVuY3Rpb24gYXMgcHJvcHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihQcm9maWxlciwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCBQcm9maWxlTW9kZSk7XG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiAhPT0gbnVsbCA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG4vLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIH1cblxuICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4gIC8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbiAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbiAgLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC50eXBlID0gc291cmNlLnR5cGU7XG4gIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuICB0YXJnZXQucmV0dXJuID0gc291cmNlLnJldHVybjtcbiAgdGFyZ2V0LmNoaWxkID0gc291cmNlLmNoaWxkO1xuICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuICB0YXJnZXQuaW5kZXggPSBzb3VyY2UuaW5kZXg7XG4gIHRhcmdldC5yZWYgPSBzb3VyY2UucmVmO1xuICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcbiAgdGFyZ2V0Lm1lbW9pemVkUHJvcHMgPSBzb3VyY2UubWVtb2l6ZWRQcm9wcztcbiAgdGFyZ2V0LnVwZGF0ZVF1ZXVlID0gc291cmNlLnVwZGF0ZVF1ZXVlO1xuICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZWZmZWN0VGFnID0gc291cmNlLmVmZmVjdFRhZztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQuZXhwaXJhdGlvblRpbWUgPSBzb3VyY2UuZXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHRhcmdldC5hY3R1YWxEdXJhdGlvbiA9IHNvdXJjZS5hY3R1YWxEdXJhdGlvbjtcbiAgICB0YXJnZXQuYWN0dWFsU3RhcnRUaW1lID0gc291cmNlLmFjdHVhbFN0YXJ0VGltZTtcbiAgICB0YXJnZXQuc2VsZkJhc2VUaW1lID0gc291cmNlLnNlbGZCYXNlVGltZTtcbiAgICB0YXJnZXQudHJlZUJhc2VUaW1lID0gc291cmNlLnRyZWVCYXNlVGltZTtcbiAgfVxuICB0YXJnZXQuX2RlYnVnSUQgPSBzb3VyY2UuX2RlYnVnSUQ7XG4gIHRhcmdldC5fZGVidWdTb3VyY2UgPSBzb3VyY2UuX2RlYnVnU291cmNlO1xuICB0YXJnZXQuX2RlYnVnT3duZXIgPSBzb3VyY2UuX2RlYnVnT3duZXI7XG4gIHRhcmdldC5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHNvdXJjZS5fZGVidWdJc0N1cnJlbnRseVRpbWluZztcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbGlmdGVkIGludG8gdGhlIHJlbmRlcmVyLlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0FzeW5jKTtcbiAgdmFyIHJvb3QgPSB7XG4gICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuXG4gICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgIGxhdGVzdFBlbmRpbmdUaW1lOiBOb1dvcmssXG4gICAgZWFybGllc3RTdXNwZW5kZWRUaW1lOiBOb1dvcmssXG4gICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgIGxhdGVzdFBpbmdlZFRpbWU6IE5vV29yayxcblxuICAgIHBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBmaXJzdEJhdGNoOiBudWxsLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIGZsdXNoUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIHJlY29yZERlcHJlY2F0aW9uV2FybmluZ3M6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIExJRkVDWUNMRV9TVUdHRVNUSU9OUyA9IHtcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcycsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6ICdjb21wb25lbnREaWRVcGRhdGUnXG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG4gIHZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlV2FybmluZ3NNYXAsIHN0cmljdFJvb3QpIHtcbiAgICAgIHZhciBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZSkge1xuICAgICAgICB2YXIgbGlmZWN5Y2xlV2FybmluZ3MgPSBsaWZlY3ljbGVXYXJuaW5nc01hcFtsaWZlY3ljbGVdO1xuICAgICAgICBpZiAobGlmZWN5Y2xlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBsaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IGxpZmVjeWNsZS5yZXBsYWNlKCdVTlNBRkVfJywgJycpO1xuICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gTElGRUNZQ0xFX1NVR0dFU1RJT05TW2xpZmVjeWNsZV07XG4gICAgICAgICAgdmFyIHNvcnRlZENvbXBvbmVudE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50TmFtZXMpO1xuXG4gICAgICAgICAgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLnB1c2goZm9ybWF0dGVkICsgJzogUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgdG8gdXNlICcgKyAoc3VnZ2VzdGlvbiArICcgaW5zdGVhZDogJyArIHNvcnRlZENvbXBvbmVudE5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoc3RyaWN0Um9vdCk7XG5cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vuc2FmZSBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGZvdW5kIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWU6JXMnICsgJ1xcblxcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmpvaW4oJ1xcblxcbicpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnY29tcG9uZW50V2lsbE1vdW50IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiAnICsgJ1VzZSBjb21wb25lbnREaWRNb3VudCBpbnN0ZWFkLiBBcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLCAnICsgJ3lvdSBjYW4gcmVuYW1lIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQuJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnLCBzb3J0ZWROYW1lcyk7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIF91bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKF91bmlxdWVOYW1lcyk7XG5cbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdVc2Ugc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyBpbnN0ZWFkLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX3NvcnRlZE5hbWVzKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfdW5pcXVlTmFtZXMyID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBfdW5pcXVlTmFtZXMyLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMiA9IHNldFRvU29ydGVkU3RyaW5nKF91bmlxdWVOYW1lczIpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIGNvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLiBBcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLCAnICsgJ3lvdSBjYW4gcmVuYW1lIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX3NvcnRlZE5hbWVzMik7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICAvLyBUaGlzIGlzIGRpZmZpY3VsdCB0byB0cmFjayBhbnkgb3RoZXIgd2F5IHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICAgIC8vIGFyZSBvZnRlbiB2YWd1ZSBhbmQgYXJlIGxpa2VseSB0byBjb2xsaWRlIGJldHdlZW4gM3JkIHBhcnR5IGxpYnJhcmllcy5cbiAgICAvLyBBbiBleHBhbmQgcHJvcGVydHkgaXMgcHJvYmFibHkgb2theSB0byB1c2UgaGVyZSBzaW5jZSBpdCdzIERFVi1vbmx5LFxuICAgIC8vIGFuZCB3aWxsIG9ubHkgYmUgc2V0IGluIHRoZSBldmVudCBvZiBzZXJpb3VzIHdhcm5pbmdzLlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSB2b2lkIDA7XG4gICAgaWYgKCFwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuaGFzKHN0cmljdFJvb3QpKSB7XG4gICAgICB3YXJuaW5nc0ZvclJvb3QgPSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6IFtdLFxuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiBbXVxuICAgICAgfTtcblxuICAgICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZ2V0KHN0cmljdFJvb3QpO1xuICAgIH1cblxuICAgIHZhciB1bnNhZmVMaWZlY3ljbGVzID0gW107XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUgfHwgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaCgnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgIH1cblxuICAgIGlmICh1bnNhZmVMaWZlY3ljbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdFtsaWZlY3ljbGVdLnB1c2goZmliZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdzRm9yUm9vdC5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSwgc3RyaWN0Um9vdCkge1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICB2YXIgc3RyaWN0Um9vdENvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzdHJpY3RSb290KTtcblxuICAgICAgd2FybmluZyhmYWxzZSwgJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlOiAlcycgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgc29ydGVkTmFtZXMpO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxuLy8gVE9ETzogT2Zmc2NyZWVuIHVwZGF0ZXNcblxuZnVuY3Rpb24gbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgbGF0ZXN0IGFuZCBlYXJsaWVzdCBwZW5kaW5nIHRpbWVzXG4gICAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgLy8gTm8gb3RoZXIgcGVuZGluZyB1cGRhdGVzLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGVhcmxpZXN0IHBlbmRpbmcgdXBkYXRlLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gICAgICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA8IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGF0ZXN0IHBlbmRpbmcgdXBkYXRlXG4gICAgICAgICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXR0ZWRQcmlvcml0eUxldmVscyhyb290LCBjdXJyZW50VGltZSwgZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgLy8gRmFzdCBwYXRoLiBUaGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLiBDbGVhciBldmVyeXRoaW5nLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIExldCdzIHNlZSBpZiB0aGUgcHJldmlvdXMgbGF0ZXN0IGtub3duIHBlbmRpbmcgbGV2ZWwgd2FzIGp1c3QgZmx1c2hlZC5cbiAgICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpIHtcbiAgICAgICAgLy8gV2UndmUgZmx1c2hlZCBhbGwgdGhlIGtub3duIHBlbmRpbmcgbGV2ZWxzLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lIDwgZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gICAgICAgICAgLy8gV2UndmUgZmx1c2hlZCB0aGUgZWFybGllc3Qga25vd24gcGVuZGluZyBsZXZlbC4gU2V0IHRoaXMgdG8gdGhlXG4gICAgICAgICAgLy8gbGF0ZXN0IHBlbmRpbmcgdGltZS5cbiAgICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm93IGxldCdzIGhhbmRsZSB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGluIHRoZSB3aG9sZSB0cmVlLiBXZSBuZWVkIHRvXG4gICAgLy8gZGVjaWRlIHdoZXRoZXIgdG8gdHJlYXQgaXQgYXMgYSBwZW5kaW5nIGxldmVsIG9yIGFzIHN1c3BlbmRlZC4gQ2hlY2tcbiAgICAvLyBpdCBmYWxscyB3aXRoaW4gdGhlIHJhbmdlIG9mIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG5cbiAgICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIHN1c3BlbmRlZCB3b3JrLiBUcmVhdCB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGFzIGFcbiAgICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lID4gbGF0ZXN0U3VzcGVuZGVkVGltZSkge1xuICAgICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBpcyBsYXRlciB0aGFuIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuIFRoYXRcbiAgICAgIC8vIG1lYW5zIHdlJ3ZlIGZsdXNoZWQgYWxsIHRoZSBzdXNwZW5kZWQgd29yay5cbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuXG4gICAgICAvLyBUaGVyZSdzIG5vIHN1c3BlbmRlZCB3b3JrLiBUcmVhdCB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGFzIGFcbiAgICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lIDwgZWFybGllc3RTdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGUgZWFybGllc3QgcmVtYWluaW5nIHRpbWUgaXMgZWFybGllciB0aGFuIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuXG4gICAgICAvLyBUcmVhdCBpdCBhcyBhIHBlbmRpbmcgdXBkYXRlLlxuICAgICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyB0aW1lIGZhbGxzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Yga25vd24gc3VzcGVuZGVkXG4gICAgLy8gbGV2ZWxzLiBXZSBzaG91bGQgdHJlYXQgdGhpcyBhcyBzdXNwZW5kZWQgd29yay5cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBzdXNwZW5kZWRUaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIC8vIEZpcnN0LCBjaGVjayB0aGUga25vd24gcGVuZGluZyBsZXZlbHMgYW5kIHVwZGF0ZSB0aGVtIGlmIG5lZWRlZC5cbiAgICB2YXIgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPT09IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgICAgLy8gQm90aCBrbm93biBwZW5kaW5nIGxldmVscyB3ZXJlIHN1c3BlbmRlZC4gQ2xlYXIgdGhlbS5cbiAgICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBlYXJsaWVzdCBwZW5kaW5nIGxldmVsIHdhcyBzdXNwZW5kZWQuIENsZWFyIGJ5IHNldHRpbmcgaXQgdG8gdGhlXG4gICAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSBsYXRlc3RQZW5kaW5nVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxhdGVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGUgbGF0ZXN0IHBlbmRpbmcgbGV2ZWwgd2FzIHN1c3BlbmRlZC4gQ2xlYXIgYnkgc2V0dGluZyBpdCB0byB0aGVcbiAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgfVxuXG4gICAgLy8gTmV4dCwgaWYgd2UncmUgd29ya2luZyBvbiB0aGUgbG93ZXN0IGtub3duIHN1c3BlbmRlZCBsZXZlbCwgY2xlYXIgdGhlIHBpbmcuXG4gICAgLy8gVE9ETzogV2hhdCBpZiBhIHByb21pc2Ugc3VzcGVuZHMgYW5kIHBpbmdzIGJlZm9yZSB0aGUgcm9vdCBjb21wbGV0ZXM/XG4gICAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gICAgaWYgKGxhdGVzdFN1c3BlbmRlZFRpbWUgPT09IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IE5vV29yaztcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCB1cGRhdGUgdGhlIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG4gICAgdmFyIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICAgIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPT09IE5vV29yaykge1xuICAgICAgLy8gTm8gb3RoZXIgc3VzcGVuZGVkIGxldmVscy5cbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA+IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZWFybGllc3Qgc3VzcGVuZGVkIGxldmVsLlxuICAgICAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHN1c3BlbmRlZFRpbWU7XG4gICAgICB9IGVsc2UgaWYgKGxhdGVzdFN1c3BlbmRlZFRpbWUgPCBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhdGVzdCBzdXNwZW5kZWQgbGV2ZWxcbiAgICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1BpbmdlZFByaW9yaXR5TGV2ZWwocm9vdCwgcGluZ2VkVGltZSkge1xuICBpZiAoZW5hYmxlU3VzcGVuc2UpIHtcbiAgICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgICBpZiAobGF0ZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmIGxhdGVzdFN1c3BlbmRlZFRpbWUgPD0gcGluZ2VkVGltZSkge1xuICAgICAgdmFyIGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG4gICAgICBpZiAobGF0ZXN0UGluZ2VkVGltZSA9PT0gTm9Xb3JrIHx8IGxhdGVzdFBpbmdlZFRpbWUgPCBwaW5nZWRUaW1lKSB7XG4gICAgICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IHBpbmdlZFRpbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCkge1xuICBpZiAoZW5hYmxlU3VzcGVuc2UpIHtcbiAgICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gICAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAvLyBGYXN0IHBhdGguIFRoZXJlJ3Mgbm8gc3VzcGVuZGVkIHdvcmsuXG4gICAgICByZXR1cm4gZWFybGllc3RQZW5kaW5nVGltZTtcbiAgICB9XG5cbiAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlcmUncyBrbm93biBwZW5kaW5nIHdvcmsuXG4gICAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yaykge1xuICAgICAgcmV0dXJuIGVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgaWYgYSBzdXNwZW5kZWQgbGV2ZWwgd2FzIHBpbmdlZCwgd29yayBvbiB0aGF0LiBPdGhlcndpc2UgdGhlcmUnc1xuICAgIC8vIG5vdGhpbmcgdG8gd29yayBvbi5cbiAgICByZXR1cm4gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuLy8gVXBkYXRlUXVldWUgaXMgYSBsaW5rZWQgbGlzdCBvZiBwcmlvcml0aXplZCB1cGRhdGVzLlxuLy9cbi8vIExpa2UgZmliZXJzLCB1cGRhdGUgcXVldWVzIGNvbWUgaW4gcGFpcnM6IGEgY3VycmVudCBxdWV1ZSwgd2hpY2ggcmVwcmVzZW50c1xuLy8gdGhlIHZpc2libGUgc3RhdGUgb2YgdGhlIHNjcmVlbiwgYW5kIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgd2hpY2ggaXNcbi8vIGNhbiBiZSBtdXRhdGVkIGFuZCBwcm9jZXNzZWQgYXN5bmNocm9ub3VzbHkgYmVmb3JlIGl0IGlzIGNvbW1pdHRlZCDigJQgYSBmb3JtXG4vLyBvZiBkb3VibGUgYnVmZmVyaW5nLiBJZiBhIHdvcmstaW4tcHJvZ3Jlc3MgcmVuZGVyIGlzIGRpc2NhcmRlZCBiZWZvcmVcbi8vIGZpbmlzaGluZywgd2UgY3JlYXRlIGEgbmV3IHdvcmstaW4tcHJvZ3Jlc3MgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBCb3RoIHF1ZXVlcyBzaGFyZSBhIHBlcnNpc3RlbnQsIHNpbmdseS1saW5rZWQgbGlzdCBzdHJ1Y3R1cmUuIFRvIHNjaGVkdWxlIGFuXG4vLyB1cGRhdGUsIHdlIGFwcGVuZCBpdCB0byB0aGUgZW5kIG9mIGJvdGggcXVldWVzLiBFYWNoIHF1ZXVlIG1haW50YWlucyBhXG4vLyBwb2ludGVyIHRvIGZpcnN0IHVwZGF0ZSBpbiB0aGUgcGVyc2lzdGVudCBsaXN0IHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkLlxuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcG9pbnRlciBhbHdheXMgaGFzIGEgcG9zaXRpb24gZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXG4vLyB0aGUgY3VycmVudCBxdWV1ZSwgc2luY2Ugd2UgYWx3YXlzIHdvcmsgb24gdGhhdCBvbmUuIFRoZSBjdXJyZW50IHF1ZXVlJ3Ncbi8vIHBvaW50ZXIgaXMgb25seSB1cGRhdGVkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3aGVuIHdlIHN3YXAgaW4gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzLlxuLy9cbi8vIEZvciBleGFtcGxlOlxuLy9cbi8vICAgQ3VycmVudCBwb2ludGVyOiAgICAgICAgICAgQSAtIEIgLSBDIC0gRCAtIEUgLSBGXG4vLyAgIFdvcmstaW4tcHJvZ3Jlc3MgcG9pbnRlcjogICAgICAgICAgICAgIEQgLSBFIC0gRlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGhhc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQgbW9yZSB1cGRhdGVzIHRoYW4gY3VycmVudC5cbi8vXG4vLyBUaGUgcmVhc29uIHdlIGFwcGVuZCB0byBib3RoIHF1ZXVlcyBpcyBiZWNhdXNlIG90aGVyd2lzZSB3ZSBtaWdodCBkcm9wXG4vLyB1cGRhdGVzIHdpdGhvdXQgZXZlciBwcm9jZXNzaW5nIHRoZW0uIEZvciBleGFtcGxlLCBpZiB3ZSBvbmx5IGFkZCB1cGRhdGVzIHRvXG4vLyB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgc29tZSB1cGRhdGVzIGNvdWxkIGJlIGxvc3Qgd2hlbmV2ZXIgYSB3b3JrLWluXG4vLyAtcHJvZ3Jlc3MgcmVuZGVyIHJlc3RhcnRzIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LiBTaW1pbGFybHksIGlmIHdlIG9ubHkgYWRkXG4vLyB1cGRhdGVzIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCB0aGUgdXBkYXRlcyB3aWxsIGJlIGxvc3Qgd2hlbmV2ZXIgYW4gYWxyZWFkeVxuLy8gaW4tcHJvZ3Jlc3MgcXVldWUgY29tbWl0cyBhbmQgc3dhcHMgd2l0aCB0aGUgY3VycmVudCBxdWV1ZS4gSG93ZXZlciwgYnlcbi8vIGFkZGluZyB0byBib3RoIHF1ZXVlcywgd2UgZ3VhcmFudGVlIHRoYXQgdGhlIHVwZGF0ZSB3aWxsIGJlIHBhcnQgb2YgdGhlIG5leHRcbi8vIHdvcmstaW4tcHJvZ3Jlc3MuIChBbmQgYmVjYXVzZSB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBiZWNvbWVzIHRoZVxuLy8gY3VycmVudCBxdWV1ZSBvbmNlIGl0IGNvbW1pdHMsIHRoZXJlJ3Mgbm8gZGFuZ2VyIG9mIGFwcGx5aW5nIHRoZSBzYW1lXG4vLyB1cGRhdGUgdHdpY2UuKVxuLy9cbi8vIFByaW9yaXRpemF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLVxuLy9cbi8vIFVwZGF0ZXMgYXJlIG5vdCBzb3J0ZWQgYnkgcHJpb3JpdHksIGJ1dCBieSBpbnNlcnRpb247IG5ldyB1cGRhdGVzIGFyZSBhbHdheXNcbi8vIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4vL1xuLy8gVGhlIHByaW9yaXR5IGlzIHN0aWxsIGltcG9ydGFudCwgdGhvdWdoLiBXaGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZVxuLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIG9ubHkgdGhlIHVwZGF0ZXMgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5IGFyZVxuLy8gaW5jbHVkZWQgaW4gdGhlIHJlc3VsdC4gSWYgd2Ugc2tpcCBhbiB1cGRhdGUgYmVjYXVzZSBpdCBoYXMgaW5zdWZmaWNpZW50XG4vLyBwcmlvcml0eSwgaXQgcmVtYWlucyBpbiB0aGUgcXVldWUgdG8gYmUgcHJvY2Vzc2VkIGxhdGVyLCBkdXJpbmcgYSBsb3dlclxuLy8gcHJpb3JpdHkgcmVuZGVyLiBDcnVjaWFsbHksIGFsbCB1cGRhdGVzIHN1YnNlcXVlbnQgdG8gYSBza2lwcGVkIHVwZGF0ZSBhbHNvXG4vLyByZW1haW4gaW4gdGhlIHF1ZXVlICpyZWdhcmRsZXNzIG9mIHRoZWlyIHByaW9yaXR5Ki4gVGhhdCBtZWFucyBoaWdoIHByaW9yaXR5XG4vLyB1cGRhdGVzIGFyZSBzb21ldGltZXMgcHJvY2Vzc2VkIHR3aWNlLCBhdCB0d28gc2VwYXJhdGUgcHJpb3JpdGllcy4gV2UgYWxzb1xuLy8ga2VlcCB0cmFjayBvZiBhIGJhc2Ugc3RhdGUsIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgYmVmb3JlIHRoZSBmaXJzdFxuLy8gdXBkYXRlIGluIHRoZSBxdWV1ZSBpcyBhcHBsaWVkLlxuLy9cbi8vIEZvciBleGFtcGxlOlxuLy9cbi8vICAgR2l2ZW4gYSBiYXNlIHN0YXRlIG9mICcnLCBhbmQgdGhlIGZvbGxvd2luZyBxdWV1ZSBvZiB1cGRhdGVzXG4vL1xuLy8gICAgIEExIC0gQjIgLSBDMSAtIEQyXG4vL1xuLy8gICB3aGVyZSB0aGUgbnVtYmVyIGluZGljYXRlcyB0aGUgcHJpb3JpdHksIGFuZCB0aGUgdXBkYXRlIGlzIGFwcGxpZWQgdG8gdGhlXG4vLyAgIHByZXZpb3VzIHN0YXRlIGJ5IGFwcGVuZGluZyBhIGxldHRlciwgUmVhY3Qgd2lsbCBwcm9jZXNzIHRoZXNlIHVwZGF0ZXMgYXNcbi8vICAgdHdvIHNlcGFyYXRlIHJlbmRlcnMsIG9uZSBwZXIgZGlzdGluY3QgcHJpb3JpdHkgbGV2ZWw6XG4vL1xuLy8gICBGaXJzdCByZW5kZXIsIGF0IHByaW9yaXR5IDE6XG4vLyAgICAgQmFzZSBzdGF0ZTogJydcbi8vICAgICBVcGRhdGVzOiBbQTEsIEMxXVxuLy8gICAgIFJlc3VsdCBzdGF0ZTogJ0FDJ1xuLy9cbi8vICAgU2Vjb25kIHJlbmRlciwgYXQgcHJpb3JpdHkgMjpcbi8vICAgICBCYXNlIHN0YXRlOiAnQScgICAgICAgICAgICA8LSAgVGhlIGJhc2Ugc3RhdGUgZG9lcyBub3QgaW5jbHVkZSBDMSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVjYXVzZSBCMiB3YXMgc2tpcHBlZC5cbi8vICAgICBVcGRhdGVzOiBbQjIsIEMxLCBEMl0gICAgICA8LSAgQzEgd2FzIHJlYmFzZWQgb24gdG9wIG9mIEIyXG4vLyAgICAgUmVzdWx0IHN0YXRlOiAnQUJDRCdcbi8vXG4vLyBCZWNhdXNlIHdlIHByb2Nlc3MgdXBkYXRlcyBpbiBpbnNlcnRpb24gb3JkZXIsIGFuZCByZWJhc2UgaGlnaCBwcmlvcml0eVxuLy8gdXBkYXRlcyB3aGVuIHByZWNlZGluZyB1cGRhdGVzIGFyZSBza2lwcGVkLCB0aGUgZmluYWwgcmVzdWx0IGlzIGRldGVybWluaXN0aWNcbi8vIHJlZ2FyZGxlc3Mgb2YgcHJpb3JpdHkuIEludGVybWVkaWF0ZSBzdGF0ZSBtYXkgdmFyeSBhY2NvcmRpbmcgdG8gc3lzdGVtXG4vLyByZXNvdXJjZXMsIGJ1dCB0aGUgZmluYWwgc3RhdGUgaXMgYWx3YXlzIHRoZSBzYW1lLlxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzO1xuXG4vLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxudmFyIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdm9pZCAwO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbnZhciByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbntcbiAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xuICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGVRdWV1ZShiYXNlU3RhdGUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZmlyc3RVcGRhdGU6IG51bGwsXG4gICAgbGFzdFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuICAgIGxhc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIGZpcnN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkRWZmZWN0OiBudWxsXG4gIH07XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50UXVldWUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGV4cGlyYXRpb25UaW1lOiBjdXJyZW50UXVldWUuZXhwaXJhdGlvblRpbWUsXG4gICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgIGZpcnN0VXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RVcGRhdGUsXG4gICAgbGFzdFVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RVcGRhdGUsXG5cbiAgICAvLyBUT0RPOiBXaXRoIHJlc3VtaW5nLCBpZiB3ZSBiYWlsIG91dCBhbmQgcmVzdXNlIHRoZSBjaGlsZCB0cmVlLCB3ZSBzaG91bGRcbiAgICAvLyBrZWVwIHRoZXNlIGVmZmVjdHMuXG4gICAgZmlyc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG5cbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuXG4gICAgZmlyc3RDYXB0dXJlZEVmZmVjdDogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRFZmZlY3Q6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG5cbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG5cbiAgICBuZXh0OiBudWxsLFxuICAgIG5leHRFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZSwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3RVcGRhdGUgPSBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGUgaW5jb21pbmcgdXBkYXRlIGhhcyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiBvZiBhbnkgdXBkYXRlIGluIHRoZVxuICAgIC8vIHF1ZXVlLiBVcGRhdGUgdGhlIHF1ZXVlJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBVcGRhdGUgcXVldWVzIGFyZSBjcmVhdGVkIGxhemlseS5cbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IHZvaWQgMDtcbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgb25seSBvbmUgZmliZXIuXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKGZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBhcmUgdHdvIG93bmVycy5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBOZWl0aGVyIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENyZWF0ZSBuZXcgb25lcy5cbiAgICAgICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShmaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgcXVldWUyID0gYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT25seSBvbmUgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ2xvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gT25seSBvbmUgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ2xvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcXVldWUyID0gYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gY2xvbmVVcGRhdGVRdWV1ZShxdWV1ZTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQm90aCBvd25lcnMgaGF2ZSBhbiB1cGRhdGUgcXVldWUuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChxdWV1ZTIgPT09IG51bGwgfHwgcXVldWUxID09PSBxdWV1ZTIpIHtcbiAgICAvLyBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgcXVldWUuXG4gICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSwgZXhwaXJhdGlvblRpbWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gcXVldWVzLiBXZSBuZWVkIHRvIGFwcGVuZCB0aGUgdXBkYXRlIHRvIGJvdGggcXVldWVzLFxuICAgIC8vIHdoaWxlIGFjY291bnRpbmcgZm9yIHRoZSBwZXJzaXN0ZW50IHN0cnVjdHVyZSBvZiB0aGUgbGlzdCDigJQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRoZSBzYW1lIHVwZGF0ZSB0byBiZSBhZGRlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICBpZiAocXVldWUxLmxhc3RVcGRhdGUgPT09IG51bGwgfHwgcXVldWUyLmxhc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIE9uZSBvZiB0aGUgcXVldWVzIGlzIG5vdCBlbXB0eS4gV2UgbXVzdCBhZGQgdGhlIHVwZGF0ZSB0byBib3RoIHF1ZXVlcy5cbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUyLCB1cGRhdGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBxdWV1ZXMgYXJlIG5vbi1lbXB0eS4gVGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGluIGJvdGggbGlzdHMsXG4gICAgICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIG9ubHkgYXBwZW5kIHRvIG9uZSBvZiB0aGUgbGlzdHMuXG4gICAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMSwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0VXBkYXRlYCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgICAgIHF1ZXVlMi5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiAoY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSBxdWV1ZTEgfHwgcXVldWUyICE9PSBudWxsICYmIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gcXVldWUyKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBnbyBpbnRvIGEgc2VwYXJhdGUgbGlzdCwgYW5kIG9ubHkgb24gdGhlIHdvcmstaW4tXG4gIC8vIHByb2dyZXNzIHF1ZXVlLlxuICB2YXIgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAod29ya0luUHJvZ3Jlc3NRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE86IEkgcHV0IHRoaXMgaGVyZSByYXRoZXIgdGhhbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyBzbyB0aGF0IHdlIGRvbid0XG4gICAgLy8gY2xvbmUgdGhlIHF1ZXVlIHVubmVjZXNzYXJpbHkuIFRoZXJlJ3MgcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvXG4gICAgLy8gc3RydWN0dXJlIHRoaXMuXG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IGVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3NRdWV1ZSk7XG4gIH1cblxuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAod29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgcGhhc2UgdXBkYXRlXG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlID0gd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IHVwZGF0ZTtcbiAgfVxuICBpZiAod29ya0luUHJvZ3Jlc3NRdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzUXVldWUuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZSBpbmNvbWluZyB1cGRhdGUgaGFzIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIG9mIGFueSB1cGRhdGUgaW4gdGhlXG4gICAgLy8gcXVldWUuIFVwZGF0ZSB0aGUgcXVldWUncyBleHBpcmF0aW9uIHRpbWUuXG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUpIHtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgcXVldWUsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9uZSBpdCBmaXJzdC5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnQudXBkYXRlUXVldWUpIHtcbiAgICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGF0ZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIF9wYXlsb2FkO1xuICAgICAgfVxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkMiA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkMiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYXJ0aWFsIHN0YXRlIG9iamVjdFxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgIHJldHVybiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAocXVldWUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBxdWV1ZS5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gSW5zdWZmaWNpZW50IHByaW9yaXR5LiBCYWlsb3V0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHF1ZXVlID0gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCBxdWV1ZSk7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlO1xuICB9XG5cbiAgLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG4gIHZhciBuZXdCYXNlU3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIHZhciBuZXdGaXJzdFVwZGF0ZSA9IG51bGw7XG4gIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdFVwZGF0ZTtcbiAgdmFyIHJlc3VsdFN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgc2tpcHBlZCB1cGRhdGUuIEl0IHdpbGwgYmUgdGhlIGZpcnN0IHVwZGF0ZSBpblxuICAgICAgICAvLyB0aGUgbmV3IGxpc3QuXG4gICAgICAgIG5ld0ZpcnN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0XG4gICAgICAgIC8vIGlzIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSB0aGlzIHVwZGF0ZSB3aWxsIHJlbWFpbiBpbiB0aGUgbGlzdCwgdXBkYXRlIHRoZSByZW1haW5pbmdcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFByb2Nlc3MgaXQgYW5kIGNvbXB1dGVcbiAgICAgIC8vIGEgbmV3IHJlc3VsdC5cbiAgICAgIHJlc3VsdFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCByZXN1bHRTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZS5maXJzdEVmZmVjdCA9IHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgLy8gU2VwYXJhdGVseSwgaXRlcmF0ZSB0aG91Z2ggdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgdmFyIG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB1cGRhdGUgPSBxdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIF91cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAoX3VwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIGlmIChuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHNraXBwZWQgY2FwdHVyZWQgdXBkYXRlLiBJdCB3aWxsIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIG5ldyBsaXN0LlxuICAgICAgICBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0IGlzXG4gICAgICAgIC8vIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHRoaXMgdXBkYXRlIHdpbGwgcmVtYWluIGluIHRoZSBsaXN0LCB1cGRhdGUgdGhlIHJlbWFpbmluZ1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBfdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBfdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBQcm9jZXNzIGl0IGFuZCBjb21wdXRlXG4gICAgICAvLyBhIG5ldyByZXN1bHQuXG4gICAgICByZXN1bHRTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcmVzdWx0U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICB2YXIgX2NhbGxiYWNrMiA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAgIGlmIChfY2FsbGJhY2syICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHF1ZXVlLmZpcnN0Q2FwdHVyZWRFZmZlY3QgPSBxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0Lm5leHRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUubGFzdFVwZGF0ZSA9IG51bGw7XG4gIH1cbiAgaWYgKG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfVxuICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwgJiYgbmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHByb2Nlc3NlZCBldmVyeSB1cGRhdGUsIHdpdGhvdXQgc2tpcHBpbmcuIFRoYXQgbWVhbnMgdGhlIG5ldyBiYXNlXG4gICAgLy8gc3RhdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHJlc3VsdCBzdGF0ZS5cbiAgICBuZXdCYXNlU3RhdGUgPSByZXN1bHRTdGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgcXVldWUuZmlyc3RVcGRhdGUgPSBuZXdGaXJzdFVwZGF0ZTtcbiAgcXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSA9IG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGU7XG4gIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgZmluaXNoZWRRdWV1ZSwgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIElmIHRoZSBmaW5pc2hlZCByZW5kZXIgaW5jbHVkZWQgY2FwdHVyZWQgdXBkYXRlcywgYW5kIHRoZXJlIGFyZSBzdGlsbFxuICAvLyBsb3dlciBwcmlvcml0eSB1cGRhdGVzIGxlZnQgb3Zlciwgd2UgbmVlZCB0byBrZWVwIHRoZSBjYXB0dXJlZCB1cGRhdGVzXG4gIC8vIGluIHRoZSBxdWV1ZSBzbyB0aGF0IHRoZXkgYXJlIHJlYmFzZWQgYW5kIG5vdCBkcm9wcGVkIG9uY2Ugd2UgcHJvY2VzcyB0aGVcbiAgLy8gcXVldWUgYWdhaW4gYXQgdGhlIGxvd2VyIHByaW9yaXR5LlxuICBpZiAoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSm9pbiB0aGUgY2FwdHVyZWQgdXBkYXRlIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgbm9ybWFsIGxpc3QuXG4gICAgaWYgKGZpbmlzaGVkUXVldWUubGFzdFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRRdWV1ZS5sYXN0VXBkYXRlLm5leHQgPSBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGU7XG4gICAgICBmaW5pc2hlZFF1ZXVlLmxhc3RVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgICBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgdmFyIGVmZmVjdCA9IGZpbmlzaGVkUXVldWUuZmlyc3RFZmZlY3Q7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFF1ZXVlLmxhc3RFZmZlY3QgPSBudWxsO1xuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9jYWxsYmFjazMgPSBlZmZlY3QuY2FsbGJhY2s7XG4gICAgaWYgKF9jYWxsYmFjazMgIT09IG51bGwpIHtcbiAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjYWxsQ2FsbGJhY2soX2NhbGxiYWNrMywgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIGVmZmVjdCA9IGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdDtcbiAgZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkRWZmZWN0ID0gZmluaXNoZWRRdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPSBudWxsO1xuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9jYWxsYmFjazQgPSBlZmZlY3QuY2FsbGJhY2s7XG4gICAgaWYgKF9jYWxsYmFjazQgIT09IG51bGwpIHtcbiAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjYWxsQ2FsbGJhY2soX2NhbGxiYWNrNCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoc291cmNlKVxuICB9O1xufVxuXG52YXIgcHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgY2hhbmdlZEJpdHNDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCk7XG5cbnZhciByZW5kZXJlclNpZ2lsID0gdm9pZCAwO1xue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcblxuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBwdXNoKGNoYW5nZWRCaXRzQ3Vyc29yLCBjb250ZXh0Ll9jaGFuZ2VkQml0cywgcHJvdmlkZXJGaWJlcik7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHByb3ZpZGVyQ3Vyc29yLCBwcm92aWRlckZpYmVyLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByb3ZpZGVyRmliZXIucGVuZGluZ1Byb3BzLnZhbHVlO1xuICAgIGNvbnRleHQuX2NoYW5nZWRCaXRzID0gcHJvdmlkZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAge1xuICAgICAgIShjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IHVuZGVmaW5lZCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IG51bGwgfHwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSByZW5kZXJlclNpZ2lsKSA/IHdhcm5pbmcoZmFsc2UsICdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaChjaGFuZ2VkQml0c0N1cnNvciwgY29udGV4dC5fY2hhbmdlZEJpdHMyLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHByb3ZpZGVyQ3Vyc29yLCBwcm92aWRlckZpYmVyLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBwcm92aWRlckZpYmVyLnBlbmRpbmdQcm9wcy52YWx1ZTtcbiAgICBjb250ZXh0Ll9jaGFuZ2VkQml0czIgPSBwcm92aWRlckZpYmVyLnN0YXRlTm9kZTtcbiAgICB7XG4gICAgICAhKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IHVuZGVmaW5lZCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID09PSBudWxsIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IHJlbmRlcmVyU2lnaWwpID8gd2FybmluZyhmYWxzZSwgJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY2hhbmdlZEJpdHMgPSBjaGFuZ2VkQml0c0N1cnNvci5jdXJyZW50O1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcblxuICBwb3AocHJvdmlkZXJDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICBwb3AoY2hhbmdlZEJpdHNDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuXG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgY29udGV4dC5fY2hhbmdlZEJpdHMgPSBjaGFuZ2VkQml0cztcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuICAgIGNvbnRleHQuX2NoYW5nZWRCaXRzMiA9IGNoYW5nZWRCaXRzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRDdXJyZW50VmFsdWUoY29udGV4dCkge1xuICByZXR1cm4gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Q2hhbmdlZEJpdHMoY29udGV4dCkge1xuICByZXR1cm4gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jaGFuZ2VkQml0cyA6IGNvbnRleHQuX2NoYW5nZWRCaXRzMjtcbn1cblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAhKGMgIT09IE5PX0NPTlRFWFQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuXG4gIC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSwgcm9vdEluc3RhbmNlKTtcblxuICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIGNvbW1pdFRpbWUgPSAwO1xuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbW1pdFRpbWUgPSBub3coKTtcbn1cblxuLyoqXG4gKiBUaGUgXCJhY3R1YWxcIiByZW5kZXIgdGltZSBpcyB0b3RhbCB0aW1lIHJlcXVpcmVkIHRvIHJlbmRlciB0aGUgZGVzY2VuZGFudHMgb2YgYSBQcm9maWxlciBjb21wb25lbnQuXG4gKiBUaGlzIHRpbWUgaXMgc3RvcmVkIGFzIGEgc3RhY2ssIHNpbmNlIFByb2ZpbGVycyBjYW4gYmUgbmVzdGVkLlxuICogVGhpcyB0aW1lIGlzIHN0YXJ0ZWQgZHVyaW5nIHRoZSBcImJlZ2luXCIgcGhhc2UgYW5kIHN0b3BwZWQgZHVyaW5nIHRoZSBcImNvbXBsZXRlXCIgcGhhc2UuXG4gKiBJdCBpcyBwYXVzZWQgKGFuZCBhY2N1bXVsYXRlZCkgaW4gdGhlIGV2ZW50IG9mIGFuIGludGVycnVwdGlvbiBvciBhbiBhYm9ydGVkIHJlbmRlci5cbiAqL1xuXG52YXIgZmliZXJTdGFjayQxID0gdm9pZCAwO1xuXG57XG4gIGZpYmVyU3RhY2skMSA9IFtdO1xufVxuXG52YXIgdGltZXJQYXVzZWRBdCA9IDA7XG52YXIgdG90YWxFbGFwc2VkUGF1c2VUaW1lID0gMDtcblxuZnVuY3Rpb24gY2hlY2tBY3R1YWxSZW5kZXJUaW1lU3RhY2tFbXB0eSgpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICAhKGZpYmVyU3RhY2skMS5sZW5ndGggPT09IDApID8gd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGFuIGVtcHR5IHN0YWNrLiBTb21ldGhpbmcgd2FzIG5vdCByZXNldCBwcm9wZXJseS4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQWN0dWFsUmVuZGVyVGltZVN0YXJ0ZWQoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICBmaWJlclN0YWNrJDEucHVzaChmaWJlcik7XG4gIH1cblxuICBmaWJlci5hY3R1YWxEdXJhdGlvbiA9IG5vdygpIC0gZmliZXIuYWN0dWFsRHVyYXRpb24gLSB0b3RhbEVsYXBzZWRQYXVzZVRpbWU7XG4gIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdygpO1xufVxuXG5mdW5jdGlvbiBwYXVzZUFjdHVhbFJlbmRlclRpbWVySWZSdW5uaW5nKCkge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRpbWVyUGF1c2VkQXQgPT09IDApIHtcbiAgICB0aW1lclBhdXNlZEF0ID0gbm93KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkRWxhcHNlZEFjdHVhbFJlbmRlclRpbWUoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICAhKGZpYmVyID09PSBmaWJlclN0YWNrJDEucG9wKCkpID8gd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgKCVzKSBwb3BwZWQuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikpIDogdm9pZCAwO1xuICB9XG5cbiAgZmliZXIuYWN0dWFsRHVyYXRpb24gPSBub3coKSAtIHRvdGFsRWxhcHNlZFBhdXNlVGltZSAtIGZpYmVyLmFjdHVhbER1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiByZXNldEFjdHVhbFJlbmRlclRpbWVyKCkge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdG90YWxFbGFwc2VkUGF1c2VUaW1lID0gMDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQWN0dWFsUmVuZGVyVGltZXJJZlBhdXNlZCgpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aW1lclBhdXNlZEF0ID4gMCkge1xuICAgIHRvdGFsRWxhcHNlZFBhdXNlVGltZSArPSBub3coKSAtIHRpbWVyUGF1c2VkQXQ7XG4gICAgdGltZXJQYXVzZWRBdCA9IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJiYXNlXCIgcmVuZGVyIHRpbWUgaXMgdGhlIGR1cmF0aW9uIG9mIHRoZSDigJxiZWdpbuKAnSBwaGFzZSBvZiB3b3JrIGZvciBhIHBhcnRpY3VsYXIgZmliZXIuXG4gKiBUaGlzIHRpbWUgaXMgbWVhc3VyZWQgYW5kIHN0b3JlZCBvbiBlYWNoIGZpYmVyLlxuICogVGhlIHRpbWUgZm9yIGFsbCBzaWJsaW5nIGZpYmVycyBhcmUgYWNjdW11bGF0ZWQgYW5kIHN0b3JlZCBvbiB0aGVpciBwYXJlbnQgZHVyaW5nIHRoZSBcImNvbXBsZXRlXCIgcGhhc2UuXG4gKiBJZiBhIGZpYmVyIGJhaWxzIG91dCAoc0NVIGZhbHNlKSB0aGVuIGl0cyBcImJhc2VcIiB0aW1lciBpcyBjYW5jZWxsZWQgYW5kIHRoZSBmaWJlciBpcyBub3QgdXBkYXRlZC5cbiAqL1xuXG52YXIgYmFzZVN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiByZWNvcmRFbGFwc2VkQmFzZVJlbmRlclRpbWVJZlJ1bm5pbmcoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChiYXNlU3RhcnRUaW1lICE9PSAtMSkge1xuICAgIGZpYmVyLnNlbGZCYXNlVGltZSA9IG5vdygpIC0gYmFzZVN0YXJ0VGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydEJhc2VSZW5kZXJUaW1lcigpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICBpZiAoYmFzZVN0YXJ0VGltZSAhPT0gLTEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3Qgc3RhcnQgYmFzZSB0aW1lciB0aGF0IGlzIGFscmVhZHkgcnVubmluZy4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG4gIGJhc2VTdGFydFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gc3RvcEJhc2VSZW5kZXJUaW1lcklmUnVubmluZygpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VTdGFydFRpbWUgPSAtMTtcbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuXG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzblxcJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUod29ya0luUHJvZ3Jlc3MsIHBhcnRpYWxTdGF0ZSk7XG4gIH1cbiAgLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuXG4gIC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIHNjaGVkdWxlV29yayQxKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgc2NoZWR1bGVXb3JrJDEoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKTtcblxuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIHNjaGVkdWxlV29yayQxKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIHtcbiAgICAgICEoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQpID8gd2FybmluZyhmYWxzZSwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAhbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA/IHdhcm5pbmcoZmFsc2UsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vR2V0RGVmYXVsdFByb3BzT25FUzYgPSAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICAhbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA/IHdhcm5pbmcoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgIW5vSW5zdGFuY2VQcm9wVHlwZXMgPyB3YXJuaW5nKGZhbHNlLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICFub0luc3RhbmNlQ29udGV4dFR5cGVzID8gd2FybmluZyhmYWxzZSwgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9Db21wb25lbnREaWRVbm1vdW50ID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9VbnNhZmVDb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICFub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICEoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzKSA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICFub0luc3RhbmNlRGVmYXVsdFByb3BzID8gd2FybmluZyhmYWxzZSwgJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKHR5cGUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKHR5cGUpO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cblxuICAgIHZhciBub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA/IHdhcm5pbmcoZmFsc2UsICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09ICdmdW5jdGlvbic7XG4gICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCgpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPSB0eXBlb2YgdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA/IHdhcm5pbmcoZmFsc2UsICclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBfc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoX3N0YXRlICYmICh0eXBlb2YgX3N0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KF9zdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAhKHR5cGVvZiB0eXBlLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyB3YXJuaW5nKGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAge1xuICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIG5lZWRzQ29udGV4dCA9IGlzQ29udGV4dENvbnN1bWVyKHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlPYmplY3Q7XG5cbiAgLy8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICB7XG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBEaWQgbm90IHByb3Blcmx5IGluaXRpYWxpemUgc3RhdGUgZHVyaW5nIGNvbnN0cnVjdGlvbi4gJyArICdFeHBlY3RlZCBzdGF0ZSB0byBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXMgJXMuJywgY29tcG9uZW50TmFtZSwgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbiAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgc3RvcFBoYXNlVGltZXIoKTtcblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICB9XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmREZXByZWNhdGlvbldhcm5pbmdzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcm9wcyk7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG5cbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblxuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcblxuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuXG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fCBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0gdm9pZCAwO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHZvaWQgMDtcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB2b2lkIDA7XG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0ge307XG5cbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ3KCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBzdHJpbmcgcmVmLCBcIiVzXCIswqBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIGNyZWF0ZVJlZigpIGluc3RlYWQuJyArICdcXG4lcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYsIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIocmV0dXJuRmliZXIpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgICEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiB2b2lkIDA7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgICFpbnN0ID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiAlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwgJiYgdHlwZW9mIGN1cnJlbnQucmVmID09PSAnZnVuY3Rpb24nICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcXG4yLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIHJlbmRlciBtZXRob2RcXG4zLiBZb3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkXFxuU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ3KCkgfHwgJycpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKGZhbHNlLCAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcoKSB8fCAnJyk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAge1xuICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4lcycsIGtleSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ3KCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNygpKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSA/IGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufVxuXG4vLyBUaGUgZGVlcGVzdCBGaWJlciBvbiB0aGUgc3RhY2sgaW52b2x2ZWQgaW4gYSBoeWRyYXRpb24gY29udGV4dC5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAvLyB0aGVzZSBjaGlsZHJlbiBhcmUgbm90IHBhcnQgb2YgdGhlIHJlY29uY2lsaWF0aW9uIGxpc3Qgb2YgY2hpbGRyZW4uXG4gIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAvLyByZWNyZWF0ZWQuXG4gIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gIGZpYmVyLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIF9wcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IHRleHRJbnN0YW5jZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UgPSBuZXh0SW5zdGFuY2U7XG4gIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgIC8vIFdlIHVzZSB0aGlzIGFzIGEgaGV1cmlzdGljLiBJdCdzIGJhc2VkIG9uIGludHVpdGlvbiBhbmQgbm90IGRhdGEgc28gaXRcbiAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcbiAgfVxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyKTtcbiAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICB7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgIHZhciByZXR1cm5GaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIC8vIElmIHdlJ3JlIG5vdCBjdXJyZW50bHkgaHlkcmF0aW5nIGJ1dCB3ZSdyZSBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LCB0aGVuXG4gICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAvLyBzaWJsaW5ncy5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAvLyBzaWRlIG9mIHRoZW0uXG4gIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG4gIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gIGlzSHlkcmF0aW5nID0gZmFsc2U7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxudmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRTdGF0ZWxlc3NSZWZzID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG4gIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbi8vIFRPRE86IFJlbW92ZSB0aGlzIGFuZCB1c2UgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGRpcmVjdGx5LlxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbikge1xuICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJlbmRlciA9IHdvcmtJblByb2dyZXNzLnR5cGUucmVuZGVyO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgdmFyIGN1cnJlbnRSZWYgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5yZWYgOiBudWxsO1xuICAgIGlmIChyZWYgPT09IGN1cnJlbnRSZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXIobmV4dFByb3BzLCByZWYpO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG5cbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiByZWYgIT09IG51bGwgfHwgY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gcmVmKSB7XG4gICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogY29uc2lkZXIgYnJpbmdpbmcgZm4uc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkgYmFjay5cbiAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gIH1cblxuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgbmV4dENoaWxkcmVuID0gZm4obmV4dFByb3BzLCBjb250ZXh0KTtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IHZvaWQgMDtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpICE9PSBOb0VmZmVjdDtcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAvLyBSZXJlbmRlclxuICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgKCFlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nKSkge1xuICAgIC8vIElmIHdlIGNhcHR1cmVkIGFuIGVycm9yLCBidXQgZ2V0RGVyaXZlZFN0YXRlRnJvbSBjYXRjaCBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICBzdG9wQmFzZVJlbmRlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgaWYgKGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHR3aWNlOiBmaXJzdCB0byBkZWxldGVcbiAgICAvLyBhbGwgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLlxuICAgIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAvLyBOb3cgd2UgY2FuIGNvbnRpbnVlIHJlY29uY2lsaW5nIGxpa2Ugbm9ybWFsLiBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mXG4gICAgLy8gcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyIHRoZWlyXG4gICAgLy8gaWRlbnRpdHkgbWF0Y2hlcy5cbiAgfVxuICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG4gIGlmIChoYXNDb250ZXh0KSB7XG4gICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuZWxlbWVudCA6IG51bGw7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV4dFByb3BzLCBudWxsLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAgIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgIC8vIG5vIHdvcmsgdGhhdCBleHBpcmVzIGF0IHRoaXMgdGltZS5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAvLyBub3QgaHlkcmF0aW5nLlxuXG4gICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgIC8vIHdvcmtzIGFzIGV4cGVjdGVkLiBXZSBtdXN0IHJlc2V0IHRoaXMgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgY2hpbGRyZW4gbW91bnQgaW50byB0aGlzIHJvb3Qgd2l0aG91dCB0cmFja2luZ1xuICAgICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgICAgLy8gcm9vdC5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbiAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAvLyBJZiB0aGVyZSBpcyBubyB1cGRhdGUgcXVldWUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB0aGUgcm9vdCBoYXMgbm8gcHJvcHMuXG4gIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICB9IGVsc2UgaWYgKG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgIHZhciBpc0hpZGRlbiA9IHdvcmtJblByb2dyZXNzLm1vZGUgJiBBc3luY01vZGUgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpO1xuICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgLy8gQmVmb3JlIGJhaWxpbmcgb3V0LCBtYWtlIHN1cmUgd2UndmUgZGVwcmlvcml0aXplZCBhIGhpZGRlbiBjb21wb25lbnQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgIH1cbiAgICBpZiAoIWlzSGlkZGVuIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlcikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSByZW5kZXJpbmcgYSBoaWRkZW4gbm9kZSBhdCBoaWRkZW4gcHJpb3JpdHksIGRvbid0IGJhaWxvdXQuIFRoZVxuICAgIC8vIHBhcmVudCBpcyBjb21wbGV0ZSwgYnV0IHRoZSBjaGlsZHJlbiBtYXkgbm90IGJlLlxuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICBpZiAocmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBBc3luY01vZGUgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAhKGN1cnJlbnQgPT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIGhhdmUgbW91bnRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICB7XG4gICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFsdWUgPSBmbihwcm9wcywgY29udGV4dCk7XG4gIH1cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuXG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICB7XG4gICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgIGlmIChfQ29tcG9uZW50KSB7XG4gICAgICAgICEhX0NvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIF9Db21wb25lbnQuZGlzcGxheU5hbWUgfHwgX0NvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiVzJXMnLCBpbmZvLCBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclczogU3RhdGVsZXNzIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBwcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVvdXRDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHByZXZQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG5cbiAgICB2YXIgcHJldkRpZFRpbWVvdXQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmVuZGVyIHRoZSBub3JtYWwgc3RhdGUuIElmIHdlIGRpZCxcbiAgICAvLyBhbmQgd2UgdGltZWQgb3V0LCByZW5kZXIgdGhlIHBsYWNlaG9sZGVyIHN0YXRlLlxuICAgIHZhciBhbHJlYWR5Q2FwdHVyZWQgPSAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkgPT09IE5vRWZmZWN0O1xuICAgIHZhciBuZXh0RGlkVGltZW91dCA9ICFhbHJlYWR5Q2FwdHVyZWQ7XG5cbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzID09PSBwcmV2UHJvcHMgJiYgbmV4dERpZFRpbWVvdXQgPT09IHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlciA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gcmVuZGVyKG5leHREaWRUaW1lb3V0KTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0RGlkVGltZW91dDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgIGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7XG4gICAgLy8gVmlzaXQgdGhpcyBmaWJlci5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBmaWJlci5zdGF0ZU5vZGUgfCAwO1xuICAgICAgICBpZiAoZmliZXIudHlwZSA9PT0gY29udGV4dCAmJiAob2JzZXJ2ZWRCaXRzICYgY2hhbmdlZEJpdHMpICE9PSAwKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBleHBpcmF0aW9uIHRpbWUgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZ1xuICAgICAgICAgIC8vIHRoZSBhbHRlcm5hdGVzLlxuICAgICAgICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICAgIG5vZGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAoYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIChhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOZWl0aGVyIGFsdGVybmF0ZSB3YXMgdXBkYXRlZCwgd2hpY2ggbWVhbnMgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAgIC8vIGFuY2VzdG9yIHBhdGggYWxyZWFkeSBoYXMgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIHRoYW4gYSBtYXRjaGluZyBjb25zdW1lci4gV2hlbiB3ZSByZW5kZXIgdGhlXG4gICAgICAgICAgLy8gY29uc3VtZXIsIHdlJ2xsIGNvbnRpbnVlIHNjYW5uaW5nIGZyb20gdGhhdCBwb2ludC4gVGhpcyB3YXkgdGhlXG4gICAgICAgICAgLy8gc2Nhbm5pbmcgd29yayBpcyB0aW1lLXNsaWNlZC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICAgIG5leHRGaWJlciA9IGZpYmVyLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLnR5cGUgPyBudWxsIDogZmliZXIuY2hpbGQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVHJhdmVyc2UgZG93bi5cbiAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBjYW5CYWlsT25Qcm9wcyA9IHRydWU7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICBjYW5CYWlsT25Qcm9wcyA9IGZhbHNlO1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gMDtcbiAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cbiAge1xuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFuZ2VkQml0cyA9IHZvaWQgMDtcbiAgaWYgKG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCByZW5kZXJcbiAgICBjaGFuZ2VkQml0cyA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2xkUHJvcHMudmFsdWUgPT09IG5ld1Byb3BzLnZhbHVlKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiBjYW5CYWlsT25Qcm9wcykge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSAwO1xuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuICAgICAgLy8gVXNlIE9iamVjdC5pcyB0byBjb21wYXJlIHRoZSBuZXcgY29udGV4dCB2YWx1ZSB0byB0aGUgb2xkIHZhbHVlLlxuICAgICAgLy8gSW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwuXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUgJiYgKG9sZFZhbHVlICE9PSAwIHx8IDEgLyBvbGRWYWx1ZSA9PT0gMSAvIG5ld1ZhbHVlKSB8fCBvbGRWYWx1ZSAhPT0gb2xkVmFsdWUgJiYgbmV3VmFsdWUgIT09IG5ld1ZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICApIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgY2FuQmFpbE9uUHJvcHMpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgICAgICAge1xuICAgICAgICAgICEoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMpID8gd2FybmluZyhmYWxzZSwgJ2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBFeHBlY3RlZCB0aGUgcmV0dXJuIHZhbHVlIHRvIGJlIGEgJyArICczMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlZEJpdHMgfD0gMDtcblxuICAgICAgICBpZiAoY2hhbmdlZEJpdHMgPT09IDApIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgY2FuQmFpbE9uUHJvcHMpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY2hhbmdlZEJpdHM7XG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbik7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICB2YXIgbmV3VmFsdWUgPSBnZXRDb250ZXh0Q3VycmVudFZhbHVlKGNvbnRleHQpO1xuICB2YXIgY2hhbmdlZEJpdHMgPSBnZXRDb250ZXh0Q2hhbmdlZEJpdHMoY29udGV4dCk7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICB9IGVsc2UgaWYgKGNoYW5nZWRCaXRzID09PSAwICYmIG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cbiAgdmFyIG9ic2VydmVkQml0cyA9IG5ld1Byb3BzLnVuc3RhYmxlX29ic2VydmVkQml0cztcbiAgaWYgKG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCkge1xuICAgIC8vIFN1YnNjcmliZSB0byBhbGwgY2hhbmdlcyBieSBkZWZhdWx0XG4gICAgb2JzZXJ2ZWRCaXRzID0gTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuICB9XG4gIC8vIFN0b3JlIHRoZSBvYnNlcnZlZEJpdHMgb24gdGhlIGZpYmVyJ3Mgc3RhdGVOb2RlIGZvciBxdWljayBhY2Nlc3MuXG4gIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG9ic2VydmVkQml0cztcblxuICBpZiAoKGNoYW5nZWRCaXRzICYgb2JzZXJ2ZWRCaXRzKSAhPT0gMCkge1xuICAgIC8vIENvbnRleHQgY2hhbmdlIHByb3BhZ2F0aW9uIHN0b3BzIGF0IG1hdGNoaW5nIGNvbnN1bWVycywgZm9yIHRpbWUtXG4gICAgLy8gc2xpY2luZy4gQ29udGludWUgdGhlIHByb3BhZ2F0aW9uIGhlcmUuXG4gICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAvLyBTa2lwIG92ZXIgYSBtZW1vaXplZCBwYXJlbnQgd2l0aCBhIGJpdG1hc2sgYmFpbG91dCBldmVuXG4gICAgLy8gaWYgd2UgYmVnYW4gd29ya2luZyBvbiBpdCBiZWNhdXNlIG9mIGEgZGVlcGVyIG1hdGNoaW5nIGNoaWxkLlxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICAvLyBUaGVyZSBpcyBubyBiYWlsb3V0IG9uIGBjaGlsZHJlbmAgZXF1YWxpdHkgYmVjYXVzZSB3ZSBleHBlY3QgcGVvcGxlXG4gIC8vIHRvIG9mdGVuIHBhc3MgYSBib3VuZCBtZXRob2QgYXMgYSBjaGlsZCwgYnV0IGl0IG1heSByZWZlcmVuY2VcbiAgLy8gYHRoaXMuc3RhdGVgIG9yIGB0aGlzLnByb3BzYCAoYW5kIHRodXMgbmVlZHMgdG8gcmUtcmVuZGVyIG9uIGBzZXRTdGF0ZWApLlxuXG4gIHZhciByZW5kZXIgPSBuZXdQcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgISh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpIDogdm9pZCAwO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4pO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbi8qXG4gIGZ1bmN0aW9uIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHJldHVybkZpYmVyIDogRmliZXIsIGZpcnN0Q2hpbGQgOiBGaWJlcikge1xuICAgIGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7XG4gICAgZG8ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGVmZmVjdCBvZiB0aGUgcGFyZW50IGNvcnJlc3BvbmRzXG4gICAgICAvLyB0byB0aGUgY2hpbGRyZW4ncyBmaXJzdCBhbmQgbGFzdCBlZmZlY3QuXG4gICAgICBpZiAoIXJldHVybkZpYmVyLmZpcnN0RWZmZWN0KSB7XG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubGFzdEVmZmVjdCkge1xuICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZC5sYXN0RWZmZWN0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gIH1cbiAgKi9cblxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG4gICAgc3RvcEJhc2VSZW5kZXJUaW1lcklmUnVubmluZygpO1xuICB9XG5cbiAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAvLyBtb3JlIHdvcmsgdG8gZG8uIEhvd2V2ZXIsIHNpbmNlIHdlIGRvbid0IGhhdmUgYSBzZXBhcmF0aW9uIG9mIHRoaXNcbiAgLy8gRmliZXIncyBwcmlvcml0eSBhbmQgaXRzIGNoaWxkcmVuIHlldCAtIHdlIGRvbid0IGtub3cgd2l0aG91dCBkb2luZyBsb3RzXG4gIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gIC8vIGJhaWwgb3V0IGhlcmUgaWYgdGhlIGNoaWxkcmVuIGhhcyBubyBtb3JlIHdvcmsgYXQgdGhpcyBwcmlvcml0eSBsZXZlbC5cbiAgLy8gaWYgKHdvcmtJblByb2dyZXNzLnByaW9yaXR5T2ZDaGlsZHJlbiA8PSBwcmlvcml0eUxldmVsKSB7XG4gIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gIC8vICAgLy8gY29tbWl0dGVkIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhleSBnZXQgcHJvcGVybHkgdHJhbnNmZXJyZWQgdXAuXG4gIC8vICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiBudWxsO1xuICAvLyB9XG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BCYXNlUmVuZGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgfVxuXG4gIC8vIFRPRE86IEhhbmRsZSBIb3N0Q29tcG9uZW50IHRhZ3MgaGVyZSBhcyB3ZWxsIGFuZCBjYWxsIHB1c2hIb3N0Q29udGV4dCgpP1xuICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gIC8vIEhvdyBjYW4gdGhhdCBoYXBwZW4/IEhvdyBpcyB0aGlzIG5vdCBiZWluZyBjbG9uZWQ/XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUT0RPOiBEZWxldGUgbWVtb2l6ZVByb3BzL1N0YXRlIGFuZCBtb3ZlIHRvIHJlY29uY2lsZS9iYWlsb3V0IGluc3RlYWRcbmZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gIC8vIERvbid0IHJlc2V0IHRoZSB1cGRhdGVRdWV1ZSwgaW4gY2FzZSB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBSZXNldHRpbmdcbiAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG59XG5cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICBtYXJrQWN0dWFsUmVuZGVyVGltZVN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBjYXNlIFRpbWVvdXRDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlVGltZW91dENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IHZvaWQgMDtcbnZhciB1cGRhdGVIb3N0VGV4dCQxID0gdm9pZCAwO1xuaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgLy8gTXV0YXRpb24gbW9kZVxuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGlzIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG5cbiAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG4gIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCk7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlY3ljbGFibGVJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHZhciBuZXdJbnN0YW5jZSA9IGNsb25lSW5zdGFuY2UoY3VycmVudEluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHdvcmtJblByb2dyZXNzLCBjaGlsZHJlblVuY2hhbmdlZCwgcmVjeWNsYWJsZUluc3RhbmNlKTtcbiAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHBhcmVudHMgd29uJ3Qga25vdyB0aGF0IHRoZXJlIGFyZSBuZXcgY2hpbGRyZW4gdG8gcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gTm9vcFxuICB9O1xuICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAvLyBOb29wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgcmVjb3JkRWxhcHNlZEFjdHVhbFJlbmRlclRpbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgZmliZXJSb290LnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAgICAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgLy8gVE9ETzogRXhwZXJpZW5jaW5nIGFuIGVycm9yIHdoZXJlIG9sZFByb3BzIGlzIG51bGwuIFN1Z2dlc3RzIGEgaG9zdFxuICAgICAgICAgIC8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG4gICAgICAgICAgLy8gcmVsYXRlZCB0byBgaGlkZGVuYC5cbiAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgICBtYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3ZSB3YW50IHRvIGFkZCB0aGVuIHRvcC0+ZG93biBvclxuICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgVGltZW91dENvbXBvbmVudDpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIEVycm9yIGNhc2VzXG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG4vLyBCeSBkZWZhdWx0LCByZXR1cm4gYHRydWVgIHRvIGxvZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUuXG4vLyBGb3JrcyBjYW4gcmV0dXJuIGBmYWxzZWAgaWYgdGhpcyBpc24ndCBkZXNpcmFibGUuXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcikge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG4gIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZXJyb3IgJiYgZXJyb3Iuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZztcbiAgaWYgKHN1cHByZXNzTG9nZ2luZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUsXG4gICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kLFxuICAgICAgICB3aWxsUmV0cnkgPSBjYXB0dXJlZEVycm9yLndpbGxSZXRyeTtcblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwnICsgY29tcG9uZW50TmFtZSArICc+IGNvbXBvbmVudDonIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG5cbiAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLy8gZXJyb3JCb3VuZGFyeUZvdW5kIGNoZWNrIGlzIHN1ZmZpY2llbnQ7IGVycm9yQm91bmRhcnlOYW1lIGNoZWNrIGlzIHRvIHNhdGlzZnkgRmxvdy5cbiAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICBpZiAod2lsbFJldHJ5KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1JlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoICcgKyAoJ3VzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdUaGlzIGVycm9yIHdhcyBpbml0aWFsbHkgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcnkgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy5cXG4nICsgJ1JlY3JlYXRpbmcgdGhlIHRyZWUgZnJvbSBzY3JhdGNoIGZhaWxlZCBzbyBSZWFjdCB3aWxsIHVubW91bnQgdGhlIHRyZWUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuJyArICdWaXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWVycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgfVxuICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSAnJyArIGNvbXBvbmVudE5hbWVNZXNzYWdlICsgY29tcG9uZW50U3RhY2sgKyAnXFxuXFxuJyArICgnJyArIGVycm9yQm91bmRhcnlNZXNzYWdlKTtcblxuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuICAgIGNvbnNvbGUuZXJyb3IoY29tYmluZWRNZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgdmFyIHNvdXJjZSA9IGVycm9ySW5mby5zb3VyY2U7XG4gIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgaWYgKHN0YWNrID09PSBudWxsICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgIHN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgY29tcG9uZW50TmFtZTogc291cmNlICE9PSBudWxsID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UpIDogbnVsbCxcbiAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnLFxuICAgIGVycm9yOiBlcnJvckluZm8udmFsdWUsXG4gICAgZXJyb3JCb3VuZGFyeTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5TmFtZTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGZhbHNlLFxuICAgIHdpbGxSZXRyeTogZmFsc2VcbiAgfTtcblxuICBpZiAoYm91bmRhcnkgIT09IG51bGwgJiYgYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeSA9IGJvdW5kYXJ5LnN0YXRlTm9kZTtcbiAgICBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeSk7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQgPSB0cnVlO1xuICAgIGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5ID0gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGUgJiYgZS5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xufTtcblxuLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgdmFyIHVubW91bnRFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgdW5tb3VudEVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZScpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZGlkV2FyblNldCA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuICAgICAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY3VycmVudFRpbWUsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIFByb2ZpbGVyLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBUaW1lb3V0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBUaW1lb3V0cy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlID0gdm9pZCAwO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuICcgKyAnVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJXMnLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yayksIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICBpZiAoY3VycmVudFJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgY3VycmVudFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4vLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcbiAgfVxuXG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAvLyByZW1vdmVDaGlsZCBvbiB0aGUgaW5uZXIgbm9kZXMgYmVjYXVzZSB0aGV5J3JlIHJlbW92ZWQgYnkgdGhlIHRvcFxuICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gIHZhciBub2RlID0gcm9vdDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgIXN1cHBvcnRzTXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50KSB7XG4gIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gIC8vIHNob3VsZCBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gIC8vIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIGN1cnJlbnQucmV0dXJuID0gbnVsbDtcbiAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gIGlmIChjdXJyZW50LmFsdGVybmF0ZSkge1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpIHtcbiAgaWYgKCFzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuXG4gIHZhciBlbXB0eUNoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVySW5mbyk7XG4gIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBlbXB0eUNoaWxkU2V0KTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG4gIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG4gICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcbiAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG4gIGlmIChwYXJlbnRGaWJlci5lZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgcmVzZXRUZXh0Q29udGVudChwYXJlbnQpO1xuICAgIC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG4gICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIC8vIElmIHRoZSBpbnNlcnRpb24gaXRzZWxmIGlzIGEgcG9ydGFsLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpIHtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gdm9pZCAwO1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShwYXJlbnQgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgLy8gQWZ0ZXIgYWxsIHRoZSBjaGlsZHJlbiBoYXZlIHVubW91bnRlZCwgaXQgaXMgbm93IHNhZmUgdG8gcmVtb3ZlIHRoZVxuICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgcG9ydGFscyBtaWdodCBjb250YWluIGhvc3QgY29tcG9uZW50cy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbihjdXJyZW50KSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudC5cbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICB9XG4gIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICAgIHZhciBvblJlbmRlciA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLm9uUmVuZGVyO1xuICAgICAgICAgIG9uUmVuZGVyKGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLCBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZVRpbWUsIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGdldENvbW1pdFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgVGltZW91dENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQoY3VycmVudCkge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgLy8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gIC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuICB1cGRhdGUucGF5bG9hZCA9IHsgZWxlbWVudDogbnVsbCB9O1xuICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIGxvZ0Vycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoO1xuICBpZiAoZW5hYmxlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICYmIHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoKGVycm9yKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICBpZiAoIWVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCB8fCBnZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIGxvZ0Vycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvciwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUGluZyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gT25jZSB0aGUgcHJvbWlzZSByZXNvbHZlcywgd2Ugc2hvdWxkIHRyeSByZW5kZXJpbmcgdGhlIG5vbi1cbiAgLy8gcGxhY2Vob2xkZXIgc3RhdGUgYWdhaW4uXG4gIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmluaXNoZWRXb3JrKTtcbiAgdmFyIHJlY292ZXJ5VXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgZW5xdWV1ZVVwZGF0ZShmaW5pc2hlZFdvcmssIHJlY292ZXJ5VXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gIHNjaGVkdWxlV29yayQxKGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByZW5kZXJJc0V4cGlyZWQsIHJlbmRlckV4cGlyYXRpb25UaW1lLCBjdXJyZW50VGltZU1zKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZWZmZWN0VGFnIHw9IEluY29tcGxldGU7XG4gIC8vIEl0cyBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgaWYgKGVuYWJsZVN1c3BlbnNlICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgdmFyIHRoZW5hYmxlID0gdmFsdWU7XG5cbiAgICB2YXIgZXhwaXJhdGlvblRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhyZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIHN0YXJ0VGltZU1zID0gZXhwaXJhdGlvblRpbWVNcyAtIDUwMDA7XG4gICAgdmFyIGVsYXBzZWRNcyA9IGN1cnJlbnRUaW1lTXMgLSBzdGFydFRpbWVNcztcbiAgICBpZiAoZWxhcHNlZE1zIDwgMCkge1xuICAgICAgZWxhcHNlZE1zID0gMDtcbiAgICB9XG4gICAgdmFyIHJlbWFpbmluZ1RpbWVNcyA9IGV4cGlyYXRpb25UaW1lTXMgLSBjdXJyZW50VGltZU1zO1xuXG4gICAgLy8gRmluZCB0aGUgZWFybGllc3QgdGltZW91dCBvZiBhbGwgdGhlIHRpbWVvdXRzIGluIHRoZSBhbmNlc3RvciBwYXRoLlxuICAgIC8vIFRPRE86IEFsdGVybmF0aXZlbHksIHdlIGNvdWxkIHN0b3JlIHRoZSBlYXJsaWVzdCB0aW1lb3V0IG9uIHRoZSBjb250ZXh0XG4gICAgLy8gc3RhY2ssIHJhdGhlciB0aGFuIHNlYXJjaGluZyBvbiBldmVyeSBzdXNwZW5kLlxuICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICB2YXIgZWFybGllc3RUaW1lb3V0TXMgPSAtMTtcbiAgICBzZWFyY2hGb3JFYXJsaWVzdFRpbWVvdXQ6IGRvIHtcbiAgICAgIGlmIChfd29ya0luUHJvZ3Jlc3MudGFnID09PSBUaW1lb3V0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gX3dvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gQSBwYXJlbnQgVGltZW91dCBhbHJlYWR5IGNvbW1pdHRlZCBpbiBhIHBsYWNlaG9sZGVyIHN0YXRlLiBXZVxuICAgICAgICAgIC8vIG5lZWQgdG8gaGFuZGxlIHRoaXMgcHJvbWlzZSBpbW1lZGlhdGVseS4gSW4gb3RoZXIgd29yZHMsIHdlXG4gICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIHN1c3BlbmQgaW5zaWRlIGEgdHJlZSB0aGF0IGFscmVhZHkgZXhwaXJlZC5cbiAgICAgICAgICBlYXJsaWVzdFRpbWVvdXRNcyA9IDA7XG4gICAgICAgICAgYnJlYWsgc2VhcmNoRm9yRWFybGllc3RUaW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lb3V0UHJvcE1zID0gX3dvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5tcztcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0UHJvcE1zID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGlmICh0aW1lb3V0UHJvcE1zIDw9IDApIHtcbiAgICAgICAgICAgIGVhcmxpZXN0VGltZW91dE1zID0gMDtcbiAgICAgICAgICAgIGJyZWFrIHNlYXJjaEZvckVhcmxpZXN0VGltZW91dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVhcmxpZXN0VGltZW91dE1zID09PSAtMSB8fCB0aW1lb3V0UHJvcE1zIDwgZWFybGllc3RUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgIGVhcmxpZXN0VGltZW91dE1zID0gdGltZW91dFByb3BNcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWFybGllc3RUaW1lb3V0TXMgPT09IC0xKSB7XG4gICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSByZW1haW5pbmdUaW1lTXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF93b3JrSW5Qcm9ncmVzcyA9IF93b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgfSB3aGlsZSAoX3dvcmtJblByb2dyZXNzICE9PSBudWxsKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIHJlbWFpbmluZyB0aW1lIHVudGlsIHRoZSB0aW1lb3V0LlxuICAgIHZhciBtc1VudGlsVGltZW91dCA9IGVhcmxpZXN0VGltZW91dE1zIC0gZWxhcHNlZE1zO1xuXG4gICAgaWYgKHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlciB8fCBtc1VudGlsVGltZW91dCA+IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgc3RpbGwgdGltZSByZW1haW5pbmcuXG4gICAgICBzdXNwZW5kUm9vdChyb290LCB0aGVuYWJsZSwgbXNVbnRpbFRpbWVvdXQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHZhciBvblJlc29sdmVPclJlamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0cnlTdXNwZW5kZWRSb290KHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH07XG4gICAgICB0aGVuYWJsZS50aGVuKG9uUmVzb2x2ZU9yUmVqZWN0LCBvblJlc29sdmVPclJlamVjdCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIHRpbWUgcmVtYWluaW5nLiBOZWVkIHRvIGZhbGxiYWNrIHRvIHBsYWNlaG9sZGVyLlxuICAgICAgLy8gRmluZCB0aGUgbmVhcmVzdCB0aW1lb3V0IHRoYXQgY2FuIGJlIHJldHJpZWQuXG4gICAgICBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgIGRvIHtcbiAgICAgICAgc3dpdGNoIChfd29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHJvb3QgZXhwaXJlZCwgYnV0IG5vIGZhbGxiYWNrIHdhcyBwcm92aWRlZC4gVGhyb3cgYVxuICAgICAgICAgICAgICAvLyBoZWxwZnVsIGVycm9yLlxuICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBTeW5jID8gJ0Egc3luY2hyb25vdXMgdXBkYXRlIHdhcyBzdXNwZW5kZWQsIGJ1dCBubyBmYWxsYmFjayBVSSAnICsgJ3dhcyBwcm92aWRlZC4nIDogJ0FuIHVwZGF0ZSB3YXMgc3VzcGVuZGVkIGZvciBsb25nZXIgdGhhbiB0aGUgdGltZW91dCwgJyArICdidXQgbm8gZmFsbGJhY2sgVUkgd2FzIHByb3ZpZGVkLic7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFRpbWVvdXRDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkge1xuICAgICAgICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICB2YXIgX29uUmVzb2x2ZU9yUmVqZWN0ID0gc2NoZWR1bGVQaW5nLmJpbmQobnVsbCwgX3dvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGVuYWJsZS50aGVuKF9vblJlc29sdmVPclJlamVjdCwgX29uUmVzb2x2ZU9yUmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZSBuZXh0XG4gICAgICAgICAgICAgIC8vIFRpbWVvdXQgYW5jZXN0b3IuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcyA9IF93b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gIGRvIHtcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID09PSAnZnVuY3Rpb24nICYmIGVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIHJlbmRlcklzRXhwaXJlZCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICByZWNvcmRFbGFwc2VkQWN0dWFsUmVuZGVyVGltZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoZWZmZWN0VGFnICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoX2VmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBUaW1lb3V0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX2VmZmVjdFRhZzIgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIGlmIChfZWZmZWN0VGFnMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgaWYgKGludGVycnVwdGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIC8vIFJlc3VtZSBpbiBjYXNlIHdlJ3JlIHBpY2tpbmcgdXAgb24gd29yayB0aGF0IHdhcyBwYXVzZWQuXG4gICAgICByZXN1bWVBY3R1YWxSZW5kZXJUaW1lcklmUGF1c2VkKCk7XG4gICAgICByZWNvcmRFbGFwc2VkQWN0dWFsUmVuZGVyVGltZShpbnRlcnJ1cHRlZFdvcmspO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcENvbnRleHRQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdm9pZCAwO1xudmFyIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbnZhciB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IHZvaWQgMDtcbnZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSBmYWxzZTtcbiAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgXCJDYW4ndCBjYWxsIHNldFN0YXRlIChvciBmb3JjZVVwZGF0ZSkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBcIiArICdpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gJyArICdmaXgsIGNhbmNlbCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluIHRoZSAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZC4lcycsIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpO1xuICAgICAgICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgIGlmIChkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluICcgKyBcImByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgXCIgKyAnYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3Igc2lkZS1lZmZlY3RzIGFyZSAnICsgJ2FuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byBgY29tcG9uZW50V2lsbE1vdW50YC4nKTtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG4vLyBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbXMuXG52YXIgb3JpZ2luYWxTdGFydFRpbWVNcyA9IG5vdygpO1xudmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcbnZhciBtb3N0UmVjZW50Q3VycmVudFRpbWVNcyA9IG9yaWdpbmFsU3RhcnRUaW1lTXM7XG5cbi8vIFVzZWQgdG8gZW5zdXJlIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24gaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMuXG52YXIgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IDA7XG5cbi8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbi8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbi8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbnZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxudmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4vLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG52YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xudmFyIG5leHRSb290ID0gbnVsbDtcbi8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbnZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbmV4dExhdGVzdFRpbWVvdXRNcyA9IC0xO1xudmFyIG5leHRSZW5kZXJJc0V4cGlyZWQgPSBmYWxzZTtcblxuLy8gVGhlIG5leHQgZmliZXIgd2l0aCBhbiBlZmZlY3QgdGhhdCB3ZSdyZSBjdXJyZW50bHkgY29tbWl0dGluZy5cbnZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxudmFyIGlzQ29tbWl0dGluZyQxID0gZmFsc2U7XG5cbnZhciBpc1Jvb3RSZWFkeUZvckNvbW1pdCA9IGZhbHNlO1xuXG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuXG4vLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbnZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxudmFyIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG52YXIgcmVwbGF5VW5pdE9mV29yayA9IHZvaWQgMDtcbnZhciBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSB2b2lkIDA7XG52YXIgb3JpZ2luYWxSZXBsYXlFcnJvciA9IHZvaWQgMDtcbnZhciByZXRocm93T3JpZ2luYWxFcnJvciA9IHZvaWQgMDtcbmlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBudWxsO1xuICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IG51bGw7XG4gIHJlcGxheVVuaXRPZldvcmsgPSBmdW5jdGlvbiAoZmFpbGVkVW5pdE9mV29yaywgdGhyb3duVmFsdWUsIGlzQXN5bmMpIHtcbiAgICBpZiAodGhyb3duVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHRocm93blZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhyb3duVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgIC8vIFRPRE86IE5lZWQgdG8gZmlndXJlIG91dCBhIGRpZmZlcmVudCBzdHJhdGVneSBpZi93aGVuIHdlIGFkZFxuICAgICAgLy8gc3VwcG9ydCBmb3IgY2F0Y2hpbmcgb3RoZXIgdHlwZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3NcbiAgICBpZiAoc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiBEb24ndCB0aHJvdyBiZWNhdXNlIHRoaXMgY29kZSBpcyBERVYtb25seS5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdDb3VsZCBub3QgcmVwbGF5IHJlbmRlcmluZyBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKGZhaWxlZFVuaXRPZldvcmssIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMpO1xuXG4gICAgc3dpdGNoIChmYWlsZWRVbml0T2ZXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcG9wSG9zdENvbnRleHQoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgcG9wUHJvdmlkZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZXBsYXkgdGhlIGJlZ2luIHBoYXNlLlxuICAgIGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yayA9IHRydWU7XG4gICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IHRocm93blZhbHVlO1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIHdvcmtMb29wLCBudWxsLCBpc0FzeW5jKTtcbiAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICBpZiAoZmFpbGVkVW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICByZWNvcmRFbGFwc2VkQWN0dWFsUmVuZGVyVGltZShmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3AgXCJiYXNlXCIgcmVuZGVyIHRpbWVyIGFnYWluIChhZnRlciB0aGUgcmUtdGhyb3duIGVycm9yKS5cbiAgICAgICAgc3RvcEJhc2VSZW5kZXJUaW1lcklmUnVubmluZygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgYmVnaW4gcGhhc2UgZGlkIG5vdCBmYWlsIHRoZSBzZWNvbmQgdGltZSwgc2V0IHRoaXMgcG9pbnRlclxuICAgICAgLy8gYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICBuZXh0VW5pdE9mV29yayA9IGZhaWxlZFVuaXRPZldvcms7XG4gICAgfVxuICB9O1xuICByZXRocm93T3JpZ2luYWxFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBvcmlnaW5hbFJlcGxheUVycm9yO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNldFN0YWNrKCkge1xuICBpZiAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gbmV4dFVuaXRPZldvcmsucmV0dXJuO1xuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICAgIGNoZWNrVGhhdFN0YWNrSXNFbXB0eSgpO1xuICB9XG5cbiAgbmV4dFJvb3QgPSBudWxsO1xuICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIG5leHRMYXRlc3RUaW1lb3V0TXMgPSAtMTtcbiAgbmV4dFJlbmRlcklzRXhwaXJlZCA9IGZhbHNlO1xuICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG5cbiAgaXNSb290UmVhZHlGb3JDb21taXQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgfVxuICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgLy8gdXBkYXRlcywgYW5kIGRlbGV0aW9ucy4gVG8gYXZvaWQgbmVlZGluZyB0byBhZGQgYSBjYXNlIGZvciBldmVyeVxuICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgIHZhciBwcmltYXJ5RWZmZWN0VGFnID0gZWZmZWN0VGFnICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IERlbGV0aW9uKTtcbiAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgIGNhc2UgUGxhY2VtZW50OlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgLy8gZG9lcyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlXG4gICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdERlbGV0aW9uKG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgU25hcHNob3QpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBjbGVhbnVwIGVmZmVjdHMgeWV0O1xuICAgIC8vIFRoaXMgd2lsbCBiZSBkb25lIGJ5IGNvbW1pdEFsbExpZmVDeWNsZXMoKVxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QWxsTGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcblxuICAgIGlmICh3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcykge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncygpO1xuICAgIH1cblxuICAgIGlmICh3YXJuQWJvdXRMZWdhY3lDb250ZXh0QVBJKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50LCBuZXh0RWZmZWN0LCBjdXJyZW50VGltZSwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGNsZWFuIHRoZXNlIHVwIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGtlZXAgdGhlbS5cbiAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAvLyBhbmQgbGFzdEVmZmVjdCBzaW5jZSB0aGV5J3JlIG9uIGV2ZXJ5IG5vZGUsIG5vdCBqdXN0IHRoZSBlZmZlY3RmdWxcbiAgICAvLyBvbmVzLiBTbyB3ZSBoYXZlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgYXMgd2UgcmV1c2Ugbm9kZXMgYW55d2F5LlxuICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzZXQgdGhlIGVmZmVjdFRhZyBoZXJlIHNvIHRoYXQgd2UgY2FuIHJlbHkgb24gZWZmZWN0XG4gICAgLy8gdGFncyB0byByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgbGlmZS1jeWNsZS5cbiAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIHJldHVybiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCAhPT0gbnVsbCAmJiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gIGlmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9PT0gbnVsbCkge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKSB7XG4gIGlzV29ya2luZyA9IHRydWU7XG4gIGlzQ29tbWl0dGluZyQxID0gdHJ1ZTtcbiAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gICEoY29tbWl0dGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuXG4gIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gIHZhciBmaXJzdEVmZmVjdCA9IHZvaWQgMDtcbiAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmXG4gICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgfVxuXG4gIHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcblxuICAvLyBJbnZva2UgaW5zdGFuY2VzIG9mIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIGJlZm9yZSBtdXRhdGlvbi5cbiAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCk7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgIC8vIENsZWFuLXVwXG4gICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpcyBiYXRjaC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgfVxuXG4gIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gIC8vIHJlZiB1bm1vdW50cy5cbiAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAvLyBDbGVhbi11cFxuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcblxuICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG5cbiAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgLy8gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGNvbW1pdCBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbFxuICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG5cbiAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gIC8vIGFuZCBkZWxldGlvbnMgaW4gdGhlIGVudGlyZSB0cmVlIGhhdmUgYWxyZWFkeSBiZWVuIGludm9rZWQuXG4gIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yMiA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwsIHJvb3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9kaWRFcnJvcjIpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHtcbiAgICAgIGNoZWNrQWN0dWFsUmVuZGVyVGltZVN0YWNrRW1wdHkoKTtcbiAgICB9XG4gICAgcmVzZXRBY3R1YWxSZW5kZXJUaW1lcigpO1xuICB9XG5cbiAgaXNDb21taXR0aW5nJDEgPSBmYWxzZTtcbiAgaXNXb3JraW5nID0gZmFsc2U7XG4gIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgc3RvcENvbW1pdFRpbWVyKCk7XG4gIGlmICh0eXBlb2Ygb25Db21taXRSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICB9XG4gIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICB9XG5cbiAgbWFya0NvbW1pdHRlZFByaW9yaXR5TGV2ZWxzKHJvb3QsIGN1cnJlbnRUaW1lLCByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWUpO1xuICB2YXIgcmVtYWluaW5nVGltZSA9IGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCk7XG4gIGlmIChyZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuICAgIC8vIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICB9XG4gIHJldHVybiByZW1haW5pbmdUaW1lO1xufVxuXG5mdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gIGlmIChyZW5kZXJUaW1lICE9PSBOZXZlciAmJiB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICB2YXIgbmV3RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgLy8gKEFuZCBcImJhc2VcIiByZW5kZXIgdGltZXJzIGlmIHRoYXQgZmVhdHVyZSBmbGFnIGlzIGVuYWJsZWQpXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgIHZhciB0cmVlQmFzZVRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZVRpbWU7XG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB0cmVlQmFzZVRpbWUgKz0gY2hpbGQudHJlZUJhc2VUaW1lO1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VUaW1lID0gdHJlZUJhc2VUaW1lO1xuICB9IGVsc2Uge1xuICAgIHZhciBfY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoX2NoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBfY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gX2NoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlXG4gIC8vIG5leHQgc2libGluZy4gSWYgdGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3MsIHJldHVybiB0byB0aGVcbiAgLy8gcGFyZW50IGZpYmVyLlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIEluY29tcGxldGUpID09PSBOb0VmZmVjdCkge1xuICAgICAgLy8gVGhpcyBmaWJlciBjb21wbGV0ZWQuXG4gICAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwgJiZcbiAgICAgIC8vIERvIG5vdCBhcHBlbmQgZWZmZWN0cyB0byBwYXJlbnRzIGlmIGEgc2libGluZyBmYWlsZWQgdG8gY29tcGxldGVcbiAgICAgIChyZXR1cm5GaWJlci5lZmZlY3RUYWcgJiBJbmNvbXBsZXRlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmXG4gICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgIC8vIHRvIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgdmFyIGVmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgLy8gU2tpcCBib3RoIE5vV29yayBhbmQgUGVyZm9ybWVkV29yayB0YWdzIHdoZW4gY3JlYXRpbmcgdGhlIGVmZmVjdCBsaXN0LlxuICAgICAgICAvLyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpcyByZWFkIGJ5IFJlYWN0IERldlRvb2xzIGJ1dCBzaG91bGRuJ3QgYmUgY29tbWl0dGVkLlxuICAgICAgICBpZiAoZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgIGlzUm9vdFJlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSBiZWNhdXNlIHNvbWV0aGluZyB0aHJldy4gUG9wIHZhbHVlcyBvZmZcbiAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IGVudGVyaW5nIHRoZSBjb21wbGV0ZSBwaGFzZS4gSWYgdGhpcyBpcyBhIGJvdW5kYXJ5LFxuICAgICAgLy8gY2FwdHVyZSB2YWx1ZXMgaWYgcG9zc2libGUuXG4gICAgICB2YXIgX25leHQgPSB1bndpbmRXb3JrKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVySXNFeHBpcmVkLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkge1xuICAgICAgICAvLyBSZXN0YXJ0aW5nIGFuIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgICBfbmV4dC5lZmZlY3RUYWcgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgIHJldHVybiBfbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgZWZmZWN0IGxpc3QuXG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybkZpYmVyLmVmZmVjdFRhZyB8PSBJbmNvbXBsZXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZXhwbGljaXQgbnVsbCByZXR1cm4gRmxvdyBjb21wbGFpbnMgb2YgaW52YWxpZCByZXR1cm4gdHlwZVxuICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gIC8vIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICBzdGFydEJhc2VSZW5kZXJUaW1lcigpO1xuICAgIH1cblxuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBVcGRhdGUgXCJiYXNlXCIgdGltZSBpZiB0aGUgcmVuZGVyIHdhc24ndCBiYWlsZWQgb3V0IG9uLlxuICAgICAgcmVjb3JkRWxhcHNlZEJhc2VSZW5kZXJUaW1lSWZSdW5uaW5nKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN0b3BCYXNlUmVuZGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgaWYgKGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yaykge1xuICAgICAgLy8gQ3VycmVudGx5IHJlcGxheWluZyBhIGZhaWxlZCB1bml0IG9mIHdvcmsuIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlLFxuICAgICAgLy8gYmVjYXVzZSB0aGUgcmVuZGVyIHBoYXNlIGlzIG1lYW50IHRvIGJlIGlkZW1wb3RlbnQsIGFuZCBpdCBzaG91bGRcbiAgICAgIC8vIGhhdmUgdGhyb3duIGFnYWluLiBTaW5jZSBpdCBkaWRuJ3QsIHJldGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yLCBzb1xuICAgICAgLy8gUmVhY3QncyBpbnRlcm5hbCBzdGFjayBpcyBub3QgbWlzYWxpZ25lZC5cbiAgICAgIHJldGhyb3dPcmlnaW5hbEVycm9yKCk7XG4gICAgfVxuICB9XG4gIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIHdvcmtMb29wKGlzQXN5bmMpIHtcbiAgaWYgKCFpc0FzeW5jKSB7XG4gICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cblxuICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluaXNoLCBwYXVzZSB0aGUgXCJhY3R1YWxcIiByZW5kZXIgdGltZXIuXG4gICAgICAvLyBXZSdsbCByZXN0YXJ0IGl0IHdoZW4gd2UgcmVzdW1lIHdvcmsuXG4gICAgICBwYXVzZUFjdHVhbFJlbmRlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzQXN5bmMpIHtcbiAgISFpc1dvcmtpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJSb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIGlzV29ya2luZyA9IHRydWU7XG5cbiAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICBpZiAoZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCByb290ICE9PSBuZXh0Um9vdCB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgIHJlc2V0U3RhY2soKTtcbiAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgbmV4dExhdGVzdFRpbWVvdXRNcyA9IC0xO1xuICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MobmV4dFJvb3QuY3VycmVudCwgbnVsbCwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxuXG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuXG4gIG5leHRSZW5kZXJJc0V4cGlyZWQgPSAhaXNBc3luYyB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xuXG4gIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcChpc0FzeW5jKTtcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgLy8gU3RvcCBcImJhc2VcIiByZW5kZXIgdGltZXIgaW4gdGhlIGV2ZW50IG9mIGFuIGVycm9yLlxuICAgICAgICBzdG9wQmFzZVJlbmRlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZmF0YWwgZXJyb3IuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBnbG9iYWwgZGVidWcgc3RhdGVcbiAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhpcyBpcyBkZWZpbmVkIGluIERFVlxuICAgICAgICAgIHJlc2V0Q3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFpbGVkVW5pdE9mV29yayA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAgIHJlcGxheVVuaXRPZldvcmsoZmFpbGVkVW5pdE9mV29yaywgdGhyb3duVmFsdWUsIGlzQXN5bmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogd2UgYWxyZWFkeSBrbm93IHRoaXMgaXNuJ3QgdHJ1ZSBpbiBzb21lIGNhc2VzLlxuICAgICAgICAvLyBBdCBsZWFzdCB0aGlzIHNob3dzIGEgbmljZXIgZXJyb3IgbWVzc2FnZSB1bnRpbCB3ZSBmaWd1cmUgb3V0IHRoZSBjYXVzZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjQ0OSNpc3N1ZWNvbW1lbnQtMzg2NzI3NDMxXG4gICAgICAgICEobmV4dFVuaXRPZldvcmsgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnRmFpbGVkIHRvIHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgd2l0aCBhIHJlcHJvZHVjaW5nIGNhc2UgdG8gaGVscCB1cyBmaW5kIGl0LicpIDogdm9pZCAwO1xuXG4gICAgICAgIHZhciBzb3VyY2VGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3QuIFRoZSByb290IGNvdWxkIGNhcHR1cmUgaXRzIG93biBlcnJvcnMuIEhvd2V2ZXIsXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCBlcnJvcnMgYmVmb3JlIG9yIGFmdGVyIHdlIHB1c2hlZCB0aGUgaG9zdFxuICAgICAgICAgIC8vIGNvbnRleHQuIFRoaXMgaW5mb3JtYXRpb24gaXMgbmVlZGVkIHRvIGF2b2lkIGEgc3RhY2sgbWlzbWF0Y2guXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBub3Qgc3VyZSwgdHJlYXQgdGhpcyBhcyBhIGZhdGFsIGVycm9yLiBXZSBjb3VsZCB0cmFja1xuICAgICAgICAgIC8vIHdoaWNoIHBoYXNlIGl0IGZhaWxzIGluLCBidXQgZG9lc24ndCBzZWVtIHdvcnRoIGl0LiBBdCBsZWFzdFxuICAgICAgICAgIC8vIGZvciBub3cuXG4gICAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcih0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB0aHJvd25WYWx1ZSwgbmV4dFJlbmRlcklzRXhwaXJlZCwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lLCBtb3N0UmVjZW50Q3VycmVudFRpbWVNcyk7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gY29tcGxldGVVbml0T2ZXb3JrKHNvdXJjZUZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICB2YXIgZGlkQ29tcGxldGVSb290ID0gZmFsc2U7XG4gIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFlpZWxkIGJhY2sgdG8gbWFpbiB0aHJlYWQuXG4gIGlmIChkaWRGYXRhbCkge1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgLy8gVGhlcmUgd2FzIGEgZmF0YWwgZXJyb3IuXG4gICAge1xuICAgICAgcmVzZXRTdGFja0FmdGVyRmF0YWxFcnJvckluRGV2KCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgLy8gV2UgcmVhY2hlZCB0aGUgcm9vdC5cbiAgICBpZiAoaXNSb290UmVhZHlGb3JDb21taXQpIHtcbiAgICAgIGRpZENvbXBsZXRlUm9vdCA9IHRydWU7XG4gICAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpO1xuICAgICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgICAvLyBUaGUgcm9vdCBzdWNjZXNzZnVsbHkgY29tcGxldGVkLiBJdCdzIHJlYWR5IGZvciBjb21taXQuXG4gICAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICByZXR1cm4gZmluaXNoZWRXb3JrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcm9vdCBkaWQgbm90IGNvbXBsZXRlLlxuICAgICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KTtcbiAgICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgICAgISFuZXh0UmVuZGVySXNFeHBpcmVkID8gaW52YXJpYW50KGZhbHNlLCAnRXhwaXJlZCB3b3JrIHNob3VsZCBoYXZlIGNvbXBsZXRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIG1hcmtTdXNwZW5kZWRQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXh0TGF0ZXN0VGltZW91dE1zID49IDApIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0cnlTdXNwZW5kZWRSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfSwgbmV4dExhdGVzdFRpbWVvdXRNcyk7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3RVbmJsb2NrZWRFeHBpcmF0aW9uVGltZSA9IGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCk7XG4gICAgICBvbkJsb2NrKGZpcnN0VW5ibG9ja2VkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgLy8gVGhlcmUncyBtb3JlIHdvcmsgdG8gZG8sIGJ1dCB3ZSByYW4gb3V0IG9mIHRpbWUuIFlpZWxkIGJhY2sgdG9cbiAgICAvLyB0aGUgcmVuZGVyZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2goc291cmNlRmliZXIsIHZhbHVlLCBleHBpcmF0aW9uVGltZSkge1xuICAhKCFpc1dvcmtpbmcgfHwgaXNDb21taXR0aW5nJDEpID8gaW52YXJpYW50KGZhbHNlLCAnZGlzcGF0Y2g6IENhbm5vdCBkaXNwYXRjaCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4nKSA6IHZvaWQgMDtcblxuICB2YXIgZmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgc2NoZWR1bGVXb3JrJDEoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIF9lcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCBfdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgc2NoZWR1bGVXb3JrJDEoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgdmFyIHJvb3RGaWJlciA9IHNvdXJjZUZpYmVyO1xuICAgIHZhciBfZXJyb3JJbmZvMiA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHJvb3RGaWJlcik7XG4gICAgdmFyIF91cGRhdGUyID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlciwgX2Vycm9ySW5mbzIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgX3VwZGF0ZTIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBzY2hlZHVsZVdvcmskMShyb290RmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZXJyb3IpIHtcbiAgcmV0dXJuIGRpc3BhdGNoKGZpYmVyLCBlcnJvciwgU3luYyk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpIHtcbiAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gfjUwMDBtcy4gNTI1MG1zIG1heC5cbiAgdmFyIGV4cGlyYXRpb25NcyA9IDUwMDA7XG4gIHZhciBidWNrZXRTaXplTXMgPSAyNTA7XG4gIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleHBpcmF0aW9uTXMgPSB2b2lkIDA7XG4gIC8vIFdlIGludGVudGlvbmFsbHkgc2V0IGEgaGlnaGVyIGV4cGlyYXRpb24gdGltZSBmb3IgaW50ZXJhY3RpdmUgdXBkYXRlcyBpblxuICAvLyBkZXYgdGhhbiBpbiBwcm9kdWN0aW9uLlxuICAvLyBJZiB0aGUgbWFpbiB0aHJlYWQgaXMgYmVpbmcgYmxvY2tlZCBzbyBsb25nIHRoYXQgeW91IGhpdCB0aGUgZXhwaXJhdGlvbixcbiAgLy8gaXQncyBhIHByb2JsZW0gdGhhdCBjb3VsZCBiZSBzb2x2ZWQgd2l0aCBiZXR0ZXIgc2NoZWR1bGluZy5cbiAgLy8gUGVvcGxlIHdpbGwgYmUgbW9yZSBsaWtlbHkgdG8gbm90aWNlIHRoaXMgYW5kIGZpeCBpdCB3aXRoIHRoZSBsb25nXG4gIC8vIGV4cGlyYXRpb24gdGltZSBpbiBkZXZlbG9wbWVudC5cbiAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBvcHQgZm9yIGJldHRlciBVWCBhdCB0aGUgcmlzayBvZiBtYXNraW5nIHNjaGVkdWxpbmdcbiAgLy8gcHJvYmxlbXMsIGJ5IGV4cGlyaW5nIGZhc3QuXG4gIHtcbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH41MDBtcy4gNjAwbXMgbWF4LlxuICAgIGV4cGlyYXRpb25NcyA9IDUwMDtcbiAgfVxuICB2YXIgYnVja2V0U2l6ZU1zID0gMTAwO1xuICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25NcywgYnVja2V0U2l6ZU1zKTtcbn1cblxuLy8gQ3JlYXRlcyBhIHVuaXF1ZSBhc3luYyBleHBpcmF0aW9uIHRpbWUuXG5mdW5jdGlvbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gIHZhciByZXN1bHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgaWYgKHJlc3VsdCA8PSBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uKSB7XG4gICAgLy8gU2luY2Ugd2UgYXNzdW1lIHRoZSBjdXJyZW50IHRpbWUgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMsIHdlIG9ubHkgaGl0XG4gICAgLy8gdGhpcyBicmFuY2ggd2hlbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uIGlzIGZpcmVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gd2l0aGluIGEgMjAwbXMgd2luZG93IChvciB3aGF0ZXZlciB0aGUgYXN5bmMgYnVja2V0IHNpemUgaXMpLlxuICAgIHJlc3VsdCA9IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gKyAxO1xuICB9XG4gIGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gPSByZXN1bHQ7XG4gIHJldHVybiBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcikge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nJDEpIHtcbiAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBBc3luY01vZGUpIHtcbiAgICAgIGlmIChpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJhY3RpdmUgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIHVwZGF0ZVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICB9XG4gIH1cbiAgaWYgKGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGludGVyYWN0aXZlIHVwZGF0ZS4gS2VlcCB0cmFjayBvZiB0aGUgbG93ZXN0IHBlbmRpbmdcbiAgICAvLyBpbnRlcmFjdGl2ZSBleHBpcmF0aW9uIHRpbWUuIFRoaXMgYWxsb3dzIHVzIHRvIHN5bmNocm9ub3VzbHkgZmx1c2hcbiAgICAvLyBhbGwgaW50ZXJhY3RpdmUgdXBkYXRlcyB3aGVuIG5lZWRlZC5cbiAgICBpZiAobG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA+IGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG59XG5cbi8vIFRPRE86IFJlbmFtZSB0aGlzIHRvIHNjaGVkdWxlVGltZW91dCBvciBzb21ldGhpbmdcbmZ1bmN0aW9uIHN1c3BlbmRSb290KHJvb3QsIHRoZW5hYmxlLCB0aW1lb3V0TXMsIHN1c3BlbmRlZFRpbWUpIHtcbiAgLy8gU2NoZWR1bGUgdGhlIHRpbWVvdXQuXG4gIGlmICh0aW1lb3V0TXMgPj0gMCAmJiBuZXh0TGF0ZXN0VGltZW91dE1zIDwgdGltZW91dE1zKSB7XG4gICAgbmV4dExhdGVzdFRpbWVvdXRNcyA9IHRpbWVvdXRNcztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVN1c3BlbmRlZFJvb3Qocm9vdCwgc3VzcGVuZGVkVGltZSkge1xuICBtYXJrUGluZ2VkUHJpb3JpdHlMZXZlbChyb290LCBzdXNwZW5kZWRUaW1lKTtcbiAgdmFyIHJldHJ5VGltZSA9IGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCk7XG4gIGlmIChyZXRyeVRpbWUgIT09IE5vV29yaykge1xuICAgIHJlcXVlc3RSZXRyeShyb290LCByZXRyeVRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29yayQxKGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSBlYWNoIG5vZGUnc1xuICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgbm9kZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmICghaXNXb3JraW5nICYmIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgICAgIHJlc2V0U3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB2YXIgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBmaW5kTmV4dFBlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QpO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSByZW5kZXIgcGhhc2UsIHdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgdGhpcyByb290XG4gICAgICAgIC8vIGZvciBhbiB1cGRhdGUsIGJlY2F1c2Ugd2UnbGwgZG8gaXQgYmVmb3JlIHdlIGV4aXQuLi5cbiAgICAgICAgIWlzV29ya2luZyB8fCBpc0NvbW1pdHRpbmckMSB8fFxuICAgICAgICAvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGRpZmZlcmVudCByb290IHRoYW4gdGhlIG9uZSB3ZSdyZSByZW5kZXJpbmcuXG4gICAgICAgIG5leHRSb290ICE9PSByb290KSB7XG4gICAgICAgICAgcmVxdWVzdFdvcmsocm9vdCwgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkge1xuICAvLyBTdWJ0cmFjdCBpbml0aWFsIHRpbWUgc28gaXQgZml0cyBpbnNpZGUgMzJiaXRzXG4gIG1vc3RSZWNlbnRDdXJyZW50VGltZU1zID0gbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICBtb3N0UmVjZW50Q3VycmVudFRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUobW9zdFJlY2VudEN1cnJlbnRUaW1lTXMpO1xuICByZXR1cm4gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xufVxuXG5mdW5jdGlvbiBkZWZlcnJlZFVwZGF0ZXMoZm4pIHtcbiAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICBleHBpcmF0aW9uQ29udGV4dCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4sIGEsIGIsIGMsIGQpIHtcbiAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgZXhwaXJhdGlvbkNvbnRleHQgPSBTeW5jO1xuICB0cnkge1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gIH1cbn1cblxuLy8gVE9ETzogRXZlcnl0aGluZyBiZWxvdyB0aGlzIGlzIHdyaXR0ZW4gYXMgaWYgaXQgaGFzIGJlZW4gbGlmdGVkIHRvIHRoZVxuLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbi8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG52YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbnZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbnZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xudmFyIGNhbGxiYWNrSUQgPSB2b2lkIDA7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbnZhciBuZXh0Rmx1c2hlZFJvb3QgPSBudWxsO1xudmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbnZhciBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xudmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbnZhciBkZWFkbGluZSA9IG51bGw7XG5cbnZhciBpc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xudmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbnZhciBpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gZmFsc2U7XG5cbnZhciBjb21wbGV0ZWRCYXRjaGVzID0gbnVsbDtcblxuLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xudmFyIE5FU1RFRF9VUERBVEVfTElNSVQgPSAxMDAwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxudmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPiBjYWxsYmFja0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FsbGJhY2tJRCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgcmVxdWVzdCBjYWxsYmFjayB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcuIERvbid0IHN0YXJ0IGEgbmV3IG9uZS5cbiAgfSBlbHNlIHtcbiAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gIH1cblxuICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gb3JpZ2luYWxTdGFydFRpbWVNcztcbiAgdmFyIGV4cGlyYXRpb25NcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgY2FsbGJhY2tJRCA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayhwZXJmb3JtQXN5bmNXb3JrLCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeShyb290LCBleHBpcmF0aW9uVGltZSkge1xuICBpZiAocm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIEZvciBhIHJldHJ5LCBvbmx5IHVwZGF0ZSB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSBpZiBpdCBoYXMgYVxuICAgIC8vICpsb3dlciBwcmlvcml0eSogdGhhbiB0aGUgZXhpc3RpbmcgdmFsdWUuIFRoaXMgaXMgYmVjYXVzZSwgb24gYSByZXRyeSxcbiAgICAvLyB3ZSBzaG91bGQgYXR0ZW1wdCB0byBjb2FsZXNjZSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICAgIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG4vLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbmZ1bmN0aW9uIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGFkZFJvb3RUb1NjaGVkdWxlKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcblxuICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBiYXRjaC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyAuLi51bmxlc3Mgd2UncmUgaW5zaWRlIHVuYmF0Y2hlZFVwZGF0ZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBTeW5jLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb290VG9TY2hlZHVsZShyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgaWYgKHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBzY2hlZHVsZWQsIGJ1dCBpdHMgcHJpb3JpdHkgbWF5IGhhdmUgaW5jcmVhc2VkLlxuICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eS5cbiAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKSB7XG4gIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG4gIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgbmV4dCByb290IGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByb290LCB0aGlzIGlzIGEgbmVzdGVkXG4gIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICBpZiAocHJldmlvdXNGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBwcmV2aW91c0ZsdXNoZWRSb290ID09PSBoaWdoZXN0UHJpb3JpdHlSb290ICYmIGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IFN5bmMpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH1cbiAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IGhpZ2hlc3RQcmlvcml0eVdvcms7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgcGVyZm9ybVdvcmsoTm9Xb3JrLCB0cnVlLCBkbCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29yaygpIHtcbiAgcGVyZm9ybVdvcmsoU3luYywgZmFsc2UsIG51bGwpO1xufVxuXG5mdW5jdGlvbiBwZXJmb3JtV29yayhtaW5FeHBpcmF0aW9uVGltZSwgaXNBc3luYywgZGwpIHtcbiAgZGVhZGxpbmUgPSBkbDtcblxuICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAvLyB0aGUgZGVhZGxpbmUuXG4gIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXN1bWVBY3R1YWxSZW5kZXJUaW1lcklmUGF1c2VkKCk7XG4gIH1cblxuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSAmJiBkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvblRpbWVUb01zKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIHRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKGlzQXN5bmMpIHtcbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBtaW5FeHBpcmF0aW9uVGltZSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSAmJiAoIWRlYWRsaW5lRGlkRXhwaXJlIHx8IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLCAhZGVhZGxpbmVEaWRFeHBpcmUpO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbWluRXhwaXJhdGlvblRpbWUgPj0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSdyZSBkb25lIGZsdXNoaW5nIHdvcmsuIEVpdGhlciB3ZSByYW4gb3V0IG9mIHRpbWUgaW4gdGhpcyBjYWxsYmFjayxcbiAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICBpZiAoZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGNhbGxiYWNrSUQgPSBudWxsO1xuICB9XG4gIC8vIElmIHRoZXJlJ3Mgd29yayBsZWZ0IG92ZXIsIHNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgLy8gQ2xlYW4tdXAuXG4gIGRlYWRsaW5lID0gbnVsbDtcbiAgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcblxuICBmaW5pc2hSZW5kZXJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICd3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgYXR0ZW1wdGVkIHRvIGNvbW1pdCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuJykgOiB2b2lkIDA7XG4gIC8vIFBlcmZvcm0gd29yayBvbiByb290IGFzIGlmIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUgaXMgdGhlIGN1cnJlbnQgdGltZS5cbiAgLy8gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBzeW5jaHJvbm91c2x5IGZsdXNoaW5nIGFsbCB3b3JrIHVwIHRvIGFuZFxuICAvLyBpbmNsdWRpbmcgdGhlIGdpdmVuIHRpbWUuXG4gIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgLy8gRmx1c2ggYW55IHN5bmMgd29yayB0aGF0IHdhcyBzY2hlZHVsZWQgYnkgbGlmZWN5Y2xlc1xuICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgZmluaXNoUmVuZGVyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZygpIHtcbiAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gIGlmIChjb21wbGV0ZWRCYXRjaGVzICE9PSBudWxsKSB7XG4gICAgdmFyIGJhdGNoZXMgPSBjb21wbGV0ZWRCYXRjaGVzO1xuICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJhdGNoLl9vbkNvbXBsZXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgaXNBc3luYykge1xuICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhc3luYyB3b3JrIG9yIHN5bmMvZXhwaXJlZCB3b3JrLlxuICBpZiAoIWlzQXN5bmMpIHtcbiAgICAvLyBGbHVzaCBzeW5jIHdvcmsuXG4gICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IGNvbXBsZXRlLiBXZSBjYW4gY29tbWl0IGl0LlxuICAgICAgY29tcGxldGVSb290KHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgdmFyIF9maW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgdHJ1ZSk7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgIC8vIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICByb290LmZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcms7XG5cbiAgICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmlzaCwgcGF1c2UgdGhlIFwiYWN0dWFsXCIgcmVuZGVyIHRpbWVyLlxuICAgICAgICAgICAgLy8gV2UnbGwgcmVzdGFydCBpdCB3aGVuIHdlIHJlc3VtZSB3b3JrLlxuICAgICAgICAgICAgcGF1c2VBY3R1YWxSZW5kZXJUaW1lcklmUnVubmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzUmVuZGVyaW5nID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBiYXRjaCB0aGF0IG1hdGNoZXMgdGhpcyBleHBpcmF0aW9uIHRpbWUuXG4gIHZhciBmaXJzdEJhdGNoID0gcm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCAhPT0gbnVsbCAmJiBmaXJzdEJhdGNoLl9leHBpcmF0aW9uVGltZSA8PSBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjb21wbGV0ZWRCYXRjaGVzID09PSBudWxsKSB7XG4gICAgICBjb21wbGV0ZWRCYXRjaGVzID0gW2ZpcnN0QmF0Y2hdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZWRCYXRjaGVzLnB1c2goZmlyc3RCYXRjaCk7XG4gICAgfVxuICAgIGlmIChmaXJzdEJhdGNoLl9kZWZlcikge1xuICAgICAgLy8gVGhpcyByb290IGlzIGJsb2NrZWQgZnJvbSBjb21taXR0aW5nIGJ5IGEgYmF0Y2guIFVuc2NoZWR1bGUgaXQgdW50aWxcbiAgICAgIC8vIHdlIHJlY2VpdmUgYW5vdGhlciB1cGRhdGUuXG4gICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tbWl0IHRoZSByb290LlxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG59XG5cbi8vIFdoZW4gd29ya2luZyBvbiBhc3luYyB3b3JrLCB0aGUgcmVjb25jaWxlciBhc2tzIHRoZSByZW5kZXJlciBpZiBpdCBzaG91bGRcbi8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gIGlmIChkZWFkbGluZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGVhZGxpbmUudGltZVJlbWFpbmluZygpID4gdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmspIHtcbiAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAvLyBhbm90aGVyIHVwZGF0ZS5cbiAgbmV4dEZsdXNoZWRSb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25CbG9jayhyZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIC8vIFRoaXMgcm9vdCB3YXMgYmxvY2tlZC4gVW5zY2hlZHVsZSBpdCB1bnRpbCB0aGVyZSdzIGFub3RoZXIgdXBkYXRlLlxuICBuZXh0Rmx1c2hlZFJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZuKGEpO1xufVxuXG4vLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIGZsdXNoU3luYyhmbiwgYSkge1xuICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJykgOiB2b2lkIDA7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc3luY1VwZGF0ZXMoZm4sIGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMShmbiwgYSwgYikge1xuICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgIHJldHVybiBmbihhLCBiKTtcbiAgfVxuICAvLyBJZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcywgc3luY2hyb25vdXNseSBmbHVzaCB0aGVtLlxuICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgd2UgcmVhZCBhbnkgaGFuZGxlcnMsIGJlY2F1c2UgdGhlIGVmZmVjdCBvZlxuICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgbWF5IGluZmx1ZW5jZSB3aGljaCBoYW5kbGVycyBhcmUgY2FsbGVkIGR1cmluZ1xuICAvLyB0aGlzIGV2ZW50LlxuICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZyAmJiBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgcGVyZm9ybVdvcmsobG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUsIGZhbHNlLCBudWxsKTtcbiAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHRydWU7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaEludGVyYWN0aXZlVXBkYXRlcyQxKCkge1xuICBpZiAoIWlzUmVuZGVyaW5nICYmIGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcy5cbiAgICBwZXJmb3JtV29yayhsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgZmFsc2UsIG51bGwpO1xuICAgIGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ29udHJvbGxlZChmbikge1xuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgc3luY1VwZGF0ZXMoZm4pO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgZmFsc2UsIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG4gIHJldHVybiBpc0NvbnRleHRQcm92aWRlcihmaWJlcikgPyBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSA6IHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUm9vdFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSwgY2FsbGJhY2spIHtcbiAge1xuICAgIGlmIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID09PSAncmVuZGVyJyAmJiBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG5cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50LCB1cGRhdGUsIGV4cGlyYXRpb25UaW1lKTtcblxuICBzY2hlZHVsZVdvcmskMShjdXJyZW50LCBleHBpcmF0aW9uVGltZSk7XG4gIHJldHVybiBleHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBzY2hlZHVsZVJvb3RVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQpIHtcbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0FyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50KSk7XG4gICAgfVxuICB9XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lckluZm8sIGlzQXN5bmMsIGh5ZHJhdGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGN1cnJlbnQpO1xuICByZXR1cm4gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoX2Fzc2lnbih7fSwgZGV2VG9vbHNDb25maWcsIHtcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAvLyBNaWdodCBub3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfVxuICB9KSk7XG59XG5cbi8vIFRoaXMgZmlsZSBpbnRlbnRpb25hbGx5IGRvZXMgKm5vdCogaGF2ZSB0aGUgRmxvdyBhbm5vdGF0aW9uLlxuLy8gRG9uJ3QgYWRkIGl0LiBTZWUgYC4vaW5saW5lLXR5cGVkLmpzYCBmb3IgYW4gZXhwbGFuYXRpb24uXG5cblxuXG52YXIgRE9NUmVuZGVyZXIgPSBPYmplY3QuZnJlZXplKHtcblx0dXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZTogdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZSxcblx0Y3JlYXRlQ29udGFpbmVyOiBjcmVhdGVDb250YWluZXIsXG5cdHVwZGF0ZUNvbnRhaW5lcjogdXBkYXRlQ29udGFpbmVyLFxuXHRmbHVzaFJvb3Q6IGZsdXNoUm9vdCxcblx0cmVxdWVzdFdvcms6IHJlcXVlc3RXb3JrLFxuXHRjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uLFxuXHRiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMkMSxcblx0dW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblx0ZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cdHN5bmNVcGRhdGVzOiBzeW5jVXBkYXRlcyxcblx0aW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSxcblx0Zmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM6IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzJDEsXG5cdGZsdXNoQ29udHJvbGxlZDogZmx1c2hDb250cm9sbGVkLFxuXHRmbHVzaFN5bmM6IGZsdXNoU3luYyxcblx0Z2V0UHVibGljUm9vdEluc3RhbmNlOiBnZXRQdWJsaWNSb290SW5zdGFuY2UsXG5cdGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cdGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyxcblx0aW5qZWN0SW50b0RldlRvb2xzOiBpbmplY3RJbnRvRGV2VG9vbHNcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi40LjEnO1xuXG4vLyBUT0RPOiBUaGlzIHR5cGUgaXMgc2hhcmVkIGJldHdlZW4gdGhlIHJlY29uY2lsZXIgYW5kIFJlYWN0RE9NLCBidXQgd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgb3V0IHRvIHRoZSByZW5kZXJlci5cbnZhciB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gdm9pZCAwO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCA9IGZhbHNlO1xuXG57XG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nIHx8XG4gIC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgTWFwIGhhcyBubyBwcm90b3R5cGVcbiAgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFNldCBoYXMgbm8gcHJvdG90eXBlXG4gIFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxuXG4gIHRvcExldmVsVXBkYXRlV2FybmluZ3MgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyICYmIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIuX2ludGVybmFsUm9vdC5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgIShob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyKSA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgISghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCkgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJykgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcbiAgfTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAhKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuaW5qZWN0aW9uJDIuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudChSZWFjdERPTUZpYmVyQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUmVhY3RCYXRjaChyb290KSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24oKTtcbiAgdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21wbGV0ZSA9IGZhbHNlO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICB0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX2RlZmVyID0gdHJ1ZTtcbn1cblJlYWN0QmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAhdGhpcy5fZGVmZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdiYXRjaC5yZW5kZXI6IENhbm5vdCByZW5kZXIgYSBiYXRjaCB0aGF0IGFscmVhZHkgY29tbWl0dGVkLicpIDogdm9pZCAwO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZhciBpbnRlcm5hbFJvb3QgPSB0aGlzLl9yb290Ll9pbnRlcm5hbFJvb3Q7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShjaGlsZHJlbiwgaW50ZXJuYWxSb290LCBudWxsLCBleHBpcmF0aW9uVGltZSwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdEJhdGNoLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgaWYgKHRoaXMuX2RpZENvbXBsZXRlKSB7XG4gICAgb25Db21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgY2FsbGJhY2tzLnB1c2gob25Db21wbGV0ZSk7XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5fcm9vdC5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICAhKHRoaXMuX2RlZmVyICYmIGZpcnN0QmF0Y2ggIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYmF0Y2guY29tbWl0OiBDYW5ub3QgY29tbWl0IGEgYmF0Y2ggbXVsdGlwbGUgdGltZXMuJykgOiB2b2lkIDA7XG5cbiAgaWYgKCF0aGlzLl9oYXNDaGlsZHJlbikge1xuICAgIC8vIFRoaXMgYmF0Y2ggaXMgZW1wdHkuIFJldHVybi5cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuXG4gIC8vIEVuc3VyZSB0aGlzIGlzIHRoZSBmaXJzdCBiYXRjaCBpbiB0aGUgbGlzdC5cbiAgaWYgKGZpcnN0QmF0Y2ggIT09IHRoaXMpIHtcbiAgICAvLyBUaGlzIGJhdGNoIGlzIG5vdCB0aGUgZWFybGllc3QgYmF0Y2guIFdlIG5lZWQgdG8gbW92ZSBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gVXBkYXRlIGl0cyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgdGhlIGV4cGlyYXRpb24gdGltZSBvZiB0aGUgZWFybGllc3RcbiAgICAvLyBiYXRjaCwgc28gdGhhdCB3ZSBjYW4gZmx1c2ggaXQgd2l0aG91dCBmbHVzaGluZyB0aGUgb3RoZXIgYmF0Y2hlcy5cbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBmaXJzdEJhdGNoLl9leHBpcmF0aW9uVGltZTtcbiAgICAgIC8vIFJlbmRlcmluZyB0aGlzIGJhdGNoIGFnYWluIGVuc3VyZXMgaXRzIGNoaWxkcmVuIHdpbGwgYmUgdGhlIGZpbmFsIHN0YXRlXG4gICAgICAvLyB3aGVuIHdlIGZsdXNoICh1cGRhdGVzIGFyZSBwcm9jZXNzZWQgaW4gaW5zZXJ0aW9uIG9yZGVyOiBsYXN0XG4gICAgICAvLyB1cGRhdGUgd2lucykuXG4gICAgICAvLyBUT0RPOiBUaGlzIGZvcmNlcyBhIHJlc3RhcnQuIFNob3VsZCB3ZSBwcmludCBhIHdhcm5pbmc/XG4gICAgICB0aGlzLnJlbmRlcih0aGlzLl9jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICAgIHZhciBwcmV2aW91cyA9IG51bGw7XG4gICAgdmFyIGJhdGNoID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoYmF0Y2ggIT09IHRoaXMpIHtcbiAgICAgIHByZXZpb3VzID0gYmF0Y2g7XG4gICAgICBiYXRjaCA9IGJhdGNoLl9uZXh0O1xuICAgIH1cbiAgICAhKHByZXZpb3VzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2JhdGNoLmNvbW1pdDogQ2Fubm90IGNvbW1pdCBhIGJhdGNoIG11bHRpcGxlIHRpbWVzLicpIDogdm9pZCAwO1xuICAgIHByZXZpb3VzLl9uZXh0ID0gYmF0Y2guX25leHQ7XG5cbiAgICAvLyBBZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIHRoaXMuX25leHQgPSBmaXJzdEJhdGNoO1xuICAgIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IHRoaXM7XG4gIH1cblxuICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCB0aGUgd29yayB1cCB0byB0aGlzIGJhdGNoJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICBmbHVzaFJvb3QoaW50ZXJuYWxSb290LCBleHBpcmF0aW9uVGltZSk7XG5cbiAgLy8gUG9wIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICB2YXIgbmV4dCA9IHRoaXMuX25leHQ7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2ggPSBuZXh0O1xuXG4gIC8vIEFwcGVuZCB0aGUgbmV4dCBlYXJsaWVzdCBiYXRjaCdzIGNoaWxkcmVuIHRvIHRoZSB1cGRhdGUgcXVldWUuXG4gIGlmIChmaXJzdEJhdGNoICE9PSBudWxsICYmIGZpcnN0QmF0Y2guX2hhc0NoaWxkcmVuKSB7XG4gICAgZmlyc3RCYXRjaC5yZW5kZXIoZmlyc3RCYXRjaC5fY2hpbGRyZW4pO1xuICB9XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuX29uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21wbGV0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9kaWRDb21wbGV0ZSA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICBfY2FsbGJhY2soKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RXb3JrKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21taXQgPSBmYWxzZTtcbiAgLy8gVE9ETzogQXZvaWQgbmVlZCB0byBiaW5kIGJ5IHJlcGxhY2luZyBjYWxsYmFja3MgaW4gdGhlIHVwZGF0ZSBxdWV1ZSB3aXRoXG4gIC8vIGxpc3Qgb2YgV29yayBvYmplY3RzLlxuICB0aGlzLl9vbkNvbW1pdCA9IHRoaXMuX29uQ29tbWl0LmJpbmQodGhpcyk7XG59XG5SZWFjdFdvcmsucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25Db21taXQpIHtcbiAgaWYgKHRoaXMuX2RpZENvbW1pdCkge1xuICAgIG9uQ29tbWl0KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfVxuICBjYWxsYmFja3MucHVzaChvbkNvbW1pdCk7XG59O1xuUmVhY3RXb3JrLnByb3RvdHlwZS5fb25Db21taXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tbWl0ID0gdHJ1ZTtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUT0RPOiBFcnJvciBoYW5kbGluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NhbGxiYWNrMiA9IGNhbGxiYWNrc1tpXTtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2syID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIF9jYWxsYmFjazIpIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjazIoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaXNBc3luYywgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGlzQXN5bmMsIGh5ZHJhdGUpO1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhdGNoID0gbmV3IFJlYWN0QmF0Y2godGhpcyk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGJhdGNoLl9leHBpcmF0aW9uVGltZTtcblxuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCA9PT0gbnVsbCkge1xuICAgIGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gYmF0Y2g7XG4gICAgYmF0Y2guX25leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIEluc2VydCBzb3J0ZWQgYnkgZXhwaXJhdGlvbiB0aW1lIHRoZW4gaW5zZXJ0aW9uIG9yZGVyXG4gICAgdmFyIGluc2VydEFmdGVyID0gbnVsbDtcbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoaW5zZXJ0QmVmb3JlICE9PSBudWxsICYmIGluc2VydEJlZm9yZS5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGluc2VydEFmdGVyID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlLl9uZXh0O1xuICAgIH1cbiAgICBiYXRjaC5fbmV4dCA9IGluc2VydEJlZm9yZTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgIGluc2VydEFmdGVyLl9uZXh0ID0gYmF0Y2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhdGNoO1xufTtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5pbmplY3Rpb24kMy5pbmplY3RSZW5kZXJlcihET01SZW5kZXJlcik7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUpIHtcbiAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxNy4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgfVxuICB9XG4gIC8vIExlZ2FjeSByb290cyBhcmUgbm90IGFzeW5jIGJ5IGRlZmF1bHQuXG4gIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaXNBc3luYywgc2hvdWxkSHlkcmF0ZSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlLCBjYWxsYmFjaykge1xuICAvLyBUT0RPOiBFbnN1cmUgYWxsIGVudHJ5IHBvaW50cyBjb250YWluIHRoaXMgY2hlY2tcbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgIHRvcExldmVsVXBkYXRlV2FybmluZ3MoY29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIFRPRE86IFdpdGhvdXQgYGFueWAgdHlwZSwgRmxvdyBzYXlzIFwiUHJvcGVydHkgY2Fubm90IGJlIGFjY2Vzc2VkIG9uIGFueVxuICAvLyBtZW1iZXIgb2YgaW50ZXJzZWN0aW9uIHR5cGUuXCIgV2h5eXl5eXkuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdC5faW50ZXJuYWxSb290KTtcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBhcmVudENvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICAgIHJvb3QubGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QucmVuZGVyKGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9vcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gVXBkYXRlXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICByb290LmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QucmVuZGVyKGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdC5faW50ZXJuYWxSb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbnZhciBSZWFjdERPTSA9IHtcbiAgY3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwsXG5cbiAgZmluZERPTU5vZGU6IGZ1bmN0aW9uIChjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgICB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuICAgICAgICAhd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgISFyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPyB3YXJuaW5nKGZhbHNlLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAgIC8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEoX3Jvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEoX3Jvb3RFbCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICAgICEhaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPyB3YXJuaW5nKGZhbHNlLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9LFxuXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzJDEsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfaW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSxcblxuICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICB1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQ6IGZsdXNoQ29udHJvbGxlZCxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5SZWFjdERPTS51bnN0YWJsZV9jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIHRydWUsIGh5ZHJhdGUpO1xufTtcblxudmFyIGZvdW5kRGV2VG9vbHMgPSBpbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzLmRlZmF1bHQgPyBSZWFjdERPTSQzLmRlZmF1bHQgOiBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzPzhiYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFLQztBQUNEO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.4.1\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.4.1';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for('react.timeout') : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\n// Relying on the `invariant()` implementation lets us\n// have preserve the format and params in the www builds.\n\n// Exports ReactDOM.createRoot\n\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\n\n// Suspense\nvar enableSuspense = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n// Warn about legacy context API\n\n\n// Gather advanced timing metrics for Profiler subtrees.\n\n\n// Only used in www builds.\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + '.' + callerName;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warning(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n  {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown = void 0;\nvar specialPropRefWarningShown = void 0;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName = void 0;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nfunction cloneElement(element, config, children) {\n  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;\n\n  var propName = void 0;\n\n  // Original props are copied\n  var props = _assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps = void 0;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar ReactDebugCurrentFrame = {};\n\n{\n  // Component that is being worked on\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      return impl();\n    }\n    return null;\n  };\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child = void 0;\n  var nextName = void 0;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum()) : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step = void 0;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children) {\n  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warning(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    _defaultValue: defaultValue,\n    _currentValue: defaultValue,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue2: defaultValue,\n    _changedBits: 0,\n    _changedBits2: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null\n  };\n\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  context.Consumer = context;\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nfunction forwardRef(render) {\n  {\n    !(typeof render === 'function') ? warning(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render) : void 0;\n\n    if (render != null) {\n      !(render.defaultProps == null && render.propTypes == null) ? warning(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;\n    }\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_TIMEOUT_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return 'AsyncMode';\n    case REACT_CONTEXT_TYPE:\n      return 'Context.Consumer';\n    case REACT_FRAGMENT_TYPE:\n      return 'ReactFragment';\n    case REACT_PORTAL_TYPE:\n      return 'ReactPortal';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler(' + fiber.pendingProps.id + ')';\n    case REACT_PROVIDER_TYPE:\n      return 'Context.Provider';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_TIMEOUT_TYPE:\n      return 'Timeout';\n  }\n  if (typeof type === 'object' && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        var functionName = type.render.displayName || type.render.name || '';\n        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    }\n  }\n  return null;\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nvar currentlyValidatingElement = void 0;\nvar propTypesMisspellWarningShown = void 0;\n\nvar getDisplayName = function () {};\nvar getStackAddendum = function () {};\n\n{\n  currentlyValidatingElement = null;\n\n  propTypesMisspellWarningShown = false;\n\n  getDisplayName = function (element) {\n    if (element == null) {\n      return '#empty';\n    } else if (typeof element === 'string' || typeof element === 'number') {\n      return '#text';\n    } else if (typeof element.type === 'string') {\n      return element.type;\n    }\n\n    var type = element.type;\n    if (type === REACT_FRAGMENT_TYPE) {\n      return 'React.Fragment';\n    } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {\n      var functionName = type.render.displayName || type.render.name || '';\n      return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    } else {\n      return type.displayName || type.name || 'Unknown';\n    }\n  };\n\n  getStackAddendum = function () {\n    var stack = '';\n    if (currentlyValidatingElement) {\n      var name = getDisplayName(currentlyValidatingElement);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n    }\n    stack += ReactDebugCurrentFrame.getStackAddendum() || '';\n    return stack;\n  };\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\n  }\n\n  currentlyValidatingElement = element;\n  {\n    warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());\n  }\n  currentlyValidatingElement = null;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step = void 0;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var type = element.type;\n  var name = void 0,\n      propTypes = void 0;\n  if (typeof type === 'function') {\n    // Class or functional component\n    name = type.displayName || type.name;\n    propTypes = type.propTypes;\n  } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {\n    // ForwardRef\n    var functionName = type.render.displayName || type.render.name || '';\n    name = functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    propTypes = type.propTypes;\n  } else {\n    return;\n  }\n  if (propTypes) {\n    currentlyValidatingElement = element;\n    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);\n    currentlyValidatingElement = null;\n  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n  if (typeof type.getDefaultProps === 'function') {\n    !type.getDefaultProps.isReactClassApproved ? warning(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  currentlyValidatingElement = fragment;\n\n  var keys = Object.keys(fragment.props);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'children' && key !== 'key') {\n      warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());\n  }\n\n  currentlyValidatingElement = null;\n}\n\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    var info = '';\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    info += getStackAddendum() || '';\n\n    var typeString = void 0;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  var element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  // Legacy hook: remove it\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\n\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n\n  createRef: createRef,\n  Component: Component,\n  PureComponent: PureComponent,\n\n  createContext: createContext,\n  forwardRef: forwardRef,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n  unstable_Profiler: REACT_PROFILER_TYPE,\n\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    ReactCurrentOwner: ReactCurrentOwner,\n    // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n    assign: _assign\n  }\n};\n\nif (enableSuspense) {\n  React.Timeout = REACT_TIMEOUT_TYPE;\n}\n\n{\n  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar react = React$3.default ? React$3.default : React$3;\n\nmodule.exports = react;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzPzcyZDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQSxrREFBa0Q7OztBQUdsRDs7O0FBR0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TkFBdU47QUFDdk47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjQuMVxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuNC4xJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1RJTUVPVVRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnRpbWVvdXQnKSA6IDB4ZWFkMTtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gUmVseWluZyBvbiB0aGUgYGludmFyaWFudCgpYCBpbXBsZW1lbnRhdGlvbiBsZXRzIHVzXG4vLyBoYXZlIHByZXNlcnZlIHRoZSBmb3JtYXQgYW5kIHBhcmFtcyBpbiB0aGUgd3d3IGJ1aWxkcy5cblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG5cblxuLy8gRXhwZXJpbWVudGFsIGVycm9yLWJvdW5kYXJ5IEFQSSB0aGF0IGNhbiByZWNvdmVyIGZyb20gZXJyb3JzIHdpdGhpbiBhIHNpbmdsZVxuLy8gcmVuZGVyIHBoYXNlXG5cbi8vIFN1c3BlbnNlXG52YXIgZW5hYmxlU3VzcGVuc2UgPSBmYWxzZTtcbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxuXG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcblxuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxuXG5cbi8vIEdhdGhlciBhZHZhbmNlZCB0aW1pbmcgbWV0cmljcyBmb3IgUHJvZmlsZXIgc3VidHJlZXMuXG5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkICVzLicsIGVsZW1lbnQpIDogdm9pZCAwO1xuXG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMDtcbiAgdmFyIG5leHROYW1lID0gdm9pZCAwO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgIShjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyhmYWxzZSwgJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgX2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY2hhbmdlZEJpdHM6IDAsXG4gICAgX2NoYW5nZWRCaXRzMjogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuXG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgY29udGV4dC5Db25zdW1lciA9IGNvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgICEodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpIDogdm9pZCAwO1xuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICAhKHJlbmRlci5kZWZhdWx0UHJvcHMgPT0gbnVsbCAmJiByZW5kZXIucHJvcFR5cGVzID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/JykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfVElNRU9VVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnQXN5bmNNb2RlJztcbiAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dC5Db25zdW1lcic7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdEZyYWdtZW50JztcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdFBvcnRhbCc7XG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcignICsgZmliZXIucGVuZGluZ1Byb3BzLmlkICsgJyknO1xuICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICBjYXNlIFJFQUNUX1RJTUVPVVRfVFlQRTpcbiAgICAgIHJldHVybiAnVGltZW91dCc7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0eXBlLnJlbmRlci5kaXNwbGF5TmFtZSB8fCB0eXBlLnJlbmRlci5uYW1lIHx8ICcnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/ICdGb3J3YXJkUmVmKCcgKyBmdW5jdGlvbk5hbWUgKyAnKScgOiAnRm9yd2FyZFJlZic7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG52YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSB2b2lkIDA7XG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbnZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xudmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgcmV0dXJuICdSZWFjdC5GcmFnbWVudCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdHlwZS5yZW5kZXIuZGlzcGxheU5hbWUgfHwgdHlwZS5yZW5kZXIubmFtZSB8fCAnJztcbiAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJztcbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyKSk7XG4gICAgfVxuICAgIHN0YWNrICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIpICsgJy4nO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcCA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIG5hbWUgPSB2b2lkIDAsXG4gICAgICBwcm9wVHlwZXMgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIENsYXNzIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgbmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAvLyBGb3J3YXJkUmVmXG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgbmFtZSA9IGZ1bmN0aW9uTmFtZSAhPT0gJycgPyAnRm9yd2FyZFJlZignICsgZnVuY3Rpb25OYW1lICsgJyknIDogJ0ZvcndhcmRSZWYnO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvcFR5cGVzKSB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKTtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID8gd2FybmluZyhmYWxzZSwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGZyYWdtZW50O1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7XG5cbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB2YXIgdHlwZVN0cmluZyA9IHZvaWQgMDtcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuICAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBjcmVhdGVSZWY6IGNyZWF0ZVJlZixcbiAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcbiAgZm9yd2FyZFJlZjogZm9yd2FyZFJlZixcblxuICBGcmFnbWVudDogUkVBQ1RfRlJBR01FTlRfVFlQRSxcbiAgU3RyaWN0TW9kZTogUkVBQ1RfU1RSSUNUX01PREVfVFlQRSxcbiAgdW5zdGFibGVfQXN5bmNNb2RlOiBSRUFDVF9BU1lOQ19NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX1Byb2ZpbGVyOiBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbmlmIChlbmFibGVTdXNwZW5zZSkge1xuICBSZWFjdC5UaW1lb3V0ID0gUkVBQ1RfVElNRU9VVF9UWVBFO1xufVxuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkMy5kZWZhdWx0ID8gUmVhY3QkMy5kZWZhdWx0IDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxhQUVDO0FBQ0Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-hot-middleware/client-overlay.js":
/*!**************************************************!*\
  !*** (webpack)-hot-middleware/client-overlay.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*eslint-env browser*/\n\nvar clientOverlay = document.createElement('div');\nclientOverlay.id = 'webpack-hot-middleware-clientOverlay';\nvar styles = {\n  background: 'rgba(0,0,0,0.85)',\n  color: '#E8E8E8',\n  lineHeight: '1.2',\n  whiteSpace: 'pre',\n  fontFamily: 'Menlo, Consolas, monospace',\n  fontSize: '13px',\n  position: 'fixed',\n  zIndex: 9999,\n  padding: '10px',\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  overflow: 'auto',\n  dir: 'ltr',\n  textAlign: 'left'\n};\n\nvar ansiHTML = __webpack_require__(/*! ansi-html */ \"./node_modules/ansi-html/index.js\");\nvar colors = {\n  reset: ['transparent', 'transparent'],\n  black: '181818',\n  red: 'E36049',\n  green: 'B3CB74',\n  yellow: 'FFD080',\n  blue: '7CAFC2',\n  magenta: '7FACCA',\n  cyan: 'C3C2EF',\n  lightgrey: 'EBE7E3',\n  darkgrey: '6D7891'\n};\n\nvar Entities = __webpack_require__(/*! html-entities */ \"./node_modules/html-entities/index.js\").AllHtmlEntities;\nvar entities = new Entities();\n\nfunction showProblems(type, lines) {\n  clientOverlay.innerHTML = '';\n  lines.forEach(function(msg) {\n    msg = ansiHTML(entities.encode(msg));\n    var div = document.createElement('div');\n    div.style.marginBottom = '26px';\n    div.innerHTML = problemType(type) + ' in ' + msg;\n    clientOverlay.appendChild(div);\n  });\n  if (document.body) {\n    document.body.appendChild(clientOverlay);\n  }\n}\n\nfunction clear() {\n  if (document.body && clientOverlay.parentNode) {\n    document.body.removeChild(clientOverlay);\n  }\n}\n\nfunction problemType (type) {\n  var problemColors = {\n    errors: colors.red,\n    warnings: colors.yellow\n  };\n  var color = problemColors[type] || colors.red;\n  return (\n    '<span style=\"background-color:#' + color + '; color:#fff; padding:2px 4px; border-radius: 2px\">' +\n      type.slice(0, -1).toUpperCase() +\n    '</span>'\n  );\n}\n\nmodule.exports = function(options) {\n  for (var color in options.overlayColors) {\n    if (color in colors) {\n      colors[color] = options.overlayColors[color];\n    }\n    ansiHTML.setColors(colors);\n  }\n\n  for (var style in options.overlayStyles) {\n    styles[style] = options.overlayStyles[style];\n  }\n\n  for (var key in styles) {\n    clientOverlay.style[key] = styles[key];\n  }\n\n  return {\n    showProblems: showProblems,\n    clear: clear\n  }\n};\n\nmodule.exports.clear = clear;\nmodule.exports.showProblems = showProblems;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWhvdC1taWRkbGV3YXJlL2NsaWVudC1vdmVybGF5LmpzP2M3YTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZLGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy93ZWJwYWNrLWhvdC1taWRkbGV3YXJlL2NsaWVudC1vdmVybGF5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyplc2xpbnQtZW52IGJyb3dzZXIqL1xuXG52YXIgY2xpZW50T3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuY2xpZW50T3ZlcmxheS5pZCA9ICd3ZWJwYWNrLWhvdC1taWRkbGV3YXJlLWNsaWVudE92ZXJsYXknO1xudmFyIHN0eWxlcyA9IHtcbiAgYmFja2dyb3VuZDogJ3JnYmEoMCwwLDAsMC44NSknLFxuICBjb2xvcjogJyNFOEU4RTgnLFxuICBsaW5lSGVpZ2h0OiAnMS4yJyxcbiAgd2hpdGVTcGFjZTogJ3ByZScsXG4gIGZvbnRGYW1pbHk6ICdNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZScsXG4gIGZvbnRTaXplOiAnMTNweCcsXG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB6SW5kZXg6IDk5OTksXG4gIHBhZGRpbmc6ICcxMHB4JyxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICBvdmVyZmxvdzogJ2F1dG8nLFxuICBkaXI6ICdsdHInLFxuICB0ZXh0QWxpZ246ICdsZWZ0J1xufTtcblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xuXG52YXIgRW50aXRpZXMgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJykuQWxsSHRtbEVudGl0aWVzO1xudmFyIGVudGl0aWVzID0gbmV3IEVudGl0aWVzKCk7XG5cbmZ1bmN0aW9uIHNob3dQcm9ibGVtcyh0eXBlLCBsaW5lcykge1xuICBjbGllbnRPdmVybGF5LmlubmVySFRNTCA9ICcnO1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKG1zZykge1xuICAgIG1zZyA9IGFuc2lIVE1MKGVudGl0aWVzLmVuY29kZShtc2cpKTtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcyNnB4JztcbiAgICBkaXYuaW5uZXJIVE1MID0gcHJvYmxlbVR5cGUodHlwZSkgKyAnIGluICcgKyBtc2c7XG4gICAgY2xpZW50T3ZlcmxheS5hcHBlbmRDaGlsZChkaXYpO1xuICB9KTtcbiAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsaWVudE92ZXJsYXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBpZiAoZG9jdW1lbnQuYm9keSAmJiBjbGllbnRPdmVybGF5LnBhcmVudE5vZGUpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsaWVudE92ZXJsYXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2JsZW1UeXBlICh0eXBlKSB7XG4gIHZhciBwcm9ibGVtQ29sb3JzID0ge1xuICAgIGVycm9yczogY29sb3JzLnJlZCxcbiAgICB3YXJuaW5nczogY29sb3JzLnllbGxvd1xuICB9O1xuICB2YXIgY29sb3IgPSBwcm9ibGVtQ29sb3JzW3R5cGVdIHx8IGNvbG9ycy5yZWQ7XG4gIHJldHVybiAoXG4gICAgJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojJyArIGNvbG9yICsgJzsgY29sb3I6I2ZmZjsgcGFkZGluZzoycHggNHB4OyBib3JkZXItcmFkaXVzOiAycHhcIj4nICtcbiAgICAgIHR5cGUuc2xpY2UoMCwgLTEpLnRvVXBwZXJDYXNlKCkgK1xuICAgICc8L3NwYW4+J1xuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgY29sb3IgaW4gb3B0aW9ucy5vdmVybGF5Q29sb3JzKSB7XG4gICAgaWYgKGNvbG9yIGluIGNvbG9ycykge1xuICAgICAgY29sb3JzW2NvbG9yXSA9IG9wdGlvbnMub3ZlcmxheUNvbG9yc1tjb2xvcl07XG4gICAgfVxuICAgIGFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuICB9XG5cbiAgZm9yICh2YXIgc3R5bGUgaW4gb3B0aW9ucy5vdmVybGF5U3R5bGVzKSB7XG4gICAgc3R5bGVzW3N0eWxlXSA9IG9wdGlvbnMub3ZlcmxheVN0eWxlc1tzdHlsZV07XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgY2xpZW50T3ZlcmxheS5zdHlsZVtrZXldID0gc3R5bGVzW2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNob3dQcm9ibGVtczogc2hvd1Byb2JsZW1zLFxuICAgIGNsZWFyOiBjbGVhclxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jbGVhciA9IGNsZWFyO1xubW9kdWxlLmV4cG9ydHMuc2hvd1Byb2JsZW1zID0gc2hvd1Byb2JsZW1zO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-hot-middleware/client-overlay.js\n");

/***/ }),

/***/ "./node_modules/webpack-hot-middleware/client.js?path=/__webpack_hmr&timeout=20000&reload=true":
/*!****************************************************************************************!*\
  !*** (webpack)-hot-middleware/client.js?path=/__webpack_hmr&timeout=20000&reload=true ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__resourceQuery, module) {/*eslint-env browser*/\n/*global __resourceQuery __webpack_public_path__*/\n\nvar options = {\n  path: \"/__webpack_hmr\",\n  timeout: 20 * 1000,\n  overlay: true,\n  reload: false,\n  log: true,\n  warn: true,\n  name: '',\n  autoConnect: true,\n  overlayStyles: {},\n  overlayWarnings: false,\n  ansiColors: {}\n};\nif (true) {\n  var querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring-es3/index.js\");\n  var overrides = querystring.parse(__resourceQuery.slice(1));\n  setOverrides(overrides);\n}\n\nif (typeof window === 'undefined') {\n  // do nothing\n} else if (typeof window.EventSource === 'undefined') {\n  console.warn(\n    \"webpack-hot-middleware's client requires EventSource to work. \" +\n    \"You should include a polyfill if you want to support this browser: \" +\n    \"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools\"\n  );\n} else {\n  if (options.autoConnect) {\n    connect();\n  }\n}\n\n/* istanbul ignore next */\nfunction setOptionsAndConnect(overrides) {\n  setOverrides(overrides);\n  connect();\n}\n\nfunction setOverrides(overrides) {\n  if (overrides.autoConnect) options.autoConnect = overrides.autoConnect == 'true';\n  if (overrides.path) options.path = overrides.path;\n  if (overrides.timeout) options.timeout = overrides.timeout;\n  if (overrides.overlay) options.overlay = overrides.overlay !== 'false';\n  if (overrides.reload) options.reload = overrides.reload !== 'false';\n  if (overrides.noInfo && overrides.noInfo !== 'false') {\n    options.log = false;\n  }\n  if (overrides.name) {\n    options.name = overrides.name;\n  }\n  if (overrides.quiet && overrides.quiet !== 'false') {\n    options.log = false;\n    options.warn = false;\n  }\n\n  if (overrides.dynamicPublicPath) {\n    options.path = __webpack_require__.p + options.path;\n  }\n\n  if (overrides.ansiColors) options.ansiColors = JSON.parse(overrides.ansiColors);\n  if (overrides.overlayStyles) options.overlayStyles = JSON.parse(overrides.overlayStyles);\n\n  if (overrides.overlayWarnings) {\n    options.overlayWarnings = overrides.overlayWarnings == 'true';\n  }\n}\n\nfunction EventSourceWrapper() {\n  var source;\n  var lastActivity = new Date();\n  var listeners = [];\n\n  init();\n  var timer = setInterval(function() {\n    if ((new Date() - lastActivity) > options.timeout) {\n      handleDisconnect();\n    }\n  }, options.timeout / 2);\n\n  function init() {\n    source = new window.EventSource(options.path);\n    source.onopen = handleOnline;\n    source.onerror = handleDisconnect;\n    source.onmessage = handleMessage;\n  }\n\n  function handleOnline() {\n    if (options.log) console.log(\"[HMR] connected\");\n    lastActivity = new Date();\n  }\n\n  function handleMessage(event) {\n    lastActivity = new Date();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i](event);\n    }\n  }\n\n  function handleDisconnect() {\n    clearInterval(timer);\n    source.close();\n    setTimeout(init, options.timeout);\n  }\n\n  return {\n    addMessageListener: function(fn) {\n      listeners.push(fn);\n    }\n  };\n}\n\nfunction getEventSourceWrapper() {\n  if (!window.__whmEventSourceWrapper) {\n    window.__whmEventSourceWrapper = {};\n  }\n  if (!window.__whmEventSourceWrapper[options.path]) {\n    // cache the wrapper for other entries loaded on\n    // the same page with the same options.path\n    window.__whmEventSourceWrapper[options.path] = EventSourceWrapper();\n  }\n  return window.__whmEventSourceWrapper[options.path];\n}\n\nfunction connect() {\n  getEventSourceWrapper().addMessageListener(handleMessage);\n\n  function handleMessage(event) {\n    if (event.data == \"\\uD83D\\uDC93\") {\n      return;\n    }\n    try {\n      processMessage(JSON.parse(event.data));\n    } catch (ex) {\n      if (options.warn) {\n        console.warn(\"Invalid HMR message: \" + event.data + \"\\n\" + ex);\n      }\n    }\n  }\n}\n\n// the reporter needs to be a singleton on the page\n// in case the client is being used by multiple bundles\n// we only want to report once.\n// all the errors will go to all clients\nvar singletonKey = '__webpack_hot_middleware_reporter__';\nvar reporter;\nif (typeof window !== 'undefined') {\n  if (!window[singletonKey]) {\n    window[singletonKey] = createReporter();\n  }\n  reporter = window[singletonKey];\n}\n\nfunction createReporter() {\n  var strip = __webpack_require__(/*! strip-ansi */ \"./node_modules/webpack-hot-middleware/node_modules/strip-ansi/index.js\");\n\n  var overlay;\n  if (typeof document !== 'undefined' && options.overlay) {\n    overlay = __webpack_require__(/*! ./client-overlay */ \"./node_modules/webpack-hot-middleware/client-overlay.js\")({\n      ansiColors: options.ansiColors,\n      overlayStyles: options.overlayStyles\n    });\n  }\n\n  var styles = {\n    errors: \"color: #ff0000;\",\n    warnings: \"color: #999933;\"\n  };\n  var previousProblems = null;\n  function log(type, obj) {\n    var newProblems = obj[type].map(function(msg) { return strip(msg); }).join('\\n');\n    if (previousProblems == newProblems) {\n      return;\n    } else {\n      previousProblems = newProblems;\n    }\n\n    var style = styles[type];\n    var name = obj.name ? \"'\" + obj.name + \"' \" : \"\";\n    var title = \"[HMR] bundle \" + name + \"has \" + obj[type].length + \" \" + type;\n    // NOTE: console.warn or console.error will print the stack trace\n    // which isn't helpful here, so using console.log to escape it.\n    if (console.group && console.groupEnd) {\n      console.group(\"%c\" + title, style);\n      console.log(\"%c\" + newProblems, style);\n      console.groupEnd();\n    } else {\n      console.log(\n        \"%c\" + title + \"\\n\\t%c\" + newProblems.replace(/\\n/g, \"\\n\\t\"),\n        style + \"font-weight: bold;\",\n        style + \"font-weight: normal;\"\n      );\n    }\n  }\n\n  return {\n    cleanProblemsCache: function () {\n      previousProblems = null;\n    },\n    problems: function(type, obj) {\n      if (options.warn) {\n        log(type, obj);\n      }\n      if (overlay) {\n        if (options.overlayWarnings || type === 'errors') {\n          overlay.showProblems(type, obj[type]);\n          return false;\n        }\n        overlay.clear();\n      }\n      return true;\n    },\n    success: function() {\n      if (overlay) overlay.clear();\n    },\n    useCustomOverlay: function(customOverlay) {\n      overlay = customOverlay;\n    }\n  };\n}\n\nvar processUpdate = __webpack_require__(/*! ./process-update */ \"./node_modules/webpack-hot-middleware/process-update.js\");\n\nvar customHandler;\nvar subscribeAllHandler;\nfunction processMessage(obj) {\n  switch(obj.action) {\n    case \"building\":\n      if (options.log) {\n        console.log(\n          \"[HMR] bundle \" + (obj.name ? \"'\" + obj.name + \"' \" : \"\") +\n          \"rebuilding\"\n        );\n      }\n      break;\n    case \"built\":\n      if (options.log) {\n        console.log(\n          \"[HMR] bundle \" + (obj.name ? \"'\" + obj.name + \"' \" : \"\") +\n          \"rebuilt in \" + obj.time + \"ms\"\n        );\n      }\n      // fall through\n    case \"sync\":\n      if (obj.name && options.name && obj.name !== options.name) {\n        return;\n      }\n      var applyUpdate = true;\n      if (obj.errors.length > 0) {\n        if (reporter) reporter.problems('errors', obj);\n        applyUpdate = false;\n      } else if (obj.warnings.length > 0) {\n        if (reporter) {\n          var overlayShown = reporter.problems('warnings', obj);\n          applyUpdate = overlayShown;\n        }\n      } else {\n        if (reporter) {\n          reporter.cleanProblemsCache();\n          reporter.success();\n        }\n      }\n      if (applyUpdate) {\n        processUpdate(obj.hash, obj.modules, options);\n      }\n      break;\n    default:\n      if (customHandler) {\n        customHandler(obj);\n      }\n  }\n\n  if (subscribeAllHandler) {\n    subscribeAllHandler(obj);\n  }\n}\n\nif (module) {\n  module.exports = {\n    subscribeAll: function subscribeAll(handler) {\n      subscribeAllHandler = handler;\n    },\n    subscribe: function subscribe(handler) {\n      customHandler = handler;\n    },\n    useCustomOverlay: function useCustomOverlay(customOverlay) {\n      if (reporter) reporter.useCustomOverlay(customOverlay);\n    },\n    setOptionsAndConnect: setOptionsAndConnect\n  };\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"?path=/__webpack_hmr&timeout=20000&reload=true\", __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWhvdC1taWRkbGV3YXJlL2NsaWVudC5qcz83NGEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUJBQW1CLEVBQUU7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2staG90LW1pZGRsZXdhcmUvY2xpZW50LmpzP3BhdGg9L19fd2VicGFja19obXImdGltZW91dD0yMDAwMCZyZWxvYWQ9dHJ1ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZXNsaW50LWVudiBicm93c2VyKi9cbi8qZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyovXG5cbnZhciBvcHRpb25zID0ge1xuICBwYXRoOiBcIi9fX3dlYnBhY2tfaG1yXCIsXG4gIHRpbWVvdXQ6IDIwICogMTAwMCxcbiAgb3ZlcmxheTogdHJ1ZSxcbiAgcmVsb2FkOiBmYWxzZSxcbiAgbG9nOiB0cnVlLFxuICB3YXJuOiB0cnVlLFxuICBuYW1lOiAnJyxcbiAgYXV0b0Nvbm5lY3Q6IHRydWUsXG4gIG92ZXJsYXlTdHlsZXM6IHt9LFxuICBvdmVybGF5V2FybmluZ3M6IGZhbHNlLFxuICBhbnNpQ29sb3JzOiB7fVxufTtcbmlmIChfX3Jlc291cmNlUXVlcnkpIHtcbiAgdmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbiAgdmFyIG92ZXJyaWRlcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKF9fcmVzb3VyY2VRdWVyeS5zbGljZSgxKSk7XG4gIHNldE92ZXJyaWRlcyhvdmVycmlkZXMpO1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZG8gbm90aGluZ1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93LkV2ZW50U291cmNlID09PSAndW5kZWZpbmVkJykge1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJ3ZWJwYWNrLWhvdC1taWRkbGV3YXJlJ3MgY2xpZW50IHJlcXVpcmVzIEV2ZW50U291cmNlIHRvIHdvcmsuIFwiICtcbiAgICBcIllvdSBzaG91bGQgaW5jbHVkZSBhIHBvbHlmaWxsIGlmIHlvdSB3YW50IHRvIHN1cHBvcnQgdGhpcyBicm93c2VyOiBcIiArXG4gICAgXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmVyLXNlbnRfZXZlbnRzI1Rvb2xzXCJcbiAgKTtcbn0gZWxzZSB7XG4gIGlmIChvcHRpb25zLmF1dG9Db25uZWN0KSB7XG4gICAgY29ubmVjdCgpO1xuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBzZXRPcHRpb25zQW5kQ29ubmVjdChvdmVycmlkZXMpIHtcbiAgc2V0T3ZlcnJpZGVzKG92ZXJyaWRlcyk7XG4gIGNvbm5lY3QoKTtcbn1cblxuZnVuY3Rpb24gc2V0T3ZlcnJpZGVzKG92ZXJyaWRlcykge1xuICBpZiAob3ZlcnJpZGVzLmF1dG9Db25uZWN0KSBvcHRpb25zLmF1dG9Db25uZWN0ID0gb3ZlcnJpZGVzLmF1dG9Db25uZWN0ID09ICd0cnVlJztcbiAgaWYgKG92ZXJyaWRlcy5wYXRoKSBvcHRpb25zLnBhdGggPSBvdmVycmlkZXMucGF0aDtcbiAgaWYgKG92ZXJyaWRlcy50aW1lb3V0KSBvcHRpb25zLnRpbWVvdXQgPSBvdmVycmlkZXMudGltZW91dDtcbiAgaWYgKG92ZXJyaWRlcy5vdmVybGF5KSBvcHRpb25zLm92ZXJsYXkgPSBvdmVycmlkZXMub3ZlcmxheSAhPT0gJ2ZhbHNlJztcbiAgaWYgKG92ZXJyaWRlcy5yZWxvYWQpIG9wdGlvbnMucmVsb2FkID0gb3ZlcnJpZGVzLnJlbG9hZCAhPT0gJ2ZhbHNlJztcbiAgaWYgKG92ZXJyaWRlcy5ub0luZm8gJiYgb3ZlcnJpZGVzLm5vSW5mbyAhPT0gJ2ZhbHNlJykge1xuICAgIG9wdGlvbnMubG9nID0gZmFsc2U7XG4gIH1cbiAgaWYgKG92ZXJyaWRlcy5uYW1lKSB7XG4gICAgb3B0aW9ucy5uYW1lID0gb3ZlcnJpZGVzLm5hbWU7XG4gIH1cbiAgaWYgKG92ZXJyaWRlcy5xdWlldCAmJiBvdmVycmlkZXMucXVpZXQgIT09ICdmYWxzZScpIHtcbiAgICBvcHRpb25zLmxvZyA9IGZhbHNlO1xuICAgIG9wdGlvbnMud2FybiA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKG92ZXJyaWRlcy5keW5hbWljUHVibGljUGF0aCkge1xuICAgIG9wdGlvbnMucGF0aCA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgb3B0aW9ucy5wYXRoO1xuICB9XG5cbiAgaWYgKG92ZXJyaWRlcy5hbnNpQ29sb3JzKSBvcHRpb25zLmFuc2lDb2xvcnMgPSBKU09OLnBhcnNlKG92ZXJyaWRlcy5hbnNpQ29sb3JzKTtcbiAgaWYgKG92ZXJyaWRlcy5vdmVybGF5U3R5bGVzKSBvcHRpb25zLm92ZXJsYXlTdHlsZXMgPSBKU09OLnBhcnNlKG92ZXJyaWRlcy5vdmVybGF5U3R5bGVzKTtcblxuICBpZiAob3ZlcnJpZGVzLm92ZXJsYXlXYXJuaW5ncykge1xuICAgIG9wdGlvbnMub3ZlcmxheVdhcm5pbmdzID0gb3ZlcnJpZGVzLm92ZXJsYXlXYXJuaW5ncyA9PSAndHJ1ZSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VXcmFwcGVyKCkge1xuICB2YXIgc291cmNlO1xuICB2YXIgbGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIGluaXQoKTtcbiAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgaWYgKChuZXcgRGF0ZSgpIC0gbGFzdEFjdGl2aXR5KSA+IG9wdGlvbnMudGltZW91dCkge1xuICAgICAgaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfSwgb3B0aW9ucy50aW1lb3V0IC8gMik7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBzb3VyY2UgPSBuZXcgd2luZG93LkV2ZW50U291cmNlKG9wdGlvbnMucGF0aCk7XG4gICAgc291cmNlLm9ub3BlbiA9IGhhbmRsZU9ubGluZTtcbiAgICBzb3VyY2Uub25lcnJvciA9IGhhbmRsZURpc2Nvbm5lY3Q7XG4gICAgc291cmNlLm9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVPbmxpbmUoKSB7XG4gICAgaWYgKG9wdGlvbnMubG9nKSBjb25zb2xlLmxvZyhcIltITVJdIGNvbm5lY3RlZFwiKTtcbiAgICBsYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICBzb3VyY2UuY2xvc2UoKTtcbiAgICBzZXRUaW1lb3V0KGluaXQsIG9wdGlvbnMudGltZW91dCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGZuKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50U291cmNlV3JhcHBlcigpIHtcbiAgaWYgKCF3aW5kb3cuX193aG1FdmVudFNvdXJjZVdyYXBwZXIpIHtcbiAgICB3aW5kb3cuX193aG1FdmVudFNvdXJjZVdyYXBwZXIgPSB7fTtcbiAgfVxuICBpZiAoIXdpbmRvdy5fX3dobUV2ZW50U291cmNlV3JhcHBlcltvcHRpb25zLnBhdGhdKSB7XG4gICAgLy8gY2FjaGUgdGhlIHdyYXBwZXIgZm9yIG90aGVyIGVudHJpZXMgbG9hZGVkIG9uXG4gICAgLy8gdGhlIHNhbWUgcGFnZSB3aXRoIHRoZSBzYW1lIG9wdGlvbnMucGF0aFxuICAgIHdpbmRvdy5fX3dobUV2ZW50U291cmNlV3JhcHBlcltvcHRpb25zLnBhdGhdID0gRXZlbnRTb3VyY2VXcmFwcGVyKCk7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5fX3dobUV2ZW50U291cmNlV3JhcHBlcltvcHRpb25zLnBhdGhdO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0KCkge1xuICBnZXRFdmVudFNvdXJjZVdyYXBwZXIoKS5hZGRNZXNzYWdlTGlzdGVuZXIoaGFuZGxlTWVzc2FnZSk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhID09IFwiXFx1RDgzRFxcdURDOTNcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcHJvY2Vzc01lc3NhZ2UoSlNPTi5wYXJzZShldmVudC5kYXRhKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBITVIgbWVzc2FnZTogXCIgKyBldmVudC5kYXRhICsgXCJcXG5cIiArIGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlcG9ydGVyIG5lZWRzIHRvIGJlIGEgc2luZ2xldG9uIG9uIHRoZSBwYWdlXG4vLyBpbiBjYXNlIHRoZSBjbGllbnQgaXMgYmVpbmcgdXNlZCBieSBtdWx0aXBsZSBidW5kbGVzXG4vLyB3ZSBvbmx5IHdhbnQgdG8gcmVwb3J0IG9uY2UuXG4vLyBhbGwgdGhlIGVycm9ycyB3aWxsIGdvIHRvIGFsbCBjbGllbnRzXG52YXIgc2luZ2xldG9uS2V5ID0gJ19fd2VicGFja19ob3RfbWlkZGxld2FyZV9yZXBvcnRlcl9fJztcbnZhciByZXBvcnRlcjtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAoIXdpbmRvd1tzaW5nbGV0b25LZXldKSB7XG4gICAgd2luZG93W3NpbmdsZXRvbktleV0gPSBjcmVhdGVSZXBvcnRlcigpO1xuICB9XG4gIHJlcG9ydGVyID0gd2luZG93W3NpbmdsZXRvbktleV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcG9ydGVyKCkge1xuICB2YXIgc3RyaXAgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbiAgdmFyIG92ZXJsYXk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMub3ZlcmxheSkge1xuICAgIG92ZXJsYXkgPSByZXF1aXJlKCcuL2NsaWVudC1vdmVybGF5Jykoe1xuICAgICAgYW5zaUNvbG9yczogb3B0aW9ucy5hbnNpQ29sb3JzLFxuICAgICAgb3ZlcmxheVN0eWxlczogb3B0aW9ucy5vdmVybGF5U3R5bGVzXG4gICAgfSk7XG4gIH1cblxuICB2YXIgc3R5bGVzID0ge1xuICAgIGVycm9yczogXCJjb2xvcjogI2ZmMDAwMDtcIixcbiAgICB3YXJuaW5nczogXCJjb2xvcjogIzk5OTkzMztcIlxuICB9O1xuICB2YXIgcHJldmlvdXNQcm9ibGVtcyA9IG51bGw7XG4gIGZ1bmN0aW9uIGxvZyh0eXBlLCBvYmopIHtcbiAgICB2YXIgbmV3UHJvYmxlbXMgPSBvYmpbdHlwZV0ubWFwKGZ1bmN0aW9uKG1zZykgeyByZXR1cm4gc3RyaXAobXNnKTsgfSkuam9pbignXFxuJyk7XG4gICAgaWYgKHByZXZpb3VzUHJvYmxlbXMgPT0gbmV3UHJvYmxlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNQcm9ibGVtcyA9IG5ld1Byb2JsZW1zO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHN0eWxlc1t0eXBlXTtcbiAgICB2YXIgbmFtZSA9IG9iai5uYW1lID8gXCInXCIgKyBvYmoubmFtZSArIFwiJyBcIiA6IFwiXCI7XG4gICAgdmFyIHRpdGxlID0gXCJbSE1SXSBidW5kbGUgXCIgKyBuYW1lICsgXCJoYXMgXCIgKyBvYmpbdHlwZV0ubGVuZ3RoICsgXCIgXCIgKyB0eXBlO1xuICAgIC8vIE5PVEU6IGNvbnNvbGUud2FybiBvciBjb25zb2xlLmVycm9yIHdpbGwgcHJpbnQgdGhlIHN0YWNrIHRyYWNlXG4gICAgLy8gd2hpY2ggaXNuJ3QgaGVscGZ1bCBoZXJlLCBzbyB1c2luZyBjb25zb2xlLmxvZyB0byBlc2NhcGUgaXQuXG4gICAgaWYgKGNvbnNvbGUuZ3JvdXAgJiYgY29uc29sZS5ncm91cEVuZCkge1xuICAgICAgY29uc29sZS5ncm91cChcIiVjXCIgKyB0aXRsZSwgc3R5bGUpO1xuICAgICAgY29uc29sZS5sb2coXCIlY1wiICsgbmV3UHJvYmxlbXMsIHN0eWxlKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiJWNcIiArIHRpdGxlICsgXCJcXG5cXHQlY1wiICsgbmV3UHJvYmxlbXMucmVwbGFjZSgvXFxuL2csIFwiXFxuXFx0XCIpLFxuICAgICAgICBzdHlsZSArIFwiZm9udC13ZWlnaHQ6IGJvbGQ7XCIsXG4gICAgICAgIHN0eWxlICsgXCJmb250LXdlaWdodDogbm9ybWFsO1wiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYW5Qcm9ibGVtc0NhY2hlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBwcmV2aW91c1Byb2JsZW1zID0gbnVsbDtcbiAgICB9LFxuICAgIHByb2JsZW1zOiBmdW5jdGlvbih0eXBlLCBvYmopIHtcbiAgICAgIGlmIChvcHRpb25zLndhcm4pIHtcbiAgICAgICAgbG9nKHR5cGUsIG9iaik7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdmVybGF5V2FybmluZ3MgfHwgdHlwZSA9PT0gJ2Vycm9ycycpIHtcbiAgICAgICAgICBvdmVybGF5LnNob3dQcm9ibGVtcyh0eXBlLCBvYmpbdHlwZV0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9LFxuICAgIHVzZUN1c3RvbU92ZXJsYXk6IGZ1bmN0aW9uKGN1c3RvbU92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkgPSBjdXN0b21PdmVybGF5O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHByb2Nlc3NVcGRhdGUgPSByZXF1aXJlKCcuL3Byb2Nlc3MtdXBkYXRlJyk7XG5cbnZhciBjdXN0b21IYW5kbGVyO1xudmFyIHN1YnNjcmliZUFsbEhhbmRsZXI7XG5mdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShvYmopIHtcbiAgc3dpdGNoKG9iai5hY3Rpb24pIHtcbiAgICBjYXNlIFwiYnVpbGRpbmdcIjpcbiAgICAgIGlmIChvcHRpb25zLmxvZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIltITVJdIGJ1bmRsZSBcIiArIChvYmoubmFtZSA/IFwiJ1wiICsgb2JqLm5hbWUgKyBcIicgXCIgOiBcIlwiKSArXG4gICAgICAgICAgXCJyZWJ1aWxkaW5nXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJidWlsdFwiOlxuICAgICAgaWYgKG9wdGlvbnMubG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiW0hNUl0gYnVuZGxlIFwiICsgKG9iai5uYW1lID8gXCInXCIgKyBvYmoubmFtZSArIFwiJyBcIiA6IFwiXCIpICtcbiAgICAgICAgICBcInJlYnVpbHQgaW4gXCIgKyBvYmoudGltZSArIFwibXNcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgY2FzZSBcInN5bmNcIjpcbiAgICAgIGlmIChvYmoubmFtZSAmJiBvcHRpb25zLm5hbWUgJiYgb2JqLm5hbWUgIT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXBwbHlVcGRhdGUgPSB0cnVlO1xuICAgICAgaWYgKG9iai5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAocmVwb3J0ZXIpIHJlcG9ydGVyLnByb2JsZW1zKCdlcnJvcnMnLCBvYmopO1xuICAgICAgICBhcHBseVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChvYmoud2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAocmVwb3J0ZXIpIHtcbiAgICAgICAgICB2YXIgb3ZlcmxheVNob3duID0gcmVwb3J0ZXIucHJvYmxlbXMoJ3dhcm5pbmdzJywgb2JqKTtcbiAgICAgICAgICBhcHBseVVwZGF0ZSA9IG92ZXJsYXlTaG93bjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcG9ydGVyKSB7XG4gICAgICAgICAgcmVwb3J0ZXIuY2xlYW5Qcm9ibGVtc0NhY2hlKCk7XG4gICAgICAgICAgcmVwb3J0ZXIuc3VjY2VzcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXBwbHlVcGRhdGUpIHtcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZShvYmouaGFzaCwgb2JqLm1vZHVsZXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjdXN0b21IYW5kbGVyKSB7XG4gICAgICAgIGN1c3RvbUhhbmRsZXIob2JqKTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChzdWJzY3JpYmVBbGxIYW5kbGVyKSB7XG4gICAgc3Vic2NyaWJlQWxsSGFuZGxlcihvYmopO1xuICB9XG59XG5cbmlmIChtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3Vic2NyaWJlQWxsOiBmdW5jdGlvbiBzdWJzY3JpYmVBbGwoaGFuZGxlcikge1xuICAgICAgc3Vic2NyaWJlQWxsSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICBjdXN0b21IYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9LFxuICAgIHVzZUN1c3RvbU92ZXJsYXk6IGZ1bmN0aW9uIHVzZUN1c3RvbU92ZXJsYXkoY3VzdG9tT3ZlcmxheSkge1xuICAgICAgaWYgKHJlcG9ydGVyKSByZXBvcnRlci51c2VDdXN0b21PdmVybGF5KGN1c3RvbU92ZXJsYXkpO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uc0FuZENvbm5lY3Q6IHNldE9wdGlvbnNBbmRDb25uZWN0XG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-hot-middleware/client.js?path=/__webpack_hmr&timeout=20000&reload=true\n");

/***/ }),

/***/ "./node_modules/webpack-hot-middleware/node_modules/ansi-regex/index.js":
/*!*****************************************************************!*\
  !*** (webpack)-hot-middleware/node_modules/ansi-regex/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function () {\n\treturn /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWhvdC1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzPzA3MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLDZCQUE2QixZQUFZLElBQUksSUFBSSxNQUFNLElBQUk7QUFDM0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1ob3QtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-hot-middleware/node_modules/ansi-regex/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-hot-middleware/node_modules/strip-ansi/index.js":
/*!*****************************************************************!*\
  !*** (webpack)-hot-middleware/node_modules/strip-ansi/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ansiRegex = __webpack_require__(/*! ansi-regex */ \"./node_modules/webpack-hot-middleware/node_modules/ansi-regex/index.js\")();\n\nmodule.exports = function (str) {\n\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWhvdC1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzPzBmMDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1ob3QtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-hot-middleware/node_modules/strip-ansi/index.js\n");

/***/ }),

/***/ "./node_modules/webpack-hot-middleware/process-update.js":
/*!**************************************************!*\
  !*** (webpack)-hot-middleware/process-update.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Based heavily on https://github.com/webpack/webpack/blob/\n *  c0afdf9c6abc1dd70707c594e473802a566f7b6e/hot/only-dev-server.js\n * Original copyright Tobias Koppers @sokra (MIT license)\n */\n\n/* global window __webpack_hash__ */\n\nif (false) {}\n\nvar hmrDocsUrl = \"https://webpack.js.org/concepts/hot-module-replacement/\"; // eslint-disable-line max-len\n\nvar lastHash;\nvar failureStatuses = { abort: 1, fail: 1 };\nvar applyOptions = { \t\t\t\t\n  ignoreUnaccepted: true,\n  ignoreDeclined: true,\n  ignoreErrored: true,\n  onUnaccepted: function(data) {\n    console.warn(\"Ignored an update to unaccepted module \" + data.chain.join(\" -> \"));\n  },\n  onDeclined: function(data) {\n    console.warn(\"Ignored an update to declined module \" + data.chain.join(\" -> \"));\n  },\n  onErrored: function(data) {\n    console.error(data.error);\n    console.warn(\"Ignored an error while updating module \" + data.moduleId + \" (\" + data.type + \")\");\n  } \n}\n\nfunction upToDate(hash) {\n  if (hash) lastHash = hash;\n  return lastHash == __webpack_require__.h();\n}\n\nmodule.exports = function(hash, moduleMap, options) {\n  var reload = options.reload;\n  if (!upToDate(hash) && module.hot.status() == \"idle\") {\n    if (options.log) console.log(\"[HMR] Checking for updates on the server...\");\n    check();\n  }\n\n  function check() {\n    var cb = function(err, updatedModules) {\n      if (err) return handleError(err);\n\n      if(!updatedModules) {\n        if (options.warn) {\n          console.warn(\"[HMR] Cannot find update (Full reload needed)\");\n          console.warn(\"[HMR] (Probably because of restarting the server)\");\n        }\n        performReload();\n        return null;\n      }\n\n      var applyCallback = function(applyErr, renewedModules) {\n        if (applyErr) return handleError(applyErr);\n\n        if (!upToDate()) check();\n\n        logUpdates(updatedModules, renewedModules);\n      };\n\n      var applyResult = module.hot.apply(applyOptions, applyCallback);\n      // webpack 2 promise\n      if (applyResult && applyResult.then) {\n        // HotModuleReplacement.runtime.js refers to the result as `outdatedModules`\n        applyResult.then(function(outdatedModules) {\n          applyCallback(null, outdatedModules);\n        });\n        applyResult.catch(applyCallback);\n      }\n\n    };\n\n    var result = module.hot.check(false, cb);\n    // webpack 2 promise\n    if (result && result.then) {\n        result.then(function(updatedModules) {\n            cb(null, updatedModules);\n        });\n        result.catch(cb);\n    }\n  }\n\n  function logUpdates(updatedModules, renewedModules) {\n    var unacceptedModules = updatedModules.filter(function(moduleId) {\n      return renewedModules && renewedModules.indexOf(moduleId) < 0;\n    });\n\n    if(unacceptedModules.length > 0) {\n      if (options.warn) {\n        console.warn(\n          \"[HMR] The following modules couldn't be hot updated: \" +\n          \"(Full reload needed)\\n\" +\n          \"This is usually because the modules which have changed \" +\n          \"(and their parents) do not know how to hot reload themselves. \" +\n          \"See \" + hmrDocsUrl + \" for more details.\"\n        );\n        unacceptedModules.forEach(function(moduleId) {\n          console.warn(\"[HMR]  - \" + moduleMap[moduleId]);\n        });\n      }\n      performReload();\n      return;\n    }\n\n    if (options.log) {\n      if(!renewedModules || renewedModules.length === 0) {\n        console.log(\"[HMR] Nothing hot updated.\");\n      } else {\n        console.log(\"[HMR] Updated modules:\");\n        renewedModules.forEach(function(moduleId) {\n          console.log(\"[HMR]  - \" + moduleMap[moduleId]);\n        });\n      }\n\n      if (upToDate()) {\n        console.log(\"[HMR] App is up to date.\");\n      }\n    }\n  }\n\n  function handleError(err) {\n    if (module.hot.status() in failureStatuses) {\n      if (options.warn) {\n        console.warn(\"[HMR] Cannot check for update (Full reload needed)\");\n        console.warn(\"[HMR] \" + err.stack || err.message);\n      }\n      performReload();\n      return;\n    }\n    if (options.warn) {\n      console.warn(\"[HMR] Update check failed: \" + err.stack || err.message);\n    }\n  }\n\n  function performReload() {\n    if (reload) {\n      if (options.warn) console.warn(\"[HMR] Reloading page\");\n      window.location.reload();\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWhvdC1taWRkbGV3YXJlL3Byb2Nlc3MtdXBkYXRlLmpzP2UxMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUVBOztBQUVBLDJFQUEyRTs7QUFFM0U7QUFDQSx1QkFBdUI7QUFDdkIsb0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy93ZWJwYWNrLWhvdC1taWRkbGV3YXJlL3Byb2Nlc3MtdXBkYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlZCBoZWF2aWx5IG9uIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi9cbiAqICBjMGFmZGY5YzZhYmMxZGQ3MDcwN2M1OTRlNDczODAyYTU2NmY3YjZlL2hvdC9vbmx5LWRldi1zZXJ2ZXIuanNcbiAqIE9yaWdpbmFsIGNvcHlyaWdodCBUb2JpYXMgS29wcGVycyBAc29rcmEgKE1JVCBsaWNlbnNlKVxuICovXG5cbi8qIGdsb2JhbCB3aW5kb3cgX193ZWJwYWNrX2hhc2hfXyAqL1xuXG5pZiAoIW1vZHVsZS5ob3QpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiW0hNUl0gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBpcyBkaXNhYmxlZC5cIik7XG59XG5cbnZhciBobXJEb2NzVXJsID0gXCJodHRwczovL3dlYnBhY2suanMub3JnL2NvbmNlcHRzL2hvdC1tb2R1bGUtcmVwbGFjZW1lbnQvXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuXG52YXIgbGFzdEhhc2g7XG52YXIgZmFpbHVyZVN0YXR1c2VzID0geyBhYm9ydDogMSwgZmFpbDogMSB9O1xudmFyIGFwcGx5T3B0aW9ucyA9IHsgXHRcdFx0XHRcbiAgaWdub3JlVW5hY2NlcHRlZDogdHJ1ZSxcbiAgaWdub3JlRGVjbGluZWQ6IHRydWUsXG4gIGlnbm9yZUVycm9yZWQ6IHRydWUsXG4gIG9uVW5hY2NlcHRlZDogZnVuY3Rpb24oZGF0YSkge1xuICAgIGNvbnNvbGUud2FybihcIklnbm9yZWQgYW4gdXBkYXRlIHRvIHVuYWNjZXB0ZWQgbW9kdWxlIFwiICsgZGF0YS5jaGFpbi5qb2luKFwiIC0+IFwiKSk7XG4gIH0sXG4gIG9uRGVjbGluZWQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBjb25zb2xlLndhcm4oXCJJZ25vcmVkIGFuIHVwZGF0ZSB0byBkZWNsaW5lZCBtb2R1bGUgXCIgKyBkYXRhLmNoYWluLmpvaW4oXCIgLT4gXCIpKTtcbiAgfSxcbiAgb25FcnJvcmVkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihkYXRhLmVycm9yKTtcbiAgICBjb25zb2xlLndhcm4oXCJJZ25vcmVkIGFuIGVycm9yIHdoaWxlIHVwZGF0aW5nIG1vZHVsZSBcIiArIGRhdGEubW9kdWxlSWQgKyBcIiAoXCIgKyBkYXRhLnR5cGUgKyBcIilcIik7XG4gIH0gXG59XG5cbmZ1bmN0aW9uIHVwVG9EYXRlKGhhc2gpIHtcbiAgaWYgKGhhc2gpIGxhc3RIYXNoID0gaGFzaDtcbiAgcmV0dXJuIGxhc3RIYXNoID09IF9fd2VicGFja19oYXNoX187XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGFzaCwgbW9kdWxlTWFwLCBvcHRpb25zKSB7XG4gIHZhciByZWxvYWQgPSBvcHRpb25zLnJlbG9hZDtcbiAgaWYgKCF1cFRvRGF0ZShoYXNoKSAmJiBtb2R1bGUuaG90LnN0YXR1cygpID09IFwiaWRsZVwiKSB7XG4gICAgaWYgKG9wdGlvbnMubG9nKSBjb25zb2xlLmxvZyhcIltITVJdIENoZWNraW5nIGZvciB1cGRhdGVzIG9uIHRoZSBzZXJ2ZXIuLi5cIik7XG4gICAgY2hlY2soKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuXG4gICAgICBpZighdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltITVJdIENhbm5vdCBmaW5kIHVwZGF0ZSAoRnVsbCByZWxvYWQgbmVlZGVkKVwiKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSAoUHJvYmFibHkgYmVjYXVzZSBvZiByZXN0YXJ0aW5nIHRoZSBzZXJ2ZXIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBlcmZvcm1SZWxvYWQoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcHBseUNhbGxiYWNrID0gZnVuY3Rpb24oYXBwbHlFcnIsIHJlbmV3ZWRNb2R1bGVzKSB7XG4gICAgICAgIGlmIChhcHBseUVycikgcmV0dXJuIGhhbmRsZUVycm9yKGFwcGx5RXJyKTtcblxuICAgICAgICBpZiAoIXVwVG9EYXRlKCkpIGNoZWNrKCk7XG5cbiAgICAgICAgbG9nVXBkYXRlcyh1cGRhdGVkTW9kdWxlcywgcmVuZXdlZE1vZHVsZXMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGFwcGx5UmVzdWx0ID0gbW9kdWxlLmhvdC5hcHBseShhcHBseU9wdGlvbnMsIGFwcGx5Q2FsbGJhY2spO1xuICAgICAgLy8gd2VicGFjayAyIHByb21pc2VcbiAgICAgIGlmIChhcHBseVJlc3VsdCAmJiBhcHBseVJlc3VsdC50aGVuKSB7XG4gICAgICAgIC8vIEhvdE1vZHVsZVJlcGxhY2VtZW50LnJ1bnRpbWUuanMgcmVmZXJzIHRvIHRoZSByZXN1bHQgYXMgYG91dGRhdGVkTW9kdWxlc2BcbiAgICAgICAgYXBwbHlSZXN1bHQudGhlbihmdW5jdGlvbihvdXRkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgICBhcHBseUNhbGxiYWNrKG51bGwsIG91dGRhdGVkTW9kdWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBhcHBseVJlc3VsdC5jYXRjaChhcHBseUNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0gbW9kdWxlLmhvdC5jaGVjayhmYWxzZSwgY2IpO1xuICAgIC8vIHdlYnBhY2sgMiBwcm9taXNlXG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbih1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICAgICAgY2IobnVsbCwgdXBkYXRlZE1vZHVsZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LmNhdGNoKGNiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2dVcGRhdGVzKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcykge1xuICAgIHZhciB1bmFjY2VwdGVkTW9kdWxlcyA9IHVwZGF0ZWRNb2R1bGVzLmZpbHRlcihmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgICAgcmV0dXJuIHJlbmV3ZWRNb2R1bGVzICYmIHJlbmV3ZWRNb2R1bGVzLmluZGV4T2YobW9kdWxlSWQpIDwgMDtcbiAgICB9KTtcblxuICAgIGlmKHVuYWNjZXB0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChvcHRpb25zLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiW0hNUl0gVGhlIGZvbGxvd2luZyBtb2R1bGVzIGNvdWxkbid0IGJlIGhvdCB1cGRhdGVkOiBcIiArXG4gICAgICAgICAgXCIoRnVsbCByZWxvYWQgbmVlZGVkKVxcblwiICtcbiAgICAgICAgICBcIlRoaXMgaXMgdXN1YWxseSBiZWNhdXNlIHRoZSBtb2R1bGVzIHdoaWNoIGhhdmUgY2hhbmdlZCBcIiArXG4gICAgICAgICAgXCIoYW5kIHRoZWlyIHBhcmVudHMpIGRvIG5vdCBrbm93IGhvdyB0byBob3QgcmVsb2FkIHRoZW1zZWx2ZXMuIFwiICtcbiAgICAgICAgICBcIlNlZSBcIiArIGhtckRvY3NVcmwgKyBcIiBmb3IgbW9yZSBkZXRhaWxzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSAgLSBcIiArIG1vZHVsZU1hcFttb2R1bGVJZF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHBlcmZvcm1SZWxvYWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sb2cpIHtcbiAgICAgIGlmKCFyZW5ld2VkTW9kdWxlcyB8fCByZW5ld2VkTW9kdWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbSE1SXSBOb3RoaW5nIGhvdCB1cGRhdGVkLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0hNUl0gVXBkYXRlZCBtb2R1bGVzOlwiKTtcbiAgICAgICAgcmVuZXdlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVNYXBbbW9kdWxlSWRdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cFRvRGF0ZSgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0hNUl0gQXBwIGlzIHVwIHRvIGRhdGUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgIGlmIChtb2R1bGUuaG90LnN0YXR1cygpIGluIGZhaWx1cmVTdGF0dXNlcykge1xuICAgICAgaWYgKG9wdGlvbnMud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSBDYW5ub3QgY2hlY2sgZm9yIHVwZGF0ZSAoRnVsbCByZWxvYWQgbmVlZGVkKVwiKTtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0hNUl0gXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcGVyZm9ybVJlbG9hZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53YXJuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSBVcGRhdGUgY2hlY2sgZmFpbGVkOiBcIiArIGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVJlbG9hZCgpIHtcbiAgICBpZiAocmVsb2FkKSB7XG4gICAgICBpZiAob3B0aW9ucy53YXJuKSBjb25zb2xlLndhcm4oXCJbSE1SXSBSZWxvYWRpbmcgcGFnZVwiKTtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack-hot-middleware/process-update.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./src/entries/Home.jsx":
/*!******************************!*\
  !*** ./src/entries/Home.jsx ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n\nvar _Home = __webpack_require__(/*! ../pages/Home.jsx */ \"./src/pages/Home.jsx\");\n\nvar _Home2 = _interopRequireDefault(_Home);\n\n__webpack_require__(/*! ./normalize.css */ \"./src/entries/normalize.css\");\n\n__webpack_require__(/*! ./app.sass */ \"./src/entries/app.sass\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import ReactDOM from 'react-dom';\nvar App = document.getElementById('app');\n\n// ReactDOM.render(<Media />, App);\n(0, _reactDom.render)(_react2.default.createElement(_Home2.default, null), App);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZW50cmllcy9Ib21lLmpzeD8yNWJkIl0sIm5hbWVzIjpbIkFwcCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFFQTs7QUFDQTs7OztBQUVBOztBQUNBOzs7O0FBTEE7QUFPQSxJQUFNQSxNQUFNQyxTQUFTQyxjQUFULENBQXdCLEtBQXhCLENBQVo7O0FBRUE7QUFDQSxzQkFBTyw4QkFBQyxjQUFELE9BQVAsRUFBaUJGLEdBQWpCIiwiZmlsZSI6Ii4vc3JjL2VudHJpZXMvSG9tZS5qc3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG4vLyBpbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IEhvbWUgZnJvbSAnLi4vcGFnZXMvSG9tZS5qc3gnO1xyXG5cclxuaW1wb3J0ICcuL25vcm1hbGl6ZS5jc3MnO1xyXG5pbXBvcnQgJy4vYXBwLnNhc3MnO1xyXG5cclxuY29uc3QgQXBwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpO1xyXG5cclxuLy8gUmVhY3RET00ucmVuZGVyKDxNZWRpYSAvPiwgQXBwKTtcclxucmVuZGVyKDxIb21lIC8+LCBBcHApO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/entries/Home.jsx\n");

/***/ }),

/***/ "./src/entries/app.sass":
/*!******************************!*\
  !*** ./src/entries/app.sass ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZW50cmllcy9hcHAuc2Fzcz8xODU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vc3JjL2VudHJpZXMvYXBwLnNhc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/entries/app.sass\n");

/***/ }),

/***/ "./src/entries/normalize.css":
/*!***********************************!*\
  !*** ./src/entries/normalize.css ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZW50cmllcy9ub3JtYWxpemUuY3NzP2JjZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9zcmMvZW50cmllcy9ub3JtYWxpemUuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/entries/normalize.css\n");

/***/ }),

/***/ "./src/img/op.png":
/*!************************!*\
  !*** ./src/img/op.png ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL29wLnBuZz8zZjljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIuL3NyYy9pbWcvb3AucG5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTm9BQUFBM0NBWUFBQUJxeDFTSEFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQnA1SlJFRlVlTnJzWGZGMW16NFFWdkx5djlrZ2RBTDdOMEg0VFJBeVFad0o2azVRdW9FOVFmQUd6Z1FsRytBTjhBWmtnaFJlajJlaUluRkNnZ2puKzk3VGEydXdkTHE3NzA0NllYcjEvdjR1QUFBWUY5ZFFBUUNBYUFBQW9nRUFBS0lCQUlnR0FGOEpONHJQKzBxUnIxV0xvTDVQUmEzL0ZmMDlxMW8rQTNuRHFnV081SzM3MlZTdHFGbzZWNklCZnFKMjFLUnFjZFVXMHJVZE9aNVBDRWplZFllOGUvcDhhTDgxV1pmMDc1V0hjLytBSzhVNUdqS2FmNmlkY3R2aHNCL3NPVE41djFGR3NpRlpnLzk4enVySWFQTWgyVFBUQ2N1WnlldUNaRVA2bWhRb2h2aVBnREpESDE0OUlabUp2TGtqa3IwTnlJd2dHdkFCcTU3bFYrTzA4UVhMcXlMWnNXby9hTzhLb2dGV3lNbWhWQTc3UVB2bDBoTjVNNDI4OWVkUGh2TEtKR3ZJOVkxSXZmVm83dGlqelJnbE9WUXN6dVg4Z3B6UDF5anVVdDQxNmFBbTE4SDN6S1dDNjZwalFBcU82ZnBDRWRWeVVudzZJMTNWOC9uTjFhdmpzYmN0cDlWbHZzM0ErOFVueXpzVitUbDd4M1FNdjNTWjBXSVNzRzk5dnFUMlNCTlBtQXF3VWZDYS9yeVRycDNJNEFkcTVVZ0VqV2o4UUZwaWNTTjlsK3d1NzlmMUU3U0lVVTQ4Zmp0dzEzM2VTZ1dRSm1BZkdJV1ZnQ2xUeHJScHM5cmdGWFRxak5iUitwQko5Ni9mN1hCUXlHSFRvcXJsQmpLVVZVdXFGbWo2NHlLZ3ZrcUQrVWVhdVdTR05za0cyREFnTzZaVkt4amYzVll0ZENTdjZKQWxOZlNockVlSFhQc2wwdmRXVmR0US8yV1AveHhJaC8rTTc0Sm9RWWNBUmNzSWpRSDduRzdyaUdBNkk1VjBMZEdRc0NEbDJoQ3R0QWc0d2NSRWkyamNJU2dWdXJJaFdxelJYMDYyU3dmNGtRblJBaUpYUGxBdnVXeEhGMFRiYUtLNkhCbjZFRGtnV1c3Z3hMcE12TFlnbXF3clV5T3RKaUJhd2NoYzc4eCtYQkZ0clNGMExOMGJhbXlkV1JBdHR3aVV5c3g0N1dodnBxb1d5WnZmRjBhRnlRWUgwWDJnZVNRNXk0Nk43NU9pcjJmR2hsNkZFNVhkcjJnOWYwWC9QaksrdTZSNWpQMmt3NjIwNTZsbHJwOC8vTVd3azl4UDVNaVBualhYRHRKbkJZMTc2cmovenFLZ3NaVHFERWZTeVU0eEZvc1hZNTZqQlFNMm1pdUw4UkxOWmpmdXFUSzlhb2c3eE9GWEhZNXhJTWM0TXAzM01GRTE3a1RCSnFSQWw1QytuaWFzQ0FZYVl1dzFmbE5xZ3ZPanNEdkVmMm1kMVNWVUlRME5ndERTTmRFeWc4OXpFK0VNRGJYUkdLcGdrRlRsOEVPeWJLbjVQR0pHeGpzeC9vUGJlM0trMURBQXVVYWlxVlluRFA4N2FvNFpodUNKU05ybE40T09KRndRYmR0aGtCMnpUT3J5YUdHaHlVcWNZS0Z5ZnRkblBTWERlY1lhVzE1T3IzdEs5bE5sMWJWR3hvTHgvVlFUS0UyejJxNW4yVmtNQ1VEWGpoeW5qcnoxenhUK3AyaVFrVE5GbHN0QjIzMmlNQ0I4cmpGVzZGamVsTTZCK25BLzRsNnR0TkNKNjNQR2hTWFJjOGFabDB1OUdNUFZnWFZ6c0xpUmxQYXp0UTlJUnpUY3lvSGljbkxzTG9RanlKeHB4bk8xYjUwRFhOZ3U4MTEvTjQ0VWxRbjlFeUczUkxxM2tlWnhxL2o4eldNSHk1bEV1M1FFbjV4Uko0SHQwakhzSUZsZGxYbWdaZVNEdEo1ZGpEUVBGYUVXOE9PTEplR1hJcHI4VS9VZjRuem1rWWx6U1hzL1FYYVltMUc1eTlIeXdzbVVPMWoyaGI3cno1Wm83YVhQVWFqTHFXdGhkdGpuMGxqY3pYQ2t5WmJaU0VVQVRxYk9MNXhvTHZaWHE0SDl6NEpvY2hUcHF4Q05XU3JXblpmRXpMa3NKNVI3cGRsWFRxVXpYMUFLOVNGd3hGeHA5RDJRTUd1aUZZWkxyM0RFZVJRYVk2MFpzcTAxMTVLSkE4UFlZL3VJcldhUEhUUDg2bEZ4YlhjcFM4ZFhwa01IWXZ5bkhEYWl1eWl5RVBxRDMxQnovWmR3LzR2ZVdrK2MzMFdOTWJiUHk4ZWRob1RCQUpLZWZBcFUxdzZjdSszUVdZZFNtbmMrakYwQkxJak1YV1Q3cWNoYUFTM1B1bVRiV3hoSzVSeDFmNXpYc08zRjE4bG1iVjg2S2dKbHB0SG52V0p2R3d1UENrbTI1MmoxUnYxSm5LdVBTM0w0NXQwT29kQS9IalZHVVNSU0VQdVpaTm0yOWttSlFqYmJ0LzUrSjJLblpPem1RSit6TC9QeGpjTlRJU0w3eUV2QkpkazJJYjlxbm0yOVUyU3lXSGhXUkhKeFlKMlNZMjhwdWl3VWErYm1LZXpuQ2NnV0tneDJML1NIeENjeW9HMFJZazlqZnpmNGptN3NuRG52b2ZmckNoV3Z6UHVFZy9HYnAvRXo4ZS9SMFMzRGQzWkV4dEppTG9VajNYM0FsZVAvV3JmWmk2MGtvYkpQU3VPaE9EOXpxY3NtTCtUZ2FVKzBOWGs1ajh1eHZ5TGFqL1V0ZXdMVWdZanA3WjdXTmRGOFJ0aHFRU3NxWlFiTG1xRnZ3YklkR3pnWDB5SnhmbEZRSVdaU01QcEtSSE5oNk05NjNSd3djK0JOeFFBQW9nRUFpQVlBQUlnR0FDQWFBSUJvQUFDQWFBQUFvZ0VBQUtJQkFJZ0dBQ0FhQUFBZ0dnQ0FhQUFBb2dFQU1EWnVvQUkyQ3ZIM2hUa0FZQXo4SGcwQXNIUUVnTXZBSHdFR0FQRElzdERhNEVqb0FBQUFBRWxGVGtTdVFtQ0NcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/img/op.png\n");

/***/ }),

/***/ "./src/img/slide-1.jpg":
/*!*****************************!*\
  !*** ./src/img/slide-1.jpg ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/jpeg;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL3NsaWRlLTEuanBnPzBkN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0NBQWtDIiwiZmlsZSI6Ii4vc3JjL2ltZy9zbGlkZS0xLmpwZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0JEQUFJQ0FnSUNBUUlDQWdJREFnSURBd1lFQXdNREF3Y0ZCUVFHQ0FjSkNBZ0hDQWdKQ2cwTENRb01DZ2dJQ3c4TERBME9EZzhPQ1FzUUVSQU9FUTBPRGc3LzJ3QkRBUUlEQXdNREF3Y0VCQWNPQ1FnSkRnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzRPRGc0T0RnNE9EZzcvd2dBUkNBSklCNEFEQVJFQUFoRUJBeEVCLzhRQUhnQUFBUU1GQVFFQUFBQUFBQUFBQUFBQUJBSURCUUFCQmdjSUNRci94QUFkQVFFQUFnRUZBUUFBQUFBQUFBQUFBQUFBQVFJREJBVUdCd2dKLzlvQURBTUJBQUlRQXhBQUFBRDI4MGVvZHFZa3hKQ1oySVhLTUNnTWt3RUxpUzdVR2lXQXdEbUdZdkxxeGxabGNrTlJJa1NpYWlLMkhKZ3F0MkxWYW1aMGpZR290TXhTQ1J0THFzeElOa01ZMU1sbU9tUWNqRlpoWUc5RFNIb2tWNUNjY1FFWE5KcERnMFM1SGdaT2xFY0xDeHNVUmhiR3F5MWpvaUI2RXpLQkk4RWxpTHJFdE1qVEVpV1RDaGhHRXdBVVN0NFpGSnNPalVGU2pXTjFkcEtvb2N0SHpMZFlxMDBpaVJyTjdRZ29HVldneEpLYm91aWtnZ2FUbGkyT2k2VUlVbWk2S0xKcEZGQWNXRW1hVnN2SUtDb0doZWNsZzRKUlNxQlNIR1FkQU5SOXBlQmtPd0VtU2l4RURoWWJSTHBjZ21VZUNVU04xQUlTSkFpWkZ3UktMRWpna1dGallTUjRIUTZEeE5sbmtvVWJTYXFNT3JOb3VtVFJCMWhkY2Nqa3lzUlltSlFYdFVpQVVXdFVjQVRqaTRYWGRKeE5oa2p3Y2x5TEJDNWtKRWdKTUJKUlFrb0RIUWNpeWg0bkFLRlNIb051aUI4a1NHaEpTS0xBSkxGRndBRUhSSVdPZ3hJa2VQaHBIRWV4a0M4aGpHb25pSGxLU0dxR3VsOHVGdU1rSGd0TjVEN0kwcU1zT0VCWXNRWG1ySUJFdW9tc2xVUWlaTWlxbjdKVVVSQTBUQTlDTGs0U0l5T2dZQlV1eFlnU0xIaWhra3djTElvbEJoalBLWkE0UnNrRHdiUWJlb0NCRjdxU2NYSENKQktGTGdpMk0xa2l5cXhVeFUydWd1SmtKQ2pzUXBEMHhTR0N3K0tFQW9TbTRJaFNTMEJyS0MxV2l3OFdTTWk2d2c2c1dyZEk2a2RXUzdYREpRaWlSVUxTbEtrMVVpeTRraGc4TXhxa2k2TUxGeEpKaWlpTUJjWXJJZkFBOFNBVlRkZ0FHV0tFbGhaSWlBZEtsM1dNRVp4NUVvc3JSU1hCNVlkV2t0SWxBS3NMVnEyV1V4a0Z3QWtaSmhSY3BqajhnYkhrUEtJNERLS0ZreVJZSVpBUllPVHdPUndNTkZFaVNnZ2dCRlNiSjRRUXdhRFZPeUtnQkpxVjRWSWtISjlMcUdTR0VsazNSTUFZWldscXlMa3MrU1lsRVBKMkRkcU9yU0VXSWlJYWF5VW1heEd5a2N1TkZaajYzeUN4TEpIS3RGMWl3UldZa3VBVXc5RjRsU2t5aURaVmVBeWttbDBBRWVYSjBYQ3BVQml3b3VBZzQ0REZsYnhNcE1qaG82QWpRMFhKU0lCazRGa1drVW9seDJoeThBVmg2MEdMUkVKQ1lYV1c3STVDMVRtU05HNnF0VzYxaVNRU21MZzFXcGNwQzAzVmpScEVtbDVGRkxXVkdJOWtwV1RWY0ZGRmxycTNHU01pNVVqMWFHVnJEaVk5akZyZDYxWlJZVUlRd2dldGpMU3dLQ0dPbDI0T1FhdE5VSnVhTGx4QXN2QzZYSXF6RXYzUndPT1FxUTVJRWVKS0Zqd2tHSkFhSkVZU09NZ2xMcFV0QjRMVGNWRVJKU2FrOUZTNE5Xc1pXcmxjakE4c01xU0NoTWxwVE9LcW1tU01tUklyWk5peGVWb0tKZ0hIZ1FZSlVnaEpZU1RCRWs4T0VWQ05sY2w2aXJHUmlEOG95RW5GR3NrUmxiM1MyZ3FRMVV3a3UxWWRaNVFhbDBXYTZtdkJkNDR1dkhMbG1sWllkWXN6bXNieE9xNnozTlMzb0ZESmF5T1NLa1NtUlNWRlFobVpGVEpXc1l4eGF6Q3hTbzQ0c09Tc2kxYWkxRU1NcUxYTFZrc2xRQndNVEdvR3F0STJVbVJnYUxJWVVUZ2dGS0NnQWVHQlpJakpjdVJoYXNIV2traWh4aldrcUxROHpSTERna2NyRHFFV2tGRGxiRldOMWdHYVhrWXVtc2pGN0wxaXBTTW1VaGpFSmdYS3FxdFVkVW9vc1VzMGdCTGl6STR4eVpRMHNHaVJRRWtoQ1dSMHNMRXNkSlFsU0JFRUxPaUV0QUVTZEpnb1FXVVBpeW9tb1ExeUtMeXNXc3FxeFZscVZRaWV2ZXFrMlJBOEtxUll3U0lLS0JBNEpJb1BHRmkwTklhQ0VoSUpHVXF4M0hCQnBTeUZDMHR6RnExazV5RGtsV0t0WUt0U0xTSldwMElTMHBpRGxqNGdkRU5KSlVMUmtzS0VsazNRcEUybHdBQXh3YUhDUUFpT0Vrb1NBSVFSUkt3UGt3WEk0Y2hKeklscUpwZDlWdElreVJKOURVUkdJSWllWDd4NDFaTWZCV1V5dGpNcUtLS0tLS0tNa2lQU3lsdlpEQzZXbTBQQ1ppcXBpT3FOdUttVXBiUkhSRFU1RmhDcksxRHNud09FdU56amlHUkVVdXM1TUhLMGtFcThWQjJVeFJWdzRUVXF3SVVGa2FPRHdRQmhCUXdFRElhQ2tlTHFsckdoZ01yQVlWWkJwV1RCUkVpaHd1REVnR0RFUUdwY0xYYmxIb2RXYkZFMk5GRFZSRmx5NkZxV0tLaVdaQ1JDcHlOc2JUSWdJUkpvb1FtS1RMcVJDRFF0WVJOa0ZvdWhJQUhMVW02b3FTUmxaQUVpVGhZakN5Smlac201RkNDcXFzcXBKVlNwSmxWa3VXR3hRd0JpZzhZRmpwRkRvSVNxWFJwS2xZOFBHUlNWMFhURUFwYUMwU3FJOFRDUXNZbTRjUTlDUm0xVm9pOE4xcTlGNCtaQXBkTEhOVEtZbUhVVFpVcnhZMnRpb0NGNUF3UWl3U21hQnlGSHdjTUFDVUNDSEh5WUdESGk1TERaR2x4MkV6SWVFTkxJQjBpZ29NRkVTeDY2bWZDM05IQXVTUFgvQUJUNm5ZN1pERWVUT1dQR2JMR0VUTkZGRkZGSG9GU09uYXZKdkk5V3FUN1g0WnpSQVU1R3FZNnV0TnBoWmxRSEhBbVRJUVhWZFdGRFJzYkpoVytTelJGWTZzb1d2VEhTOUlWYXBOa3BVcXBPUUdNbGd3UUdrU1BDdzhDQ3k0MlVXTEJKQ2hCSmx5TUVDUlFLUGtvWEF3QUpMZ3hNQWdJSFVQeWVzRkk2c0ZXbGtzVFFHWENLeFZwY2d1Y2RGZ1VHRXNsb1BUak5MTWlGSFY3a2FIRVJGWnVZc0lIU0pYWVJKcHN4dkMxckZMVVVoQ1FRa3NwSEZrcFdLcWtiSThQSWtSald5TERna1JXdExXcW9uTEFMRGdJQUZGaVJxcXlMSlFRREJ3NE1yTWppcncyUlJNSlRqTUpjdmFPcmpFaXppSmhFS1BRbGJyVkJBRElTazlXazBpaXdoSURISjF0QXF0U29NaEpWS0V6ZU1SSXhMQkVJUXNva1E4eDRXRkFRMlVTQTBWQ1prQ1E1Y25pS2hVSHBFU2p4NkVkS2VDQVpDa2pFZ2NoV3A4Mm1vcjNUU2ZjbkRiT3BySXNoVmNjVmUycGJUOGt1YW5jdFc5b2JWaTIxcTF5Q0oxdk1lSDJhUHBsd1R1OCtmckxHaHBqNlpjTjk4UkkxS3VYRHpNdXVJeGlqY1dlbW9iSW9LVmtWa0t4ODFmV0p2VUpNbFNJOVlOQzRtaWxaRElQS3F1bUZ0RlZLc2NGZ29XU1ZWcER5SUF4OEFIeVFBeHNrU0pMQklzRkJoQmNVS0hBOFdReEtGaU5KZ2l4QklCeFFLQkNpaFJMRlkxckl1MVVFcXNPTnFETHJqSGVjaTFEbHJJc21oNlFzU1NYUXlSWk1JU2dOTWlSYXpDaVVVeUdCeUEwRklqVnkwT0pGckY1TVRJNnQ2Mk10RkpOaGVWUWhvSXNlQ2lQS0hvT1NES29uTHJEUUlXQnl3YUZnNFFORVdtWEdhVERvcEZoK0xISWJtNVFKQUd4Y0pVRVZCZ3lxV0xGaktVRFNVeGVSbUgwVW1pT1ZzSHJKUkFLVVB3bWFLR0V4OTBsUzdwUUFSUlJSa0JDZ3hNa1lLRWxEd1VFa0ZCaVVuQTJVQ0VRYWswRXdrNVFaY2tDVUxFS2NUWHI4NUdvcDczNExla3VPNUErQ1Jqa3BCV3lja1hwODMrYW4xejRNcWxVcnoxTWRRaGp6eXlQQWJQSDFQNEo2Qmg0MDJlUFdhdjA5WUxkUEY2RHJySmFTSlN0b0p5WkxLdUJoWllZa3NtTzZhUUF5SEt1S2hrY080MG1QNURRS2t4RU9YTEI0TU00MTVUdHlSVUdwWElzc1VTQVVNQWdnc1dLTGdvU1VNRnl3NFNCR0J4WUZKTWRCd3VDQzhralJjc09ENVdOV1FtSzJTcVFhRVZzVFlvYWlwVXltSURUSVRJUklpR096SmRRVUFSTWdJUUVKWVhpV080L0Z6NWx0U05KbGVNVkpTVEV4TTQyU21SWmFneTRvVVZDcFE5VWpaRmx3c2VyRVhhVkVpUnhNRkFJREJjQ0xHZzhTUGtXRmdTWlZFVGp5REtscWlGbVN5cnBMQ2dUSlVISE11dTBSaWd5RWlCWlprTEpGamVJNWU2Q2tvSUZTaWJTNG1BVm9tYVM5RVIxZ3Rqa0dTUnJjMkxXUkNvR1hwV1dCQUFuUjRCQndRa1IwaXhxRWlIeWhSdUE1VWxFdkE2VFkwUGtXeG5NbkkxbytaVFU0dnBGMDl1NmFMeWpJdVJNQ3hXUldxWjhJczFBWmU1K0xKYVlVbWJwakpoQmpaNVA1WGovbHI5VG1teWJGaTNtNWx4K0QrYVBxZzAwOUQxUjJSSUYweFZJY2hmSmthQ3cxVkEyc1RhbFJOSVVVdEhva3J3MnVuSGpiTFRLZ2k4S0lvWUZob0dJeHFrWmNkVXVWNEIyQkRwWWNDaU5LRkZENVlRWExrZ1JnZ2NLQ1FBZUZWTjJPRXFVRDFpS3JWVnJWYWFLTGx5NVFTU2VOYklaaUJZaFZySkhCWUhGWldacENpT1NjTVJNZEtYWTQ4YVpKaGppWXZMU3BXeTZCUXNaSXBVaEVnaXpKZFcxYnN6VmtHa1JVdTAzQ2FtYkxENURrc1FrTFNsS3krcENWdFJMNUVXUzVWVEZrVlVtVjVGa2hqTVpEeEZoZ01IRUhqeVdWdk5hU1RFQ01pU1hDSnFMZXJ1UElnaVIxUVZDUkljU0RJMlE3R2dOZ1pVQkkrMTRkUnNuVjNVWTlGWENib2lMR2JKcUM1SXFoSkd4WSt0bWlDS0pVR0FqSUM1RkFRNk5Gd3lvNnh1cUprbVVtUTRkQWdmTFF0YTEwWFJZMXJOZms4MU5QV0hIUHRYaXRSUUlseEJFTFN0RDVFdFZqK2hQUzVzUjJYbEdiYzk2dTYrMkRsR1EwbzdFdzlvSHFvOFJzOGNHV2ZVbGd0bTFvOGE3UEx2SkgxWWFlY2pnWmRaTjZ5eldyV1FVczhVaWdKY0lOVkxTTWc4c3NOa29DbG5HdUtWV0p5SmxLa1JnMkdnSmFnbTRzRkNBd0ZHQ3dvVUhrWUt4bWNnc09JMGZIa2hJSEZqb2NJQndrQ0xodzJPamd3UnBlcTladE1YdXVYcXF5Z2dPcXZZM1dJYTBHUko0MUFXWlZJK3E5cTNCVm1CMGpnOEJDbU0xYU1XbHdBR1ZrMW5DOElxYWlyVExHbGtwamZXdFc2clJZc1dMa2VIUWpwV0pNaHlXSU9JdEtVb0ptMEhXTFdTOWtZU29BU0pFbDZyMkhsNnFzdUtMRVVFRVhqeUdobVRHZ2o4ZVJ3RENGWks4S0twTU1JRGlMVm9sQTBzc0V0Q3hqcVZEc0phQUVwT2NpRlk1VmFiRlZpU3Fnc2d1RDRDR2pFaEltY3BkUmpxRUpuUUVTT0FJa2VnUklzZkxBUkhRWWs2SHdLa0lQUWg1TklvcEtvVk9QNXlkUkhDMTUrdTdTM3pLRkZ5NmFFbEhLMW8rY3pVWXZwMXd1RmRUcksyL2QrN3JiRnkxbXg1ZkU0TkxLWWdvM3dueG15MTFVZlRCZ2txcjV0TlJHNzRlK1dDUk1nS3RweVM2VlZlOTVVVWdGWUlJQmljQlI5V01XYW1xaTBXV1BxRkVYa2c1YVNWdXNNcTJCRDVKaWlnSW94Mmx1UnEzNTRwbTEzTjUvRm0zSGF2UjJUU2ROWk1ERmpna1VXWkNWYnFpQXBKQTRHU3dJREZpNUpqNUhoUkVsRjZ4VVM5YzBVWEdOQm13ZnA3bU1Sd0xlNHpZOWF1NHZrZTI1ZDJoeHJMZXllTVA2cUpTS2l6YTBEWkFxbHJSUTZ4dENZdFUxa2w2SStzeTlrTlNLSk84dmtkRUJvTGxJcXBXdXJWYkIyc1JRdVduelVGc2NrbmFFdHVXaG1zcnJaeVpoNnpLeldFaXRSa2xaaCt5RXhyWkV0VkcyUzRtQ3BBaGhIaWdNc1hDaVFBZ1pMRkVtdkZLckc0akhMVnZYR0FrUlZ5WkpYeWVaTXJlbFhRNHVVSldzbVBpa2ZKb29LaElWQlNjdE1jaFJOTHcwVW1hSUs2UUI1RHdxUjBBU1lyZTh4b2pjTk5pZWFuU1dtdG83UG55UzJtbU1SVkw3QzBHcFJGb1pOSWxBc291TWtYVUhZZENTbGNnSU56amRaQ0lJT0tjbFBtRzFNZXB1SjlBbUE2dU9QSm9iSDBOSThMODlYRDNYMHQvSVhxejBqdG50ZnpIbWw5VHhiZU91NlRyNll3U1dSdzdyVHZpTC9MZGx4WWpNZXUrTzNkMk44bUdwcjlYbW50dlNpTGxWN3VZNlpFeUx5S0d5Q1ZXc2NySExUdzByRkxJTHEwVVdMck9EK1RISnBXbTVlbGFLaFdSR0RZK1JGWG1OZzF2Qm1EV3cwNG81QTFwY3BxSGtTTTAycldub3JxTkwzam0wZzh3UFZlMHZwbGtYc2hrVFpZRkRDTUdCWThPaHBjWUlvb1BCS2tXS0N0UGZSM212czNtRG9ydFI3Zys4bWFPc3RpMGowVU56WVpmVzZBYmt1SGJYcUhyVGVQZnZYQ01oYURrM21Md0VJOVdwdFJTWm1BMEk2d2dHSDBIZ0NXQndsMUxvRnJjQzBvQ1FQTHBmSzZtZkNvbk4wYkJ2SFN5Tm94UGpIV2VqSmpvR0hTOU1tY1dRdElxWmxMSHlFRTFTNUcyVEZWaTFnb3lCVUVYT0FaY1NTZzhRdzhFRVZqdnFDK1B4aW5OclMxZDdVcjJOV3ZkVVl1WjdaTWdEb2lGeU9vS1d5Q3MwbWtDMURqWmVSRUV6YU5tckpNNHpXUXFvT1pUS2FyZUttbDZ3REIrUmtsMXZHV3FSRWd4T0I2N0J4UHlMUWRTN1RxdHdhZTJkYWRxalZSeUh5RGJ1U09RYlRwVGU5dDlFK3Z1WDk5Y2Exd21tMUtrS2hKeWVJVU9oSXlpNFNNZ2g4aG9JbUpZWXFldFB5L2FqRHhKa3Q3ellIcnhpeU5CQTBoUlpQbmRreCtQbVNPT01rL1JqZ2VtZUo1LzlUZW8raStUOVQ1bnpYclRpT3lXaGpSM0JWbDhUT1RDNXQ4c0dhbkc5NW82RnJHeElkR1EraVRUekNXSnRhU3BVK2NpckxJaTBncXZyTXFsemFVaEREWXBVcEpDVnFxRnpDME8zbWxvNVZ4RDFWeCtEZDBTVWFqeDVQRXJTN3RxZXRSWnE1RUxTT3VIT1FlZE1xYnZVejVWU2ZSdk5wdlM3VTdVUWg4SFpKT2FsM3JFRWlOaG95TURKUWdiSk1JcVlzREhCa2JSS0p4ampPNWN0ZUl1K3NJNnk1V2ZHZ3gvZEdtTzI5bHl6aTI5NE55RFJiZDZ3MytVMGNSbW96SHNPOXU1K3R1a3ZhSFI1MmFoNjBWSzQrTW9IVFE4aVdpUlNQUlpOcGk2S0xSRHMybEJZZ2gwdENvaStUVDZkczhtNDFYcTVYRnRuVHhZeUxOV0J3Mmx0VFBtRlhKenpqaWwvWWExTXhpYUpRZklTeEJNMVJ0a3hVTlkrRGdBempMeUNCaWhCYTZWS29oaTZUNWFyeFJ4eGtlRGw4dllDUFRSajZMVnl5cytTVnI4SDN0Z3NOMDFlbTdGM25XZHFWc0RqcTZLdktVM3BWWUxJc0hzWkpxbDRySWxjY3QyQ1ZQU2hyWTcwTk1rMmgyWkZWalZ0WmF6VGN5YnhwdTc5Z3o1RmVUTFN6V1loU1ZYNVEzZlNlWXZQdU0rbDNCZVNkamJOcThmb3gvUzZtOHpPU2c0TGtNRmt0UkYyRlNJSUNGcEZoUnoxYVBrcDFWTzRNY2MvMmRhMWU4ZURKdDJKSlBQNjlmRHJOajVrdmFpallFUjlSMm5uVm5WM29YTU5adDIzT3hlaStaNVppWThkWlZaaFlIamFQdStSL1VtaWlpaklZcDlrdWx5NXFyVXJBOXNoZ3hGWVFWTnFMMXh6VjhnVUExVHdsWVlZVlFVbFV3NkYzcVV0UmRFV2k1TENTRU5iVXQ0UmFMZCtmMk9NeVlxbVhyWGsxVE1kemFaa1d3dWw2Nmgya1pSTnZVSytpOUVkWnR5b0laQ0p4ek41aTBPalpKZ2dVUm9NS3F2Wk1paGdIcWNzQUhheGJaZGJ4WDRKOUdZRnhQa3N0dGthOTdHMkRGZTJ1TXhXOWFVTGptdXdIbE8wN0I0SnZHMytzT1U1UHc3ZE1KNUZxYzAySFRiL0FQUW5WUFN2c1Rwb2hNT0dpaDlFV05wZFJMSkdoR3lvb29wVjFXVGpKVWtETUkxQ29pSXphVEFkSHFzVzBlb3lQSmpuc3RjMzFkTkk1VzNJWndhOXdWeUtiK1VNWmVLY2MrNzJvd2JScmFxV2xMQ0tvVElRVE5VWlpNVUJYRmd4R2lhcjJFRnNaZ0lsSlFpaGd1bkE3WXNNeFpmSmpKbDJiT1AxT3JnZHg1SGdDc1RPZkh4WmZKNUlzMnVGdmVyRnArajJPZHRseURGTFpjRmtaQVN4eUNZT1NabEsxeVJoSWtPRENpWXRqaGFyTTBncklrZWpIY3VIWEZxWmpwcGg5d2hPU1p4U090T3hjVnJhT2NRVzBMbnpibGFUWW1qeVpCcWFSVnFNNmJXdW1PazRBMVIxazNReGRVQ0pRb2tsaHBIalhsanlZeTArc3pUWlpCVHhqeXg1TzVhK3QrSy9KRm80TXlLS0tLS052Ulg2bnRCbTNKSXkrTWdibEhBTUx5TGg0ZjVvOFlzMDlSMXIzaFMyUlFRWS9NK2c5STNqVWVuQ0pabk5zMGhOMG94Szk3SUpVS21ZeUprRlFWaGdvSUhpNnJheUFmSlJzTnBCNmIzaXFJdTh1Rkk4SWRIdWZIMUxybkhPeGFjeVhoOGVURm9uSHI2YUF5VWs2eHNhbVV1TGdWeW9yZktFZTlHczJqb2pKZ2pJeUltczVlSTlFc1VXS0xnZ0NLQ0E0and3RXFlc0F4bkRpRHhaNkt4N3BUbEdOYXZjSkhSVEc3em90VStzT285bDlCOWdoYmJrMHoyanhUTGR1MTIzdW4rVjMycmM4VTNuSk43WFdhMCtuN1U5MGVjZHE5c2NUalFpWVpxa0xTaGppeERKTmpCRkl2Q29pclMrU0NiMVhzc0NBU0FHSFZPT25nczEvc2xwc1BVVm9keXhDNnltbWw4VngyMDlFZWdzMHdiYk0yS0hKT1I2RTZ2SG1WOFNxYWgrWWRtWVlSQ1lsRzFTcGFFYkp5eFJHbEJBcWlpUkFBV0YwNFhFNG5qakU5TG54bUxiWXk0cG5KaWxzbEoyOUl2SGZGYVdtY3VQenN5NStKNXY3T2FYQnNXQStYSHNhY3pOVGtEU05zTWc4Q3dISHc1a0RLSThIRmsraVBJdE1nT3pHUHpUemU1UHR2YW16MzJQdCtxUDFWVGJvaThQcmF6eFczYmloalUxOG5lUzE2azBPbDYvNDN1RTJxQmwwb21IV0xybng2RnhJaVJrSldUUTZRSTJTeFkrWWJVWXZUTEhmMUl4MnVVYUd0SHpQYWpIejVhYUtLS0tLS09rYXg5UXVublo5amxVUkJNbktwc2dMUGtIMU5kVHpiMEx4MTVUdFBVOFFSRGtHMDlVUkcxSXRvdVhMMW85RjZXN3pwSG8zaUtFNUxTSWVtTDFHazh1L1VIaU1jU0VGeHNzUERCUStNaUI0ZEtCaFppM1dYZFhuRjB6NlBkdmoybnMrdjdBOHVkaHAzRFRDOG8yN3p2OUM4SG1yV1ZpUVZNbURaY1V0TmN2eDVJL0hhWGpQMlpmVCszR3QydVFUeEY1VzdXZzk2NC9wejZiZk9ONHNNaVM0UVhLR1I0UVhrM0JRMFo3NVE5VE0vTTczcTB6YTA1ZHJNMjQzS3Eyd2JzYmkydCt4ZUs0bnVXanlyWjkzM2QxQnlYTHVHN294Zk5BYnhPSTd0bjJOeGJTN203SzRGMjc3dTg5M09lZW5PWTZNNmU1cnEzNktlQW9mdFRyQklPRXJWSWFGeXhjSUtRaEtpNkVwa2RIdUhadm1UMko1eFUzSFMrU2ZYVGJzVzdkVEdyc09XWTNQRHBuRGtSa3JsU05wYWVjNHpOVFdjWVlYYmVoYmMxRll2TForMThLNG51L0szbXJzL0NQV1hsekNQWEhsaE1MaktLUzZVTWpaUStMR3hvb04wdXU2MTh2KzFzSHc1dlBIVlBZblM0WUd1UXZVNHRVWG5PSXhrMW5NcXNZMDk4UG0yTFpKMnJpeDVObGdFeS9MT1Qwa1E1RjhzOXM0bnUyeDZpK25memVvdU5Gb1B6WkFtSXVEanc0bWtDSmRHMGRLOUNlcnZNbmtXNGU0WFZlOXQwMUd5dGJwell5a1pVWmlqQ2FUc1BWVTQzM3ZSOFljdTQ3bE8zN242czhBM25FTkhreWUySm5QQzhlNFJFQWd1UVpSTkFVQ1lCV0ZDWUtsOGNtcXcvVmpwc3U4SWtaQkJjK2FUVVkvUHJKTkZGRkZGRkZIWjlJOVNhVHA1T3BiTlVUVFZzenFjMWphUVNqMExvNVVtTnN3bzFCTHAySTJ4VzNuSGtyYzlHcVg3cnJIcEJqT0VyYTVnZ2c5WHQvZ3g3eCtYRkVybzlkTTZUY0VUU0QxMjJ6T2ozQ1MwK3J4WGN0bUpwbEh2aUp4NWpNV2R1WWp0UnBHcjR3OCtubzE3NHgraldqT0VkbXBSdFRpMjk3aTZoNTlEVnB1L3B6a1hFWHNIcG51ano1emZWL1pISHRLZHU4ZEV6enJTYllSbjBtUllNdVRZOCtmNmUzMFJidHN1dzhsUEtyemx2bUVjbDRqb2Y2d2ZMeWlpaVEwMnJPd2FscTFHclVsZE5yQXMybmo5UnBROCtub29vbzYvOEFpcDlrcEx6MTMvakc2Nmh5YWc2MWorNXpsdkd0WEo2WEV6a09WaDZtT0sxMDRqeUswL3RGak5OR3ZPVVk5dThMeGVsLzBROG5GNzlvT1FPcmRmeVYxaHV1ay9wdjgzc2Y3aTZvb29rTkxxeUtaV2I0M2FaWmpTNjNITmZ0TWxwOVhBN2h0bEZGRkc5T3V1Mk03OGhlK3RJWHlZM2EzZkdteGRrWWNlbThlbzNGbng1Rm13eWV2akE5SmVFMDl0bjducC9NZW1ieUtuTDlCKzNWMlhnblkycngzMWVYVC9HTS9uaDBMdnV1ZlpIa1hYUHRIeURSUVpnems0czZMVnZFemVqM0NMMUdrSHlZR2IwRDFHbm9vbzN4MU4zdDJmNU45eStVV3RyTzVLK3cyM3lpWTBucTR2YU1IQjR2dWF0Tmk2Wm1HZkR5cGJOdFdrWm5qczlhc2xkc0dWenpEODliOWdtLzhWMEw5WnZsdlJSUklhYlZuWU5TMWFqVnFTZW4xWTJURkc2blJoNTlQUlJSbnZHdVdrK1ovb0Z3VnpqWS9vTTZKNXZzM1I2bUlYWm1YMVkvRTNacjlEenp2V0xnUGsyajFSeWJqa3B0VzYrcVhYRzk1cnRPcnkrdFhzMVRzbXRIcE1GZFljR1NpVXFMc1pJZ1RDRnMrT2ZWWWZ0RjBtWnNMS0lsaitkelBQbXpsaWlpaWlpaWlqUG9yM3RSdEtKMnBFN1hpZHd4RzM0YkZoODh1ZVBPTzgraGRLOHF6TytvUmhwUTZiUnRDdHZPYkl4S1hxSmpudk9rZWxtSktaTWx5UENqRmRYdDNoYjd4K1hGRzgrRTltYjQ0UjJvdUs0dnVXeTdVNHp6VFFuTitzNHZVNkxxRHJqdVRtVHNicDdvenIvdHpYTy84V2tNR2VBMSswNmk1VjE5cFhtWFhVeHN2SXVZL0NuMUUxZk5SU1FzTHJrekxiOVlEczI0Ylc0bHVtWTQ3N202UzVWdFRoR3A4K1BvTDBqaEZHTDRzMVUxTTNXMmRWdDdyNjNaK2w4dUR3MTl1L00vQ3Q5NDNSUlJSM0YwdDZYbWRIdU1Ock51THc2dkNONjQzc25qM0xkQ2MzNnM1NzUvMVBSUlJrSEVPWTlnZkEvN25ZMWgzZkM5OXpaVHRGMnJaaks0TVUzNmc3VkNhekUzZWorS0lmV3huSEZOZTFhcHVIQUZyY1Y4ZGZSLzF4NXMyVDNCd3pnRHYveWY1L2Q4K1c2S0tLT3R1cXUrdGg3RHl6VDNMT3YrZ2VDZHNhZjVaMTdrT2czZVgwbXY0Tzd3OHUwVVVVZFdlYlBZUEMzU3ZwZHc1OG1PNmRPOUx0Sk8xTTlNVGkwU2grc2pWamZXcDBuTGVvbnlLeVo5d0hWR2tyMXZ0czdwMW1LWDNIUG9MbmZWbmpqNjkrZjFGRkZHNWVJZGhkVWRZOTU2SzV0MWh0eml2UGNhM0hhNWZTYXpIOWR0ZXBPV2RlNlU1ajExUlJSMk41aTlvajlNZWl2SDdWWXN1UG9IMjNOTDVLSHpqd1BMR1hUV1dSaWVselpqbHg2bHkwOGNkVG05Qk1GZXE5SGZJTHBmVWFmWVRMTW5oMzdpK2FPQzc5eG1paWlqdUxwYjB2TTZQY1liV2JjWGgxZXRPUmNPM2p3M3NmbkRzRHAvbnZuL0FGUFJSUnVEcHYwZG83cnowdmUwZDdkYmN0NnMyQ2NqaUZ6RDA0NVhWVHkvdTJuODhleGRoMU51bWkxUGt5NHZyZE4zeHduZVBYL3JEZjhBRzRtY3JHUzZ2TEtZczBOY0hKWWlvdVE1SlFpTEtoYVdzSmo1VTlUait3L1M1SFJTWTRaWS9DSE5Qa3JtaWlpaWlpaWlqM3Z3UFhhQ2lJeG5wWGtWVVZacXFYeVNhaW5hVlo1VG1lN0t6anh4aE1kTkkyelcyaWJSeExlZlVUSFgwSnBQcFJpa0N3UzF6VXFpa0xxOUQ0VCs4dmx4UnNMai9LM3FadGhiRHl5WDB1dmo4K2p3dmQrUDJtTnVjVjV6cjNmdUx1MXlacHMvSVlqVjZCNmw4RjN2aTJtK1g5ZnU4TzdCNWQ4WWZTakFzZU5LMEZmRThsUUdydEt4eXNaRnNlOFpueFhlY083TDRYSFk4bURZYzVFSmF1Zk9hMzl2ZFhzL1UrU3ZpUDdnK1plRTc1eHVpaWlqcWZySHZESDlkdFM0dVRqeUJac0JtSE1Uank4MWRpZE9zNWNkRkd5K2p1OGVodmlWOWw5ZDczcm1iYXJET1diQnJUbmZHdG1jRzVKcmptR3piMjZpN010R1JtOHhtcnhzWkxJUlBhRFNtNGNSMm54eDJ2MGZvLzZUOC83cTc1Njk4NysvL0ovbjkzMTVib29vbzJ0eGJuVzF1TDg3eExkZVBUMmgzWVBOcFRNT3BxMU5BYzQ2c2dkdzJ5aWlqY3ZrSDZBZFg5WTlwTlljbWo4bVhjOXFaWmxodlRUdUNrRjNxdkxweExaZEZIa0h1TnVrOFdIY1ZiNlZ0UHNEdDJITWRSTW5xOCtoK2U5V2VRL3I3NS9VVVVVWi9zUEtkemNRN0h4amN0akZ5WXNyMnpleDcwcGp3dmVPT2FjNWYxL1JSUjAvNUc5N2FFNjU3azh2TXRNclQ3aTZHM1NlR2NTb2xMUkpYcktXUzlxdHc4K3RaVHlvejM3d3hUNnphQ3pUSGtHYkR1RE5sWWkvaUw3aCtaMkQ3OXhtaWlpanFmckh2REg5ZHRTNHVUanlRMnIwR1NiZnV5SnB6VjJKMDZ6bHgwVWRYZWRmWFBUSFNmb3pWK3B2TjdUdVhubDJkeExxblo4K05hbkRvYmRxZEw4RjVoMTdzdUh4KzUvcGR2NnpZODYwZVdJMVdIbS9KcS9aM3JmY2QyYVhJcTJLT3k2bklNZVpjb0tUVmpneUlIQW1ENUhHczVmS2Rxc1AyS2FYTllJSVFwajg5c2p6YXlTUVdIVU5LMHU4TW1RdzkrTUVaWGtIWTBWS1B1Sm9lZ0dGNUhtdExVVXRGV2p1U2xvbFBGMW8zZWpPcWladHcxYXZhVlhVRlhYbFZGcldteUt4MVhydEI0TGU4dmwxUnRUaS9OK2tPdjhBdG5hbkdPYzZaNWJ3SFlleGNteFRjOW9aeWFXSjFPajJCc1hMT2Y4QW5YVmU1K0lkaEE1OU5tZXo4azBOemZxL2w3c3ZwWlhET3dlVy9HbjBvd0RIajJ0ZkF4R2JXK1BNSmFqVjZNWHFET01tTFpyQm1MaVlwR3FOaTA1WFVaalI5QjJxMmZidVczaVY3ZjhBbVhoVys4Ym9vMkR4L2xYV1BWL2VlYWJSditHN3Zza1ZxdHI1ODUxMWYxMTFYM3ZobTc3QXhrd2JDMkhsZm5ENkQ4alVVWi8xQjNCdi93Q0hQMm8xMXlQY3RFZHVjSmhlUWJCakc5N1NGcUtNWU5RenBzNk5YYnB6b3Z0dkt1UDcreGx4TzF3eW1qeHlPbXhyaUc4K2c5TS9YWG5EYWZhM0R2T3Z2L3lid0QzejVkb295M2FkODcwNlI5TjRKdlhITVozSGFNYzNIWjh3MmpmOGMzSFp0bmNhNXpGNnJic2cwTzY2WDVkMTd6SDJUMHpSUjMzNG4raXVaOEQ3Q0dybENSUFhyNDBhN1BiVVlOMDRvM3hodGptU3ZjT1BEenBiSjVQNjJuUmNWeENHQkwvUUpvc0c4ZFZRcStxMFB6N3F6eUg5ZS9QNmlpaWowSDZIOVVPMHk2ODM3aWVnZWM5WWRwOVFlaGRmYjV4cVcwMnJhdmg0Ujd0ODBVVVVibThpZS9ONzlhOXdha3RUbnZKYlptRjZBNmVjOHRqVE1Xa0JNeHRKNSt6MThyZFhYUmQ0WXBQdlRvN2JseDF6SFBoM1Rsek5yZUlQdDc1bllKdi9BQm1qcXZyRHV6TzlrNVFkZzFRMlhERWFyUmJKNDl5M1VQSytCeGVwMitiMFc3YlQ0MXpPSDFlM29zNUs3UjZKMXR5UGlIYUhtYjJGdTdvMzBrRFcySTd4b1BJVHVEaDByaXZwamNxOVJiTm4zTnNPNmVyWFhPK1FWTHkycHhXdlNNejQ5YmFtazNvZGJvamZ0czNqdG1zNlcyN1ZTbVBPbENDRnlFQTRzT0hvRlNoU0RoOGMrc3gvWnBwTHZFMUV3RXZQVGh2ckhpTGkzcFc2TnI2L2hIc1IySjRNMEZ0UFozbEJ3SDI3YzdLNUw1ODd4NVY1bThSZXNQbzUydHluemI2VDh6OGptMnQ1WGNDOXE4UGNZOUY1M3ErTCt1SFl2Z3ZtalkrNWVFZUplbi9WTHNEdzc1WGRmKzR1eE9TZWY0WEh1SEttd2Q0UHc2WjN2cC8wRTVkNWM4Y2V1ZmZXR2FiZnU3dVcrWVBTVG12aisxMUQwSklCZ3ZXYUh3Uzk1ZkxtamN2RCt3KzNPblBSTzVlSTlpODA5aWRRYmg0cHpqSGRkdGdXZlM3VjR4em5tUHNmcGpRdk9lc09yK3JlOVI4bUxkbkR1eHVQdTErZ3VMTzR2T3gzSCtUOGxlSXZxQmcxSUh5UjFiYlM1dENPck9vb3ZvV21RcWNjTElxOTBoK09WMHRKVm5KWW5vZUoraFRWYmFWTHc4OXYvTTNDZDk0M1JSdTdoblkzUUhCTzFldnVxdTlOTTh1NFFpZEx4WjNCNTQ3QjZuOUJaaHRPOG00czJxK1RjTTg1ZlFQa3FpakorTWNxNk4rQnYzaHdEZXR5dzdsdXk4cWQrOVJZOXZlek5ZTTcrZzF1UWJWdTBob2R3ZHphZnJIenQzbzVYSE9hSFJ0MmtySGprdExqTTFPM2VwSHV6eTVrdkpkcjg0Ky92Si9CWGZYbHVpalBOaTVMNkw5QmVzc1kzRGJ0aGJGeVRRWE9Pc2VvdXR1NStJZTVmTjNRWEErM0V6aTJweG5tZkpQYVhSM0ZuY1huU2lqdVR4cjlBTm9kYjlxWkZpeVk1ZXpOSGxidTFWV3g4ZTVyN2tpbkxXU2ZjWFFZK3E4TnNJeFlzeHZoMXZtblgyVy9mREh0N1daNGl1WFEvTytyUEgzMTc4L3FLS0tQVzd5eDdxd3JkOWdtZEp1UEwzWlBTdlRQWFhjb0diVDVSdHU3TVpkTDVVZW1mRkRXWEhSUjBCNW05bWRBOUdlbHB5c3dLREpwaG1iQ0JTMi9NSXljZXJjclpwNXo2NnZCOTRnSm5wV3JxRERIbzVTcm1TTjJ4ZGc4Vi9jWHpSd2ZmdU0wZHY4QVRQbzdZT3djdTJseHZtUk9QVVk3cjlyeGJjOWl6WForUWFtNVJ3akJONTQ1MXAxZjNoaE84OGJsOUxydUMrN3ZNV2plYTliOVYrZS9WSFVubjcxUks2YlBCelBDUFlQRytGK1lhSUNIY1BHOVg2Q2RlNzdrMkM4ek44Y0diVWNtcFVWNDY1bHRlQjc5dGV5OXYzRDAxNEp5RWlzeE1wUVFtSWtEYUpDRFl6SXlvR1ZqNDl0WGgrckhTNWR5eE1wVkYyZVR2QVBjM25Kd3YxOTJKeVB6M3gzeHowSjY0OWgrQ1RKcDVCZGQrK1pTMmk2NzVEMFI2MzlnK0ZmbkI2Yit0M3BOekx5TDY3ZGplRWVjOWo3YitlL3FQNm03bTNIci9UMjNjOTY1NUYwTHZqZHVzZk1uZy9zdjFNNTU0bThzK0IrMmZRVGxubHlCdzdwd3p4bjBmdHpYOEQ2bDMvcFBDdEx5UGtianZmT3g5YnhEVXUzYzcrakR1ajVIN1YzSGc5cEdEMk5VbzdWNkx3ZTk2ZkxpaWpKZHMza2pIa2J0U00xT2tMeFppTWVaVUFzMm5BMUdsbHRKcmhNdUc2V3JVaWRab0txMWQ0bCttblBQSCtZN0ZuRjBIT0hZdVRGZ00yRnJFSEZjR3JseVNhY2U0OVZKemRsU1hwYWN3NU01aTNvenFOTjZ4MjBnNTRtZTMvbWRoVys4Y29vcXJJOXUzYzNGbkd5WTVmUzZ5QjEyMklsZURsYjVGb3R5MTN2L0FCZWlpOUhUbnhOKzNtTzlZOXZqNWMyaE80ZXZ0UmRuOEN0ajFHTmJwb0pQYjlTVnMyNzdBMkRlT2llaysyUmMrR1owR1FyRGdtdEZnbk5EcHRvZGc4UjlEL2IvQUp0ZHU4NU8vd0R5ZndaM3o1Ym9vZXhaTWoyL2RnOHVDZDBXNHNaS0Q1TU1YcU5HYmgxSXVYQzFiSGFZaTlYb3FLT3F2TlhyNk42VDlMSDRMYk4wMlNmckhLK3NwNTBhK0pTdDdxOXphT08xZE5USm90RzQ2MnlKL1U0TXV5eDU0NnpMNjkxdkxMYUY1MzFaNDVldmZuOVJSUlJrMjJid3hmSFlidGplcGxadmpJeDVSTXVuaU5ib2FLS051ZFA5L2RaZVUvY1IxSnRXenlQSGZkdEpEV1l4Wmk2dS9xUjdEYVJwR3VTRXk0NW1MRFdwdVZHaE04OWVWZEVVbVRoNGUrNHZtamdtL2Nab21kRnVGNFRPazNGdTFJYlY2QTdCcVQ4T29oZFp0OUJHTFBjcEVCcjlyUmV1ZThQNTd0VHluOUJNbDBHVG9qanU2NHB1R2o4eHUxdUo4NmI5dC90cDBienpZVzM1NTZreEVpTTJMQmQyMG05ZHAxRUZOSXpldEo1VzlnN042NzhDMy9jV3g3a2NKTGxtUkpqV1RITDFFMkJRYkFZVkw1bE5UaTlaTVYvU2Vsb3VJbFplUlhYL0FMbjg0K0YrdnZiZnRINXNlSkhWMzBuOVNlZWVJb3ZIcmZNbmd2dEhvSGVPcVRyWWZhZnN6NTJmT1YwMzlidlJqbVhrVDE3N0M4TGNUY1k5RWVJdldYMGM5cnV6UG5WNU9jQTl4NWJuMmJzM2tubjN5NjRQN043WDVMNTM0bzQxNkk3OTVaNWJnTU82Y1E4WjlJZlMxM2Y4ZGNtMU93K0NQVUgxSjA3dDNQOEExMTdFOEY4bDhmNzI5S3ViK1BOMDdsMXhWMGhRbUQwb1hQcC9QUDBoNDhkTFROQ1UzUUlVa2t1Z1VLTGxoWXdXSFRCZXArLy9BQzI0RDIyTGZIMWpiVHdoVXljakQ0bkNLMjBCWExTV2pKSXlTc1Z5L0hmZWxhKzdXcDBHYlJGenovOEFRbmt1SjNIYUtzcXF5V3JMVlVKRWhjd3dYSDVNcFhFTXBLQ3ZIZnNMVDNpZjJkSDU3dFRmRGVVYlJqdTVSaS9JOWl4dmV0bTJid3ZrbWVjSTVnOWoxRnNtaXlmYVpWRmNqMnpUVEZkdTdqOWE5R2JsN3Q0QThjcWRsZEw4ODlrZE9OQTZieXZFSmxkQmNUVW1vbGxGRjVPMVBUTEV4YUdUOE03Q3hUcFAwVHJHYmJ0ME5wR011cTlUaTh2ZHdtU3JIZmVtcDFWcDZTa3puMDRwaTJubkpwZ0dQVzR2cmNXRTZ5UFFIRnFuTWJXdkp1RzhEOTQrWnJSSlNGSlNoaVQwTFNjaVV5dFVNRkNCQTBLSkRiZDVOODUrdW8yclA4RXJwZmtQVllQSlRjTWVBMnIwTlYyVnA3K2ptbUc0NUlWVmVzN2xwcjdKUEpHcW4yUDA4dlZIbm5wNkc4bTQ3dVd6Q2p3MEtpVUxMUW9HRkZnbEtrTmpBV08weVpoMFQ2czE1VFZiczQ3dVQyT2ZPTHM3akdDVG45WU9ydCttWWdYSlRtL2xHM2NoYzIySG4zZk52K2hEbzNtc0pFNGZ2V2owM3Y4QXAvUm5oZSsxaXpEZ0ZqQTFTWEJWNEtnZFpHd2pwSkZROGNNMU5Vekh2dGd5UjhzZ1BKbnI3M041cWNNOWZkRjd6MUZvN2F1eS9kUHRmNWpjRmNSOVNjVWNYOUk5UmI5MGxvZmFlMGZkdnRmNWgvT3owMzlidlIvbVhrWDFzN0M4SThWY1k5RytKUFdYMGI5c2V6Zm5QNVBkZis1Y2l6YlIyTnlYejc1ajhIOW1iUzEzQ2RXNkhtM2UvTGZMY0ZnM1RpWGpQcEQwVTVsNUs2TTNycUxBTkZ5cnllNEI3bzM5dTNWbnVwMnQ4ek15MVhIYUtza0tHN2ljYU9rVkI4SXlaRk1kTHg2UlNsWlJaOGhTU0NBSldVV2pSQ3BhQkpqNTBvMVhNMFhBSkdaM2hrMDJiUzJ0a3BwMmwrVE1HdWFtbDBaVkNlcE93TWIxL3dBbWg3ZHoxZHJJa0RaaXJyQlZEc0VXUmJKVVZwV2t5MHhFMlhxSmdxNVJINDAva0JZY3ZraDQ2OU02czJyZjQ3UG1UZVhzV1Z6UzZrN1NaSkRTMGRyZGpQUlZXVjdUZ2s5SmhudEhvdDM5dDhDN3A5aWRDTTVZY0F5UkljSkxDcWhwaE1KVzB2akJGWTFGeVJtSHJ5MlhFbkpPaHB6NmJaMDg0cGkxV0taSzhEN2hpMnJWNkM2WEdGQW1YQnU0MDFabnQ2UTRkSnRpdG96VVIwSGkxZVpydTR3bVJHRnk1TURBd1BzZ2pHY21GUXJIZEJOb2JWalZxV2RHV1BRT1BMeEhNa1liN1kwZHBPYStMMjdZdWZyeDNiZ2oxRjBkcGhPYVJVUkNyMWlNa3kyYkRtOXN1MmNaMlN5NGlTYWtMS1M4bVBKUWNJRXNYSndERkFCTmxHRFh4ZWVHKzdidDdadFJPN1pyc0oxRkpDMlBNdEpsSlJxRGttZzBaeXJhZFdhL1MzdlgxZjZ4NU1mang4N2NncDJKdHVmTE5zMThUY0pLeFFiakhBdHpKUkhTSUQ0R1M1M1I4b2Vydy9SanBzdmYxWkFQTHpyNzNSNXE4TTllOUFicjFib1BhZTBQYmp0UDVyZWYzRC9WdWs5cTdKNnE1QjBid3R4UDA3OUIvY255YytlRHByNjIrakhNdkl2cS93QmhlRmVMK01laWZGanJMNk4rMGZadnpuOHFldjhBM0xrZWJaK3d1UytmL00zZy9zdVV2b291bXQ3NTVaNWJnTVc2Y1M4WTlJVWR3Y284MmUxblp2enY4Z091UGZ2bmx4SDFOMFB1L1UvdnIyNzh0aWJZTEJ0U3k0R1BaRXJqTTNsc1ZOeVNnSldsWkZhRVd1VEpjWVZaQkNUbUhsZVY1djhBUDYxZUxWQnhMQ284amEyYm10cFdpY3RYbFlpY2w2UDQ4WHFmbjB6MW9rNkhKbHEwSUtBUjZoK0NiQUxFUkV4Tm5FaEtpeENwbVdvSGhIa3pjbUdtZUk4ajh1Zk92ZW1KYVBlcGpqdThYMHVyaGR4aDNOaEpqVEVhYk12VDZqTGRscE9hSEFTMCt6K3hlSStoWHIvenFWdU9uUEVnWmNhRkRnWUxJaWd1NlJvVGRDVVdoYXlSa3VWRkQ1aHRISEdrb3JUNXNwclRsN05mUk5yOWVZS1p3bkw3NldDMWxORDZxa3BEb0dkTm1FWHkrTmR1SEhrUmtKcUZzQnh6TFRFUEV1U2xydzJtNklhbHB1WUNpNFVRWWs5VUJZY1VTSkhLaXJjbVVuUStPK1phVEllanpqMStEUVdXUFlyYnJUY3psbHBlcmpKbWh1V291U20wc2x0eU1yZU9vSXprVldiUlo2Sk5CZ01sZ1FrQUVHRFJnYkZFZVR4RGtnYXRZOUc0YXorTzNtLzJQeC9XTzc2TDFENnE1Uk00TWh1ZkZKNThSOThXTDJ0bDJHK0FhaTNST25uT2RQckljR3VWQk1UTlFiUkRTbHlLc3NUQStYSW1BY3ZtTTFHUGpmSTlsTUU1SERMdXUvZFhuSnd2MTc5Q2Zidnl2K2V6cUw2b2Vpdk0vSXZOR3g5eWdVMWZUKys5SitlUER2VzN2cDI1OHJ2QXZxUDZvK2pITXZJdnJCMkY0VjR2NHg2SjhWK3N2bzM3U2RtZk9meW82LzhBY3VSNTluN0M1TDUvOHplRCt5K2h0NDZtNTUyZnRudmpsdmx1QnhicHhMeGYwaDlIWGMveUp6L1Y4ZTRHNGY2b2hjVzVjNGJQMnh4UnhyMEw3MjlzZk1IcHprSFNyVlRzSkc0VEdYSXU2TXhyQ0JXU2FyQnRza2dxbFowRUlzZUMxUTFwVWgxTWdSVXdQTGtpTW5ncFRXNDViSTNYRkd6VEpZdTZoMmJTRXhqbDY3UXBYMDltbm85T25JRldINHk1TlNEZ3VTTEVGaEpRNlNna2NJU0ZwbWFyREZnOVRkaGdBWUR4amtQbFIwWjNYb1BmOXR5empPOHl1dzduTmJWdVUzc210anRURnNsOHUyQ0U2akIxRDIvMWgyZDZQNldrOVJwM3J6TERaR2cxRTFjSVBnUStDRHhLVVh1aFJ1Q1Nha29VQUZGelh0SEhXbnB5dGtjbzVNc1ZldnBSaXc5SzRZaGIxMXRuclZzZXc2MDNGYU5sVTNETW91b3RjS2wxRU5qc29RdFNKUEpRc29oOGVSNUVpbElrV1JZUUNGZ1lJRm5OV210cVBCZHlZNXJ2RzFhMjJKRkRiUnFYVTR6cjFrVmRwcWRCMXZzZStVaE5ZNlVVdlNiSmFSRWp4SkE1WUpMRkNDQkpzR0lza3lJSllzWU5mSHl2dU9nNEM3RDQxelh5SForeWVGOGw3NDRQdmMxb2N6dVNISW1QMTJuNXgzdlQ5VWJOdUc4OXQxVWhRRGNzRWxNNDhpbGNkeVZJaEpRanBUTXFJcUJnYklVNE10WDVrOVZXanRMRzlIZXQvZFhuSnd2MTk5QWZiWHk0K2Z6cVg2aitrL00vSVhEZkYvU1d2Tkp5dWlqMjU3UithL2lOMWQ5S1BSam1Ya1gxZzdDOEs4ZWNaOUIrSlhXUDBoOW1leWZuajVVY0E5eVp2cStNZGQ4ajZGOHkrRCt5L1FYbC9sSHo2NGg2dTlBK1crWE1ZdzdueEh4ajBoOUtmZFB5RXp2VWJKNEE5Uy9UM1grazVSNnRjKzhVZUt2V3YwSTl4KzBmbTExOXlUejVSWW5JUXhMeUZnRVN0N2tSRFNSbFFybDBtVnRhd1FScW9TMXlSVm9RcktGRjdFbzFPdjVqVnorZUVaTmZyelVSSm9rRTdHbU8yR2w5Qkp4YnVzSXRMQVFEVkpMU1hJMEVFQ0NpNGNLQ3dZSEFpWkd4OGlCSlZWUWN4NWVOT3UrdytDdUs4cTFyc084eUNtVDhhM0xMK0diOUw0OVQwSDJaMTUyTDNMMWJzVG52RWsxbTZKYThvRnhXSWkxNFRGMGVTQTBJRkFoTFkxcklheEFrbXFoTEd3NGp5VWhVc1RxNFZxNUpxMFhubUVuRjZoeHBOa1ZKUk9wM0F2bDFOVzhtNWFUNFZjV1JtT1JSd2FTcWF6U2IzZ1hIa2kwVEtqSzBTVEJIclNLSVZKQ3NnRExXWTNWdEkwdDUrWTU4enNrYmdtUFZEQWRwRWxsWkxOTTl2WFo2ODFDVnZhOFNvQXFOVGNvWUVCSlJIRDVFaFJJa09YSmNGSWNTWER3VW5JWTFhdm5yeUhhOUpibm9WYXJEaFdiTDN4d3Jjc0QxazRWcmNXNjl2MUhSZTE2dk5zV1FRbU1hRnNkSm1KWEZ4Q0Z0aklsSnlkSEJCRXdNRDVXQlQ1cXRSajg5c2p0dkc5Sk90dmRYbXB3ejE5a0dUYThmeDdwN05kbGZPL3h1NjEraFhXM0llaWVsOTc2ZzhxZUIrMi9YenNid0Q1QjljKy9zc3piRm5XczR4NlljMzhhZU9mVy8wSmtiNk9FeDdsMzl5N3lybW1yNDc1bThHOW1ld3ZZM3o4OGV1dWZvSDMxeXp5NWorSGRlSmVNK2pxTjZibjF0MGh2UFVmbjN4UDFMUDVOc2hNVzRmUmYzUDhrTm82L2hORmlTZzBPaXNockdsYjVMVEtjY05Dc2xZaFc5RTFmSTJQaUNsYnhXTGxNRDJSY29IVkFyYXJBNGFPcmZXNng1dGRUYXNWSmtzVEVTT1NSQm9hRWxCSkxESU9FRElvc0pMREk2Q0JnU0tCU054cmxwVFZ5eU5yR0U3YnVHdTlIcmI2WFZaamx3YkUzamFKalZhYXJ6RERkSU1tMGxXS2tpMFFrellkQ1FjSkd4c2NKT2hOMEpCTW5pUkFTdytPaEFnRUNockd3S0dwa1pES2tabE5zdGhheCtDQkltRkNzaFJKQUFQaktTMm1RSkRKVkdPOE9vaE1nbUxEMWdTWkFDU1VwTU9zZ2syTmxaV091czdUbzFNTExkOFZ5NWJLcGgySUxxaWhkazNDOThqR01zV05EaGRhbGFJa2FCU1NCUVVuaFEyUUFrdVhKMGRGQ1FNeGVLNC9OUnBUY3pOVnVvdEM1YVdRNHlCWlprc1VSckhIV1R0ak5UQkkySkhDT3FYWWVhVFBsUjFXTG91cyszSEVQUm5LT3c5NENvM1Z1WFgzZlhMZkwzazF3RDNIMWx2M1NPNzkxNno4NE9HZXV1MHVTK2ZPT09OZWcyd2RYMEo1ajVNMWhvT2JjUThXOUs3QjF2RS9URG5YalBtWFl1Nk9TK085OGVrSE5mSC9tL3duMkIwcHZmVUVkajFuUCswZHAwYkQxdkUvUWptSGxMemE0UDdJMXJvK1c5aWNtODg5dGNvODNxcmVrMHhxeUpyR2hzaVVpMGZXczFObXBtNlUwRTNnR0t4dFlrWktreEpNMmRpcmc5WklYTUFCUktnUU1Td0VNQ2hvb2NvUkpOaEEwTWxGRnhRVVNCWXNNbHdZUU9oZFFWaWlnaXE1YXl4VlZXWExRcUZpOWxoZFY0VWlrMkxDNFVYa3U2RUd4MkJFbndnamhnbHhaR0FncXFTc0NFRDRRV0N3V3BGaG1OVmxWVklHOWpxMWo3RmdRMktDd3FoWXU2d09MVEcwa1lxRmtTc2lJczByRExXS0xEcURsaUNsQTZ3Vk9SdVRVUUlNMFVWZWprelJKTHd1UEdteHlwQXV5VnFJWktLR0NCTWdIU2lpSkk1RkYwcEpnS0xEWkFDUlVKVUtrc2FJMkFzbkM4QmlSQ3BNRGhDd3VPMVdIZzZMRUNTNnFSTXFFWExFaWpIaDBORkhJTXg0cVpzZm9uVy9BOTYraDJPM21wa3I3aVlyNnFERklrOHNNcjFPeDI4cDhsZmUzRGZIMWZEdk5UMHR4MjVPdENaVU9rc25JcXVSYngzNWp2bjZmTGZMajlXY1U4bzJqMFF4MjhSczBkN1Z0d1BlbnZCam5vV01sWTEyT2dzTEl5WklTbFdWZzllNDBDclZpNlFGQ1VrellLRmhJbVpJeVFHS0I4WldSS0JPTkZaRWlORWNVV29xNThZTEZxcXNTVUtGRnhSS2x4dXBtd29pQzRXTWlBa29qY2EyUW9zWEtLTGxxcmxyS0xsaTJPTHpOWFZWY3NMSnV5REVGRjRWSlFRSENBRVlMd1BreURpaVdCaFFTUjRXVlFzdkJHUkRKbWdXb2EwVUVWRjJYS0JSd2RMSnNtNkJrUjJPekN0bGpscEFGSXRGMDBGcXJXT0k0Q3BqTGdySmt0ak9Ed2kwTTJwWkpTeXlLcFFPRDBweUNyR0toV1NRTENSdEx4WkFvVVJ4RXNkRjJTV0ZBUWdjQ1JzY0RCSlFNUWdVQ0QwSkdGQXNxQzRNQWNoWkVRYkM2SlFEQkI0TkxGWkZoRkNFdzlvZWt5VE5VVlpweVk4bjhsZE8yaVBNM1BlWFQ1UE5USldRUnhUa2lOVGpNeE53OXY4VjlJbythZlU0KytLVGhoR3pOSWVOR3k2L3FwT0VJNmNyYnpmeVU5TnFYNVR0WDE3d3o1aTVIUmNUeTlhUGJuSGJvQ0pWQzhVdkNpUkZ6TWRFRUNKRXhaYzFGZ3lGeUxrRFliVmFWclNUZUJpV0d5S0xFdUt4bDVDU05HQzViR3RrTEZqQWtWQk1sQklVTkRWQjF6SXNmQlNOQ1FnZEd3aXNzV2lMeG44aEkrTkZ4d2FIQ2hBNk5sRGxETnl4WXhVZ3VTOFJDek43S2hZdkp3c0lLSGg4Y0FSc0xIZ1FJQ2h6R0h5RjFKc1NSaVpsRVNURlp0YXlWRzZXamdtOVRTa3ByRFVaSTlWSXBVaFlsQzR1MnhqTG9RNHNwVUpZWkRoSktJWkZDd0tzTFVkbTVDVlVpMHlpOWJLM2hhTDFNTmtTaEZJbkJlUzhYQUNzdndreDhRTEJDSER4NGgwSkpWTkVVV0NoNGFFRWdGRnl4UkN3RWxRVVNSRFFsWlIwSFpGMU1RaXJxRjFUbFZFYVVsUWVpNDFrTTBYWkxFVGZHb29VV0ZIaHpscHFLMFJSZzB4OUdPbnljQTNnMDRxdlZpWFQxYmVjT1N2dHRodFI0WVpxTUcyNFlwTmxJZlJ5N2FPOUtTU2E2bHRPczZZdEcrcXpxR3oyQXd2RlBOSHNmaHllTUdhbnRiaXQzakZiQ29YaGVGQjlwS3JFZGNkSnlwc29kSGJMREVHSkd5SnVpU2FMRHBZalNRS3hoN3dOTXREZ2tiRkRhREVqbENDMEg1U1lBRlZCd0xzY2xjb2hoSklGeG92UWZBYklqTVovSUxHUjhzTkQ0Z1NQREE2WEI0RXlzTWo1R1ZLc09wV05teWgyMGtEaUZpcUhJWHlMVkRXRGl3c1dSUTZLSEFTcDZ3OG9zRGkyUUJqa0JhV2lJeHlRc2ZreHJCcVpDbFlXTE1LWExJb3BaNUxvNE5qQ0NGalZXUmhZUlZwYTZzMHNRUmtWUHBhMlNJK3RJKzFrSnZTbHhjSGdqSkxxN2VQR1hrTjQ4a1dERW1IalpGa29LSWdraTVqNCtTNUFGa3lDSklHSThTTURvZUVEbzJSZ0NUSUxCTW00T1ZKRVdHMFEyUVJDVm9jRWtVSHNnZ0t4ekJqOGlJRDVGeXFKTWtRRWZ1aGp3N3kwOC9jdGUwTWM4dldyOUIybnk4bzNqenl5MXpXSEpkNDdQeDI0eHlWOXVzTjlpMWVXZWF1dUVPUTE1WWt5V0ZTMmpEbDJ6cWFyWDhvUXpOUE84MTlJTWR1Q3J1ckt6eG5ldnQ5aHY2Vlk1UUltVXhDTFV0VTFaVXB5WkdCQkJVS2tvY1FYSXFUMWtXVU9ncE9qQXlGWTFnZVpNdkF3MlhHUm9XU2NSRXhMSlZoVlVqWmNqU1FxQ3NZSFV1b1pFcEhyRXZZeWxwQ3FESUQ1RVRVZFpWWWZpV2JuQlF3UGxBNFFKRWpsSlp2Q3h3R0dDeUpHc2l4TWxlTEp1aHVvYVlOZzNBRkkxMWkxVjdLSHc4YnJEc28yWlpxVGFaY3NnQWtocFlkVndLSThDeDVIRlpXYkRBU2t1dkNSV3l0RkYwcFRTMWtVUEJxREZxVmlGaHdzTUtWQ3JhVkl4V1NpWXkwUjBWcGF4ZXRiU1JkZUZwbWdxa0ZRTVhjSTlKZ29qeU5KVU9HeWxySWgwRmpKSGl5ZUdTSEpVQ0hRRWFMRnlRcVprSEthQllOQ1I2b3NqaVZoQVdFUWxZS0tJWXBLQ1dRdGFKUU9xaTB2azNVSUNDaVF5Qm9hc2xoOHhzMkoxSE1icHJOeldjeHN1SndTWTNtbm4xSFFFVEFHTldDQWFKbERaQ2hpRkp3OVhQSm5EWmpZdGNtTUl4K1QwQlpiRmlkVVM2YnFmVFl1aTVVNDdsU1ZaUlNhTFdsVVZhaVh5MlNMUXFUWkhGeWc4SkFDVHdITHI1RFJIWUxZN3Qrcmk5UGtWZ3RKNjdUeXU0NmZJTTFBaG1CZFpjeVExUUlrNjhNaXFHNE81SkRYQlk1QVpEa3NvY1NJaVVUVklGdWl3a0xHNlZYZTFDUlpZU0xnT2g5RjVzMVdIYlRRMk9nTllUYVU0N3VLeXVTQkFrY3JXMXJCWTRCVFJSUXVWN3FEUVVrQWdpd0VVdE1JWlJIa2trVVVoSVVQZ21PMFlXSlpaV1RHNm1EeDNiWTZLV3BORjBrcWtMWEcxVEVYV2lrM1kxc2c2cjQzanRKZ0RISUVVQldPeUxqSmVNYkZ6Y0hxbVFleThrMVhxSmtaR1FrVVVEanBGRWtMS1NPaFJCQ1NRSlFoeTVJRU9GRWlZNm15Sm9pNE1pUXNscGlDSmlRbFpqeVdvalFZc09rK0JBSVFJRFFGa2tsWVZEQ0NTU0k0Y0pJaWNpYkkrQUk4SUoyVnh3WkZqb0VSSThUa0V5dVJwWVVFQkJjaDV4eThGcGNYYklNeUlpUUllRkU0WEJBVmpXUFNKUzVNV3NqMlFtYWl4WlJkV1NSV1NGRWJWYXl4Y3VMcW1acTdVa3g3UjU5S2NUMzNXZkVkNUUwbVl1S2o0czE4TVpOck5QbW5OTm4ydnpIWXNtMStDTnFlZ1VtS1hlbkdTbUxpQ1F4QTZXd3VDY2dZZFNlbGlKWE1MckF0b2k2aTdDUklxRm9WWTFGR2N1UFJGYmE0eDVOOTVLYm15VkVpTlRVeVlsaXk3L0FMMWFMQTlURmJYbUpsQU53SVFTdFVaWU5Rb1dLVGVDSmhtVnJRUWxzbFF1cGkwamp5SXhMNkM2b2JBNDNqZE81dGRzOG1VV0dxekhWdEM0NzJXbFpvOFFzWFlZNldwTkpvc1dMb2RSSXJQcVVtTUxSVjhiRVFibklkV0VSUndiWGlMUksydGVtSFJ1TFRjeDVzWE9PbXBoUEVlVmg3cnh6Y0dzajFmNER2RXgycm80NmJwcEZvczZIQndzYklra2dVZkhRVWh5eE5CQmp3K0VqSllJaEZ6TWxFT1NpWVJXU3M1bXc1QXJ5RkdvNFVuTnFxdGVxbVB2MnROcllyWTNXNHRUNDJIcG9GQ2tVRnBGWE9BeUpZOGpJa01CeHNWa1BRU1I0OUtZQ0JJb1VDaXh3aGg4bEFRTFdoR0Z0a2JMajdIUE1pV01ZaDVaQ3VKRWlrNnNLckNpZzhrd01paFU0NmhhVncrVW5ZeXlOakFrU1NjNDNyZ1Jrb3ZqWGtaZE1NYmFjWXczMUZ4amV0WmNHMzZOMnJWWkN4eUZxQjZYS2lidHpRclBYR2Fha3JYYVhvZnMzaTJ3K1JiWlljQkVOSkxFcEFXdmp4aWxDd3pJb2NEVmhLMWR0TklaV2phVk9MM09qVlZJMWZhT2Q1alVHbjFIUXVYSE9VY1NXeVRlejZqdFBldEZzdkpUbTdGZlIxWTlMN0M3VGVxTnJlY3lVZHhtY2lNckI5cGFMSkxXY0VJb1VsS3RJWUxwS0FVRXFFck1yMlZZTVV4WXZQallkb3htdGU0OW03QW51ZmNmM3JrdzBZZEdUalRhT1JTdXdNNTNEYTl2YjFwSnJMSkNvaGRha1VtaXlGcElIaFNyNndBOEpBV09XeGc4aHVoTnJLcldTaEc1RXBqeVkvcDQ4Lzc3WnhadStMQzl5dHRUcmIwTDNab3MrbXR0NVp5MXhEbkVWMjE0TTltUE5lKzlDK3I5THFucTdXVGZhR0s4RWlSUWNIQ2hCQ0NpWEFDTktKWUhCeHNuQ2lPQllLbE9ERUlqVTRNSzAxOHhtTmFaYmVlbUhMcVRMaTV2elczRGZGMHhTZlg2TVhLOXN1NXRGa0lyTHhJTWxFQ0ZNYUNkWktJbFFJdWlRRkNoc3NKa2NMdWlTY0hxQTdoU1dHU0dNaktLTGlTb0psR2dvMFVXSnNLUW1RazBQV2lxM3VpWUxqU1ZJb3VRNUtqeUVnUkhpOGxKMkNaeU5LeDZ5MWJMUzFxVk1KbFFzcXBnUXJKMnJCVnR6SHdIbEdzdUg3NWtHa3BzdlIxem5jTkcva3g2eDJYZGNXMFdwZXRUSXNVTjZqSGoyb3REN2pmb2JzN2lPMWVWN09SZXR5aUtUSW9ZQmNlUmdYT01zTnZNWFdDRUdqZHBkQkVxUkZqNFpTV0x3WFNOVjVNZkhHTE9OcDhtK05aZzh6TW1YMStqRGplMjUvR2pqRzZlczNNdG5jbU95TStMa0xCZmovVFovVC9VNHBlTFZLWnZXeWIwaTk1U0pTdFlaUlJkRFlZQ0JXTTdrTnBFaUJKS1ZrMHBUSEpOaUlhZEw0ZGNwNFBKN2hxZlY3eVoyM3VIdnpqZVNXcmM0RjR4cjhINkIxL0pmTnVQYSswR3o3QnRYMEw3VjNucUxmOEFWV1NwTkZGa1dSUXBZbFdRUXl2RUJCTUlqS2tDNmtpMUd4c2J5Q1YrRWN1MmVYTzc0SXVIUS9CKytmYXZjdUFiSDNQakhtaHdYMGQ1ZGFXM1hXeStOZlpQdFBtalhYdXU4TDlzMEc3T3pzL3FkbXoyVFlkR3hBY0hpd1lJSUlITGg1SWk0UllOSllrV0dEa1JoT2ZGSmFkSVk0RHZQbXZqejR4V05RWks1bm54K2Urc3Y3TFlKOU9jbUZNdVRHWGQraHRKeEpFV3BBSUdLSlZjQWptTndZSkVrU0ZIaHdaSmtnTWhJNFQyTTFrRFFrcE5FSENSZ2ZZb2JJOElnWklRaDJPd3Rrc1NaSkZ5NG9neDhrUm9MRUFvWVJSUlFnT0JnUmp5S3lvdUplR1ZrVnhtV3NYa3ExVU5FSWd6TWkxc2lJdk9LK1JwZmptOGFDNFp5SUxqK3YyMU9uUngzVmJBNVBzK1U4cDBHSWRlYjlpK0syZDZyUlpJeHdtRFBoZURXYTZ5YWsvTzY0Nzg2OE0xdUNRUlEwbDlDVXgyTzdDc2prcUNsYUdpWW9DdWNFaFFNeVJ6R2VYb0hyYkVjbUxuNm1UazNiOVYyTHE4R3VkVmp5dTBidnhUNVpiWnJPeXRPemJlZEYwWm14NWJNd1ZZMWpwY21ydHMxZlJ1OFlYMUVKazdDWnFIV3hkeTFsMW9sQzdMaXhBckdoY2c4YnJBZG9wYWtLVElqQk1YcGkwMDhRdVVjVW4raGVkZXZPWFZaWDJIdFY0bU5xNEQ4NDZ2ei81UndvelQxOUMrY2J4MWp5Zlc0Z1QrNHpzUytyb3RXS3ROS3FXTlZOTHBwTktnckZEcFJRbkd1TXNiR1Jhb0tHSjc1dC9nejNyMS9xanBibTgvcHRUNjhkYmVpL1FubXZRQUZNdmdsMDE3Yng3c2p3YjZlOFIyVHVEczdsdXVlQjRmRFRkdU1jeCtzK0IrbWZtcnVMMDd4NithRkdQRFpaSzBHa2lLQUNLTEZCUkxqZ2dhRUVXVFpwbWdMRGZNcVlzcXpZek0wY3U0c3ZMYTNQbXByckhVVXlUSGsraDJjRDk0cUpabG9rMkJvZFVmU0E1Z0FMWkN4UU9SckdPS0ZoQkxBb3NXVVErUlkxWnpMcnJ6NTlHZVFYWlVVaWtzekZoK0pvWUxsb0VXaGdTVVVYSER2TG9mMUgwUjF2M0NrS0lNVUVFZVpHUnBJRnlEQ3g4aHRScGpKcU9CS1pDbTByVEFNUXVSZGdjR29nQkMwV1pLTENveDQvb3RieGYxanpxKzI2bkk5UE0yMEc3ZWQ4Y3diVDdxYmp4YWs2MTN2ZCs0NmJvN21uR2w3aGoxajFqeVhIc09iVXVrM1JHNDR0bjlrOGYzN3o3amFsckNSVkxLWXhJdEVyT1RqdXlKVnV0UFh4MmhSVVRlME1WQzFrYURFc1Z2WFVWWTNncjVRY2MzbjJENUZzczVxS3ZWdjVaYkx1T2J4SG9UdmUydlRLclJ5N2d2ekJwTlJtY1IzRHFOS1ZreXQxeXFSSjJnS0Y0UzlvWnNEVWJDNjJSWWFDRWtCQkVJeVlTbWlxMXF0aXNpUnRRMjBlZE82N0w1MGFMSjZRK1RlMCt4UFUvQmRrWHBSaHRMZVIvalhVYWg3VDRkMlZ6UGR2Uy9zVGNYN3FNYXJFUmh6cVRSU0xyRkJnOFVvSWt5c1VsaEk0YUlJNnA4WlVYa05ZMlE1b2tzMVBDTHZmcnptRGkycGU2czdvOTB1Szh4Nms1ZjFCeDl4bnVUemszVGlHUzlPZE1leHZkdkxzcTFHVG1mcmphdkRmc25SWU42azYxOURlZ3V3ZlFicmprZTM5eTNCWkRnSmNjQ0IwUEZBeEVEWlE0SGp3UENPbE1tbEx6NHQ0ODBKcGN2WHVseTllWThQUTJzMFVka3A1MDVyOVc1ZEpvUEptNmJxNjQxRVVNWXphc0Rkb3ZEazNGcGRWSFRqbGlIV2ZLV1pKQmpLTEdQaUE4YUR5UEd3eTRVMEoySjFINVZldmZBZEZGRkZGRkZGRkZGRkZGRkZGSHB2NWY5cmRVZFArZ21TWEFRUVVHaEEwU293UXhKZzhQSlgyQjgvTkFkZzlWVVVVVVVVVVVVVVVVVVVVVWRMZUlmb0pzRG9QMGU3dGVvbU5KQ3VXYVhpM1Erd3NXMGZLZStPYythSjdoWG4zWWUyY3A2WTVIc09ZZHA3SnIzcUxrT2wrR2I5aGQ5UkhXdk44aDBuWGZkL0ExM2hTZkozMVA0V3hUZE5rVUlHeTR0S0VVUG9xVkZSYWtKQjZyeVhXMjhQSDN1M3NyTnVXZVJYeHE0MXZmc1p2OEFzK1NhbkJ5M3MrNCthY1pmYy9lZHFYZUM3V3duRmJpamcrK2NMN2xpbTkxMG5valhEMUhyc0NMYWxJOGpYdkt1RGVaM3BUeGtxVFFrb1dXSENpNDBMR2hSWXNLaHRyakhPUFQ3em43QzFaV1BEVGY5aTZ0OGc5dGJkNzMwL3BCeWZpQXdVY1gweThuZVFkMTJoNk00VjFyeWJkZCthL05SY28xeGp1YmpsUzNHbmpydXZFZDM0OW9UNjIvTEc1UlNMajFacVlIRml4b1VVV0xpc1dib0xvcjJaTjROZDR1ZDc5ZGJSNjkxZUJlYVBhZjBqYS9yZk50NDR6NHRjRzlSWVQyUjQ5NkI4OGNiOWQrL3VjUitCNXQ5U2NUODJ1K2R5RzdHNDE5SXZVdlBQUFRoMndkMjhpNVVJYy85Rjg3MUYwcno3U1AxSCthVVAyeDFhMklManhjc01saTVSUll1RzQ4bUllWGZkK2tkdjErazZaT2d0RXl6UzVmWmhqY3RQSGszNTV0WHJyV1l1MnN1Q1d5ell0QzhxTkc0NlpycE5kVVVDRDB3Z2tvVWllTEVHS1NpVDBHaGRvdFZra3JuUGZZdlVua2w2KzhCVVVVVVVVVVVVVVVVVVVVVVVVZWt2bC8ydDFoMC93Q2dxUWVtd0lXV3BWOG5CWkdnQ0NoS2ZKVDJCOCs5RGRnZFYwVVVVYlA0enpUTzlrNVJobTc4ZHFXVjdYdmtmbjAwTHJOdTFQeXJnZEZGRCtETjJkODB2clJBY0Y1ams5OFlPMDZibXJsSGZlQThmNmo2ZzU5MnR0dlZkVTRSMVpzTzFOZGwzdm85Qm4rKzdYZ1hFdDMxalRYUk9XdzAzbE56MC9WL2QzQjVEYzlNWWp3MTl3L016Q3Q2NDdSUlJSa2UyN3ZPYVBjbUxVSHlZRGNPcXRNWTdyOW9oZGR0MUZGRzVlRmRpNXQ0VCtrbm90diswNUVyNDE3QnZIci9BTGx0MHpxTVBoeHQyNmV5MnMwRzA5ZHBITHhlMWViK0VjaDhVTjV3OVNaOGZmMmtwcW1sK3NkMjBPdzlmZDZZZk9mK2FkYmVPZnNUNTZVVVVVSGFmVVpSdG05UkdxMGN0cHRjZGcxQStURkdhblJCNWNFSHI5c29vbzlPZk9Ic1BxWHBIMFI1SjhpMkRTL1dISmVwdUk5bTk1ZHY5YzZFdGo4dXE1UG96eTZmek8yM2toL2x2ZE9UTzN1WmJ4M3pqWHJienJycFZsRkdDMWtuRGtTbnk1NmwwR0E4ZzRwcGI2YmZPT2lpakl0dDNhZDBXNkM1Y0F1VERLYWZXcWhqTzRiUkNhL2JLS0tNejRGMnZrWGxqNkMrZm5kSFV1RWM4NGh0cm9IdFRPUFB2dGI2Yk95UEtubjkxLzZWOHY4QWtIWE8ydUQ5THlPeThYOVBlN09XY09kUThmNEo3YTNERHVSYXlhNWxzbjBrY0Y1Vngvd0RZT3dPUzh2cXpqZmgyMzgwY09wcC93Q2l2eitodXpldTZLTWoyM2VKSFQ2b0RQcHBEVDZ1WTB1dXhMZE5qeURRN3ByL0FIL2l0RkZHZThGN1EwejVJK2d1dE1NeStDK2U2YTNwSHA0N0JyT2t0bTVOdGpkTnF5dmRObjFKZ3k5T2JucGxERVFpcHlKVlpIeEdFNGM4M2l1bE5vWTVKQ3FpNU1EeERGTWpwTEVFR1RqRU1paWNmTkI5amRSZVZ2cjd3SFJSUlJSUlJSUlJSUlJSUlJSUjZVK1h2YTNXUFVIb0pDWmhFY01sbG5VVGFFRVlVSEljRXA4aWZZSHo3MEoyQjFYUlJSUjJwMDU2UjJueG5uR2lPYjlXWmR0WElpTWQzYTVSc21IaDN1bnpMUlJSblhGK1k5SC9BQzcrdEplU3N1eHhXOFkvTkxoUEsraU4xNFgyUDJUMkR0bkwwVHBqcXZzcU8yelZuMHJJNHFzelhHY1dmSThtT1kxZW15N1hVNlk3ZzRYTWI3b1pGSGg3N2krWm1GYjF4MmlpaWp2em9yMVVCbjBiR1RIa1czYnpwZmwvWG0vT0VkbmN5ZGpkTWMvYzk2b29vbzYwNlI5STZwOG0rMlBSamVOdmxvbnpzMjNXK2pkOU5wbkRrNUZtZlREZU5KQTFENDZ6RjYrYi9XWEsrT2UxdU4rNEd5MDNOdU9rUXJ6ZnBOZDJkdmVHSXJMMHREYzA2MjhlUFl2ejBvb29venpZdVM5LzlGK3JlUmUxT2llbk91TzVOWThrNFhKYWJXWFJwRG1mVzJqT2JkWTBVVWUwbmpENktjYmNhNWZ5WlRUZEkrWCs2c2k5SmNHeWpWYlh4YlpEUzlvYlllQXR2NUp0bnk5ejd5SDdjN1VOM2JoZjBmOEFNUFB1YTY0cThONExZRG53U09tMVRVMzhVL2JuelJ3SGtIRmFLS0tPNStrL1RzMXBOZGlPNjdCbU8wOGswMXkzcjNldkMreXRKY3c2NTVZN1A2Tm9vbzdlODkrdDVqeTU5RlBMOWJVdk9PakJOUG05U2VwL1Zmc04yMzVFOFZla1BlZkQzZlBnSG92eXB1WFVuUk9oNWI5RjhYNU05RzdrNXVtYUxxeks5dlkvazJrMmwweHF0cDdodlVycjhuQUhvenlIeE4zcDVqb29vbzYyNnI3NTJieHZtbWxPWTljZEVjQjdkMGp6THJUWWV3Y3ZJeDI0QzcyOHJVVVViZDZOOVA4QVBYbnoxdEc2VE5tV256OXZhR2Vvb3hUVk5YaFdnM2piVzY3SnREZHRwZzhOOFoxdE9XTFQ1aVJmZVdPbmZtQzI2cTRzMHlvaWN4K0RVTkJNVmhaQlRWVUZweUVXUW9VU05RZHIzSWxqZnNuYTJoem5uc2ZxSHlzOWUrQTZLS0tLS0tLS0tLS0tLS0tLS1BUdnkvN1c2bzZmOUJYSk5HT3BvS1JNQUtZNGxCMFVFaTRlUC9zSDU5NkE3QTZyb29vb3pmWk9TSWtYanpRZXMyelpYSGVZWWR1K3dsNHMyRTd4eHVPMVdrb28yTHd2c0RwajVwL1ZocmJja1RuMm5HZVljbTRTNjI0dk9ZZUhkemRxOWo5aWNvNjc0LzZYNWZtK2kzbkc2WmNRcG5QcFRKZFBHWTN3NVJ1T21sOTB3ZEhkdGNQbXQxMGh5L2g3N2grWkdIYjN4NmlpaWpvSGdYYXdlWENQa3dTR0RWUStxMFNpYTBtdDBIempxOXJKU2lqclh6MzZ2aC9PdnEvMGsxT2x3ckJuOG9kczNEMk8xdTM4RTZQVk5hZWZRTGY5dWtNMk5NempHT2ZFTHEzbGVWOW1jZTlpTGFESzgyQ1F4Wk1Rcm15L1gzbjdDcXRCYzE2MjhlUFl2ejBvb29vbmRCdVhTUFh2Y2VydVNjS1p5WXN5MmpmNHJVNk5pK09OMU9oMUp5dmdkRkVyb2R4OUx2Qm4xSTgwdVVjVDZkOG5kdmN4ZDhhYjNTMTNFTklaYlJNWTlhV1oxYTJsRjMrbGUwL09GeXZWZSs4eTlxK1grY3U1dDU0eElhaXJXUEpwWFg2WE85RHFFTTNpdjdjK2FHQThnNHRSUlJSMEp3RHRxSjFlM3FpVXpRZTlGUW50RnV1Z3VjOVZqWnNORkhyRDVYOXk5YWRYZDE2RTQzMkh4endIMFptbXQ0NzN6MmI1aW5OVHQvZ3owNTdYNHg3MDhNNVpqck02REpqVys2UHArMmw1bFpzVngyaE5QcS9VN25uSCsvT3Q5K3piWWQya054eWNFZWpQSVhEdmVubVNpaWlqTzlpNVJ0RGpmTklEVzdVYmkxU29Mcm1qOVJvTlg4azRWQTdodGxGRzllaC9VK3F1Z1BXVDJpejlmN1JsNkJyQk1SQTZIZXg4T3M2VTVQdzNYK294L01qcWMyekZOMjJ4WHZPdXJZK1MyWDBFd1I2bVVqcDJ1UjNEbWhKcExydkRUR2dNcmQxTldXRlJqb3ZHU3BJbkhZZFpLT2NPeHVuL0FDZTlmZUE2S0tPMnVuUFEyK3VFOWw4QTk0ZVk5VThwNFZROWl5ZWhQUkhxVHRQcUwwRm5XeThqMS92bkdlRk82Zk5uQjNkbm11cktLUFR2eS83VzZ6NmY5Qk9naVl0aWt5UVpJb0Ntc3hGbWhKY2VGbmtQN0ErZmVoK3dPcStuK3RlNXQwOFE3RjJYeDNtTDlHbk9XY0c1WTdMNlQ3bDZZOUpNM3hINE5aU09DKzd2TUhidlRucEhJTkJ1bUc3dng3VS9KK0VjOThzNjM2eCtadjFjZHg0OHk1YnhYek00RnY4QWgrMTdianU3OWQ1RG9OZjNuMlYyYm5OK0g4NThGNS9rbTE2L2RPWFJZYm85Wm1XeVRrdTZZTW8xZWttTiswblJmYnZFajlYaWFWOFRQY1B6THc3ZStQWmJ0Ry9kOGRJZW5zUjNUWTgwMmpmNWZTYmxyYmtYRDZpZGhiRnluWHUrOFYwRnpqckRyanEzdmZIOWR0VXRwdFM3VFUrYXZvZng1c2ZvRDFmMTE1NzlUZER4SE4yemEvbG1iK3FXNTdiemxzK3Y4MDhPYjJyNUZzNzJRMU5UNGp4cDZ1NVZoblptdyswYlJaeHFOUE00cXorcHRKWk5XSmFUam4vbW5Xdmp0N0UrZXQ2ejJQMUw2QXc3ZHRneXZhOTZ3dmQ5Z3o3Wk9UZ1o5RVBla1ZxZEhCYTNiTUgzcmpXN09IOWpSK2JUT1JKK24xWE0zWVhVTzd2bkg5bWNENDMxc1h2dksvUi9tUFh1emJ1R0p6QW9PeVYyNWdRZDQ0MDJuc0RIdk5IYTNKZmVNZHVadVBldVhMdWhzLzFHUi9MWGsva0d6ZEw3RnZnOVo4Ui9idnpUd0hrSEZhS1BUVHpsN0dFeTRJM1BwQnN1R1F3YXVBMTIyYzZjKzZsNnk2djd3aWRYb2g3VndqZXVMOFhkd2VlcU8vdkkvd0JDZTdldHUxcGJGaWtzdW5YYzdraEVSNTlkYytvL0c3YnVZWVZ5SGhXYlp0SDBGbTJqYk45dFBUeURueTRweXZwWFpIWkhDZmZ6Z1hJOHMyUGRveVhuMTZNOGg4Ujk2ZVk2S0p6UWJ0NnIrWmZhK29PVmNGemJadVM2ODMvaWdHZlI2RDV2MWgxeDFiM3ZqRzRiUHNuWU9WY3U5azlMOGw5cDlHVWRzK2QvWGVSK2MvVm8ybHliQmpFaXVadlQ2Z2JUYnBtV3EwMjlONTR6eFpxNDRGMU9UaHEyUGR0STFWVy9aR1RGbWMxWXgxOU9MWStrTWVZUEJrV1ZiSkJHUk1iVlJOYlV0V1JHRGxjY2hJWWNnL2FZaEI2U2s4ODlpOVErU25yL0FNQjBUbWczSDBQNkc5VDk1ZEorbGxyZU5Yclh3Snpwei9xcWowcDg4ZXVPOStrdlRGRkZGSG1aNkg4ZzhKZDIrYmFLUFNyeTk3WDY0Nmc5QXlZTUVvVW1NQUdOOG5abUxXZWliakFlZVFIc0Q1OTZLN0E2cjNud25zbmMvRU94SEs1U3NkajhPcDVtN0U2azZSNis3Wng3WDdSRWFyUXpPazNUbVhzWHBqcHpybnVPVjB1NFIybzBtcCtVY0UxSHlQaGZXWHpPK3J1Uzd6czI4K1QwOGsrazlKclRCb0RaMlRYKzY4aHhETjJ0M1Z5VG1Xd2RIMHByM2pQTU5yN2RxcExCbDNWYlI3QTFHaXlEY01SKythVGMzYVhHcjJnbEhpTDdpK1ptRjcxeDNxRHJYdVhzM3FMMFJqK3UybkV0MTJYZTNDdXl3YzJpMTV2M0Y4azIvZGNwMjNlZlB6dlR5MzEvMVQzMUY2alNTK20xV2I3THlmeUs5VStFZHE5UGQvOEFlM21QMlJKeFBuWnRXNWRkNDY1L3V1akYwV1h4aDJ2WCt6bTc3Ym1lczA2cHF4ZHpydzdmUEhqbFdoOVNkc3QyL3VHMzRzdnJ6Y0hiV3BxT1N0WFBQTk90dkhuMk44OUZVdDZkZWNmWmdPZlM1TnR1OFo1c2ZKOFYzVFlzVTNUWThnME82WVh1K3hTV24xR2x1WDlkNXpzdktNbzJ6ZlRLVXp6WXVZZVZ2cGp4THVYNXEvV3ZJT0c3dG5QZGZYdmRPbjBzYk02LzFOUUwzSW1OcTRxZzByNElXNWY2T2ViT2RlVWZadlk4cmozYjJTNXI1aTdSM2JqZWxOYnBkYjY3U2RWYmJ2STdINGtlM1BtcmdYSU9LMFVlcXZtUDIwYmkxUk9MTGh1N2JIc2pqL0tjRzNyam5HSGJ2bm5zN3FQMEhoVzc4ZHlYYnQ5MXZ5SGgzQ0hkM21XalpmbXoycHIzb1AyL3EzaC9PT3c5cTNyMlI3UjhudTN4Tmx5TDB1dXh2U2JyTjZyYlhLdy9rb3JLNVl4Yjk1VTlhK210TCtudkNIMHNjSDVDVHRtNGpubk42TThoY1Q5NmVaS0tNaDIvZC9XTHkvN2h3ZmVlT1k5cnR2ejNZK1RabHRPOStkdmZubEhzZnFYdi9YSElPSjlDY0U3UjVGN1Q2SzR1N2g4OFVkRmRUZDhkUCtSUGQrTzZMTnNiSmc4UTlaUFMyajF2UjJqMUhTRTEyQnJ0djh3dHowdk5Xc3BweTFHTWJhYXZUYzEwN2VuVTJLZlZmVWFjN1I2dDZtVVdTd0lsV09PaTB0U3FsclpMUnc2b1pTVVhxdGt1WSt4eW9jYzRkaTlSK1R2ci93QUI1YnRPOSs2Zmk3NlJaQm90em9vOGF2V3ZnVG5Ubi9WVXBwTlo3OGVIdnB4S2FmV2NvOW1kSjhUOXcrZXUvT2p2VG5SWEErMWNIM2pqbmd0N2ErYVY3S1BTank5N1c3SDZmOUJDU2xDaXhqaFRIY21HUUpqSVRhYk9STmp5UTlnZlB2UW5ZSFZkRkZGRkZGRkZGRkZGRkZGS2RYK0V2bzlydnJQM0ZzWGNPcjlJY0o2a3l6VzZLUHlWZ3NtbXhUQmJsamJ1L2VoTmQycDEzcmZMK3h1SGNoZ2NHNGRFN2x0TXJseFNHNTQ4ajVGdDJmOEFOOW1jSmhQaG43aStaV0ZiMXg2aWlpaWlpaWlpaWlpaWlqZVhXWGMvWS9rejNjVHA4dm5Qc082N2kzemEyTlRUTk1PVG4vYk5WdHpSWk91TjkyN0tweDhzNUw3dXZUVW5FZDM0ajNQRG42T3B0VnBlanRWVGUydHhtWkVpYy84QU0rdGZISDJMODlhT2t1dSszNDdVYU5NMU13Nmx1MWNkMSswVFdrM0J1WUt4NXNKM2pqbXllUDhBTFl6VWFURjl5MlhMZHIzM25ibjNWSGFYaXozbk84Tjd3Nnl4N1l4RnNLNDVmanJvVHVqSVBRWFhHMSt3K0c5SWNhMVVpZVl1dHk1UHcvc3pUL25ydFhuL0FMOTR2dWpiZDA2MDNQaE9PYm5wL1JYbEhWc2hodVhlM2liN2MrYWVCY2c0clJSUlJSUlJSUlJSUlJSUmJwNzBObmZqbjE3ci9qZTdjOWM3NVo5QXV6Y282UDVMMURvM1lld2REY1o3VU4xKzM3eTVMMVBzbkxzcmVETmFMVFc1YVBXR3B0NGk5ZmVscHp2RHh6NzdjUjVLSGl2Yzg0ZlJYa1BpVHZiekhSUlJSUlJSUlJSUlJSUlJQYlJ2bmZuaFA2ZXQ3UHJYcXo1VWJ2cHRZMng2aHU5ZmRMazlJWnI1RGFwbCtPZGFYYVp5MDdGcGk1NjFWTzdjTHBLYWI4UmlXbDFTRXlBL0YxS1dRYkUxV0dMWkI3RHk1YXFyWXhVbXhlcHgzTG5QWFl2VW5rbjYvd0RBV2FiTnYvdFo1QitoSldIUG0yMGNobzhhdld2Z1RuVG4vVlc0ZUpjNzl2OEF4eDlGYVBFdjJGODhkSjh5Njk2azYwN2w5ZlBLM3V1andOOXZmTXZFZDIyT2owNzh1KzF1dU9vZlFVZkF1UlFoR1BKb29NSlpqWUxCTXpFeGJYM0srRFJPdTJ4QU9nY1pWc1ZLYmtJaHVVcmFJU2tubEV0SlY0dkRET0RjNTgzdXRmVm1tOWo2T2d1TWNFRzNEbk9NYXZpbVc2UGJKSFg5aFlSZmxraHN1MGJ6NVY2djdzbnhSZ0hEZWJkTTc1c3p1cXh5dTlhZmJ2WXZIcFBQaVBHYTI0TTd4OHl3dXQyeTFsTFVpa1VtUWlWRlJOa1I1Wk5rWHRWUVdtWjArczJuMGw2VTVVME92NXYyaldkZzdqbzlBNmljUWlldXRpMWZuaW5zZmVOSjJYYlRhc3ZHaFp0dEdZMmJXT2pZMHN4bW0wNm0wV2tyaWpBZDU0MXhUM0Y1NXFJdE1sb1VVbFVRUEp0SkNHRTBYbGFGa1Vta2JVNFIyUHNUckR0OXpUM2g2NUkybTRlZWZHOTMyWnMyNFo3M3YxWDFwd3pkaVdack5qOGJYSmZTYm9QbGZBdXA1b0J6N0hzMWo5QytUOVQ3cTNYajROQ2NsdU5lN2ZORVR1RzFXZ01rb1NYU0txb0lBUlNYMDBoNGFnd0Y3ZHV1R2VZdTZOTjlFOG00QTlXN2g3eGRjOTBiVDNqZ25obHNYWmVvZXlPaUpIUWN1WG91WjVmaXliNHh4c25QdGhGYWM1dFZvdmxQVlh1N3UzRitnZU5iOU9GcXVhK3grb2RHODc2d0pnZ0ZDd0lQRWpJMkdEUUlVVVdLTm1kUmQvd3ZET2U0VnA0NEgzTEJ4VnF0UGU4OW1hTy90MW9MNHZqM0dXMW1EVCtmRENaOUpqV1NtSjJwNkh4aXltYTQ3ZzFjYmp5WFJRVXlQS0dWZ2kwMGlLWkk5anlXdGhyV0dKTmphSDY1S21nODNVYUM3RjZnOGsvWC9nS2lqY1hFK2RlMzNqZjZMVWVOWHJYd0p6cHovcXJkdkRPdy9iUHg5OURhUEVUMk44N2ROY3U0RDA3MXgzQjdCK1V2ZUZIZy93QzF2bXByL2Z1TlVlbmZsMzJ0MWwxRDZDV01oOExFUklFdVVYQ1I2Mk94WWJFVnNoWlJTWDBHRWlpTnlVb0NobE9TQXNjb2dYa2dhMDFqUjBCVGpYalcrOFc4Sjdkd2pUWk16M3ZqV2U2M2hXemR4MVc1ZDNyekR4N3VuRU5GdFdOYlgzSjF0cWZIWW5DK1NiRHk0anR3eDlRZHBjU3luZTlGYUVaRUJWV0xscHRTMVhpMWFXcW5tUjBvUVkrV0ttVnhRMjFaRzFvNldKSzhFNGNtaHRQbDdZcE9vdFZoM1pnakVObjEvbWR1V0hzSFhhYnMrY09YNXFZaEZJNnphMXNXWjFpWW5PZTFCSUxVUlpjRkdxanBJa0lHQzRKbGFxZ0N5eGFxckhCcUp0V3Q1bldXSERENmV6Tk1tdk5YWGl6ZU55d2ZrL0R0NzZlbmZQWDIvd0E1bHJhK1BUbVRKekpvK1hiNzgrYnZvUGsyOGRiOWhjTDNaeWZqcTdJK29wTXRXQXBrTkRhODNFd28rU2pIR2xpUmt4R1JvdUVsRWFvUWlLdmg0TDROdFBrbjJOdmZ1cndMdDAzRlh3NzVSeGZXUGZ2bnpETzllQU5jWTVobkd6cHZhOG9PWXJMVGVXMjV2VnZnZTg5ZzlZZGd4ZExaRVVORVVQallzTUljbWhJRUxIeUtnMUpZeU9RYWtsUE5XajFHbGROazRYM0xSOHVaWWw3UzNwM3Vub3RSdWFrNjYwbTc1MXE5S0hiSHMzVmJUSzZqRnpsbVp4VEx1YlQ1RVJLSnFORXh0cnlOY2RpUXJORE9TN3RjYWlLbkl3cE15R1FjbG9GWGl6UTNZM1QvQUpXK3Z2QWRGRzR1Sjg2OXZ2Ry8wV284YXZXdmdUblRuL1ZXN2VHZGgrMmZqNzZHMGVJbnNiNTI2YTVkd0hwM3JqdUQyRDhwZThLUEIvMnQ4MU5mNzl4cWowNjh1KzF1dStvZlFTaFJhaTlqY3hHQUNibEZGTWRTdktoZFJVaVVtTHV4RWFCakdTbVNReHlVL2FKbTFHcVhqWm1ac3RGV3BtR3BPSTZUTnhSMXZ5NlAyTFg2N3RyUUxhSjJtTjNWYUxLT1E2bkJjL2NPV2JaMUx1TGptaXp2VzBPMTJMWjNLZHQyNXk3WkFvbUlwRjdXVFdMb29vcGVsYVJlVS9FcXlYVGpEa0xrcFZadkZueWN2V0lXTVFFcnl0VzJtTlBia2pGbjY5eDBuTVZ1RzdYMmRyTlB1L05pNjB6WUJVWWdKbXU0cTB5akpHWVUxajFwR0xGa0tSQ0xKeHNndVprQ0ZCbFVMUURKOE1rc1Zja3NXb2NtR3JURzQ0NXA2dTN2WS9ZbXl3OHBTK0dJMVdCL0JteWZDbk1sREwxazhtTFh1b3lsNE0yeEpEVnpQMFd5RzZEMHgwUTdhWlNzRHBzc3dQWkJsS1JOMThhU3lCY2VSc2RFamlBMUdpVm1kUmFUYnZCTGM2ZTFYRyt6K2tkMTROOCsyeGQ0Yzk5MStXc2Q3djY3K2k3eTczTnZIUzZqbnZKWWlyck9ZMFR5RFk5a2NaNUVOcDhwWkl3aTVJQ0JrSUJSSTRLRXd0S1RLR0FZdU13Y0dwT0dLUlBJZURMd0hiRmhGNjZZc21WZXV0UHFmVFhTNThzellKRzdJcjZZdTBZVHFjT2g4anFiU2F0NnFRWEtVYWk2eVB0akNUTVV2U2dOMG1pc2NxUW5Jc3lRN0hNZ1pJTWtZYUk3RjZmOG0vWC9BSURvbzNGeFBuWHQ5NDMraTFIalY2MThDYzZjL3dDcXQyOE03RDlzL0gzME5vOFJQWTN6dDAxeTdnUFR2WEhjSHNINVM5NFVlRC90YjVxYS93Qis0MVI2YytYZmEzV1hVUG9LMVY3TGhJc1NKQm1Oa291eUxIWnhrWEx4cXlLcVJWRFRLWXM3TlJieGxkV05XR295TzVxZ0pNWmtIcXFXTmlvdU8yRjZiTnlaeEhrZk52SGVaRjRkYzdnMVd6TWZITVMyN1FaZnJOb3p2TG1Oeld6SGV0THYzbkd4NWJ1ZWtZQnkrT0Z6S3BscXRRZ2NxVlFxVWxBZ2J5V2R4eXFhUVFpNWVQSk4zRXpTR1hjR3hwWGxYRGNEUzI1T3JmSE1sZXJsTmk2akJtbWZIb3VMYTQyL1ZRK3lhMklSMVZ1R0hzVGZ0RVRFaXpFZ0RrYk1GSkRTb2t4SUVQRHRXTTFsbEZGRXRWSTJNWkZDRVBwSEZHTDdCcmZQcnFQc0ppZER1THRUaG1aN3R0MjI1eHYyb1JOWmpOUTIrTkdwdElZdFNiaDFBdERZME9nVXltSVJZNVdTME1FclpRaXhtaFZnMEZ4a3FDRU96RFVWVU9qUVBaNVBZOW96dmIreS9UbmN1QmNJN0IzRjVTODg2Y3cva0d5N1g1ZnN2YzNHdHhudExud2FjSnF2ZVhEZVU1bm85VlNKUVFEbGhra1FRU1ZDaElSSTJGU29qSU1DQ2l4ZVZvSUlRNUt4VzRaeTFLclRselVYN08wRnZWdVRDSmkySzJTTklaMm45VGk3cjIvVWp4SXhQbEVDU29VUUpKVlNGYlZZbTFVVnlPV3hyeDJEdkVaTVNDV2lncE9oT3hlb3ZKZjEvd0NBcUtOeGNUNTE3ZmVOL290UjQxZXRmQW5PblA4QXFyZHZET3cvYlB4OTlEYVBFVDJOODdkTmN1NEQwNzF4M0I3QitVdmVGSGcvN1crYW12OEFmdU5VZW5YbDMydDFqMUQ2Q2loMFdUZ01EQjVjR0dSMWpLWkttTGpVVVhLOTBKUmFCTW03aHpNS29leVNxaHBBU3lXcStVZWpGcXlEQ1NSSzJSc1RwdmFkZnkxeDdrK285aDNLSzI5c3ZUNGRnN2hvY3kxK20zYnl2YU53Y2gyMEtZWmlTbFVRRXFxYk16VjJKT1E1Q0tFRlpDeHZHc1VGU1RCZ2twbVJ2ZTZyUzBTUEttTE9xYU13NWNHd3NQeDEybHFNSzRweWhwOWJwbmJ0WHRUVmFmcXZkOUJ2TzE4MHRMVWpLd0RhZ3ExTEppSkdaY0tJMFBGaWF5UFdSb2lKbUdDaWlkb1JrUzF6SkdpaVhJMGNwUEh1eDhzNUg2MDV6cDdZOWJzQ2RMUDdudG13Tmg0Wm1kOEc4dVI0OTM5dTdQbG1vQVFWVVBZaXQ1Z1RNeDhWRm1xSWx0QzVUbHBxbG95YVI1ZVpLUmFxV0FBOEhCQkdRSFUvVmRiaURGck0waW1odHU1bHdmdlBIOWQ4ZzRWSzN4N0l4eDFEb012ZTJ3Ym50UFY2bDJ3OGp5WEZrUEJjaklPU2VncERjbHhLeE1ycldpc2JJS0RzclFRUFNZZ3FWQ1lXbHBESGZrbVo1N3lSdGVqMHJqQWZOY1l5eHgxZWVyNlczWGd5S0tCQnNMRWx4UkRFd2w1RkRRMHlVb1ZqbXNrUWlKVmtoQlRFYXR6djJOMUo1Vyt2dkFORkc0dUo4Njl2dkcvMFdvOGF2V3ZnVG5Ubi9WVzdlR2RoKzJmajc2RzBlSW5zYjUyNmE1ZHdIcDNyanVEMkQ4cGU4S1BCL3dCcmZOVFgrL2NhbzlPdkx2dGJyTHFIMEZEQ3dzbHlLR2lYQkNKUlJaRWt0SmxpSkR3ZkpqQ3htV1NhWXdKT1hYeHk1a2lkZzJDekJFU0dBU0VKTW1vRldSc1NDaHJHY0JKdklMTnhRTzlaYXlQaVRJaTBCYWtwdWhrTXRrSXJRRkNKU2NveW9leTVSWW9vcUJCSzN5TUt1ckVxaHJPcXRMT0QwMXFMUkNOWTFubjJtVGJFNDlrV3BrdGs4S3RMODFSRVB5akppaXF5V1BwVlpRd09WTjFDUVpoYWNqckhlVWRBT1JWSmw1ZzZ4dkpFWmptOWt6WkNFaVFSS21DWWJ3dUxVTUtaYk9seWpMWWlUNnd1T29reUZNRlZTckl2SVRVRFkzR055Z1VhbExSZU9zVXFGV0c1VkZwWEpXUHhqWkVFWkNSeUl1aG1aTXJZZEx4TUVHblJ5b2s0ODRSc21NaDZ6aERnNVJZbHg4WkdZWG1IVXNEdytBQXhKQ2hKRmk0Skc1UEE0L0JndUVBNVVsUVJFdzBXdEZHTEpTR1F3UVJ3a2xTaGtlTEFZUVFSS3hNaFJlWUN0WnViU09QSGRJZG9pYkpOa2lTbU9qUjNZdlVubFI2LzhCVVViaTRuenIyKzhiL1JhanhxOWErQk9kT2Y5VmJ0NFoySDdaK1B2b2JSNGlleHZuYnBybDNBZW5ldU80UFlQeWw3d284SC9hM3pVMS92M0dxUFRyeTc3VzYyNmg5QlJBU1BFZ1hHeFJCaUN5MWxicTVBbTVSY2lsRXlFaFBnRWc3amFXY21zMUlySldreE5aeHFEeFpHVldxZlcxa3dzSnV6SE1ZV0JESW9kbWlyd0xDUmhHUWNKV1p0TnJSVzY4VEdORUpISVp4bzRsNVJsekJhRlZYbFFxc3l5d2w2M1E1QWVabGxnMG56QWd0VjFtV3BkRE1oMEYycVhLNGdxc1JscVdMc2w0cTVOaXlxbXJDaGlreGxZSG9lc3N0VTFxaHVTeCtVUktiV2tKaEtJc1ZaTFdRZFM2aFNoQklqa0hwbW9PU1F2Q1Z4eU16ZXRpYnpmR1JlSXFZYURMVlB4V1JKTVFpTHdlUTVTcnN3UEVwdmFRcFU2UTBWVEFRUEFabG1MdWd3b25TZ1lqZ2drU3hjQkdDNWFCc242Z3JRMkdwamc4c0tNYUxFbUVRVEkwc01EWVNCaEl6VTVZNkMxRHl0SWFEZ2JVMUJ3ZEtJOFNHZ3hRNFhBQ1dNZlpKRUlyampKTVN1UE1ra1hyampMSkprQUIyTXcwcjJMMUo1Syt2L0FBRlJSdUxpZk92Yjd4djlGcVBHcjFyNEU1MDUvd0JWYnQ0WjJIN1orUHZvYlI0aWV4dm5icHJsM0FlbmV1TzRQWVB5bDd3bzhIL2EzelUxL3YzR3FQVHJ5NzdXNjE2aDlCUklRUEJBb0pJa0ZLTEZ5NFNTYUxwc0lBUWhqVEptQllRV0ZGN29rbjZzUnVtS3AyOE55VE1McUVpUjRzNmlQaEsxeUpHOGxCa1NOUUFIVk81TEFVc2RJT1JzeUpGWW1sSlVBRFNPSmpJaHFrV1hxb29scTVHeXpHMkxsVUcyU1hBZzRDVWN2bUlWYm1IRlNiVnRaUlJjc1dpQmhBUUltVENNR1E3SE1PdVJGYjByWUd5Rll6bzJLeUI2RGJtOGQ1akxWRjRqQlJMRVZRRkJzc09oZzZpT1dlWGsyT0laS3JReVlqNUdSa1BSRXpWa3NzVXBLUmVwbE5EVUlTNW9PR1Vqb2xLMUttd2xjWWtwYTYyT3pLellNSURRa0NGQ3dnRkk4b29TVVZDcGhLbEI3SW9kQVE0b2lnVW1Cc1lDeU1nWko0WXFLc2ZnbURWbHhJT05BTUNSK1RNQmFDUndLS0VrWVhHUTRLR0NBSlpralI0U1hIRkIwU3NJeVdReGtFVWk1WkFhQTdGNmo4bGZYL2dLaWpjWEUrZGUzM2pmNkxVZU5Yclh3Snpwei9xcmR2RE93L2JQeDk5RGFQRVQyTjg3ZE5jdTREMDcxeDNCN0IrVXZlRkhnLzdXK2FtdjkrNDFSNmMrWGZhM1czVVBvS0lDQjhicVVTZGtiQVlSSmtkRmhRc09Ha1JhWlFkUkRoeWxwR3dRTUpKdkVVWlhJR292SkFOb1NseUpURU1BdUxJVkFrUURYaTAxZnF0SU9oc25MMnNzMVF1MDJVaVlocUlsNVJNSEI0VEoyRVprVVhnVkNXdGFGU1pTZ3NIUWNMWGZIOGt2amNYYmhlMVlwQk1WbUwxdllvdFV6WUNPaDVjb29HSEJCRlk3M2liUlJkWUFKWXRaRjFURW1CcURBY3ZKWmFOd2lzaFJNRVhRNUNKTEJRc1pTeW1RV1lyakdXbTdXRmlyMG9oWWxqR0RBZEsxNWlURUdTa0xyTVBKbVRsWVBtU1lvSEVSZ21EcThpbElra1NrMGlER2hSWWxoSkZseXhZcFZLdHhKUk9NZ1FkQnNxWlFoNHFGNVJzR0NWbEJ3UEpHQ0xHSkRRYkxGRWtCRHd4UTBMc2ZsR1kwa0NpZ3dxRWRKWThSNUxFR1hnb2ZuSTBFc2RocGtjQjJOWkwwczVlc0t5VFp6NTJMMUQ1Syt2OEF3RFJSdUxpZk92Yjd4djhBUmFqeHE5YStCT2RPZjlWYm40Znovd0J1ZkhmMFJvOFJmWW56dDB6ekRnUFR2Vy9jUHNINVQ5MzBlQzN0cjVvWVJ2WEhxUFRueTc3VzZ6Nmg5QkFpaDRzWEpFamlTSVlRVVRoSEI0NE5FVXh5akk0UmczT09VZ3RhUFZpek1iajVXTGpGb1ptR0tYR0RCMjBRZUhJOFVEVGpsY2htb1NSVlRFQTRQWEZUZThReldCWml4TU1qRVkyb0RCK1JHMVRCRFNRTGhPVnN2SldJeG1SMElzQ3FmRkVxeVd0S1ZxUXFhaXlrYlkxMlhFbHlKQnk1S0JKUTREQ2hxdG9qSFlpbzlEYWtJU2txaEhrcll1b0lIa1pGNVBMVkY0aVlLSmlVWmpGZ0FBRWpvQ3RZb3BXWHJZbTFveFVRdEN5cGNwVWpoa1NteVVqeEtyTlVKZzJLVkRURVRTb1VsUzFrekpDa21TQ1FrUlJPQ3lDRHhaRWlTeUVwZUdXT2l4UmtiS09pMEh5MGdDUkVDeUlnb2s1T0tzVElVR3lwV2lhS0tGa2hVRFpmR1pMWE5TazhZY2JHQ1NFZ2cwR2tRTEZDcW01UHprWkdsS0NCOEdIU1N4blVvdXBIT25ZM1VubEI2LzhBQU5GRzR1Sjg2OXZ2Ry8wV284YXZXdmdUblRuL0FGVmxXMWIxNzZlSVBwb3BieWs5TmVLZU91MnVoZStPanZUUHBSNTg5YngyYlMvUHo3bytYdzJiRlI2WGVYdmEzVjNVSG9KSW1DcEpLZzROR1F5aGFud2VVNFJjcmttV1JaTkNFRGhLWEFTWUtpalFXbVN5UUt0U0Z6RGhGeGtKWXhFbW1PVXVOQlprR1NnOGlhUkdKS2lEWkJTRVdUS2hVV0ttcHl6SVZGR0ppcWtWRFdLdGtHQjR4eWtqbGtWZ0tBRVE2SUh4UUlTS3hkc2lJcUJHTnhrS1l5TEhieUhNQTJUSUF5QktMUk1qZ21oaXBNRld0SHdza3FTc2RXVVJKTjVGOGFFbE1Bd1ZFZ3BieVRrQ2xpSHlGa3VSdFViVStYR2dvQld2WEhkTXBhNUVXQmdQTURUTnB4bFZzTk5iQmdDWEpGSTZTd3N0U3lyazBKSTJJaTBPSmFWY1hjSlFoaEJObGlESndjSUlKQ2t3cXRsVDBSNVlkSHdNb3lTTW8weENCNUpRaXlSbGo1T1JFSktXcko5a2JPTm02OEtvc3lXS1V1bXhTWGtrbHNhTERwSkdZRkN5SkpLRUZJNGtRTWhKV2c2S0NJQnprdUVLWEJVT0JUSXdUdGNiOWJLUlk1NjdKNms4bC9YL0FJQm9vM0Z4UG5YdDk0MytpMUhqVjYxOENjNmMvd0NxcVBhYnlCOUJkOWNLN0xqODJsMHp5N2dHNitIZGhsMHpjbzltZEtlUnZxancxUlI2VGVYdmEzVi9UL29KVW1oeURjbFFkazJGd0ZrOElDeWlRSFN4ZUVmS05ZME1oQk5scUx5VmF0MVhjZ3BrSG5DdWJsRVpXWTFXWUpSVktJK0xSOFpKVzlJZXRubFJaeUZoQWtjVlV0UlFNUEYxWWxaaXVPd2VFMUFTZnZJNjh2TlkrNlJ4eEZVWGlMaWdiSUp4aFpTVjdPVVI4U0twUXFSRUNiSHJtYmpSc1Vsd2VvWXBBdFFFcWxJU0NvY0RNaHZHRmszQWtUS3dGQ1dzYXJjZEk1UDNxOWxyRURSTVZSeEcxS0xrZ0tJa2N4NDVUSm1lVFN5b2hNVmlKaHBNbGFxNEFDd0l1VVBFdlc2SWxxQk1sbFhBVVJVQ1lOVERvaUpLbEdEWVFTcEZnaFJjblFNQ1kwRkNBOWtqR04wSlhCTWhTa2pTUkZrWkN3QkpRd1pHckhYcmFzMWFLa3F0bnEyZUxxQ0x0aVNrU0NheG9ZbUFNaFE0a0FJUElRUExFU1dKY29IZ3hKNWtHQ2gxampnc2FId3NNaGNjaTNPZlpIVVBsQjYrOEIwVWJpNG56cjIrOGIvUmFqeHE5YStCT2RPZjlWVWJwNGQyQjdJZVRQZkdUN2Z2RkZHdjk3NHg0eWV1UEFHdXVROFZvbzlPUEx2dGJyUHFIMEVrYUhpaXdvQWczSk1GU29vTmdza0FlVHhSanFLVFRITk1pZ01VcEpvWFkvYkpIS1NGcUgydEI0d3JJZXBPc1dGeGtMUk44WjFFSjEzdU1RdE1ka2JmSmNqd2pxcVdKVnNBTENqWStyTGtPc3lTSXRXTkphdFllY2tsTU9EOFRhMVZSTVJqQ1RRKzBzMW0wVkd0Sk5ZbE1tUU9tTUl0S3FseXZDMGxraFlxeHE2VkVwSHhSRzFKZ21WQlFPRWdjTDVEV05NSmhVb1JPSUNJNHV2TUpqQ1N0QmQ2TjNBRWxVSUJWbVJTQ0ptc3JFdzFha0txdmtmeDNla3dKa1JFUTk0bUxINjFISVdDU2c2TEd4WUNBTUxFdkkwWGNKUmpzVmVnbXkwVGRFaW1PVFEwVG9vWUdBOHNCTWJZMEJNaGlKVk1FaGhNNFJST3dpcFNoVUx5YU1lS2dtWUxnYmVyRm9vWENTcUtoZFpDSUdZbFl5Um8waXc0bVRvaTRXSENFSlVISkVkaFVoaUJMU09oTUVLTkpTaFE0T2pvTUpHeTRlU0lFU0J6bDJOMUg1U2V2dkFkRkV4b3RkdlBodlk5R2wrWGNBeHpjZHBvb3l2YWQ3NnM2eTdxelRhZVFhOTMzaXZLUFozU3NKcnR1b29vOUp2TDN0YnJicC8wRWd1V0xsU3ZCSllKbGNvUUVpU1JCUWtkSW9DUWVrOGpaRGhsYW5UQzBKeVdGVmxreDAxT2hDTXA2czh4WWoxSnUrdVBBUFBJTG9MZmJZYjBYMU5KNzBOc0dhKy8rQ3lQWjIzdUVtcVN0RWdxc3VzaFdMSlpaMGNJNVY1YUxKdFcxYkttSTNMUTZ0bFliQ0lDdkRONnpHTzhIR09iWkVrYkZLbFVDU3cyVVVXa1dtV3lSRjNTRkppTVVHajVIeVRJNm9MSkw4UTBYQ0lLbTZDOFFxdFUydGRMY0dZa1JKTEdMZU1rc2k1SGtjV3JrQlZVV1drMVFxVmN2Skt4bU9SaDRCSDdWRnVYRUdvZzFrS214WWl0Z29CaVNpaWlXRFMwb0tLalNYTVdyYXlKeGFDSHhrT0gxVUxYVFNLR3l3a2FWZFdNSU1aSnNpeVhHd3NzUmNKS1ViQ0xMU2xZSnk0N0NpWngyZFZvYlNpYjJnOE1vaEUyTEI4RjBRQktFSVNZR1RRMlBBQkN5dGNaakdESS9LcWhKSkNCUXdEaFlzYUpFREpnNTk3RjZqOG1QWC9nT2lpaWlpaWlpaWlpaWlpaWlpajBpOHYrMXV1ZW4vUVZoRUZsNU1qNWFGaHlWRnk0NUFxUlFvb1FDbEQ1WVlZeGFIc2sxQmxFcmtzaEVta1pWYUlkZVNXeHZ6THlIVmZ6TDdHd3pjTVdYN0RxY08zL0FFc3BvOGtmcTZaZHNPcHhQbVdoMy84QVNQcitZOUQ3RTJTZ1FyRExUUkVGRXdBQm9FS0FGWmVMVks5VnN0RXlBaVpIRlp0QWRoZFp2Q2tSTVVTVkk2Q0dRcGpmWkIyTU1iS2xJU091ak1hMEpLeW9WQmdySWJwa0R2UVdJTEg0UncyWGdtRWhkUkhRTnFYa0MxTlFsN0Raa1pMYUVSQVVFMktpWEl4eU5zb2EwclNyS2J6TGxRU0t5VkZpMVRDZ1ZhV2pHSlM4Y1dtS1NtRkl2SzBXb2xROEZJTlM5NXZpRjJtU1RFRFl5RW9DTEZpNVJjcUY0bThxbEsxUnNtWlRRSVJGcThMZG05Y2FTMG0zaDNiZzFXNWRiOU9laGRtNm5qSk9vMmNTVXdoaTlMeWxxQ29NZ05wRHRDaVl4NUhoS1kxV1BVcGtXU0dOR0VTWExFMlFoUk1EeGp3aklYalRJMFJBb0xnVks0ME5EWkloUkdqZ2dsRFIvT090cmNsNHJSUlJSUlJSUlJSUlJSY3NVVVVDN0x2MitlQWRxc0M0V2trZUdpNDZObGhZNFBoWWdVVU1qa1JGVWtQSmpMSEdRUWJyQ3JVVVpMa3lEaHBES01pMHM5YWJqcVg1QWRydDdibTg1dldmRHZSSHloeXZ6MTlWOFlZeVJFYS9GNlplTytZZWNQcmJpZnBINW01UHUzN0Q5VHQ4NjBZeE9EUStRUWVOa21KVmpWbkZXb2ttc2hRY0M1V3RBMTROeFd2ZGJHaWlSbUJZa0VwakxsSXdZWkZNWkRJb1F4eDgzR21oRlVqWkVWSDVEVkRrREpCUUltMVJhSHZSNmtYQVNVQ2hBZ2hTWEkvSVRqSGtWSmNYazhrRExOcTBxNE9DNHNtMERKa0t2TVRnM3Nmekk0UDdHN0Y1SjBQelpzbmJXRzZYZnJJdk0yaGFWeWlvV0tLS05xN2h3dkg4TzZZVnBlUVVVVVpucWRpeWpVYlBxWGJ1YXBPcStRZEw4cjhmN29zVUlMazFsMEgwbGQxZklPbGFMbExLS0VpeUxoS3dqNUZTSGcrZVhIYzNVSERYbFh2akN1cy9vYS9qeVpudS9sajZKdS8rbVBMemkrc3dHL1hvdlkreGV4SEhlYld2UjJFelJIMm54MDNUcjQzZ1BMTmw5amJWNlhiSHlrZVV0WEk5RTRXamh6Smo3MHg1S0Q2SWlBd2tNSlVBRkFoSXdFbEVTb3FCb0RDcFVYbGNJZ1dPRG82REVhU2dlYWY1bDE2RHgzblE1MWVhME9ZenVjNVBKazZYT0hUckV6RTU2T2hUVFJwYzdOT1ZETkFMa3ZCZG5jTDdDRENoc1pKQWlnbTZUQlFVV09nZ29jRUhIL2NmbnVTeFo4NDJMazNPL1pQVC9aWFIvcFBtdnN2cHZwWHE3dXpSUFpmVEdYN0x5alNuTXV1ZXkrblBSSElYY25ubktkbzVCdlhndlozSS9iZlFYVC9XZmRHM09HOWlhMStaSFkrUGVXdVQ2dzVsdDNIUGYydzlwZWVlUWMyZHZiVnIzbFdpWnlUNlArU09XZWMzclBpM294NU41Ym1YcjdpVzB2bzkxOWkrZkJ3ZjM5NVY2WjY0N2h4RGQrUGJJNGZ6K3RWb054Y1E3RDQ0N2o4OVBZcytZYkZ5Zm5Ec2pwM3Zmb1gxSnpyenZxam83cTN1emk3dlh6Skw2RGR0NDhKN0s1TTdrOCtkeGREZW9lSk85UE1uWVhUL0FLQzVZN082VjJCc25KTSs0dnpPZDI3ZGNFNUJ4WHAzcnJ0N0E5KzRyd3IzbjVvN0Q2WDlGN1A0dHpMbVB0Ym8vYzNEdXdjZjNEYTlYOGk0bHNEai9LOHUwRzY2NzNuamVCOGk0akhaOEhaM1RQb25RUFkzVU95T0o4NndEazNEZEpjejY0N0c2YTlFeXUzN29iQ0xKK0FwY2RsQ2tyQ05rV2tCRFJlYnllU2cxY2xsU2tTeU1mQ1lTTnpjVEZ4UGwvd0wycDVaOEU5cGZWVDMzOFpQQUhxTDZhYXgwUEw0SER1T0FhWGs5RkdSWmRxRHBxQks1dHo3bndIVCszYzZSRmdJMVB1YjJuODUvTTdnL3JuRmRQdldrTnI3RFJOcVBXZnNEeExvZmFleWVEK0sra3VudDc2Zm44MjI4NDdMMnJsdXAyVFVtMzgzb29tTDZENmRPOGZqVmNzVVdLS0xsRVlTc0V5ajRUTlN6d3Q3VTZTNVQ4Uy9aL2QvR3V2TmdiaDEzeWJ1L3NmM0k3SjhBK1Vtenp6dngvNkw5QTd4OFlOczl1N0FUeXpqbCtGNytSa3dNWU0vTUhDTzhNTjRCOVFlZ09YZkhMY2ZaZXpkSzlwOGYwQjAzeW5EbzFtK2V4K0k5WDhYNS92ekhsU0hVUjhJd1VUWkhCMVFGamdSQjZUY0ltUTVSUlJSY3FWUXFWeWk4TGhoS2o1cWJtWFh1cGVPODYwR24xVFJ6cUtPbkRtSVpPb3poczdGRkduRG9BNWdMblR4cUlpU081SndYYkhDK3dxSXNVU1JSUXJJU1hLSTBSQjJTWUlsRTYvYXZQOEE5QmVVdlJQemg2KzgxZlRmakRybnAvMERvN3NEcXJrWHQzb1QwTjgzZXdPUis1UFBXMGVNY3kyNXd6c1hXM0xPRGFiNWwxN25HeDhrM0Z4UG43R2JUZGU5T2VocTI3VjZkK0luY3JlejUrQ1BUdkY4ZDNiUzdLNGhyZCs5WDdseC93QjliTGsyejVldXVpZDY0YTlJN0I2TCtUdVdsOHEwbStmdGQwN29Mbm5XZW9PVzhCN1Q2ZzlDK1ZYcVB4QjFsMUI2QmdOMDJEcXJyTHV6ejM3KzhwK2gzblQxNzVuK21QR1BXdlVYb0RXWEorRTZONXAxaDZVK1hmYlBtSjZ0OE5lbDNtTDJwNXorai9JSG9kNXE5amNrZHplZDl4OEc3TmtxWmROOWc5VWF3NVB3elA4QWpITklyVjZHSzNEYVBSN3puNjY4NHZSM2tMdFRvcjA3d3YzNTVZOUovTlhzanlvOVdlR091dW4vQUVEaC9JT0s4UDhBZHZtN3N6cFgwZHREanZMdEhjMTYxMWp5YmhtLyt2dTJkaTdEeWprM3Rqb3pvenJ2dG5WM0tPRDc1NEYycm9Mbi9WSG9UNTc5YVJzVUtFd2NoWWJGWkEyT3hzeUVoaFcwcldPVVRGd0RKU2tnZ0ljSlN5cWhqeWw0RjdXOHV1Q2UwdnFwNzcrTW5tWHdiMXpnbWw1SDZZYzM4aitGL1ZmMGE1bDJUdDMwSjVmNWUyTnJlTGJGMW5GT1ZkaDduOTJ1MXZuRDQzZGJlOGU5T1dlYk9QOEFqbmV2Zi9ML0FESnd2eFAwZDZqYzk4YytEUFUzMG05VGVlK05lUmVPZDRiazNQZ2VDNlhrZVQ1OW40TDRsNlU3ODVkNW01ajJQdC8wdTV0NUk4ait2ZmIvQUxGOWorRC9BQnE2Mjk3Y2FjYTc2K25idkg0MVVVSktMRkZGRWFUQURBcVJOQ2p4SDVaMUh3MzVoKzFQVC9HT2pkMDd0MXg1OGJqNzMzQjZBK01PS2JKdmVFZE9mWTNiM0JmSCtHNzU2TXluZWZucGdHbCtsRzRlSytDZGJiMzdzeXZkUG5OcTNMOUl0cjhMOHZZeHV2ZnVUYy8rWU91ZUsvVXpNTmo2NEkzUHF2cmoyZDg5Zlh2cnpuOWlReHdQVkJXWEo4aklTZ2dEbEZHUmxGd1lEQXgwU0lFbHBYTFFkQ1EyQmNvWWJOVmN6NjlrdU9jNjVhTytUQURTWjNrY1htMGpmeHhBZFJFZ2NjbmRSemlhMk80RGtBbGpKZVNjRTJYd3ZzTXdqQlJKRmk0bVRJVGRIUWJrN0F1VGhFR3VlVWNJNWE3WDZKNzM2QTlXK1hmcW53NTNQMEI2cTRzN3g4ejZPNTUxaDBUMXAzUEU2M2JjaTJ6ZDl6OEg3SzF0ekRnR2h1ZjlXWlZzL0lPbmV1dTRPU08yT2hmUzd6ZjdGeVRxL25XbS9pZjNIUjV5ZXRPSWRmOEFRdTkrVm50bmgzc0Q0SjV4NWMrME9IYlA0WnJOOGRaN25wWHNUUWVpL2szbDFYamZYMjQ2YXhIbS9HL0tYMVY0WTlOdk5uc2p6ODc3OHI5Z2RSZWdjSzNQWU4wOEs3TDVjN1Y2SjlCK2dmVjNsUDZuOE9kLzlBK3ErUDhBdG5vVER0NDQxNlcrWGZiSGtMN0wrZVhhdlJucG5sN3RUcEQwNjhwKzQrQi9SbmtmcnpwVDBicTNsZkNBTjM0L3EvbHZCMk1lWEF1UWNZMkZzUEkvUnJ6cjY0OG8vVlBoejFMOHJlNVBMbjFQNGc5UnZMSHQvd0FzL1ZuaHJyUHFIdjhBeEhmZUs4aGR0OUQ1MXNuSmV1ZW9PL3RLODI2MjF0eVhoblkzVFBvalYzS2VGYWc1bjEva09nM0NSMDJyN082WjlFZWN2b3Z5TjZuZVZmY1pDUVZSNWk4eGFMV1NURXVrZE5HcHRVU3VZUU9WVHQ2dTJtT2dDcStPQ0JoWktQTC9BSUY3Vjh1T0NlMHZxcDc3K01ubkR3cjFab2ZhdXlQWS9zandiNGlkWGZRM2hqaS9vejNyN1krYXZqNTF6N3IzcHV2WFBjWEtmTzNvTnpEekQ4MXZTWDFuNjg1SDBiNlE4MDhvUytYUThMOFQ5SGVvM1BmSFB5czlDL1pyMlg3SThFNVpxTmtEcm5iaTJTNTlvOENlcGZwajd0OXEvTi9XT2g1ZjFQdi9BRTM4NWZUUDFWK25idkw1QmVhbkIvV3ZtWHdmMXo5T3ZlWHhxb291SkxGRmlnR0U1TEhpWUljS2g0d2NvNmo0WTh5ZmF2cURpL1JlNmQyNjQ4K053OThaMTZqK0E3WEF1OU1MNlord3ZRUEF2bkpvM21mMEwyM3Mvd0E2ZFVidDlGOXc4VjhFNjIzdjNabGU2Zk9iWG1MNlFiajR2NEoxbHZYdXZOOUI0bXg5N0ZkMS9sU1Y0LzZaMlQ3ditQbnUzd0RuTGtEY2RtVmNma29raTBMeWNnVEptcDZ3QURGaDBDWldMbGhSUU5VVFpjc1hCd0FVYXU1bDE3bVhIZWRCR1JqQkFBWnNZMDRaeVJCblpBa21TUm93ek16Y3hBbVRIdVNjRTJEd3ZzT1ZGRmdFYUpVb29Sa1JNSFpTSllzUXhpbkllSmNrOXY4QW4zdVR6LzZ2OHp2VWZpVHVyb2oxQngzM0g1NDF2eXJoczN0bThuWVp5M1plUzN0VHRMb3IwNzV0ZXBmRXVlYkZ5bnF2cXp1L0Q5NjR6Mk4xRDMvQjhkMVdsUGlQM0xWWjg1UFdmRWZSN3lWeXZ6aTlhOFU2WDZnM2ZVUE85djZNNm4zTGt6dkhaMVJQb041WTVaZlBUZW4zQTZaRzNuQmltN2JENTllZ2ZKc0pydHU3RTZnOUE0dnVtdzc0NEoycHlOMjc1OTd4OC84QXJEekc5UWVKTzZlaXZVUE1QWi9TdXIrUWNNOUxQTHZ0ZnpJOVVlSVBUSHl2N2Y4QU5QMVA0ajlRdkxIdHpnWDBMNVI2cjZkOUFhMjVEeFhGZVFjVTF4eTdnMHh0MjdoWk5OaWU5OGU5Ty9NZnN6eXk5UmVKL1QveTk3WTh6UFQzakQwOTh3K3p2S2oxWDRjNis2ZzlBNEx2M0ZOZGNoNG56djJOMUwzL0FPZWZXV20rYmRhNjM1THczc0RwejBMcG5uSFhHdjhBa0hFc1kzTFo5cWNXNXIySDA1Nkc4K2UvL0szcFo1ZjlxdldySjFzWEUyQnBnYUFzMVptTHl0VEpja3d3WEoyNk5WQ1JaQ1N3b0pXT1BLL2dYdFB5eDRKN1Q5d3UwZm5ieDV4dnZqVm1nNWw2SGN4OHQrYnZDL1dITSt5ZHVkRWJ2MWIxbnlIcEtlemJieUh4enZMNkorNWZsbDRNOVRmU2J1VGxQblRpSGkvb2ZmdTc5Wjg4N04yajE5eVBvM3gzNjQ5MjkxY3E4NHpPWFFNeGt4ekJ1dTR0eTRIcC9iZWQ3LzNqckhqN2puZXZUTzk5UmVYZkJ2WXZyVjJENGo1VDQvM1R5eHNIY24wNTk1ZkdwUll1V0VpeHN1TWhaREN4Sk1WZUpQTCtvdUp2TGYycDZhNDEwZHVyZHV1UFBuY2ZlK2Irby9nT2pnUGV1RmRNL1lUb0xnWHptMFp6VDZGYmQyWDUwNm8zYjZMYmc0dDRKMXR2ZnUzSzkwK2Mydk1YMGczSHhid1RyTGUvZGViYmQ0cGdMZXduZGY1VWxlUCttZGtlNy9qNzd2ZGY4NE94WkdXRUcxbUJrUUlLRkVsQ1FrTlZBV0hBd3lUQVJDTmxNaVJSR3dsSldCZ3VFUkowWk1CNWwxNkx4M25Rd1NReHNvMGlkTUhISjFNYVJPaHpqazNnZE9uTVJoaDBRWVlaS1lmeVRnbWZjTDdEbVZyb1NpUGt6Q1ZIRTBBWklXQlFtWkRFYUdRSm12bHQ2bjhROUc5WmR6Nnc1ZndESDlidDIvT3ZPMnRIYzc2eGhkejJXOVl6UFplUjlmZE5laU13NC95bnpMOVYrSGRpY2Y1YnRiaTNPdVZPMWVpZThlaWZVVzl1QTlvYVgrTVBjQUhBdGY1eStzK0llam5rcmx2blA2ejRwcy9odXEzeDFsdWUwT0dhN3psOWFjUjdTODljaDJQeEhYeS9hMjFiayt3M1V1QjhnNHp5VjIzMEhDNWRQaDI4OGN5TGJkNzIzeGJtWFh2VWZmOEE1VitvL0VYVEhXbmRHcWVXOEJnZFp0dldQVkhmUG0xNlU4WmQ0OUFlcWVITzgvTTNUL1ZQZTBmbDAxWmRQdGZoL1lYUGZaSFQvU1BWZmVQSy9jUG4wbTBidjRSMlJ1TGduWnZBUG9ieVg2NStTUGVmR25iM1F1dWVVY0t5amF0OTdXNk85SmVhZnB2eHBrVzNiem5teGNsZzl6MkxVL0tlRjlYOVI5KzZnNW4xdHBUbS9XK1NiZHZXK09COW9rNGMvTXZadlMrMk9LYzQxcHlIaXZVdlZIZTNTUFdQYzFvclUySnJNdWtjaVVXTHBvc21nbEUyTzNpUG1Sd3BqakJBOFM0OHlSYW5sWndIMnA1ZjhGOXAwVVVVVVVVVVViTTF2RXZwNDd6K1FIelc5SmZXZlJ1MmRpMFVVVVVVVVVVVVVVVVVVVVVURnRCOU9uZVh4cWNFaVJJa1pLZ3dNeWtJbU9tTFFWSlI0VGQyOUM2WStlLzJsenJGd1RPdHc2OTBOcC9YK0grL1BnZmwvUmZvdkN1bWZzSjBGd0w1emFNNXA5Q3R3N1Y4M2RLNzM5TWRzY1E4U1lidS9zUEs5MCtjMnJjdjBxMnh3L3hianVzOWF5M0pmbnBpRzEvUk9kMG5tK1YwSE05dys2L2xaN3JkWjlnM3JkeFdMdldOdEZvbXdrdVhKYUJjcU1mRmpRb1pKa2RxSnNGSHlNaEx5aTRGeWZNZkpvaXpCdVpkZWc4ZDUxajVrcFk2Y09aRHBzNFFON21OSFRwNXhHM0RzRTVrRW5UcHp5UVJPY2s0SnNEaGZZY3V5WEtZNkxDaExJMEFXeGsyQ2c0NUNTazJMcWlOUnBsNU1SMm0xY1B1RzFURzI3eGFxUnVpU1RFRVdTcWtoTjFRaTVQd012R3VmRFhNOEg4RTg2ODVQV25FZlJ6eVZ5eUkxK0tRMHVSM0hhNlkvVlluOGNrNGNtZS9RL3I3T1BadkVDTFRpVzdiRmxXMWI0TGx4UjJmU3lHZzNHMWljdW5hdGhrdExyb0xjTnFudHQzY0NEc0NyVmlzZG9naGR6Mm1kMnZkc2EzTGFwM1Fibko3aG9aSERta05QcWszaU94ckJLbUdicnMrYTdYdlNZckdaOFVYbjBzL290ZWZGckJDMWhrRUtKQVNRWWdXR0tKdEFWU0pPUmVjUzBSWXlYS1k2Q0dTVUg4a1JLVWkxR1VHa2lLRXJpeFR5aTRGN1Y4d09DKzA2S0tLS0tLS0tObWEzaVgwOGQ1L0lENXJla3ZyUG8zYk94YUtLS0tLS0tLS0tLS0tLS0tKaStnK25udkg0MUFnb1hBK1VlTWpVTFNJRG95UXNZN1NWSWs4Z2U5dWt1T3ZQbmFoM25ENkVZRnZ2cFRvbmdYeTk1aytwdmg3Sk9xK3dwVHB6MGFabjZ0WTBuWjJNOXUrY3NuNlQ5WnprZFp4V3E1TEZjdTZrbGVKZHVMbmE0N2V0dXhidjNvUEsvTlhxZGVnNVByM3VEelY3TDdOeS90amE5d0FUTW95SmFKeVlvMU1tV0JCZ21hbnJMQ1FXREVrRWVYSlFraXhSR1FMaERTazVNZ3hQa0FZUHpQcnpNOXI1Tm1wancyWmdhckdwWlZCa2h5Tmxta01MTnZtS21Pa1dTSk1tdXQ0NHJ0M2hIWThndFpFT2c4SGtVS2lRUk40VUxEcE9nWkhCOEVqa0RyR3dDcThqa0J6SmlIQmtJU3VTWUxSZTB1MkM3WmZUL3lON1U4LytmYlozWDVwNU5hYlVVVVVVVG5kT3piait0SFZqZXJ4c3liZ2tYa1BWeVBxdVVrT0ppYW55VkloakZtMXEybUp4a3praUtJdW9jZWxrR1FZWXRqeU9UanlmTXZqQ2diSGNReVhZN1dJcVBXRldVU2lZeEVlWERDVUl0QVErbVpJK2NaMEZFWUJUa01oTWlBSkVhSUxqaVdSWk8zaGN4WlY0VVVVbWtKVHdGeEgwOXdIeEwwOHdJbUx3SmlXSktRMFhDRTFiRm4rcTQxZ09sNUd6WFBaQzRsbVlXbEFSQm1DSkVGb2x0Q3BtOEV6Q0N3a2s4bWo5M08xUG1sSGd4ZUVoSUtCSVZVc2RHaURzdEtVRkdJM3grVkhZL0FPSk55NE5NK1EvZlNjT2JEUFgvejg5SmVxdS9lcEt5c0pBYXViT1E3SDBmc3U4U0dMSThHR0Y2N1JhcjFlbTd4MlRkOWEzcnF5SzdrMCtYUGFnaVlXaUU1V0x0amRIYkk4alNhZ3FWaTVSR2cxRWtZL2RjdUdrd0tBWVJjcUZqWkxCNWpaS1o5SmlXODhmWWtXQVFmc0pnQUdqWkNrdUJKbVFBS0laQkVtYlE1RXorMDczbTJpM0J3b3g0UUx5Sm1wcXBrcTVVSDVJR2g0Tmt3WHFqcFM4aHhpRGtDME16TDhsQ2hBM1NHNUp0V1Z5WFdDWXdmRTlYclA1ZmRqd1hTbTlVVVVVVVRYZmV3N2MrbmZXNWZJdE1tYlZNM0xTcVY2azJYcWphbzhzVDVFVFVlSlhNeWtWS3RLN1NuR2JrN0Mwa0dKNHpobGVRM0I3SVFnU2xRb2k1VWtRbGw0aUpHbE9CQkZxZ3JQRTJZK1hKMFNRckdtVW5jYVJPUEkyVFlDSkRpUEFFcFJTYm9lSjdKVjFXazJCcXdHV0tTaEN3cUE4bzJ5V3JaZGEyeVNtTFhtQzZXanBnZUtDeWZxUFdkWGpMNDBVc2xNckNFa2VIUWJrMkxCeE5WN0l1RDQySWttQ3BPUVlsYUQ0ZlVVQXdQTWR5SkVlbkdOS2lxMzVKNURzZkkzSStPcEZwOUErdk9lYm1pMWtPcE94U3VKa00xWUlTSUVCNWFrdzJOZUpvaVVDQnF3U1plMk5VSlFGdFVaYWFreFZhUTRkSzVDd2VrNFE1VUx5VU9JbGt2d2haTWxCUlBRb3gyVXFJSXN5TWhDZUxqQStVTWhLWXhlVkdBZ2htTVF2WllKck00QklOR1NLRHBTSkN3Zkg1REN3Y1BHZ0d5VWcvWkhRR2tjTVFKay9TWVdSOW9PSFN4U0xsSUp5V1dDb1RVVmh0aXZsL2ttSmVYT1NSWFdtNVh0RXQyZnR1WGVxZU1aRjZXNDZUYUxTSGs3RXF2TkNhaFppUG1yaUpTdVNMZy9DUUdnQUptc2RGU21TUXlGbHNZQUpIOGh1aFJVVmhsWFY1QkxtUW5HalZXMVNwbDZMd0pjVVRRU0JrYVNoREJxSlZNR0xZN1dMcWVMc2pJK1JoTmp4UWdqZ0pLVmFRK3RrRnlwckVyRXNiMk5IMldDckhnWEdiQ1pDVE10VzhXU29DQWhzbysyTnFzcGpMTm9mUVBOWVd0akpBa2xDUWtTRHhDRWdTU1BCSkdGcWxXUlVISkdnNE5DNHVSTkV0QzhyRU5aSVdnSlMxeW9TZExsb0NRbVpPaXd4RUtJVFpaMkIySElibHBHMmdNY0pWSWVLWXFscVFJa1ZFZ1E2RW9XaVJ1ZWsvVVhDMG9td2NOSThJSndRTVFhSW1WNElsUXRGa2xFb05FZVN0UlZseUZCaDBTT0JKS0NCUlJZUUxTM1dDSXRlOWtpR05ndVVQTWpvRXh5WW9zTEVtT0V3R0VJR2loWXN2a1FwTmdjSEpYZ2lGcFNTQWgybVNJeVVQRHdjY0FtT1puSXE1UmFxckw0emdrc09DQlJSVXNkdFE2c0UyczlNcFFDaU5RUW1jcGRKZTRQR2NDQ09Zd1NtU1dRVmtsT01FZ20wdVdLRUE5S1JTS1hOaVpJaWlSQkpxNUNLV0hKTWpTZzBQQ0JCRmxFZ0JvSnlVSG9NSXN2R1NRSTRHSjBkTGxpaEJIb0FFclM5b1JZU0Q0OGFKU0VCeEFnZGxlRE1uN3lianZHRWdRSWtkeUp2SGpncHMxRjVSQmsxaElzZ1VTb1RVS01XRUV1RG9nRTNMRlFma0pBTXFWaEpjVVNoYkdJQjdtZzZFYmx4MmhleWF4MmRWUXNGWWRXeWlram9oVlVyV0pERllvRnkxRUplRUppc1BXeVNQSHdvR1F5bWcwUHlZMkF5c2tSZkdiNDI1T1FkQXl3U09qZ2FRZ29ITENoU0tUUVdTZzhMS0FTR0xaQzhkVkdRckNFT1dGRnlpOGxSS3l5OXltT2lpNVNiaHdjTklpWlpIQUlqREloU3c2SStZZURJRUNaUWx4MEFneVE4Q1I2VWVrMnA1RVZLUWtZV0tJSkU4bWd1VlhDWXpjcENBNEdTNkl0TmlVSTRqSm81TnB1MFF5bzVLclVFVWxkNW9XQ1k0WFlSYVI4ZFltYXFsTlJlOTV0UXFDWkRXaDhWTTJ4eERLSkppVGtYRXNOaVdpSGlSUXhFZ05nSUlYRmtzRUVLSGdaSXpDWURrY2s0bFFBaXg0TEpBWUFCNGtwSWlvS3lydzlFdXdMakhGeVdIRU5LWHFvSHNIcWR5U2RqdURKeUFBSUhFbUJKaVVTUUdEaDVJam9uR2c3cmxwWkloc2c0a1FhazlCbVNvTmpvM0toSkowRWxRZElTVE1zZ0lyTmp1R1ZtVXJDRXcrU0VGb0hSWTZ0N29ZSU11R1VrcWxoODFEaU94VEVVczZrUUpMamFBUThqQ1ZLbWxwbWFyZTVpK1RHbWFxaXhSSGxpZnFmc2p4K0gvL0VBRGtRQUFBRkF3RUhBZ1lCQkFJREFRQURBQUFCQWdNRUJSQVJNUVlTRXhVZ0lVRVVOU0l3TWpRMlFqTVdJeVFsTjBBSEprTkVKMFZHLzlvQUNBRUJBQUVGQXhpM2tGb05SaTJwWUJXd01Ed1ExVUMxdGdkK2p4Yng1TFE3WUdBV294MDRzV21RZWdLK1JyYlBZckgwWkJEeCtwYWRYakl6YjlTME94YWZ0YnpxVnYyR1JrWnNZTFFlTEYxZU1EQXhmSFdYelQ2VDF1WFZqb3piSFg0NkNCNkRBeDhqSXlDSDdkV2JrUEpBd1hSb080N2p1Q3RnRnFEdjV2bTVsMEsxQkYxWUJBN2xxRDBQVDlDMEJhMkllVDBMb3lNakl5QzB5RDFHUVZqdWZSNUxRd1dvOEF0TCtmTjhBOUFXdlRqcExRWUJXOEEvbGVDMXQ0SzUzeUNzZHlCZ3RCNHQ0NlNzZlNlbWVqRjhqTmpCZGZqQXhjOUI0SGdGOGtyK09qeFk5UVFQUzM2MnoxbGJ1WXdNRHowK1Q2QzA4Z3UvUWZWZ1lCRmJQVHFESzU2K2JaNkM2dkIvU08yQm9SYWRHZXc4RHgwZnJqdWVoYUFyNEJEemk1NmxvWld5TTlHZS9ucE1IOU5pTytCaTVuMTVHYjR0NHVXbm5GakdlMS9PYkgxWUdMZVMwSGkzanBMNXgzOGZJTDVCV3hiSXpiSXo4ang0OEYwNHNkczNQcHhmd1YrNDhkR0JnaDR1V3BnOUMwdWVuZzllblB5Y0F0REJhOVBnZUFkeTBHQnVqQTFQeGpveFpPbmpJL1cwaVhHaW9mMnJoTkI3YXlvTERsYXFyb1ZKa3JHVE1FWmtFUzViWWFydFdhREcxczFBamJWVTU0TXlHSkRXUm14NmxvTjBZc1dnUFh5TWo5Zmtac1lLMmJsYnlXbmpveGJ3TWRHZTRQU3hkSG01YWRPTCtMZU9yQXgxZWZrRjBGYlB5c2RIZ2RoZ2FGNHovd0JMQXdNVzhZR0xGb05USG14VzhqQTdFTTlPTGxvZXRpR1JxWVBVWnRuNXA2RnFZSytMbFk5TEp0a1pHUVZzZ2p0Z0g5UmtDMFBTMCtyd29BbTdUVHBBdzlKa3VzdXNPL0phZWRZZGhiVXltaENxVU9vSUI2ak5zOU9iZVBHbGpCYTlXUm5yeGZBeGJJSUhvUDJ2NHhZK2c5Q3QrM1ZrWkdiRjBrRCtSNTY4L05LK2ZrZVFlaGRQbm83RHNPMSt3N2RlUmtadDU4ZzlTMDZkYlk2RDZNVzcyd1BKanhiRnUvUWZUZ1lHUmpxUFFIcURzUjNMVUhwWk9oOUo2RHdETUZjOVpFbGlMRnFXMHNpUUk4YVROa3dObFVFR0kwZUswN0hZa01WRFpWQmgrTS9Ga2RlenNXTk1xMDdaTlJCYUpFT1pUTnFWb0NIVzNtUEI5SGdmcVAxR2U0SUdDMStWam96MFp1UThqOXJlQzB5Q3VXdHV3eU1qUFNkc0RGdkI5SjJ6MEdDNjg5R09yejQ2Zkk4WitjV284L004ZytndExuMDV2NHpmTnNkQjZrZHpLeGRmN0R6WWk2TUR4am9Mb1NQTnpCYWc5TGVEMXdZd05BWDFLc1dnd05CbTFWcTBlbXNUWjBtZkxwZXpic2dSNHpFVmdFVmoxbHc0MDJLNlRaU28relZSZllSc2k4RWJJc2hPeVZPSDlMVXNoSjJWaG5FL3lJVlJvMVdicWNHWkJpem85VjJla1FCVHFySnBzaW5WR05VWWg5SGc5T2p6NXRnWXRudU1kT1BsRmZ5Q0diWnNmVGtaQi9JOER4K284V0s1L0lNRmJJejhqeVBOdkZ5MUI5Qld6M0dRUThlQWZRV3ZVZHlCOWZpeGFEeVBCYTlPYlk2Q3RnWXRrZGhraGtaNjhqUFNWOGpQUWZTZW9MUUdRSzJleFc4Z2lIZ1pNWnNYMWVMRm0rTzlacktLWkhNNUU2b1VqWjVFSXNHTURRWnNZclVuMG16Vk9qZXNyWkZjdFBBcmxHS2ZIalNINEZScHRSWnFWT0ZZMmRKd1JwVWlCUHBkVlpxa0VZdjRJZnQrMXZJSStqRjhkUkR4ZlQ1SGk1V3o4akF4MC9xTWpOaTBHT255UEhYam96Y3JmdDBIY3dXblJqcHdDK1o1OFdJWTdXOFhQcDhadGtlQzFCMjhYemM5UE5zOVdMNEdiZUxGcDRzV2d6YkZzM081YUhxQzBHTTNJaG01RmZ6Y3I0c1lJVmlxb3BrRC9JbTFHaTBacW14ckdZTHVXTGVOclpXWkd5Y2JNdTVmVGZhQ2krb1JUNTcxT3FNU1l6T2dDdVVJcHJjV1RJZ1ZHblZGbXBVN3hudmJ6NUhraXZqcTc1dmtaR2JuMTU2RHY0OG5wMFlHTFlCV1BVWUdBZHNERml1ZW55UzF2a2FXd01kSjZnN2VEMXQ1K1FYVGdZNkN2bTNtNWFYOGVlb3JZdGdlQzZ0YmxvTWRHT2pGanZrYWxvTlN0NHQ1QjY5Slc4V0xRK2pQVGkyYjZXM1JnWkdTR1NHU0dSa2hMbU13cWZObU96cWpzcEFMR1NHUmtkZ1dCa1pJWklWS1Y2eXUwWmhNSFpWMnBQTGh4NXJwUGp3RDF0dERSTjBVcXFPVXlmSGRha1JSdEZSdUkzU3FrNVRLb2gxRDhZdWtpNmMySzJlOXNqUHpjREZzOUhuejVHQml4WHhZeUdRZXBYeGJJejArUGtsZnhjOUMxUFc1Z2dkdjFCYTN6MG44enlEMUxVZWJscGZ4NUJXODRHT3N0VHNWOUJyWXVyUGF4RmM5T2pVdER0a0VmY3dWeTFNN0VZUFhwTFF3UXpmQmpBd1Z6R0w1c1pnaDU2ZG9hbDZ5cHN0TGZseDJFUm9QWFdwWHBObTZkRzlaVzZtMHBkQmhaT1BtS3A2V3hJZmM5RldqYWVqVmh5WDZPczd5V2FvbzNJOVRGT2pTbVdOb0tKNk4yaDFoVk5sa3RMalEyZ3BYb0oreTlUM0h5MFA1QjJ4MnRpMmVrZ2RpdmdHVnNkR0FSaDExdHBMdGNpSUplMEQyOG11VGZVRlc1ZTgzWGxobXJ4SFRJeVVrd1Y4M3hieGMrcnllbnlETWlMMVRZOVdQVktIcW5BVWtKZlFZem0rTG4xa0QwNkMwR2JGMCtiT3pvelk1dkVOYWF6Qk0yWjBXUzZDd1pXODNMUy9qemNyWjZjMklIcjU4V1dwS1VKY0pTTjRZeU53czdoNVR2cFBKREF3TWRXT2dnWUlIZndQQUlIclk5QVdoL1M1TlliWHpKQkV5dmlSVjFWaEV4TTl0UTlTeUNsUlZHV0RTWjNJK25GdSs5NEhrWTc0QkVLOVA5QlJSc3JENDFYd01EemdZSG5Bd05ySlpLa2JKUk42V1FtRStzVXFtdnBuMWZkNXV2dkdubzQyMUtONUw3emlvMFp4NWlXeFNwQnlhSXRLVnRWeW1KcGxXaFZpZkFLRHRSRWZFeU96VWFNNGg2SFVhWE5Lb1VVL2srYy9NeDhqTnNoMTVwbGlYWFZMSlRpMXIzdTFzamVCTEROUmRqS2cxazMzTzJNM0w1QjY5UjZXeDBhSmRsWUwxWEZIR1J2Y1JBM3lHOEN0eFZJUzFLM2tGOVBub1BxUFFadDU2c2pQUlVKN3p6eW4rRTJ4RHFUd0xaNUMxd0tXekFYTWJjZHBqaUtsRGNoVk9vdUlZcmJEZ2JkYmVSY3RMK1BOeTBPMlI0dVdsaTFQUVM1UHA0Y2lzcmRMbURqWWkxbXBPTGgxQ1ZJbWptaUVyVFVvaWh6R0hqbThOTHBPRnhiNUdSa1pHUmdZc1FNYWxnWXNZS3hhbUMwOG5hVExSRllRY3FwTGFwaUNRM0Vpb0dmaWRwOFY0cFZITkxibE9lS05FeTdVbW5OMlg4UnQzTE44Mk1yR1lJZVI0dFg1dnJOb0Jzek5nb3BSYWo5ZlBuc1NKMjBrR0tKbGRxTXkyekQwWTZCNHFlZldRZC9ndjd5U1ZWdDFhcFBvVkttdE14MkdJL3BpWVpTOFNVcEdSWHBYcXRwclFhcE1wN2xXbVJxaXZaV2R3YXZjaTZENkM2Y0RBd01ESFFZSVpHYmVMVEpqVUtOTG12UzVIeVVPR2dVNnBjTUYzSzVXOG1ZemM3ZUxGb0Qra2dkOEJ4YVcwdlNETWFudkVhblhFTk5wZU4rVHd6VUhYaWpyTE9ONXpkVWFqWlF2TGJFamRHUVhSbnFQNTg0My9BRWJkR215SmNhbng0amZHSmJaY1ZiTzc4QzNEUzY0MDI4MVVhVncyMkhISFYrcVUxV29zcEVxTll0TCtQSXozc2V0L05pMDhXeVJKY1BLcXF2ZVRoeFRFR211dnNvcFNoSGk4QTNTV3BtWEZueGc1Smw1V3JlZmlQRnpTbnVPdXR0U0Q5VmthakE3RE5zRFFaQmtDMUg3V3lOZWd0Qmp2NWxTVXhvOGFLNU5DU1MyTUh4Q0lpQ2trb3ZpU2FWRXROUWpZVEwzbktUUzIwbGI2a2d0UjV4MkJIYkkxSWViZUtuTDlEUVJTNkc5VTRzeUJLZ1AwN2FPWEVFS29SSjhjR0orMFVPQ0oxWG0xQlY0c2w2SE5wbFVhcVVDUys2bVRCVXBVaVcxS2VobFJWOHRYUzNaRDZhT3Rzb3JQcGFkbTFSbGVpb21wOURUaW1aTWQ5TW1CY3V2d2RzV3lNM3lNalBRZXBhM2x5bTRjT1ZKY2t5VE56UDhBY0g5MGxFNnBLaWZJY1JDbGRLRm1TNlRVT2d0Uit4M3gzSG5wUFFnZGkxV3RMYmJ6KzhzbEdaaFVabGEwdHU4VGRXcDVha2tFT1IvWFIzV0duZU95TTlra2ZIU3JBalBZUEhRWThXOGc5UGtGMFp5dVU0MmdOcEoxU201U0dtV1hNRVRURFVpcU1Sblc1VERpTWtaYnZCTnRaUE0xZUJ3cERFdHlYVkthZ2tVS3hhWDhlUmkyZWs3Rlk3bWUrNnRaSmJrTGRNVXFqSDZkQ0VvYTN5M0U1VWpmM2JUNlN5K2wrSXIwalg5dVZTbTkyajZranVNakl4YlFaR1JnRVk4ZzdIcjBwc1pnMWJxQ2JhZkJ0a2dPVE9ITlRQUVplc1NUTGM1RzRUN0sxcVNzTFU0cHA2RkVlRWZneGtxWGxKRnV0bVEwdVFPeGFZSGdqSG0yZzJ1ay93QnFERVhPcWtlTzNHaHZOTlNJOVMyV05JSTVFT2JBMnJ3MVVxL0xuZGNLYTlBbndaa2VmVHNrUUsrYjQ3YldUUGpGSGd0MUNzcW8renFIR0tEUTVUejlCb2tWMU5JMmNXdGg2blVtTDYrR2lFeFVJVXA1ZFhwaVZQVDRVVnhpUXhKWVBvSWVCb00yd01ERnV3d01XejBlU0JpcVRmVnp6VU1BbXlVOFRDemNOQ2tHb2s4UGRTcEc0dkpQWUNWRXJvWmNOS2FYTUtaVE1YOGZ0MDR1VnZQZ2dkNUw2MzN5TEJKUEtNaGVWTkplVWx2Y1FwQngwWmJkYWlQTUdoY2cwcEJkaWQrb0pQdkhkNGpOczlmam94MG5Zd3QxTGNlYkpWVWF6UjJ5S005ditsWXp3SERaVzQ5VDRNb08wbmlFNUdteGd3VG5MM2pmTjk0MU90cXBNVTZsRkxoMG92NHNEeGZ4MFlHT2p4aXhuZDFRSS83VzQrUVdUYWh4aXlSSzQ2VWtnOTA5MDBwTWZFZzlTcXNkTGM2UTBzbllmcy8vQU5NL0VXRFNZSWVUMUxRYUF4cWtIb1doNjNPeVFaZ3pGV2xaVkJhNE5MV1plcjlPem4wN0FReDhmcFdCd1dHSDIwYmlYM0NaaHBuMUk2OVM2aXFjT0VnbnMvSUxXL2tZdHRFOXhkcTlsb0tXcVFOQnFKMU5pVDJhbkI1ZFdQa1V5cE8wMmZIa05Tb2FkRFBvOExkUTIxT2xLbVZZYk1mbFZROSsyWmMzTnF0cDNOL2FtRDcxdEwrV1RQOEFpN1o1N2c3V1NmY2RyZmY5bHZ4YTVGWmZadm5Fd2MzbGptOHNjNGxqbk13YzRtRG5Fd2M1bURuRXNjNGxqbk13YzRsam04c2M0bURuTXdjNW1EbkVzYzRsaVRWcFNxY1podlBFam10NmMvTk51b1BwcDBCNkxEWDZhVXRsVWhwdERpdUV2ZHdSa3BuNGVOdWp3clBEU0tSSTRGWHlQQzVqNVBLbnlVdGM0bGpuTXdjNW1EbkV3YzRsam5Fc2M1bURuTXdjNW1EbkVzYzVtRG5Nd2M1bURuRXNjNG1EbkVzTlRwVWhvWkNsN3NvbEVaWjd1dExVU0NjUy93Q3JrR0dZNTdyVFNHa2pJV2FWTnBXYUFRaXVia3UwMTl4bFhycEFjcTh0RDNPWmc1ek1IT0pZNXpNSE9aZzV4TEhPSlk1eExIT0pZNXpNSE9aZzV6TUhPWmc1ek1IT1pnYnFzMXg1YXNpZEw5UktXY1F0cHFaN0s0aEsyWU83NmZnT2NVNGp5WDRqYmlGTnZ2SmpQT29NTkk0Yk5Ra3FqUlVWeEoxdHNpY2FQUVpFbDFUY0wxMGdQVlNVMk9jekJ6bVlPY3pCemlZT2NTeHptWU9jekJ6aVdPYnl4emVXT2NTeHptWU9jVEJ6ZVdPY1N3bXF6RnVHcFFrUGxIaU55SkpOSVBKYnJhSDF1a2syNW02MmRRaWt0TXRsYS9nY1NwYW0xUGNDUXp3SUpyUWJTRzBXYU1Ib1dya3g5TWxVNlFUZk9KWTV4TEhPSlk1dkxITjVZNXhNSE9KWTV2TEhPSlk1dkxITjVZNXhMSE9KWTV0TEhONVk1dkxDcFRqZEppckoyS2svN1RocTlTTTJVZUV0RXM3VkdVbml0RWUrd2psMWJQdWxKb1FZOGc5UjR1WmdoKzJCa2ZyS2Q0MVRwemZBb1hqVWVkQnROK1YvSm8xV1hUWmg3V3dFaGUxNUJlMXN3TDJtcXFncXUxWllYUG5PQXpVbzdiTWZsVlE5L3AvK0p0clUvd0RLMnpoKys3Uy9sa3ovQUl0anU4Q2ZJOXcydDkvMlcvR0xZdTUvQlpDRnVMOU8vd0FVMkgwdUdsUklKaDVTdlN5Y21oU1hPRzV4alFwSkcyNGtKWmVXbzJYU2MzRjhJMHFUZVVmeG1FaHVTL0ZkYmVTZTA5UVVVcW8xTmZDb3NJam0xZWU4eEdjS251dFFNLzJ1RnZxVW5KL0UyNW5lQkdFNURMbkZoK0hubXlscmViTm5vTkNrcE5wMUlKdHd5SkMxQlREelk0VGh1YnF1SDBzcDNHQXBSWmEza05iaGtzbnlTamZUangzdG5zVHFUTWpkV29rSkkxcEphVUw0Y2pPWFVLM28rUlZYRW9YeDJnNlpLZnVTRktTVGJpazdpODhOemlGSGZOcmRVU09FNlQzVEFqbS9NcUVyY0NHUFR2U1dqWXE5SGRMY05lNGxoNURZUzgwdFJZT3o1cGFRd1crZVJQbEU3VTJQVXFyRk1YL2d0SUpwNGhnVGozYVZ4MmcrdEsraEtWS1dTRnFYdUx5YUZwSk1kOVN1RzV2Yml5YlVsU0ZkRUJCbksxT3RURk9PUU1PcVNaYnhxYjlUUFN0dW1rMGlaRDVhNGF2UVNEWENpK2xpSUlsdWYyOElxc1p3bVhJejZTVWtraEgxbUNEN3paVFZ2Tm0xMEdoU1VtMDZrRTI0WkVoYWd0aDVzY0ozaWJxdUgwUlVjU2RWcHhjTmg1YklodThTQXRzM1FjZDQxZW1mM3libEpXVGIzSHlKczdnZ3QxVk1hcUNGTXR6RXFvY0Y4M29DMUlRQ1A0ZklQVHAxdG03eXR5bklUdnVwd1NSNDBJYlVsamFYNU1hTTlMbW8yVXFTd25aQjRJMlJqaEd5MU1TRzZCUjBCTkxweUFscHRBMmhwZm9wNDJZL0thaDcvV1UrbDIycFplcTIxaWUvYlMvbGt6L2k5TFc5RUcxbnYreTM0eGkrUjRjL2h0QUxMa1hDWWtZdUNzMitMc3kvdXFuTk5rdWl5VC8zSm9UL0FGVk4reVVTVnJ4aGlQM3A2Qy8wRXpRTi93QXppc21lUm51VGppUnZrbytLWHJaRHNoMWNDVXVQSWRiS1hYcW80cjB2RUtCczloczRDczhJRVJFUmFvRklQZTJlTVNmY2VseHJqMHVhb2x0UkZiaktHaWFlWTdvYlBoVlp4UERvdlEwVzlJT3lGSmNNWkc5MjRUQmx3eXdUYXNiaGdra2xLK0FsWnIzaGtaQ2s4UkRCNUVQdkJ3Szc5WFRUQ0pURWN0eWp0L2VyU1M2aGt5bUxiM245N2pWcnBndUUyeExqU0g2dzQwKzdKcURzMWNXa3VxbE9FVC9yVEtObjBiR2ZTeVcyMExsb2FiVTQvS1VySW56dUNoNTRsVkdjNy82eFNKTyt0MG1rdnBPMVU5aDZhZDcwd2hLYXE1OTY0a25ZRW43VS90cEJmNldvZTc5RUR0Q21TU1MyOHRwUlFKWkZOTHNiaS83dVI2ZHNuVTcxbGYzMXFVb1RIZUhTRzNXdVlVeDNNMWU2bFJIa2svVVBFcjNQcGNhNDlMbXFKYlVSVzR5aG9tbm0rOFVqNFZZY1R3NkwwUi9nZ2tSK3NjVERjZm9yU2swcEdDUmRSTGRhcUQ2NDFMY2pTSERxRXIxWWJneVhZeHgzV2hTSnZBZk5XNjBUeGdsa1k4Zytnd1dwbjBUKzJ6a01zMWZVWjdFUThqYTFQK3orVHN2QTRVRXREc1ZzalBhWkdhbTB5VEhjaVR0bVB5cW9lLzdXTjd0ZjJWYjM5cEludjIwdjVaTS80dHBUUEhwUTJzOSsyVS9GOGpOaUJoWDhObzdxV2pqUEpaZFlsdHRvalRtMlVGTGFNRzYwbW12UG9jcUhNRzhLZlllWmVsazRsVTVwMTVNdGx0QlQ5MlU4NHc2d000Qy9yTFRzWXdva1p3ZVNHcW1wYjdBUTR3YVViNjVraVc0KzY1d1hYRjhSdUxZZ2o2cUwrTkNUN2owdFQwTnA5VTBwc3BUS0ExT1NtTjZoaHREMDc0SHBNWjlCNDNyeFB2RDFkWHV0OXNlcGE5UjY4elNxUmltc3orTElQU3lzN3Bxd3lTak1pdTMyblFQc3hYZnE2WThnbVdYSjZEY04rT2swVGtvcUpTSTJVemtFR1p4QlpORjBwanBjZTlNd2I2NGNad09VNVpDSkNqbEdrU2x4WTBlYXkrZVJ2NEhGWHZQUFBHaVpKbFIycFZRUXliRUZxTEFhU3B4Y2YvRW1HcEtvelo1YUZUOWo2WXJxV0tnaWVnbUNmanFNNWdjbFIzUjZ4bks1KysvS2NZZmU2SWExRTdVWFVNemxidTYydGx0bW1Ta3YwMXhhalpPUjI5UVJGeDBqanBJSVFrMGlyeWd0ZzBTSU16RWt5Q0RVYlpBZ1lrKzVkTFU5RGFmVk5LYktVeWdOVGtwakcrd2xoK2ZrbnBNWjlCNDNyd0VFcUlUVFJKY2d4MWxOa29pMHJpeVdWczFDV29sMXBhRGRyU2xGUko2M1haRVprMmswaHczMDBWV0VVeDFvUFAxTnNHa25WdHBOcGplU1poUHhmSkloaTFRTC93QmNoOXF2b01EOWJWK2x2MUp2K2w2bVA2V3FZL3BhcGorbGFvUDZXcVkvcGFwaitsYW9QNldxWWIyVm4rb1FoTGJKYUF5NmNkcTdSVlZFVVNoellOZGw3TlZKMnFWK2x2MUp1Z1VtUlRWeDltcWtpcVZtZ3pwMWVrVWFZNXNQUXFKS2d5UDZWcW1hOVJwbFJxdERoUDAraVg4QmYyOW9MYUhxcVVPUHYraGhHNjdEWWJwYW9FVk5RS0pEZGVLSEgzeWd0LzBzM0JpdUxwN01hUlUwdzRyVFNvY09OSjVaRzVqTWpzY3NIaDIwVmhEN1VtRklpTzczd1lRWTNDM04xWXlXQWw1eEtkOGdwU2xPV0lGcEFSdzZPSlB1TjRqUHFLaTlEaUxpSEFpYytUQ2pIQlJEam50WEtPUDZrNmRFV3AyRkhlalNtS2VoQlFJU25ieGZ2RERobHZURFdha01tMU9ZdzNRWEZxT254a2Vucjg0MVNLdTA0NUVuTXlFU0dSa3lTa3pVbS9mMTBNc1FoWGZydXdrbHowUklSMTJIR2l5cXJHaHRHR1k3S3RtbklMU2RsNlZIalNaTFVPSWlNVUdQR1k1WXdtc1RZN0tZTjRSWVFYR01mM3lJM0hONlF0dUpGbnlYNDB4dWVsNUxFMTBpS2RQd3FvVGNSSlRyOUZxMFNVL1FpbytFTnhpYmora2x0R2MxNHRxSVNOMk1TQ1RhcCt4OUs0TVVxMG1GRGJZaVJJcjFjZmFTMVZqcHNSVTVjS08reEloUlRqTXdHZjZjNkdEL0FNOTJJMjg4dW5ta0wzdUxUb3lHNXpaS2JXbDVHU1d6Zy9UdUZ3V1hFNzVabXorQVU1ZTdUSkUwbmhEYlBpMCtTVWlBbEprQ0x2YVY3bmFtc01Pc01Od1hhY3VuTWxYa3dXUDZvT25vVENPQkRVOUtodEpGVml0UnBERVNNNXM4cW54TjlxRkVKdGlCSFJHbU1wWXFRcHZhRnZtT0x2SE1qK29pYjBpRTl6eW9aZG1PdlMxb1ZDYmd0UzM1bkRhY2JJMDNNaVVodUhIWWt2T3JpaUpVdTcwL2h0SStqcjBCR1BBa0Z2d0VLM0hzNUxKandLMU1reFgrYjFFYzNxSWoxNlcyNHc4M0lpVmlRNUdvM042aU9iMUVVV2ZLa3o1YWpicFhONmlLTE1reXBDZEJVSzhvbmpxTTlSczFtYzB1RE5iblJhM01reFZjM3FJcGNsY21pYzNxSW8wK1hLcU5Zbnk0MVc1dlVSemlwQ2tWR2JJcmMrYzNBaHZWbW9QTFRVNTZUcDFiTjEvb1BRdFYvd0FGcWVaSnJScFUyTjh6QklXN3MrcytKTTNVSVNhRk5na05rR1hGSjJNcGZ2emZxTXltVlBWYnR6V1lSdDdNaFAxT2ZTUE05dXF0dG01UnBVTnlqS3p5cWJ3Vm9XeElVYmlGL0JqeHBjZ2tRbTkrb29TU0d1d2srNVhwcGttdHlZU1RIRmM1NmoyeERiaGJaenprcW4vM1BTcWNVaUJLMzFNSmFkZzBPN0t0MldZWGpmZmJOYktWbjZGaFBGbE55a2xWVlNVTzE1Z3VKdEs1RmJpVTZNdHgwaDhXNlc5dVdJZ2tqT2V5bmRqQ3VmVmVMN29qODFoa2hxbmNJMHpvN1RoYkxPSWJVVkY5NWllcDRKcWZVOHBSS3JVLzRLQmVJck5NUXJMZkVVSDVIdzVKYlUyT2FvN0VtT3VsK2tiRXVuTk5SWThKMlNLQmhocGJMeWpSQ2lOamdzaGNDT1licHBPcmIzSFUvcmdWTXY4QVJkTzZweXN4dUtUNkdXSW9yS01WWStKNmg5Ym5LbkZPSnA3Y21MSmhuamV2Qit2ZlBmSXlNUHN0eUdHVzBjS1hMY1pTeFVJN3d3WTBTVTZINnRYQVpXK3lUTWwyU2lSRlJEZmRpb3A1aWp4MGs4MnJLRU9FdVptMG4zSzFJVWFJbFBrTDVWdzkydHBTazZxdDlMdEVsUWt2MVltOStaVVNTN1E0bjRzMmI2SElQcWVHMnRmcEtsdWxYQlQxZjJDZUxKdWRpUEthckZ5YzlnbWwwOG1rR3d3NUxucElrb1Q4UzFSbEVyaFN5SDk0Z1N6TWtrMjgzV1dGclNtb2trb2FDZmxadDV0aXhhNm1QMHRKYjROU3A3bkdvSmE1N25ydEY5eUhxT3R1akRaNXd6Z2JSTC8xZ1dnMjNhQ3JHMEUvMlFiTi9kaXJQR3hRQkZnU3BpREl5VlEzVGJydTBuMWpaNWVZdzJjOTQyaDkrQlFKcHBvOFNVelhLNjhibGNRaFRqMHFESWgyZ3ZjZWtXTFV3a0wvQUlycWVlV2oxRCsrbDk1QnBjV2x4VHJxMHFmZlVuanY4Yml1OE5LbElXbDU1QzB1T0ljNGpuR1c0dHhWbjJkMVpsZzRjWjJUSmJxRWhpV1pVbVlrcWFuZldkWmFrcXFqaTZmNnVMSXIwdzZaSVFON3NWaUNTRkZqdWN6emFUN2owTGVlY1Q2aVJ4ZU85dStxbEJicnJvTjEwMHJkZGNCdk9xYjlYTDZjNWJVZUVpV3dwY1Z6NGFuQzRpWXN3djhBSmltNGhVbVFiOUVPRGg4SzN0eXhBaUVKcmlUZjI4Vno2cmtaa3JqdmNZM1hUYTlWSjN2VXlCeDMrTWh4eHRhWG5rRWh4eHRXK3NuVnJXNHU4RlgrRzRsbEVqZW1rZ25GR3lsWnJSVTA5Mm1aQlZseDdnQnBEanJFZUFhMHRKd0ZGTWVkM2xwUGp0Yi9BS21Qd2M0U1ZRWEpxRGUvd0JWUFl1a25ua3RJZGRhSEZkNFNuSEhBYnJwaGJqamhxZWRXaExqaUVkRU5XSktUd04xQ3diS3VIMzlKSWtMWmxuTmpyQlNpTlRUeXBKeDBQRWxwNXBkTW14Zlh0bFRXTjNsc0lMcGhiaEpOREtqTnlSQWEzV0NLMHIzT3lYSEVFVGppV2preURiS1Era3VJdmhtODhiUHFaQkRpT2NFbkhDYTR6dkJTODZsdER6clplUkdWdXpaUk1lcWh2UjBqS3N2TjhhSXBSUFFJcmY4QW54MlNqeFBCY1BkNzUzc0JpcHg1RTRuRjd6R055V25NWjJLWHJvTEJOUlNMclRvTVpNNzdRczhIYW5aaC9pN05hRiszamFMN29TZndzYk9meDdScXRWRWJsZXBDdDNhT2Y3S05uZnV5MDJnOWlGQTlnbSs4MHY4QUlOcGZyRkJjM0t5Tm5mZDYvd0MraGo3SVZjakxhS083d0owK09kWHAvd0RUMDBVK091TFNiRUQxVG9ydWprcjQ1SStPU1Bqa2o0NUkrT1NQamtyNDVLK09TUGprajQ1SytPU1Bqa2o0NUkrT1NQamtyNDVLK09TUGliVEhtYVdzZ3k4dVBLbFZaTXFpOHRhZGtGRnFzV2N6V0owZHh5ZERmaTFKNW1UVXJlU0lZQ1VpTXh4WDRySEFoV2RwRHprdmtqNDVJK09TUGprajQ1SStPU3Zqa3I0NUsrT1N2amtqNDVLK09TUGprajQ1SStPU1Bqa3I0NUcrRjA5K0xFUFF2b0NtbTFPdE1JWVNjWWxWUDBKOFFvckc1YmRKVGxpSUhwQlk0VWI5ajBxRUpjdytSeUJ5UjhjbGZISlh4eVY4Y2xmSEpYeHlOOGNqZkhKSHh5VjhjbGZISlh4eVI4Y2pmSEpIeHlTUUdxVzh3cVFUNHhIM1dGSlZDU3ZKenl6U3BEM0FxN2Exem40TVhJeDIzZDRieThjVEJFbzhQb2JFNU9LWFRvVE9MVEdUa1Uza3I0NUsrT1NQamtiNDVJK09TdmprajQ1SStPU1Bqa2o0NUkrT1N2amtqNDVJK09TdmprcjQ1SytFVWlRaHgxSzBxUytrYnl1R1c5dVZhS2wyRys2cmlwMzByaE5Pb2x4b3pzdE1aRFVadmZQZnlrRXBJM2s1a01FdW53b3h2UzhZU1ZuYU84NUw1SStPU3Zqa3I0NUsrT1N2amtyNDVLK09TdmprejQ1TStPVFBEa2o0NUkrT1N2amt6NDVLK0Nvc2dqa2t0cHFQbFVqNFZXa3NHMVY2VTB2MVFMSkd0eEpJNW5IZUtuenBGU24wWmZwOXBVNTMyUDQ1N203RWpSaW1WdTJSa1pPMlRCNnAwQm4wYld4djdleWNuaDFjenZ0SjkwSGFwSmVwamJianIxTWgraXB1MEt2OW95VzlMcnBZcjhKVzdWNTNzbzJjKzd5SytmOEFvUlFEL3dCRE85NnBudjhBdEo5WWhPY0tyRFo3M2V2KytCRzBLME0wNnJxblQ2OUNOYUJBcURzR1F3KzFKalhJSHFXZzhaSGkzZTVEd0NIZ3RRV3A2bG90Q1hHWjhWVWFhdjZjQkMxdE9zMU9TeTFMcXZxYVhIbFVzb0UvbGhJc2tyRVFiUnhYS1hEU2xGc0FyZCtzdWdnWS9XeWtrdHVTeTZ4TDNYTUh4Y0d0Wkh2bG5KZEJxSkliVHVwQkR0aUZITjE3UWlCNmViWXRpNWFBOUxucDRQUXRNQ1Exd25Vc3VwZTNjRjMzcEc0NUZuMGVTNDdIZ09rOFJaTWozaVVmRGFwYnRSUlBxRDh5bzFqbWtBcFI3cnRRbUViOHB0dExiUmFBOU9qeVkvVWg0djRzV3VMVEdjajZVUjJ5UStrakl6SWxJZWErTkt0MStsd2VJd1JFU1UveW1wQnArSFBiZS84QTJPOW9zU053V01qc080N2p1T3d5TURJMXQ0djRJL2lQUXRiUHRjUnAxa2lmUkhhYVdrdXkzaWFiNDZYQjN3WDB5L1Y1V3A5cDl0dUxIbEtpd0YxSXpJaVpJK0RKWmxQejJXVU1SaG5veGI5VWd6dGdZdFZvdnJLQTI0NHpJbzliYXFDREcrU1ZiU2ZkQnltUzI0QmRqbzh4VXFtMXhXYS9CTGVyTzBLZjlvZzkxMmQ3SU5uZnV4WHZZUlFmWXB2dlZOOSsyaitzS1NhRmpaNzNldjhBdnR0bi9mQ0xJcTlJNEJpblQxd1pwR1NrV0xVd1E4bGJJeU0zd0MxNlQwSUhxV2dxTUJNMksrMnB1WGJBUHNuY014d3p6d2U1bzNDTEJvd0VKVXRkTXArK2dpSWtndEFZL1crZWd0QWQvSDZndERFcU1VbGg5dDF0M2lrUUl5TThFT0dXVEpaRGZQZTN5Q2M0SWdRMEtJd2NsU0NKS1FXaDZGcWVvMEJncmwxZnFXaDZGb0hVRTYyZVczdmlVZTVncHNuZ3ltYXJIZHFUQjhSUmt2aVlHK3k0UFJyTmJNZVNHNHlHVW9VYlRNVmcwZEIyOEF0YmVMWXNSVy9Zd1ZzalVTNDI2a21uQ2JVa2FpYXk3NjQyRE9yc3RvWmo5bGw0dWpIRmJaeTdiQTdqdU80d01BenQ0S3hrTURBTUpCanlNZ2creGthakhhdEsrTWp3RzFrNnh1LzNFbVMwV1R3akc1dmw2eUw2cHRGajZUT3hmVDVHTDk3VjZGNlBhQWpOS3FYdFBna1ZQMS8vQUpEMmkrNUdNN0tqWjAvOHVxSzN0b0thYVNybGZXMDRzUEszOWx4czc5Mks5N0NLRDdGTjk1cHZ2MjBmMWlvTjdsdG52ZDYvNzRHV20vUnBiUVJ5NjZ1TFVvOWZYSW5WcW5waHl4UmxtN3M5YnllaGFucm9YVG5vTytiZUw0RlRwRFU1RHJUakQ5bC9SNHNXcGtiYWtNcWNFQ2s1QkVTVVc4WkhnWjZpMTZpQjI4Q1ZHYmt4NUVWMWg5Uk5wQ0RNY1JhUnhVREtGQTIrKzhhUnZKSk84b3hHcDJRaENXMmg1SGd0UjRQWDlSbXhhMjgyTFMza3dSQ1RGUkpiY04rT1M2emxMai9FQnhXNFUybG44RGlONXRzOHRycGtaUUtDYUF6eEVud2pjSkREYWVqSFVWejFMcC9ZOUMxTys2UnBmakdnWUc1a0ZQajhBbkczSkI1eDlTZUZLSnhMTWtuaVlmM1dXekpUYldQazVHTEhvV25TV2gyL1VKQmhiQktFcVFxSVR4SmZpUnBDbzdyRTlxTyswODA4U2tLenZFWUpCaGNocHRQcUhaejBXR2hoQmFub1dwOUpBdnB4OFZqTUVkc0N2VS8xMUZ0czkrWWJSZmNnMUpiMlNHemFmOHFXcmVxdDBLM3RpQnM3OTJLNytQalo4eU9qU3pKVldwWlpyKzBmMUNxTi93RHJZMmM5M3Ivdm9ZVzM2UGZRWjFjc2JTUVRKTloyaXh5UVVMdHM5ZjhBV3gyeGJzTWRHbHNYSWdZTG9NU1lrZVd6SjJhV1FmanlJcXo3cFQ5QUlnMUhkZFZHb3NsWWkwK1BGdDQ2c2RSQTduYndXblR1cFczSW95VkNSVG4wSGh6ZjNWclR3eU9RbEtFSUlqV3VQUzNURE1KbGpvSUdQMXQ0OCtNanNQQmEyODI4WjZsSVM2VTJoTk91UHdwcUd6UWpnTnpDalRJdFFha2tlRFBPNmxLQ1dFdDlpN0ZmSXpZN2VPZzlMSG9QQjYrQml4bU1qQWZoNzVUR2FraHJlVWxjWi9nejIxb2RiM2NHU3U2ZDVRU3dzSlFsSlo2TTlPTG1DK2t3V29Nd1ZqMHZrYW1IR2tPb2ZvTGUrbWtJYkIwMU9DcGtwSWpvVzNDZmRsOGNtcHJpK1ZaTnBsdGh2UFlIOVBRZjBqSUxTNWtDSzU2YlFVMzBWVEd6djVsdEo5MEZPdXJRS0d3Yk5ITTk1ZEZpc3lxbFY2YkVqMGNSRloyRERUN3pCOHhuQ0tseWZzZVpHbGFIWEc3VUNNYTUrMGYxaVUzeE5oQnM3N3RYL2ZMVXozL2FCZzAxSUxkZGNJaU0xUW1QVFVxNUF3UU1GcjgzejFxU2xTVjBxbk9CVkJwcGhOQnBwQkVDRTJDSWlLNTlSYTJ4YkF3RDBMUWg1UFF0VHVmUjRCaFRES3pPbXdqTXFiREhvSW02aHREWmRCZkp3TVdMWHA4Rll3VnZCV3gyVkVqckNxUkRVYWFkSFFSMDJNcFNJa1pyNVd2U1hUNEhnZUN2NXRnWkRzYU8rRG8wRXdWSGFRdEVOSko0RGFRWFlzQXRQSlh4MzZ6QkhZdERPM2dlT2d0TG1SR0RqdEdQVElJZW5Sa20wRjh6RnZCZ3VnekdiVFlqVTJCTWlPd3FoczUrWlZXbXVUM3Y2Y2tqK25aQWk3UHRKY2RUbUovVHNnVXVsT1FYNThRNWRLL3AyU0lzQnhuWjMrbkpJL3B5U1A2ZGtpbnhsUktaUHBETXhaMENhUnNiUEwzMldXMkk5VXB6azgvNmRrQk1mL1MvMDdKRk1wYnNHYlVxUzlOcUg5T3lSL1Rza1JLRy9IcVQ3RFVpTTlzNDV2ZjAvTzNvRkZhaXU5T3BEVXJscG14MklHTkJteGdpdGtaR2ZtNTY4OUpBd1d2N0E5Q0htL2EzWVp2MkhZZGhrWnYySGI1SmFmSUllUVFNRlk5QzZjOXdZTG93TWRXT2dqNi9KandNOUdlZ3dXdlRnRnBjOU9sWFNSWDhYSXVqSXlNak5pc1JERjhqSXlNL05Jd2YxVm1sTjFLQlEyMXM3Y2JRVk9aVDN5MmxxNlRrMWwxelluK3BLc0tQSmRsN09iUVRaTUNsYlB6NU02azE2dEtwcUc5cGF1aDJiWEVOYkxGdEpXQ1hTNTVWR2oxcVU5RDJjUnRKVk9OdEZVcEZQUlNLM1VaZTBVT3QxRjNhaWJXNml6dFBWNjNVWW0wVlRyazFrcWxXSjhlakZ0SlZ5RDliZWMyTG9GUmt6YWYvQUZKVnhSNmpJbWJOVVd0VkNadEJXWlQwUFo3K3BhdU9mUHRiR0Z0SFZ5Y3BrNHFqUitnakI5V0xIWXREdGl4RU1qVVl1V2xpMFBUbzhmSjg5UGt0ZkozL0FGLzZubnJ4YlBSanBQUXRBWThkUGdZR0Jqb01lT2pBeGNqc2ZRV3AyT3hhNnExR0JnaGdZR0xuYnpid1I5ZjdBK2dpR1JrWk1id3lRd0NMb1BRSGkzbkEwR1JrWkdBWldMWHlYeVNJSDlOODlndUJIY3JPMTMzY3ovalpyL2pEWnViQmlKWVd5L0QydDlpMlI5ZzJzL0pLM2orbTMySEhQL0h0TWRoejZkVHFjelM0ZTBaLytvN2grbnI3L3FIS0NuYzIycDM1elZQemphSDh4a084V0RXZnh0OHYvd0NNV3Y4QWp5Z0szTmtvemUvQTJhVi9vZG0veTNhVDhSMmNtUTRqdTBlNU1vTk5jaHo2ZlRxYzFUWWZTUmd5Nk1qTnlLK0JrRVFNRmJ4LzBpc1EvYm9PeGEvdGM5TDR2Z2VjREZzWHhmQThqejh2QTdYeDhrNy9BTGRHZXJJeU1qUFJnWUdCa0hjdEQwSzJCb1hqNU9oandENjgySXpCNldJZ1ozd04wWXRucE1ybHI0ODRIa3dXaDlQajljZHNkcjVHUWYwOVcxMzNVei9qUnIvakdrVVk2cWlueHZSMGZhNzJUWkgyRGEzOGtybjQxU3FoRGhiRzFLRXkwM3M3TlhOMmUyaS9EME5iMngwUE16YUdpL24xTy9PYW4rY2JSZm1NaHJnVDYxK05TUDhBaXhyL0FJOHBpdHpZR21jUGtlekt2ZzJhL0x0cEMvOEFVYVJTRHFxOStIUTZEVW9UTGJlenMxY3lnZFJHTmJadGdZNk1qVUVROER4ZnpZOU1kdm1tUEg3ZFJEOXNnanNlblNWdkZ2Rmk2ZkFMVTlMWUdCZ1k2ZXc3RHRmUUVER2haR2VqejhrcmVlbkl5TWpOaXQySVo2anZucHlNak50MitMRmZQZTJPZ3RibGJJeU0zejBZdGdIYkJqUXNkaTF4YkhRUThhRjMzclk3WEt4RU1XMnUrNmRucWQyZlV3cGovd0FYVXlyeUtXVkhtdVQ2TnRkN0ZTYTd5dUR0QnZ5MkpkUVhNZ1ZHblBNN0JLcUMxYk43TFIxczdPN1NmaDFOYTR1d096YmUvdFhSZnoyUnhhWHRjenhhcnRkdEYrWTdRTmNMYW10ZmpTNmd0ZXpucDFzLytOSTY5M1lDblVaZFFwdXpxOTJwMDJkeTZyekt6emJaS21WWitscXFiOGlyYkpLcUMxYk5iS3gxTmJPWUlZR0JnWUdCZ3gzdGdZdjNIY1lHTCtTMU81Z3IrUEFJWUdPdkYvSS9Zd1dtUVk4ZWZCREFJckhvQ3Q0dDQ2UEZ2RnZGdkk3ZEhncjU2OVN3TUE5YkZvZlgzNk8vemNYUFVZR0JnYUtCNmcvbFpHYm1Wekk3WTZUMUxRK2c5QmdmdGpwd00yeURHTWpRSHArcGFqem5xN1hPNWFqUVpNWkdSdWgrSEdrcVRUS2NoYnJEVWhubE5ORExMVEVkNk94S1o1UlRBVERKUldxWFRtWHpJbEo1UlRPTDJJbldtcEREVU9LeXd4Qmh4blc2ZkJha3lJY1dVVWVIRWlCMm5RSDMzb0VPUTY1QWhPc2xUS2FsVHJETDdCVTZENmRtTEhqc3QwNkF5NXlpbGpsMEJMWEtLWUVSMkdJNVVtbWNiUXZtNTZmRjhXMVBveVNSeDJzcGtON3FaS0ZHVDZESkprcXgyN1h6Yjlzald4MngyeGM5QzFzZW5UcGZRYTIwTytvMHY1c1JXejBaNnZBOEZxUEdPZzdhRVBOOFhLL25xeU1rTWpOejFMWFMyQjRCNmc5YllHQmdZTWJwakI5T1Juby9ZWjZEMDhXVFl3UThlT2pUb0xYVWlQdit2NmdpN0hyMEhwZ1lHTFo3akZpMVBRZnQyR2grRHRuNVJhM3o4UmpJemZIZS9qeUQxR1JtK1JrYnd6MFpINmp4OHJGMXVvYkNwS2piVXI0VHlSR1FQR0RQZEw2VzBTRm9TMnRMaFd6WTlTN0R3QzFHUjJHUmtaQmRKNlcxdG9OYjVJeWVxbE9ZQmJRVXZNZWRDbEtCcEl3NlVsc29sUllrdTM4Z3JIWXRSbm93TWRSOUo2bFk5Sk15WEZsSVVTMnVnMDlKNi9JeDBIcVdwOUJhSG9XaDJMUXpKSlAxR0t3SGE2MFFjcWt4NU9ha1k0bFJiY2oxcVFsMUNpY015d1hSbm94WXhteDZXTFMzNmxvUEIySUhvRGRSeGdsSXFFOVNGS2ttUkpxRHFYVVZLYTJJYi9xV0Q3QTdGcjVJS0JHTTk4OWhqdU0zUFhId2xwaXlRWlhJdW5OOEFpdDVCNjNLNTZEd2VoYWc3a1ZqNml0NU1lQnA4akZ2Qm1GeWNIbFNCdUx5U1VxZExlSUVTVEdUeW5JUmsxN3BtNlRobXBwOGxkQmpIeU1EeVhTZWdLM2dhQjU4bTB5NXZwaVREbHpnM1NtR2tMZ0ozSlZJUXNVT3FPT0I1UzJaTWVSeGhVcWVod285VmZoUElVbHhvYUVQRnlLMk92QXdNVzhsMFlEenpjZGwrYzdJWEdtRWlYTWJUSXBOTTc3UDJmZmJqeGlrenB3VFR6U2FZNlNKTy9nWitSMkdTR2JaQkdEMDgrTTJNRll0UXI0Uk1yWENjWE1rU1J1STRrVmw1MWJkRnlWUnBxSWtiaWJzU250RXVvd1Q0aG5vVWhwU3VuUFdkeitrcmxvTkRIa0hqQ1BpWHZvNHUrUW5UMjRrUjFUVHNWN2VWU0VOWkRuZUZRWFZwclNrN3lFcG1SNVJmRWtZQkVEMHQ1c1ozSXdvWjdGMlRxRDdCT2g2QXJaQkhZOVBrWjZjM3hZOVU2OVg3WDdEejUrUmpveU40YnhBekVsOHpTWkt3L2ppdG83YnZ3Y013NGxXNGFTU1JjTkliYU5RWHZHZ3lUbE9VQmw3ZlFXblRnWTZmMjBPNUE5TGVMU1h5WllkZjlORHBFSmJpWDZySGFnejViOC9aNmx1Y1haNlc2MUhGR2JXNVVaU3QrVERJL1hDWEJJMHMrb3B6N0R6Y2lNZXBhL0lLeGFqQXo4Z3dRZWFKMk9yZUpiZTl4bWlVN1RXbTB0UmJLYU9aV0pOUytKMXhiZzBETXA1cFVTb2s5OHJGajB2Z2Q3WUdCaTVxSWtUNXJ2cFhIRVo0bTYxSGpxSkVXTWlMRUZmZkQzd2htT3RLR1drc3huKzBTYXMrYVE2NHBwM2VKU2JZdm01VzgySTc0dG14Z3RETWlMSnJCSDJJT0pOYk1oQ3VKdVBFbC80M0pyc1pxR2hlWmxGb3lvaWhxVHlsd2cyNGx4cStCZ1lzWTgrUW0yZ1BUSTFQeDBHUUlyZUJtK1FYMVo3Z3o2VTlKL1VtMmJsWXRlNWpGc1pCNjNPNVd5TjRid3oweVg5MFpYeFcwb0RhVlAwcUxKYVNFVkdLb0lueGx0Y2VPNmhUaEhGUXh2QlJMM2pJaWMzVHlySEIvZHRXODEzejArUjR0NUdneU5iSG9DdGtFNmxicnhHOVY2dC9mbnZwbmNFb2M1U3lpek1zOFpvVldRY3lWQ2hsQWdKWk16YWFKcEdlMitqTDhWTGdiYmNpTzNMUVorV1FQcDhlUTY1d21IczhXSXlwNTlwQ3VEd3h3d2UrUjFXWGdidmNqM2pqVWJJS253eUp5bHgxQmpmU1hWMzZjZkl5UEdCSWhwa3g1WHFLWFZVRW96WlNsYzZqTjhTUUZLSkRjaC9qVkdJZ2x6YVN3ZVJMUEZOTlRhcW92ZDQ5Qm1ud1MxdDV2bTVsMEVmUmdaSGtLWHhIZUlrd2xSQXJWRGhvRHFkOXVZeS93QUNUQlg2ZWx3RGQyaExTeGtScFF5NDA0UldNeDNCSGZHUmkrZ3piQXhiTjU2MXMwdm1jNGMwbkRtazRjMG5EbWs0Y3ptam1VMGMwbkRtazRjeW1qbWMwY3ptam1rNGN6bWptVTBjeW1qbVUwY3ltam1jNFV0OTJSQTgrUWYxRnFkekhnZU5CcURVUkFscHdha2plU045STMwRGZRTXBHOGtiNlJrWlFRMzBqZVNONUkza2plU041SWNlU2hzOTVUWnJTU3ZpS1E0NjZtY2lGdnQ4dGhJQzZlMUlRY1dQeFlpbXlRWGNHa0xIY3pQQ1JuL0VpSHVkWi9NN0VNMmVVcEVXQ25EQ1cwbTVJUDhBOTZSL0NNNEt0MVUya1VTbWVuakhnd1JFUkhwSVA0bHVOYjBlVzQycEMwdXRkR1FSV3pjdGZKZ3JkaDQ2U0JGaTFWbEljYzNVdVNZemFJMEdKeFRnMjRxZldWRGU5WVRaaWtzRnpPNjBiM1ZrWnY1dGtadjNCYUR0WXJiVVk1dzAyNmw5cy84QU1vL3NncWp4R1V0cENJRGFlRlIyR2laaUNxdThPa1RDUGpRVytKVzU5T1ZBZmpQY2VIWStqQXhmSFR2REl6WWhQbEZHaHZTRmxLNXE3dnNUM3VJelBSdnBjU29PUjIzVmY0a0NjNDAzTnA1UTVNQmlsUnVEQnZnT0dhV1lyaTFnaCt3TDZqR1JrWjZjalBmZXZpMVQ5bS82ZEc5cXNSZzliRU1nckhwNU1GclZQZmYrakdSaU5ndU9oUnFaSWlPbnNMUkRwZk41UkdjbVU0MVRKejB5Zk9mYmZseGxzSmVRZG5zYmkxNExzVDdhazhOby93Qzc0cy9VcHFadk01dzVwT0hNNXc1bk5ITTVvNW5PSE01bzVuT0hOSnc1cE9ITkp3NXBPSE5KdzVuT0hNcG81bE5ITXB3YWtQdVRrRVNXMi9ybG51N2ROZDR3cWM1RVNEUkliaytvYUZaOTdoTnVxU0hxdkhTdE01azFVOTN0ZkFtcVV6U3VhVGh6U2VPWnpoek9jT1p6aHpPY09aemh6U2VPYVR4elNlT1p6aHpTY09aemh6T2NPWnpoek9jT1p6aEJsejVOUkV0OVRVSlRoNHA4WXpkSTAxR3FqSkZaSy84QTNlZm4xMFJwazB0Tk10MUhvLzhBdFp5UytVbGN5UVRYTXBvNWxOSE01dzVuT0hNNXc1cE9ITkp3NWxOSE01dzVuT0hNNW81bk9ITTV3NW5PSE01dzVsT0NxbTdEVXJhV25raWJNVk9xbnFGbkZZK3VFM3c2UzQ0bHBqMUxqcjBwU1pVOG5DZHJvVW9rbFBmYWxURk8rb2VqL3dCamFCeHRMckZPekduWnRMZWRiZTlVK0hLaE1TL3pPY09aVFJ6S2FPWlRSek9jT1p6aHpPY09aVFJ6S2FPWlRSekthT1pUUnpLYU9aVFFWU25HYzZTcFNqajVpeDBvUUlraExGTmlOSmtiYWNGb3dUVGlRbUZJT2UwNUdqVk01NVRLc242ZWw5RzdKL1l5R0JwMGxvZjAzOFg4Q3FleWY5T2orMldJSHJjcm5iTnFuNzUwK21QbEhMLzdMTVhqTUxpcVFhNFNFdkZDelVmU24wa1dWRVJreHZKUWpEbkdVaEVtZFY1UnlhdEVqRTlOcis0MnhEWk9tN01zbkZKcGpkWURUMlZHK25kVzl2b1U1dU41U3BTRnBWTFQ4WWFQZWo1dEo5eDZWdE9Ob1hGZmFDWXp5ME5zT3VrcU04bEpSWDFQY05mcCtpQTN4S25GUGYyaERaNE9yZkROWVA4QXhWcjNHcFN1YWJTdzJrUnFma1p0SmMzM0owMWNxWFRvQ1dUS0NnMi9TbkRmWmNKYmU2T3c4VkQyWHBTazF1cGpQS21tMHRLRngzbTBsRmZNSEdmSmZCZDlJdHRiU3VpaU5ic0p4emRFNTVFeCtNeHhKYzJRVEtLZkRSQXBsVnJaUUk5UWtMUnRFUjVSSmY0RzNsVFNsTGpVMUtCRm5iOVc2Ri9jNHRJa0lLZXFRZzJ1aFRUaUdWeFgyMEpqdkxDR0hYQ1hHZVFnb3I2cGZEWDZmb1liNGtpZXM4dW95ZTZGdUo5TENiTjJRWFl0b0pQRGdPeVZSWDRHN0pXL3ZzMXc2aVJSSmMvS1hwUktiU2F2VWZ5TXhIZVBTNTZlRFg3Vk53bTMvVXRoeFc4OWREVGppRVIzbkdpWmNOZnAzaWtwaHlGSk5wd21UaXZwbTlFWXY4aDFLbmFncmZiWENNa3lwZkFkS2lrcGRMTlc2ajR6RWRaOFp5UEhmU3pBWWlQZUJuQlhVUktRajZPdE9oNldJaDRCVzhDcCt6ZjlPamUyZVFXaDY5T1JnWUdCZ1ZQM3pwaXA0dEFXWkc3Qyt3ZVBpMHIvQVAwcWlMaVBGMjZJeFpxQ3Mrb1FaY1ZMSnJRMXVSbVdmNDRMcE0xdEViMVcwOVU5amE5Sm5qb1FscHpqTkU0dHB2aXFXd2FsSllMKzRST09La2tlK0dlMFFFSlB1UFNiWlB4Sml0OWlNdmh4V215YmtSZnRHaVVtb09KM0tKMFV3c0hBVi90eWNIRitDc0VYSUkvMjlUa2NDblVtTHdxQ2JEeWdhSDBBbmw1NHhtbXF5RFppVWR2QlJHaWJZQmx2Sno2T2VEMVBTbyt5OU1YM1JwUC9BTEEvOWs1aFNuKzBWUHRhbTE4aG4vYzlFVWlabzlTbDRMZE5UKzhtbjA2aHdsbTdVSnpUZ2NqTUdsNkUxSXA4RGZUU2EzOE5jbEVVcWpsdllKL2hPdHVFb3J2ZnorUks5MDZlRjZpaHpWYjhlS2U2aEtTSnh2N2RKTFRWM2tjS21kRkppSmZSUHBMaEJiU0Zud250MUxhMUhRSWU5TEZZWHhkcVdJN2s1K2pLVDZkYkxiNXpIV1k0UGZjZHd0SnVKVUlTeVRVZG5YVDVWVlVaYVIzWkZhL202YVZ1aU9uaFV4djcxV0haeC9kY1BmZStOVlg2STVZanY1T0hIUTI2RW9jVTR1bHR0MHFPUklpT3FJb2hFMmw1aHZodGtDN3Z2VEdXUk9yaFIybnFwTG50UUsvTmRFZXBNdXlreUVLVnZqNlZGcG14NjlPQml4RURLeGFneFUvWnYrblJmYXoxTG94Yk5pSWViMVQzM3Bia3ZOQXBEeEdjcDR4eFhOd3BFaVFwY2g1VGFaYjZVcVVhMTNpZTR1Rmw3LzR2cFU4NVY1QnBZam51TXVIOEZKcURhV0hFbktZWVFtSkZRY1YxaDFoSlJzY0V2cmhsdXRna091RGRhU2JmeEUzL0FCRElrZTRkS1o1b2I5WVNoNnNzTlR6YmE5VWhMVWlaeGljbU5QSjgzZ25pRlFTeWpmUUhuVzkyUTRxWFdHbXpLSlhTM3FQVFhrdlF0OVJEaXFCcWJVRnBiSVZ0WGFsZHFTMzJZSzBoa240a2ZlS0NldjZWSDJYcGFYdzVYclhXVXBrdDhCeVdweEM1eVhYUFc5dldacUR6N1R5Ym83dnV5djhBWEt5NC9FWlNsQjhXcjFwbzBjTTEwNTZWeXFHRlVjUVlEa1dwYlJJVnc0Um03UVpTZHlUcWRLZk4yaGtmYTBneTVsNUVyM1RwYW5tMGoxaGJoVENTNHpOVTNHVktSd3BFdmpvWE5iZFFlTis5RjlwRXVteFpnL3A5MUMwVUhlVTIyaHBrVlJKbnRIRms4RmFONVZSbE92NzhaQ0RmUXJnTXZQb1NFcjNndE82ZE9mNFcxbFV5VkxRVzZ5SzMvUDB0UDhKaHlvS1c4cVUyRXpqVFBLVzJFVGpTeXhNNEtGbTBmUkdKYW9VcEhHYmlSTWh1TTBtVy93RHhvN0prdXBRekczVnpCT2sram9iMVNueVRoVkY1cEp0S2xSMm9qYmJUNXgxRTZ6aGNCRWhtSFNWdXJYdTkvd0JRblFZRzc4MnFGL3BlaUJTZlVSK1J4Qk5ZVEdxZGlJelZFb3Z3dHhZN1JCeUpHZUtaUmpRbm9vdnRlTEhZaXNaMkloNDc0N2tQMVBTcCs5aW5vYjlNa29TelRHYTQvcG1TZlpqcGRvcVVrbWxlbVkvcWFKRlFTaVppTkJNQmsyWHlRVlk0VVNURzlOR2ZXNm1IdzZpaHYwVWI3OVgzSnIvdFFVWkVoZkhsTkpaWENQZlM0YlJKRUNya3NWRmgxQ3VJVW1sTnlQUnNJa015STZ0NzFhbElTNWgxYjVKd1RaZjMwL1JhUjdnR0crTE5sUm1TcjdUTFI3WVJpUzVXSThOcExVYUkydlpkcUloN1pweGhnamFpTm5zblR2VGVzS0l4SUMyR0pVTjVtT3RCc3htSTU2cWNOcWcwcHJnMElTM2VIQ29qWnV2YjVpYzJUckZHWHVMSXhrWkgvd0FxMDEvY3BUcGN2YVBNWXJFQzBQWDlhaDdMYms2dHc2ZDI1VWtMcHkyNnRJak95TnBVVXhsMmJ5dmVjVFRRdW5yUldKY1k0azV1bGI3TE5NMzJDcFR2cGtVazFOSStHVzk4UzR6UEdlblBFN0lwOGIwTUJ4bExwU1lEaVEyYmpTWDVNdFV1STg2bDZydHVTcUJRbmsrc3FyUnBmUVo0b3ozRHFES3Nvc2hSdmJVV2xlNlhpc3Q4b2FaWlRDWERZL3Frb2tjOXF5S011cXlHV1NvdE9LTjY4b3pFbERxSXJrQ1ZFYWNyVlliWlF1MU5rcFlpazgwWkV0QjlOWXB6cnpyckJFNlRSa2FXWFZtekRxZTYzVGEyazF4cThoTWhMcHZHajRJeXp6TGI0MGN3V3RiKzR1MTNrdXhtRk9yWlo5VVVkaElKRU55bkppTi8walR2VGVzS0l4SURpSWpsUFZGamM2cWJUYUc3VXp2Q1dnbEVrc0UwV1hYRi93Q1NoOUpwZFR2Q01qQ2h0RDhkSGVnc3RuR2ZiWW1OVnFjMm9uOHo0anJLSkVwRFc0MjI0NUlveVZGUlR6bkl3US9XMmU5ek1FZGpQQUsyUVIycW5zbG0yM0hYSVZISkIycTN2MXFQREltdW1zUXlRdTlHOXR5UEdMbll0UWYxQWdYMUdLbjcySWNsdGxCMU5sYjUxUnJlNWhEV3R1cVJXVXFkWVV0VldaNGttb1Izb3NXZEhSQ1RWQ0kzVm9jcVQ4NklwU3FveWxTNThOU3A3OGVTOHlyY2xMU3BjbEVWMXhTMTdrWDBzaExSa1pBMzFMTXpNR3NVeXI4TTZoQTRSclZ3V3U3N2JtQ3JSSWROS0VZYTdZN205WWhKOXhGSGIzNjBuaHlHRVIzVWJXTnR5bTV5bkNOYlhDWmNhWDZPbnU2bzRMY21EQzQxWFV0OU8wS3NRNFQ1Y0ZMYmhxVXN5TjVobjFBYXg2VlIvQlcxbjZhRXlURU54MURTWGZpWWtJOVB0TXc3eFlsa3ZJS1JVSTI4MzhWUHFGUG5wVTJUcUE1UFpiRFZRVkluZVBQaW8reTJVaFU2S2YwdmZaN205V0RiVno2R3BwVzBXOS9tU3ZZWTdNcm5sWWJVSVMxTnd0NDF3djhBOVA4QS9kdmZlbW5paDl6MGNDbHdWeFZCYVNXMm5qdE9jWjNmNHFQVTd4SkdUV054eUZXSnlFenFlUkdUaEdlWU0wcEVjakl5bXpHNDdGTGE0TVVZRXIzUzhWTHgwUW5VTlJPRWxtcXZOTXlIUC8wTGFjZnBNS0diOVhkVSttdnlrK25vc3lXVVNYV0ZJOUxadHpoc3VLYjNPT2dRYXk2eTRSa2FicVFoWTlOSEJxUTJmRmJCT0lNY1ZBcWNCTHpTMDRZaS9GSVVYY2Z0V3Y1N3RmZHljdm1oSnlBei9jcURwTittTGdsS2dRK1BWVkxmVHRETEwwOUJXZjhBdDZwMmhXcHE4VFZmeUJyc0pVNlFkZmpWUlp0c3o0andVdktrUG9JcXk2L01xYlpacHNXbnJlcWJ6YmFxcWluY0lMak04TmhDekp0dVE2Y2RuZ1F0N3ZxTURVWXRqdmN5QkYxRmFxZXlpT2tsejIybTJrWHEzdndRazF2SVNTR1JVS2w2UWMzbmI4Q2VVeHNTV3VQQXZSdmJjZGk2ODJ5TTlpR1JVL2ZQK2pHZjNuNUVxbzh6ZmNub296Y3hTU0o2TTRvdUM4YXFjM2psKzhoMXRDWmtHcFNJYmowUkJzdG9iZER6WnJxcEVSVy9kZ2p4ZVQ3ai93QkNNNXczNC8ybkVRc2xmNU8yRWwxYUsrNDhmQ2lxa3N1VnBqTUdsU3Q2bm9kUXRRZU16ZVpmSjRTcWNoMGxVQnduRVVpV1lqME5sQVlZNGNzRmFwZXpXNXJLNEROU2ZaanRWRjl0UE5KSm0zVTMyMm1aenJFMXVvdk5zb3FMNkY4ems3N2t0eDJuODBjNERWU2ZhYlJOZVFTS3BKUkdFUlRQS284UlRrM3doUWxyVW1JVXBabEJxSkxFWmFVMXUxZmpwNDFKZUpjV1pFL3kyMit6RGkySEZWUlpNeFNrT0JLQ2JiR1JLOTAvNkJwTmJiTUpsNXlkQzlMRlFlSHFRNGJsQkVpb3hZcWxWOWhLazErRW8yNmpDZE0wSWNIQlFPQWpCTnB6Tm1OUjQwbGU3VGFKSDQwNC9xdFd2dVArZzB2aHlFT0U2TWQzMThLbFNZYVVxUTJ5VTJhZitaczRwdCtocForS3BVV1lpcE10dU53bkRWQ2tRV2lRaENIcE5HWlRDam9ob1daUUl2QkIvVFlqQmtDTWZ0YkkzdW45dWlxZXlDTVpGVWZWeFFVbU9wZHF0NzhLZVdhMWFvbm10aWpuaXQya0Z1ejdVWDJ2eCtoYWRKSGJBeGJBWEJpdXU4dGdqbDBFY3Znamw4SWN1aERsMEljdGhncVhDQjA2Q0Rwc0lpNVpDM1NwMExlNWJDQlUyQ09XUVJ5eUNPV1FROUNaYVlmTjZNODlJZWtxQ2xKYkNPSVlTYWlVU25qV2NWYUJqS0tYTk9KTlcyVEZXeHhxdjQvVXY3aTlCaTJRNVIrSkk1SU9TRGtnNUlPU0RrZzVHT1JEa1E1RU9TRGtnNUtPU0RrZzVHT1NoYlp0dHh6L0FNbUorV3pvUnlRMHd0Qk1zeVhwTTFCT0pvcG53eVZoWllORWxrYnZacVErbEtIWFZyTG9LMGxuMUVIa1k1R09SamtRNUVPUkRrUTVFT1Jqa1hia1E1RU9SamtZNUdPUmprWWkwNVVSVmxkZys2MjNGbE1SM29WTi9scHkwdTFQT0J1S1VGc1IzR0RhZnAxWVdTSlVSeGsyMys0UW5BaHh1RTFkeWpjV1R5SWNpSEpCeUljakhJaHlNY2pISWh5UWNrSEl4eU1jaUhJeHlNSm94cFdtbXZybFM5NDZRMzNkb3ZhaHo1Qng2VElkVXlDZGYzdUs0a2NWQ2t0UExiTk5RbVpLcHpjS25TRFFxVXlrT0tWS2wwcUY2T0ZudmFkQjlXNXlRY2pISXh5UWNqSEpCeU1jakhKTy9KTy9JeHlRY2tISkJ5VWNrSEpSNlZURU1oUDluVHV5RU90cmJOeGhmQm9abkZsaDF3eVVTdUlsVUdscmJLbDhPVlVUVkdwME9uTE50RGFHN0sxdVJneDVzZHpQc1IyODJNWkZVOWt2VC9lclZiMzRVMzN5MVE5N0ZIOTh0TDkxdFJmYXowTFE3bjA1R1JrWkdUNnNBZ1poSmR6MUw2VFNEN0t4a2ZFTjR4dlp0SmE0SmxFYVczNmRHNnpUNDVxUlRtU2FialExUmxNSVhEUlU1RU9YTjlHOHpTR0V2VDNwRFR6ckpyYmJTNjVsRHhtbHBHNmkyZmsrTGVPZ2hwWjBzdHVsd1pqNmZUN1I3N2kwcWEveUV1bXBNbFdCUnlQMVBobjdNS2p0ck1vaWN0dHBRUUlaNmNqTjgvSzc5QzA0VUQrbHhUaVk3cmpiUWRucmRqME5sVWFtbytHODZFbWJFZ1A4R1pKaUh1TlFIVnVNUlVNR01kZ1JXeU5iZUFWKzVYL2ErUVJnMC9IV0dSSC9BSjZSMm9sV1FhNkRKK0tidktiQnFVT0c1bEVPVXNlaG1FRFltSkhCbWhpaTFSNWRNb3FJUnFWbnEwR1FWdk50QVFQUzNtNTkwdUkzVnkzRWNHVERTY3FTMDR5NUZTU3lVOHB0VUtZVXFqZGpTLzhBMkVNcFBnZW43R1JHWkVSRlU2aDZGbUU2ODVHdGdib3dDMC9mcE1nUlp0KzQ4bmFwK3pYcC92VnF0NzhLYjc1YW9lOWlqKytXbCs2Mm92dGZWajVXQmkrYmwvR0VhRHdSNE8yQ0JwQzBKY2FlYVcyNFI3emEwbHUvNHFqTmh2aHFmZWFlV3RpVWxOSUpML3B5UkpaWWFaSGp2dk1zZkVEK2NmMDlQbkE4eVd5YkM0NU9SUFVTS2UrM09TNDBjbzl5VEtVNjVIamxHaU5NbXRZVXRDQWNwSUtRNG9Fc3NKeVpZdGp2a2ViK0RzVnNqSXo4bFNkNUhHNGJwWU12M0NtbWxraEJFVml0SmhzeTIya3Z0czd2OW9zRVBPbzg1c1ZqMEw2Y0FpdG9ldHZQN2Z1UVBRdFAyRWxyaXhkd21wVkk5b1VnbHRTNDV0cVduNGkzNDhxa2xGVlJuSDBOdExtU2wxQ2puSjVhWmtsS3FnMXhkNVJvQkZiSXlOUm0yUjV3TzQwNk1ESGJVc2R0UmdhaHhzbHBsUmlkU2FwRGJpNDV2UTB4K3l5YnhSRjdrcktkM0kzak84bVMxRWlza1UxOGtwUTFrWjZORDgySXVyeUMxRzZLbVgra3ZUL2VyVmIzNFUzM3kxUTk3Rkg5OHRMOTF0UmZhOGplRzhNOU9CdWpkR0JnWUw1WC93QXl3RS9XTWhXbVRHOFkzeHZFRFNIR2tQTlBSbjJCdlpDblRVa3phNHFWTklYdzB2czhCckdkeEhjdzIycHhUYktVRU1qSXlNanNNREhTUXlNMjhYS3g2NTdEZHlsY2RjUXo0TWhsMmhzR3NxR3MxczA1bGxzb3lDQkVTVXVTVkdNQlVwbEE0MGwwUVlUbThQQmEzSVlCRmZGL055UHBJN1lEaktIa1B0UFEza1RYY3BxTVkxK3BZV25kR0xGYklTVzdiQXhZaDV2NExxTWVDSDdHTWpGc2pzb1ZxbnJKeWlURXFNVmxqcytnME80L3R3VlRJNzZLbkk0YXA2aHpLVWI2WTc4bVl3dzJ3ell0RDBJR0NHb3daREk3REk3bU1kR2UrVEdSa3hrWkdSa0xRVGlaRVVsS2ZiVmxoNXRFRlh3aWtKSTVRM1VqZExoSjdsTHFMY1VSb0VsK1dsSklSZ3g1dDVLNWRIaXhsWWdrR1lJVlQyUzlQOTZ0VnZmaFRmZkxWRDNzVWYzeTB2M1cxRjlyUFN4YWc5Q08rUmtaK1NRSThLMU1ZSXdSWUpXdmsvNDAvU0QxQ1RNR25JSThCNkd3OGJsS2RTbzJKRFpiMlVFZWJJYWRXcHFLZ2k3RVdiWUdMWXZrWStSbTVGZndNQXJQUVVyVndaTGFmVXR0aEMwdUlXNjIybVZWb2lTU2RRa2h1a3VxTm1uUjJpYWFiU3JyTFRyd01kSGl4NlhMVXlKU1pGSlljVTdCbnh3ZVJ4R2lDSkw1RDFyKzhtYkpNTm5OV1NVZkFNOThqSUsrTy9tM214M3lOYkhiQTdrTTlFbWh0cmZhZXFEQ0toVmVLdzlJYldXK2tiendhS2M2R2FKTGVFU25SNGFkMGsyeDJCYUg5Tml0bTJPb3pIbnI4R1haNkMyNHBkTmNiQnhGR2RPSW01MW5KRFRRS05WSkxrYUN4R1RmeVo5UDZscGJ3V21POXZIZ3RmT2NKcWZzMTZmNzFhcmUvQ20rK1dxSHZZby92bHBmdXRxTDdXZWxpMUJrQ0t4OUJIYzlTME1Zc1doNmpVekxBOEdXUVNRcjZFbjJQNmhvUmFENmlJc0dXcGdzWitFZ2R0QnFNREk3akF4Ykl3TVcxR1BrRmJJell3WFNhRXFDNEVWeEowQ203N1ZPaU1qZ29CSndQQ2RQUFQ0OFd4Zkl5TWpJN0dNV0xXeDZYL2J3QzBVeTBvL1J4akJRb3dUR1lTTjFJeFl3VnNkR1JxTkM4ZVFaOUpmVDVQVHhrRVBOeTFDMjIzRXFwc0JRS21RRWhNV09rSlNTU3NldHkwOEY5SmFuMDVHZWpCakE4angwWXVXcG9RWUpobkp0SkhDUVpJYWFidDRNWjZzM3pjOUU2V3piUGE5U0wvU1hwL3ZWcXQ3OEtiNzVhb2U5aWorK1dsKzYyb3Z0WThucjArZmtIcm5zUEIyeDI3OUN2b0dMRjlOaTdHTkRCQXk3K05PZ2k2VEJXeGJYNUdoRmJ6YlF4Z1o2ZDBZNlBIWG0rYmRoMkhZZGhnWkd0aTBCNlg4WjZQMUxUcC9YcUxYcU81V1BRdnB3Q0I5WmpBeDhnckZwK3cwUHBTRCtrdEw0dGkyTDRHQ0hnaXlDMXdDSWViYm9LMnBGcDQ4WTcySVpHVHZrWnVRUFVFS3A3SmVuKzlXcTN2d3B2dmxxaDcyS1A3NWFYN3JhaSsxanllb3lNMlBxTHYwN293TWpJTG9VZUJrYW9IZmU3REl5TWd3U2dhdXhGZlFySGY4QVlGcUQwSDZYMUxwSWVmSGd0QVd2enNESFQ1Nk1qdFlpR1JrYWpRYWtWajB0NDZQSmd0QVdvTXdRTzJla3RlanlNM0xRSG9YUmdZTVlCRmJJejJ6WTlNakpqSXlNakl5WXlZeUQwOERRN0dWaUI2SnRrRm9laGRHYjRHbzdnclp0a1o2Y0R1VnowR2lRUlc4NHNXZ0xRN2VLcDdKZW4rOVdxM3Z3cHZ2bHFoNzJLUDc1YVg3cmFpKzFqeWV0aXNZeDBZQ1JudmJQZXhhbm9WOTRnWlpHRHR1L0VZMUxBd01EQXdNWEx1ZXFnUVBYNUg2K0NCZ2dmUVhUK3R2UFVXZXJJejBsY3hvTURGdkg2K1JnYWd0ZklQUzNndFR1V3BnckZwbTNqOWowSDZqRmkxdGtaQmpGOFd6MFpCZ2o2UFBRZW1CZ1lHTFlHQmk1YTlhZ20yQVY4OVBqVWFGb1g2a1Z2UGpzWUs1ZlVOU0xVYW1YMWZ0K3Y2K0NINkY5UGs5UzBIN0NxZXlYcC92VnF0NzhLZDJyZHFoNzJLUDc1YVQzcVZxTDdXZC9JS3gyUDZ2MUxVRjBZK0syQjN1ZGsvVDBIb005OGp4a1pHUnFlaEVQSkE3WkdSa1p2Z0dPOWkwSGpwTDZnVnkxejFZNmp1V2x6c2VoRFU3ZWYxL1V0YkdEQmFEeGJ3V29NckZxZlNWajF2cFl3UXpjdGVrOU9uOVFWanQ0SGxJUFQ1WG5QZXhkQjZwdm41WG55ZjFHQ094Z2dXdCs5djNNd1EwR1IrdHRCa2Zya2FqeGVwK3gzcC92VnF0NzhHRjhPYmFzUmxJbmlpUjFjWUtVU0dqUGVYYWpIL3JQUHlEMS9RdFFRNzczVG0vbnA4ZVI0SGp4aTZkRDE4RFF4anB4MFpHUmdHQ0I2Z3IrQVd2a2FFQzB0a1o2RHVmeVRINmVMK1BGdlBqOVM2aXRteGFuMFlzWThXSzU2V0xROVM2ajB2NUJhZWJIcDBGcWVsc2RybVhSbXhadG92d1BIbE9tbnp2M0dCdlhMNnZBSTdHZlRnK3ZGaTB2VlBaTDAvM3ExVzkrdFRwSHFLVUZKU3RITElPK1JFbElxOGpoVXk5SDlzOCtBWFRrN1o3REpoUFQzdVhWNDhqeUMwODMzU0c1WXZxTVlHT3ZOdkZ5TUhvV3BndFI1dHFQQkR6WXRPck5zRFMyT3NnZXA2ZUFZSUdDQjJ5REJEOXVqeDBhZzlMRjEvcVduaytncjU2RDA4RU1XeUNIa0ZxTWRKNkVQT2V3eGNpN2ViR1YxRE5zOWhvbnB3TURIU1Z2MkI2QXRmQ2JZQkF6dmpxOC90MEYwVlQyYTlQOTZ0VnZmclFaaW9jdHA1dDltOGlTMUZZbFNWeXBkNkw3WGdlY2R4NExRZ2ZZK2xJeDNHYmVMa1lQVHVPNVc4ZnFYMWFxQjlqL0FHTHVvSHFrKzVxSWdicUFUaU05ak1aR2I5N2xyZkF4YjlmSmd0TG5yY3RRVmorUmtHQytRUVBVOU1qTnZGOFhMVDlqMEk4a2RpSG55V2g2andDdGkyQVZ5MDZjV3pjaitTUTgyOERBeGM5RWc5UW5VSHFDMDhqdnZYOFhMVStqRi9BL1hwUFJJTXJKQjZscFk5TEoxNnYyL2ZvMFB3blFWVDJlN2ExTlBjMm5qbTA4T3V1UHYzWmZkWWNicmtnaTU4SEszSlVUampqcm5SUi9hOGpJeU1qSXlZeU0zN2p2Z0VNMnhmRmlLeDI4MjBNRjJMSTFJSnNzMHBCdUgwazRvSlVTcmtmUVdoMks1ajlla3JZQjYzOGRHT29qdDU4ZEphR1BHQmkvYnJMVXdSNE94YUErZ2g1OEYwSHJrR0M2TURzUXoxRWR6MTZQQUlyRnBrWkdTR1NHU0hZZGgySFlkckhxQzAvYkl6ZlB4QTdwK1RqcUsyaDU3QXpCYWpKV1BTeER2Z2hraGdoaTM3ZnVROG1XQmp0K3Y2SjFGVTlrL3dDblIvYmZQWDU2RWpIVGtadjJHQ0hZaGtFZmM5U0hnc1dQNmkwZFh1MjQ3UHJReklaa0pjY2JaWVlmYWt4dzFJYWRXaFc4Vml0NUI2bHFNZHdZL1F0ZWcramRIanBJZVMwR09nckdDNkQwTFR3V2c3NTZTTUhiOVVnOVFSMnlNalBVZjFBOUxmdGkzazc1K1NSMlBvS3g2NXRvbjVSYUhxQzB0S3IwWmxaVjJvdUJWZXFMWWo3UVIzRmV2aUJwMXQ5ZzdKMHNWODlSOUo5R2hXd1BGeU1HVjhqSkRBd1BCYXEwL1Vob2xPb25mSFQrVFF4eWFHT1RReHlhR09UUXh5YUdPVFF4eWFHT1RReHlhR09UUXh5YUdPVFF4eWFHT1RReHlhR09UUXh5YUdPVFF4Q2JTeVBJODI4VzhqUzJwa1ZzOUdvTXJaNmowTHNNanpZMTdxTlREdndmK1N6K25acjJldW1iOG1tbHkvYXNVSDdzandhVDNrWDgySWZ0WS9xUFFyYnd6MTVzZHk2OFdMV3hhQXJHUEEwTXdXZ3hiemkzNmtOVDBLMm5UZ1lJWXNRMmpXdEI4ZDhGU2F3YVgvVnhwZkhlSEhlSEhmSEhlSEhlSEhlSEhlSEhlSEhlSEhlSEhlSEhlRWRpb3lpZktiR2Y0enc0enc0enc0N3daOWJJZGtNVkdJbmp2RGp2QXFkVStVY2Q0Y2Q0Y2Q0Y1o0Y1o0TnZQY2UyZzBHblVXbm5RYWpIYmFDWXBDZmhoSVhJbE9HaVRLYkJFaVlVVlJMcHI4dVZGcUhPSkFSVzVqVmJUWXJHRVZpY3RrcXhJTlZQcThsM2FISFJJZDRNQmlmSjlkYndldGl0Z2hvTjZ4bDBaNnNqZUdTSGEyU3NtMHd2OE9zU0Z4YVJXNUtvbXpJbVNDaVV4QlM0TXNUL1VLcTBaNlEzVWdhUFViUU1OazFHRktXdDNaMFQ1Q28xTlpKK0JWUlAzbDFLQVQ2RzQzOHhqeVJEeVBHTDRIY2Q4YUR1TURkR0JMcW5Ba1FxazQvTG16a1JDUldYaVdwMVBvR0tyeHBicm5CaXhhcjZtYk9uRkVOTmFSbGwxdDFoZGEzWG1LdTA2NUtmOU5DNTJJTXIxa2N3NGZ4aVU4Nnd6VVA3ZTIwdGZDcFd6Nk4zWlp2OEF5ZjhBeUxXUDhmYUFiUDhBMWhrL2lDakpDRlZsMDNJRTA1aks2bnUxZVZJOU5EZ3l2VnhSTXF4TXZ3cWs1SW1UWjZZZ1RXWHVJbHhLb2tPbytzbDVDNnp1UHg2cng1c3FhaUt4enAvS3BDRVJGVnA0M0ljajFVRitybVVpRlZQVVB6WmZwR29zZ3BVTk03TmJFbVFpTEY1ekl6RmtvbFJncXA3dFdseVBTd29rejFVR0pVeWxTNWt2MGJTcEdLUkNtK3NFaXJlbm1OVmxwYmhDYlVmUnV4bnZVdzUwL3dCR3BOY1R2TnVOdng3ZVI1TzNud05Pc3RSNXhmenRMWnY3YXQvbENJRTF4RHNTU3dWME12T2hiYTIxSlNhbk9XVkFLUXB0MDBLSWhIcUxxYVZVRlRwZFg1WlVCb2RxUE1VelJxektuU0xRa2VuY2wxcWJLUXpIZWtMWEFtdE0zYis0dG9OQnAwYTJMUWFuYXBseE50M2xHNVVZR2VIVzJlQkxiVnc1Rk1kZFpnU3BIcW1STFlTM1cyNmpQUVhOYWk4UlZLZWF1WVZYQ2FqUFc0WllwS1A1bkVIRHJ6ZFVua0QyaFlPRTlWWnFWbFZaVzhpdHVOcVpoeEwrRHZvbk5qMUlobTJCajV4RmViOWx0RWczZG02MDc2M1pWQjVacW5kbXNld2lWK1J2L0Z0V0VSSXNuYVp0cHRsaHc5Mk5TaXhzd0ozeFZXcWZ4aVd5ekxaZ1NISG84YitheG4zSS9rR1l3TWp1TWg1VzVFcENOK1o4Sm45eHRaVW15Y284RmU5c3cyZTRkVVh1MGlDVzd0QlcvclUwMnZabWlLTVJDSlcwMVlaYmJjbExOelpHak50cnBoSVNnajA4aXZ1dXR3Tm9QN1pWNTdjMlhoTmNDajBMKzVKMmliM3RtMkhPTFQ5bnY0d2s4TEZUeVZHb3BGNkhBZC9MNnQ3UFJmYkhWOE9KUmtFdVpxczhTZHJxazJUbEhwYm1hSFIvY2lFWkpLMnA0VFJDZWZHcis2a2tWaGU3RmdOazNTNWpuQnBGRWJMMDFYVHdxclZ6M29GTFh3cHpmNXNLMjUva29aUVVLa253NnY0ZC9MS3I3TlNmWW1WR3lxczk0TG40bFJBLzMydHFrWnJsOUtkMzZQUC9BTDFjb3k4MHl1ZnlKaU12MEtpTy93QjNBMEhZeDNHUmtkeDJJYTJQNUdSZ0ZubzJrczM5c2xESy93RHlQWDVEalZYaHUrcW85WGpJaTEwVVNsb2xuVnFzNnhMcFU0cW16SWdlZzJxRXlxK2pyTk5xS0tqRHJsS2FUR3Avc1ZRL1B3Y2ltUlowRTRNMm4xNm54bTZmczcrUDdTKzNSWU1lazBnNjlVZlZ2UkkxYW8yelpHbXIxQW0xVVdQVUtXeTc2ZUk0elhZTE1PYzM5eGZRYWRSYUdDMHROLzVCL2VuL0FNZTBmdUFxRHp2TTAreWVKTWRwa21GYms1MUpJaEkvbWxmd3NmZk9mWTk4eVdXMnhHUGRxUmY0MGRsb2xTWkRiU1NqZkduWnFVcjFWejB2aTNqOU9qQTNSZ1lNWU1ZNmNHTURGaStyekwrMHFuMjVVK1NscUd2aVVpcHR1THB6OHhpcDJxVHBzVm1GR2NRb2VxWWhiU1I1TEVwcC92QmdWV0EzUXlNalRVa3JTbGNsbXAxQVNYVVE5bzZlZkdteHY1aTFCa0NMcEt4bU5DR2hBOVpuczFFR0JDL0twM3RWUDlxM2Y5UFVYZUpUbU8yMXRhK3RUaUViTTBSSVlkUXp0RlVKS0praWMzd3RsWWRSVkRqUkgvVTA5VjY3OFZTbnhFemFWSFJOcUUrUXZod0tMVTZmQ29VNnMwdVRScUk1eGRsOW43cC9qa044YUloMlZUcFVPWWlYR2QvTHF2N05SdmE1cC82aWhqUVErKzFVNzJla2ZhVWIzTWdUNXg2NURxS3BjbDM4cklWcitXTjdaVlBaNkw3YlhQNTZnZWFDNnIwOVpSK2JDcis3NkNDZU5xTlE3K1cxWDJlayt4dHAzNkcrN3hkbW5QeFNpQi84dXFmc2RGK3lpSjlUVmFJdi9Kcm44a1QydWorN1p0Z2R4a3hreDNHQjJMckxTK1JrWnZ0TFp2N1p5SkhYdEFtdHgrTTBsdEVmYUg4aEd6NmtuczVVVXFUWDluMHFQYUtzbW5tZ3FmNURzeVN1WVZNeVRzL1QvWXFoK2ZoMzdyWnIyVGFIOGQyZC9INjRhVWl2RW85bXhzOFNpMmVwZTcvV1ZYL0d4QzltMm4vbmIrNCtUNXQrZ0xXYi93QWhmdFQvQU9QYVAzQVZEMzlQc2dtYUova2xmeG8vbWxmd3NmZk9mWW8vbGxmd3NmZlNQdFludXJ2dDhIM2pabjhodjR0a1pHUm5veU1qSXoxbjBub1d1Qk1ML0RuU2x4SThlYXBjeVpJT014TmtxalJXenFuSGxTSlNhbkg5WGlUUGtJclVTUzQ4N01rU1c1OGYxZ1hLTk5mZGtHM1ZaSHE5MkZKcU1sY3lSSmJuUi9XQ1pJZVJJaFNWeUdZMzgvNzN5Q1BwTFhWWGp4YVduTkpvWjJqZkJ0WE9QL1RVOHY4QVNNbHZiT3AvdXZ4L3k2cy9XelNFcllhYVF3ekdiUTd0R2cvUWJUVlgyU2llMWhWNnAzMnRGTS9NYXFyYzJicFVDSi9UNXdZWnAyY1BkcHRHYmNhcTFzL0NIbzdjaGlqS01xaTcrVzFZL3dEUzBVdjlWTFJtbDBLMFV0M2E2ZWVLUlNDLzE5SDl5eUl2NVZxY240ZHJDMHJaZDR2ZWxWSXMwYWkvWVZ2N21xSjNhUk5hM3RuWWl0L2FQeFdDeFU4aW5mRnRLZWpuNWJWL2FLVDdIUjBFNHozVENYK0tVUVAvQUpkVlBZNmNmQzJkcFVpTkdUQVdsRzBkYy9rakhpa1VjczFJWkdiNUdlb3VqUFZnWUcwMWtiUXdDYVZXRUZXMDhtUzgzdEhDNE5XbHRUYXNLZFVYYWZKbUxwTlVPTk5wZEppRkxkbTdUQ2MzQ2RyOE9WU0tkQXF0WTljVWJhRmhpblNhbzIvdEovVTBZTFBlZXBWWGFnUUtuV21aMU1wbFpaZzAyclZacW9SWUZhWlZBNVpBOVJKclVhTlQ2VlVFUUprMnZNU3FVR05vbzdVR3JWRnVvcmIrNCtUb1Axdm9VMy9rRC82VS93RGoyajl3RS8zOVBzZ21hSi9rbGZ4by9tbGZ3c2ZmT2ZZby9tbGZ3c2ZmU1B0WW51cnZ0OEgzalpuOGh2a1o2aXNlZ0loNUJHRDBMVzU2MngzQ2drZnZNK3lxZjhkUzdQVlQ3V3JrcFVaaVBKYmZtTnV1N1ZSMm5tbXBjbzQrMkVPTDZhUFBRNDV0REhhZWFUT2M0ZTNrbjhuRksrd3FDSEhOb0k3VHpTWjBkeHhFTjFtUkVqZnovdmN5QkYwR0Mra3RSbXhFTlFSdVV1cVI2a1VpbzFCdGNhcnk2aVVtS2lPY2JadW5KMzZUU3k0dFRqL2w5Yit1UDdXSVA1UldtOFB6SE9Oc3BEcUtva2FCTU9ZajkxRmh3Vkg4MkZNL01LK2VObElTZHlqQ2wvMnRyR1pUTDhnSUxMdUJKY05pQXF0bDZlak1LSmRTUXBpdFNadnJvTkY5clBHNmxUbEtxa2VwbElxTlFiWEZyRXlwZXJpdzQvcDZMRGxIRWt3YWdjeVh4dlQxdGlxcmRsVldPdmY1MS9ZbU5LbVVlTFUvVHhtSGZYMDJKSk9uU1BpcWxjcmYyVGJmRm9WT3ltdmlyUmxPeGsxamRwOUlqS1EzNHFLRlI2MUtuZXVoVXIyT2hDck44T3FML0ZLR0pxK0Z0STlKbFZJVFVGRTJZZ1FZNjZWTFFtSlg2NTlmTVgxd0tiRVZIalh6YkhXV3RqQmFtWFJpeGphVDVjTDNrVlA4aC82VGYzRjlScVBJemY4QVRvcXErRnRmS1J3NnBDZGJRS3pNWWwxQ08wYjAxOXducWluMlFUTkUvd0FqL2RHaHluV1ZwWSsrYyt4MEVwNWxZaXBOVlN6eHFlMHZoUzMxdEdtTi9iR3pSZjhBc2R6THJMVytiZUFSNUdMWXNlb3lDTWVBWDBsck4reXFuME5xNWpXS3A5dlZQNEE1K1hpVkZUTDJuaFNsUEprZmxJcXJhMTFuaW9rN1JDaysyeWZ5Y2NSWDlWd3ZlNC84cGE5WkdEMTg0dmdaQ1F0S1ZCdENFSnhrRXkwZ0hwK295QzBQVHdXbGoxS3pxZTRxWGJiTUVoQ1hOU3R1cDM4RVJob3UyUmtjQ09hdXdNa0tTaERiWldOQ1ZKUzJoc3RTU3l5aFF5TTJVVnVHMFM4aFRUU2xFRk5OclNsS1VKNmVDenhNOWlDa3BVU0cyMnlIam95QzE2ZXd4MDQ2aTFIam94MEdOcFBsd3ZlUlUveUgvcE4vY0E3RmJ6NHRnSDlOOERhT051VFVTRzFSellRY2RPNlRyeG9XaDFvMkpUVDZXNC9xSXc5WVMxRklqa2ZxbEpuY1dHRG5JWEZUS1lTNG1VbmhwbFIwdUhLUThvNUtVdHh2VUQxRVpZNHNOSWRrdVNGMEtuS2dRelZaS3JHVnQwYnZYZ1lHN2NqNkRCYUJJTXg1SG1iOWpKYmhTMkNjWVNoMzB6eVhpalBvNHpRa3N3cFlqc1E0cThSdlhxVEVWTmt0UXBaUjQ4S003L2pldFlqd0lzampOQm4wckRVbHFGTEtQSGhSblpMVU9VVWRNU0xHam5seE52R1JrWkJBOUU2bjlSNjZEd085a2c5UzBINi9yK2hhWXZqck1za3RPNnFxeDNuS3gxb1J2SzhZR0JpMkJnWXNkczJQV3hhQTBqRnlMRnNnajcyeDFrREJXTzVhZytneXZpeGEyeDFsM0xBeDExeURKbURrbFRISmFrT1MxSWNscVE1SlV4eVdwRGtsU0hKYWtPUzFJY2txWUtqVk5LdlFWMEhSNm9wZkpha09TMUlja3FZNUxVaHlXcERrdFNISkttT1MxSWNtcVE1SlV4eVNwamt0U0hKYWtPUzFJY2xxUTVMVWh5YW9qazFTQ0tQVVNlejBac1F4YzlMRVZubVdwRWFSczA2UzBxWERtNzlPR2FjSkx4U0tuUmFYVDVHelBKS1VPU1VvY2twUmprZExDdGxXT0kxUUtXMUg1TFN3VkZwV2VTMGtPMEttT05JMlpnSlcweTJ3dzdTcWUrczZIU0NOaUpIamtaZGhnZVUvVGN6QkYxR1k3NExvSTducDBGZFNVcmI5TEZIcG9vOUxHQnhvd0tMR3g2V0tQVFJSNldLRGl4c2VtakFvc2JIcFkyOTZXS1BUUmMrbGk0OUxHSHBvdzlOR0hwb3dRaERhZkhTV2hoT3BnOUMwM2hrYjFzZHowTFVHREg2RnBucEllQ3VZUDRpVWcwOWFVR29FVzZuNUo5QjYyTFQ1QkYzNk1kUjYzeGJ6MTVzWUxVWkdiWTZTN2RPUmt4M0dESGNaR294WXREQmFib3hZd1ZpMU1lQzFQVXRjMkloNHlQR3BGcVAxR09ueGNqNytDdVJBK2lvVVptZXYrbG5CL1M3Zy9wWndVK0o2Q2o5WG0rQm5IUm5OdDYyaGR3UVBVdTlzakkzcm45V2V4ZFdSNHhjdGJlUzBWZlUrbkJXL2NZc2ZRV29QUVlHQVJXUFZJUFF2cE1ZR0J1Mkl4NU1yRU5WR0Qra0orVGdGWTJpTUcwc2JpaHVLQk1xQ1dra01kK3N6R1FXb3dDSytCb1F6MFo3NjlQblBVUThYemJGaTBCYWpVOUJxRElFRDBMVTdGcGZIUm9OU3RpM2NkeDNIWVlHYkZxUDJCbU1najZDMHZwWWl2anRqdDUvZkhjR1FJSGZ4MGFIZkh4SDBZc1lJclk2ejF1WjN5TmJIcmd3V3ZuUFpJTXNqUXM5Qlh3UXoxNUdSZ1lCYVdQVUdlUVF5RTJ6Zkl5TWtPMmNrTWpKRHNPdzdEc093eVFNZU9rdEJvWjZGcDVNZUIrdVJrSG9RMVVNRFFlYzI4ZURQdjg3em5vT3hhMzg1elk3bHBiQUxTNTZXSzJiWUhnN1krRzJSbTVndFQwSVpHUjRMNmpCYUhxUEhUaTZScU5CM3RxUmFtTUR1UTFCRHlENlBOeTA2TVd5TWdqdis1akkzZ1dBZXZUNVBUOVMwTXhuNUdma2VDQjY2alFzNXZrWXNaZ2lCZ3JZSzU2anoydmtkeGl4ZGdmZnJ5TTlCNmRIaFduL1FQNlMwTzNnN2VBWTB0bS9uOUJvTlFZMFRrRVl3TUF0TCtRVnpCV1BRdFFZS3huMUZwanB3Q3NmeVAyNlN0aStiRVE4NEdENkN2cVJhNDc0QmxpeFdPK2JaR1JtK0I0MElpc1lUZndEQjZGb0QwTFF5c1JXT3hhV0lyK0xsb2VoRHlNZklJSG9XZ1BVZUxGMVo2aTBCL1ZvU2g0R09qRmk3bU80eGZ6MGxiSXlQLzhRQVdCQUFBUU1CQXdZR0RnY0ZCZ1VDQmdNQkFRQUNBeEVFRWlFUUV5SXhRVkV5TTBKaGNiRUZGQ0FqTkVCU2NuT0JrWktod1RCaWdxS2owZUVrUTFCMHNsTmdZM0NEOEdTVHd0THhOWFVWaEpTa3MrSUdSRlNRLzlvQUNBRUJBQVkvQThmL0FQbkRXMFRzaDg0b2lDSjlwUHVoZDVaRkFPaXBXbGJwQjVodTlTMDdSSS9wZVZpVmdhTFF0VXJQTmtLMGJhOTNuNlhXdS93UlRqbTBTcVRCOWxkOVlWQ3Z3U3NtYnZZNnYrY1ZFUk5MZWwvczJZdVJiWi8yU1A2dkM5cXd2enl1KzBTaXlhTjBUOXpoVDZLL0RJNkorOXBvZzIyTTdaWjVRd2N2MmFXcnRyRGc0ZjVxMCtpTTA4Z2lZTnBSaXNkYk5ENVhMUDVLNUJHNmFUYWcrM3kzei9aeDZ2YXJsbmhiQzM2b1dibmliSzNjNEl2N0h2dUgreWZxOXFNVm9pTVQ5eCtnbWl0VEJJek00Tko1d2kvc2ZMZkg5bEpyOXFvOFBzODdQVVFoRDJSMDIvMncxK3ROa2llSkkzYW5OK2p4L3dBMGRMdms1NEVRV2R0RDcza3RHcHFiTmJhd1E3R2NwMzVJUldlTVJNR3dkem1yVEdIdCtJVWdpSk1WNDNDZHlaSjNxSnJoVVgzTFR0akcrYXlxMDdZOTNReWl4bXREdnREOGwrOTk5UDdWYzlrL0p2T3dXMkMwUk85aFhrV2x2R00rYXpkcGlEeHNPMEl5dzF0RmwzN1c5S3JFYjBSNGNSMUZaMkIyUExZZGJmOEFOck5zcEphM0RSYjVQT1ZVM3JSYUpIZXNwdG90VkpiVnNHeG5kMmw5YVBjTGpmV3JOWjlqbjZYUnRWTzZ6OEFwYkdEMytaTm1pT2JtWWRSNmloTkZnNzk0enlUa2RhZXg3YnNuS2gySG9RbWhjWTVXNng4aXJ6TkNadkdSN3Y4QU5pdkN0TCtMWjgxeXA3Uks3MnErL1R0YnVFL2R6RDZDejJNY2tYM2ZKV2kxbmtDNDM2QjF0c3JlL2pqR0RsL3FtencvYmI1UVRMUkE2ckQ4T2JJYlZaVzB0WTFqKzAvVk5taE9ibFljUWVvcHMwZUI1YlBKUCthMGxvbE9pMGUxUHRNeDBuYWh1RzVQN0lTRDZrWHpQME5wdEhKYy9SNk5paHY2Rlc1eVE5S21uc3ptWnByZ0szYWx2T1ZGSGFITWxiTGd5UnUvdTM5a0xJM1IvZk1IV3I0MG9IY1l6ZW1Ud3Z2eHVGUWNqdXlGbWIzd2NjMGJlZE5tYmpFY0pHYndtU3hPdnh1RlFmOEFOWHRlTS9zOEo5NTI5Und4NHZlNjZGRkJId0dOb1BvTFM4Y053dU45YXMxbjJPZnBkRzFXaHNReHBxQ3Qxb2EvdFdHakJmZnpISHAzSm9oc21ZbWZneVdsTWVqWXJLSVpNMHdTVmxvU0tpaWYrMWFSQUE3OGNNVFU5V3hSdlpQbW1FTnZ0RDlXRkhmbW96MnpnMmwvdjFieDIrMVdmVHVsalFIT3oyRmE0bm53VWx4NUw3ejhjL2dRYTNjTmxNRkoyM2FETzV4NEo1T0pSdGRsYit5dU9rMyt6UDVMTnlhVmplZEllVHpwcm1PRG1PRlFSa3o4SS9aWnRYMVR1WC93Nlk2RHNZZVk3djRMZWxlSTIvV0s3Mkh6ZEF3V2hBMXZUaXJ4TEhOOG02cW02ZnNyVGlhZWpCVWNURWZyS3JUZUhONDlVbWlOS2xZTld4YWdzV3JkL0FOS1QyWXFndm43S3BmTlZtNHBMenFWMVpLakh4K3JuQm81MEhNMDJuVVJrR1RXZmF1RmVHNHJkNC9kcmZkdWFxOXJ5Rk5rY3d4M3VTZGFmQ0JlY3pYaXVKZVBVc1d1V0VyUWVkVmFham04VE53OS9sMFdjM1Bra3RSNE1MY09rL1EyZXhzZUhYTk45TjZ0RnNPcGd1TlZGUFpLbXBkZWh2blhRNmtaN1c2dHppeDgxMkl2UTlzTnZ2NzNTdDdSVnFtSUZsYTYyUk1sc3JkVUlCMW5wV1piTm1zNVlITWU4Y2pIQlM5aXJUREJaWnByT2JscXN3cGh6cTNXRzBXU0JrN3JHNHRuc3dvSERuQ2IyT2xuRU1jZGtiVVZ4ZTl6ZEhwcHJVUmZ4ek85eWpjNFlGT1k5b2N4d29RZHF1eHVyRElMekJ0YWcyR1dzWDltL0VJTXRUZTFYNzliVStFa09qa0dpOFkrdE9ZZENhSi94Q2h0SEsxUEc1MzhDTWtyd3hnM3B6TEl6TmY0aDFvdmtlNlJ4MnVOZTdyQ1NEdTJGQmxwakVYK0lIWWVOMUswUGFWZWRXbGRIblZLNHJoTFgzQkxEaWhuQmRkNDYrR3p2d2Znd2RHc29SV2QrZkZPUTdScWlTOGlycTFhTG42cS9NV3VlZUVUalZQZXdDK1JTdEZMSEZnOXdwVUdpNzNNZGxHdndjVndCTVFhU00yc1duRytNNmpncjhUdzl2TjQyNlJvcWFnSzgvaFV4WTEyZ2Z5UU1ibWpiUnJpRlJ0Wkc3M05USXBNeTJ1c0RGYmtiOEQ3dmxNY0hWWENjM3BZc1phZllLYTNPa0E4b2pCWERnN3hzazRrS3IzUHVWMFdNMFZSMmczeVdmbXFzaWJYZXR5MG93cXd2YzBjMlB3UmtzY3o3N1cxTEFjZWVpTFh5M0FkSzg3U0xnbTlvMHpSd1pyY1pOL3FRY1czWGJXK0pTVU5Zb3RCdnp5Q3laek4yc3ZKSWR5dWp1TVZncWs0SXNpUGJjdjFPRDdVUVpjeEY1RVdHVE1SdTc4MXhNb3lOSWFYTnAzeWc2UHpUNHBlTllhRTcrZFJadUVTeTM2Tkxod09kVzJKOWxpbHRiWldRZ3Q0TWhjclhabjJPejNoWnMrTTAyNjJRRFdGV094MmFBT3NZbklMT04rcUZvMk5rT2NicHN1QWVvck9DRmpaS1V2QnVLTkdodFRVMEd2Sk9RYXNaM3R2cS9YTFd6eWFHMk4zQktpdGtiY3phYVhabWZOT3Nqem9UOEh6aC9BYjhtSjVMZHBWNlIzUTBhbS9SYTBJcGVMMmZWVlJpUEdLdVZYR2pkeXZLZ05TRmZrTkFueHNpWkMwQ3BkSnI5aVBmR09kNXY2cU1Xb1hHTzRMMkhEMW9YSDRiMXNjalZoUVZIY0hxV0hqUE9kU01kbWpMbnUxa2JBaExhWUxnMU1qSndBNTBIRUI3MmpoRWF1aEV4YWF4NzI1Q3V0Qm9ZWGM2dVNORDI4NnZ4WGpGemEyOU84SjluTEJuR0RXMTJpL29VZmFnekRqd204bDI5WDJheGc0YnZHT1pESDFKbG5HcXVuNitEK2F2YTQyWUtqMlg3enE1b054SG5idWhZbGtiZGc0Wkh5Ujc4K1NvcHBhbElJNkNTbEJlMUsvbVk4M3RMSVducVJZNXdqMjFEUXIrSTlJYnlqdE55Ty9IRzl3QUhLMlZSc0YrV2daZWRhSzZiU2R2cjJCU1F5TnBRNkx0aDdyVjRuZXd2OEFKcWhMT2U4Vjk4cGpHTm8zbVZhNExCVWNxOGhWYXM5R1RGamk1dkpQbGZtbjJ0N2JrMTY1S0tjb2JmV3BDQmd4ckkyK3lwNjhsZnB1YkphWitXRzBaMG5KTktINWxqY0dFamhGWExURVdibmJDaEhQKzFRYy9DSHJWK3pTM3ZLYnlndWJJNk9QOXF0RzVwd0hTVWM5TGRpL3MyWU43aGs4RHJralZuR2FNbzR4bmtxYUtsMXJuVjN1UFJ1VmRlaHBFYXFveDJhY1daNTF2TGFwc0dkaWpNY29saWZIRWVHTnJxbkZXaWEwenR6ajdNWUdCak1HMTJxZTVNeCtlc3pZWFp4bkJvS1lma29iUGZMODJ5N2VPM0xhTFJ0YTNSNmRpcjNNY3JEUjdIWGdvYlF6Z3lNRHZIek0vd0N5M2VVNldVMWQxTEJWcXQ2MGhWWWk2cUE5MkxOSndUd0Q0dVhPVjU2cnlkbVM4VzBkdkJWUkxXNmJvdkJTT2ZFMjBTRFUwN0YzenNjZnNxUXlNZkxIYy9mQ3BqVWtUSDBnMXg4MjhMaHJCUDB0SFhkeUJqdUNkWGpGMWFWb2pnb09VYUp1YnRiWGlsY0N0Q1FPTzFPejVydXhSNURVNWoydTBkWnBnaTVrclhBYXpYVXNEVlBsYzh1VjZsQnpwajQ5VjY5RFU0TmR1Vm9tbWExcjdoNElWbXB0WmVQcjhZQTJLU1Yrb1k0S2VZK0VhN3YxM1lOSHFGU28zMmx4dURnamYwY3l1UnRER0RZRVNOSlYxS2o4RGtNa1VRTDlib3RRay9JbzVudmdPTkhjSVUxMCtZVU1Ub2JyODVSN3IzQ0IySnNweGtuT2RlZXI0Szc0d1NyNGZIS1c2anJvZzB2MFRxQ3pJWmVhS1ZkWDRKenFWakIxN2xJOXpITnVPcDBxczFJc0wzTlJCZ2tCY2RpR2JOMEl4dmpxRGdTZFNmSEpBYnhOWFVjUWkxdDRWT05kbUNvelNkdVZCOU56cXFzdGtHM1RkOHZtb3JOSHl0WjNCUnd3dHV4c0ZBRVlwWXhLdzZ3NEl5OWpqVWYyTGoxRllYN1BPejFFSzUyUWp2R21Fa1kxK3BPamovWnJONUxkWjZlN2JQQ2NSckhsRGNtMmlFNGJSdGFkeXcrZ2dzTFRxMDMvQUN5Q3p5dWMxbDBtclU1ait5cm12YWFFWDIva2l5emRrWkpuQVZvMTQvSkJsbzdJU1F1SXJSengrU0RXOWxYRnh3QXZ0L0pOc0w3YU5EKzFkamltV2wxcFlJSG1qWDF3S3pkbnRMSlgwclJwUmFiYkVDTmVrZ3kwV2xrTHlLMGNWbkxQS0pXVnBWdmpUaUQzbHVEUHp5Q3VGZmFoSEhKZmM0MGJvSFNWeGxKSGJtdXgxMFdrMHQ2VnVRcG8wMjcxcldJN25ERVZ3UWQrOGJnL3hhakRkakcxVWJWb1hQdEc3STREWHNST3l1UE1WV2w0SEdxNHlVY3drVXRuazBqV29jQlV1NlZNWE5GNStwbE5UVndSN0ZRYWxIc0ZkZGN1UENHdnhiblFsa2JwRFVOcDVrMnkxdkF2NzdUcUNtbEhLZmRIcVQ3cnFZTEYxNUc4N0dIRnllOXo2dXZIRzl3SGIrbFR5T2xNMDBzWWE2cHVzcU9WaHRYR3ladUxOc2pmQ05uS04zZW94YWNaTHVraG1PQUUyS2VDOXRVczBNcm9YUGJRaDJJVVRDUVN4bERUbVFQaTFFNXcwdGxFZEhVT1NWU2FJRTFxTHpVRnBjRkc3a3gxcXNoMFZocVRaeG94emNPbkpjT1VQOTdGQzdCb2JhTHM3R2pBUDM5QjFxeWVoYjFMMVpLK0xkcmpTRE9Iem5Zb203U0tsTUZ5cG9uYUZhMXI2OWFkM3B1bHJ3WGZLRURnTjNJYUdwWWx4YzRrdDZTdUVYSGVWTEtlUzJxanNtZkFBWTNPRnpLME8xTkVvWVhhV0lHNHEvcVBpTS9reDBZRWJZN2pKdFhNQXFaT1pYTFJGVThsNDRRVWxsdjV3REVHbjBPY1pwUm5qR2VVbVR3dXZ4dTFkMjU3emRhTlpLbnRMdVc3RG1HekkzMGJsYmZUdjYweHZsc2MzNS9KT2I1RWJXL1A1cXllbWIxcWJ6VzlTN0dlbi83MVp0ejZzUHNWbzlJZXRXZitXSFdWL3JIdW5IY0Z5UGRYSTkxY2ozVnlQZFhJOTFjajNWeVBkWEk5MWNqM1Z5UGRYSTkxY2ozVnlQZFhJOTFjajNWeVBkWEk5MWNqM1ZJMXhhTCtqZ01sNE12M2NhVXFxeXd0bE1qcnQ1ek51OVJXQ3pDNlMyNkhEa2Y3Q2lrekF6d3hpSk8zbldkbG1hOFBPbXc4V1cxVWpZMjZONDBJMU94VGd5U2xCZU40Y3lxQmVHSEJ4MXFpMFNxT2JrTk5lUnZreWFCK1dWd0J3cnVUamVHQTNMa2U2dVI3cTVIdXJrZTZ1UjdxNUh1cmtlNnVSN3E1SHVya2U2dVI3cTVIdXJrZTZ1UjdxNUh1cmtlNm5oMTBEVmdNdmV3S0hGOUZnYTVLeFB1T0hKNUpWMFJ5V2R1MHNkZ3NPMmo5bHFjKzdtNUhZM2ppN25WRytzbldjcm0zazFrZ3UxMVpHMU5BY01zZHpDdk11RVBZaTBYUGRYSTkxY2ozVnlQZFhJOTFjajNWeVBkWEk5MWNqM1Z5UGRYSTkxY2ozVnlQZFhJOTFjajNWeVBkVFdETjFKcHFRcS9nNjl5elRRUzBEVU5ZYnY4QVdvck5aN3ViZ1lRMEJ2WHZLaDlkZmFpSEdtRzlER3J5M0ZUWWk1SSs4ZC9RbXlYV3ZZL1N0TE43aGlLSzdhYXNZSWc0ZWNlRXM0NTE3djJiYXptclQyN1ZtT1VVRzF2SGVtT2pwZmRJQmluMkdTempWWE9SbE1raDRzKzN1SHZiZzVjSWV4Tm9XbXU5cTVIdXJrZTZ1UjdxNUh1cmtlNnVSN3E1SHVya2U2dVI3cTVIdXJrZTZ1UjdxNUh1cmtlNnVSN3FEUmNxZnFxdXR5Zkp0NVBTbXV6am15WEs2OXJuZmtFR1NhZEJ0MnE0elZ1M0lnbXJoejBVY2xwdnNlL2d4dGJnQnY4QTFUZzZXN2QxMUNJdlhUOWJhTjY4dHZNanF1YkFVR1N0dk1yWFduOTdKdmhvZWErVHFUWTJZTmFNRVhqVmtwbGVBNFlPM0p4cU5XNWNqM1Z5UGRYSTkxY2ozVnlQZFhJOTFjajNWeVBkWEk5MWNqM1Z5UGRYSTkxY2ozVnlQZFhJOTFjajNVSnBlT0kwUUFyUTkzRE00NmltOUFVV0lwVFgzSE9yMDJ2Wmt6UDd1UFRtL3dDbHZyVHJkdzdzZ2RLVTV0ZTlaek94bmV4MkIrU0lPb3E1ZXE3eEMwVGVYSVhmRldPTGRDMnVYREpKNWpmb3FPcTZ5djRiZm10Q0dkL3FBK2EwTEQ3MHY2TFFzMExlbXBXRDQ0L05qV050ZVBOb0ZwMnlaL1RLVmlTNDVXK2pjcmQ2ZC9Xb0dlUmFibnhvclMwY3FlNThsWmZUdDYxTjVyZXBkaS9UL3dEZW9KdkllSEtmMGg2MVovNVlkWlgrc2U2ZjBaYnNiQzkyNW9xcm1Za3YrVGN4UVk2RjRjZFFMZGFhNHRJYTdVYWEwR2lGNUpiZUFEZG05RWRyeTFHdlFLdU9hUS9jUmlzM2NkblBKcGlnWE5JQjNoRzh4d3BycU5TbzJKN2pTdURkaXVHSjRkU3RMcXYzVGMxWHFZSVhnUlVWRmN0enljaEZhVjJxRytIa0RFc1BPcno0ZzAzYXRMaFJ5aWpZVGV1Nk9HRGxtWXVWb2k3dVViWHNianduRERCQ09KaklIeU1OOTdZOFFGQmE0NXNidU1iUnYzSnBsaWM2T29ZSHRicTVsU04xWCtRN0EvcWkxd3hDMGVDbW5ka3cxcUtYeW1nNUpSZTVaMkp3RHRtN3VXbHpTQWRWUnJSdlJ1Rk5kV29VWTQxMVlJWFdGMVRRVUcxQy9DOWxkVldwekJHNjgzV0thbGZ1bTdXbGU2RyttUU5ycE8xSU52ZXRPTUxnMnZKSXdWSlFXeWJRVnJ5NDVLQkVzYzI2RURUVDNxNjZ0T1pacHhydUtITnJUWGJ4a2h2WWExd3ZnbkVhdTRjUTBrTjFrRFVxdFk1d3JTb0cxT0YwMWJ3c05TdVhIWDkxTVZmRUVoWjVWekJCeGFRMDZqdldiTWJzNTVOM0h1cTFvMW1KWGEwUGZKQzY2RytXN3lWSzNTZFBLQTZhOGFsaDNLeTJpUnVhYzd2ZGEwTWxWUFpUd21PdmpvUDZyVlZVYTNScWNVYnJsaGpremx5cmh0V2ZrWmRlZFZkMlJ4THYyZXpBZ2tiOXArU2IyU2tpTElIVDZUeU1CVlBqclc1SW5qUFhxOG5MS1RxdzYxd3ZnbTNUWHVBMW9MbkhZRVd0WVhPR3NBSm91bXJ1RGhyVlhNTFJXbUkyb2hzTDNFYTZNMUp3emJxdDRXR3BCNWFRdzZqVEFxNjRGcnR4N25PYkdMVmlya0owR2Y3cXJIcFgyM21BbmZRbFlvWFFyUkxIRDIwYVl0Qm9mMVRaeEsxd2xpbzY3cUtxK2NTRzlVN1BVUFZnbjFjME1yaGQ0UkNMTldHR0t2VHNCY09DdUNMdE55QnpCNDFrZlJlMUZPdU5MYnB4UlpxSTJkek1DN2xsT0Y3WnU3bHBjMGdIVlVhMGIwYmhUWFZxRkdPTmRXQ0YxaGRVMEZCdFF6a1QyVjhwdEU1bWJkZkdzWGRTdjNUZHJTdmN4aWxSV3A2RWFjclJaNXUxTWFlSXpsYTYwMnZDYm91OVNZUlNnMU9RT2RGRmV6Z0pSZHdqNXlCbE5Ca01VSmFiVFN1bHdZaDVUa2JaSjRJSDFCay9ldTJ2ZDhncmMwY0I3Y2FEQlJHUndmbUxyWGVZN0FoQzhheU0wSDgvUDYxZkxLdVErbW5mNUxDVTF1ODBWRnpkdzNuaEh6K2liQkEyOUk1WXZoWjB2UDVMdmx0WTN6V1ZXbmJKSGVhMml4ejBuUzllQ1Y4NTVLMExEQi95d3RDTnJPZ0x0aUp2N05NZmRkdXlOOUc1VzcwNyt0V2h3L3RSSU90V2QzbFQ1ejVxemVuYjFxYnpXOVM3R2VuL0FPOVRTZVJTdVNEK1hIV1Yvckh1bjlHVzBqL2gzYXloQTU3VEpja09EcTNSVG1WaGh2NXd1ZVpBUnFwU2lzclJ3dy9yY1FwQUNHdDdSSXFmT1VzZWRZTy9pampXaHc2RkN6V1k3ckhIZVF1Mk9UVDQxdUt6K2trNjFiWVhmdkRHMEhjYnVDbEIxOW9qclZuSnhPWm1DN1gydWlkTjdEK2lzZjhBTE4rZVFWMUlsT09zS20xYUx5bkY3THpqWEdxYktKYmhad2J6TlFBd0dDYWI5Nm1EYmkvYUdPTlJva00xS1pqcTRPMDNoMkFidTZWRkREdkJvSFk4MUVMK2tRS1Uza3B4amswM3VwbTNIR2xWcGNKbWo2c21HR1d6ODJIeHlXajBoNis2N0hNSENGQWVoMy9oV3g0MUdHT250VmhmU3Qxc3hVSWJ4WnRnTE9naFc4YkJLdy9mVnRsT296aVAybkZTczhtMTArSGN0SFBsemxNUmdNdERwRGNWUzZXZERrZStGeDJHaTBwZ2VocW8rUUh6V3JHVXY2TUUxemdYZE9QY1hhMDNGR3ZDMUljMlN6ZmErWGRXeU04dG9hck16bEcwTWVmV2YwWFpQMFQrdFF5dDFzWmNmN2xRdXhGRFRSYi9BRkt3eDhudGlUMlhsWkxUL2FSdStGZTZ1OEhPUHhlVHFDbW5mTUlHTmtPYjZFeVJ0b2E4QjRjV1VvQ1ZCRmFXYU1kNjdKV3Q2cDNxSzBNZm01WWNKaVJoVGQ2MHgzQ2kxMTJVWEZJM0puQ3FOeVFFODJGVnhaUFNya25CYWEwSTRXVHRlRS90TGhpZjdNYjFadXg4RHFrdXJJNGYwL21xV21ONWRBN2d4OEY1MkYzUW1PclVUeGF6NVFUWm5FZzFwaGxuOVhYM1ZuODVXdWJrdmJvZmFGNzVMc1o2Sm5XclREeXphSkhNNlF1eUhwSStwT2NjU2V4NHI3Vm1kc0xXTzl1dnJVblEzcTdseDN1VG9XR3J6dzZiQnVUOU9yM1NVRzVvR0M0QWpvL09SdGJzeHhDM2hOdXN5T2tpckE5M0N6ZW85SVdrUWVnWkJHdzZTdUZXaDNLdTNXOUp3VTFuWStqclJvc3JxRDJjQS9DaWxHeVZsOGUzSHJUWHVGZGhWZTR0SHBEMTkxMk9ZT0VLQTlEdi9DdGp4cU1NZFBhckMrbGJyWmlvUTNpemJBV2RCQzdKRFlIdFAzbGJaVHRsYkg3ZGFsWjVOcnA4TzV0Y2xhQU5vYUlTeXd0emRLTlkrUU5LN1g3UlBZNTBnb3g5NnJIcG9uNDJRZkRZcmpYM3czREE5eGRCdXE4eVZ3b2FQemJhdlBSdVZMWit4V0t0N05NTitTWDh6enBqU3dSd1JZUTJjTzYwNlZqeHA4aHAxOHljSklwTEtENWZCS01VbUJZS1NWOG5ZNzFkU0xodVdsaWEwK210eC80ZC9VcktQOFZ2WDNWbGZ2anA4Zm9uVzU0MDVjR2ViOUJMWnBSb3ZIczUxTFo1UlI3RFJNOUc1VzcwNyt0UlMrWEYxSnovQUNJaWZrck42ZHZXcHZOYjFMc1g2ZjhBNzEyWlovdzE3Mkd1U3oveXc2eXY5WTkwL295elhxNlVSYUtKNWRVMWpMY09kV1hPTmRlaGVkVzRxRUZyblhHRUhwdlZDMDcvQUlMbWlRSzQxVDRHRjdxeUIxUzJuelRKd0NPRGY2VndYZUZYL3MxcWd5Vyt5N0k0Z3RiV29Lbm9DMXpwR2x2TlFLVnp3NXQrQzRicmRxWkcwUExHeFBiVWpFbHlpQU1uYXJZN2hadnczS0hTZTE3SXJ0TG1CK09ROUJ5dXFNVHRWZFlWSENtVFd1OXlFRHlUcVJZOWhqQnU2VER1NVNaTUMyYTdxRG5jOUFDbVFQRERRMGNObGE3MEJaM0ZvcGRiSE1mbW14eVhnVGlHblkzWjNObjlmWGt0SHBEMTkwTkVtbG51ZmFxZnpSamNIQmpvV3NKR3NFS0pqUThzWkc4Vkl4SmNySXg0Sk1NdDZvM0tYTjMzbVI0THJ6YVVBTmQ2ZjJ1NlNKejVpOG5VcG1uT1IzcGM1Z3dIWjBvMHhIY2VvNWFCQ0pwdnlIWTFPYzJBbG8xbXVwZHNOYlhEVW14NXFoZHVQY1lhMDQzUTVWN2g3UndTS28rZGtzMzJ2bDNVdUJ2RXRMZlVhcVFzWWVNWVl3ZHpWYW54Wnd2bUZLT0FvMnFta29jMCtPN1QxS3lQZG5MMERlQ0dqSDExVWJpSFoxdWNPRzl5Z05vTWtqNDNPMHRlQkNHYmU1M25NcDgrNXNtZHZTTVpTUU1adlRwVEVIUGRpUzdGYVVEZWxvcDFMdlJ6MEo0VFg2eCthN1hzcmMxVEd1OVppR2tqMjhJSFlGZEJ1VGJZbjhMOWNsUXEza3dSeG1yalFrSmtiQU00Nzk1cnAwRGVya0Q3MXBMcTU2dGJtK3U4b1QybDhFMDdYZDVraStlOVhydDk1RmJ2Ti92YXBJUm9TUlB6clcxNEkzSytBSENsVzFRUE5rbjlYWDNVVXJxbHJUc1ZsYVdudllOL253b0Zabnk1d1BoRktOR0RxS043UlNWczdwT2JGV3NHK3hzcm1sdEcxcFQxcDdhUHplWUVUZCt0V3FwZm1Ic294bTdjblNzYysrYWFKWjg2OXlJV2pDNWVLTjY2eSs3UTJuenorU3Z0ZDMyK2RFRFp2VHNRK1FPdk5OTmYrOFUxdDY4K01VNlJzS3UxeEdJUGNZWXJQZzRuSksxbkJzckw3dWVUWVBWclF6SUxIRWk2VHF1dTJrcXJydWRoazcvZFAyWEVjMjFFSUYvY1dqMGg2KzZHaVRTejNQdFZQNW94dURneDBMV0VqV0NGRXhvZVdNamVLa1lrdVZrWThFbUdXOVVibE8ySys0eXVCTjV0S0N0VS90WjBrVG55M3lkU21hYzVIZWx6bURBZG5TalRFZHhNRHFKb3FDTnRPaGNDN0h5NDZhTHZWc1RyVmhmcGNqSE9oTTNPV21OdzhKZ3dmOW9JWFM0K2xzaCtTb1o0ZnN3T0tJenRvbE81Z0VZL05Pc3N6ZTFxNlVXdkhmaWRha2plL1FlMzFwOGIzelRYVHFoWmg3emw0TDc5cC9JS3JJQzMwVnEvTUs0Sng2SzF3Z1h2WHFUREZIMmwyUWprRGN6MCtUdkhNb0dORlEzQnl3YXRTUFQ5SmJoL3c3K3BXVS80cmV2Sno5eFp1MTd0Nk1tdDQ3MSs1OTlmdWZmWDduMzErNTk5ZnVmZlg3bjMxKzU5OWZ1ZmZUTTg2TVJYdEloMnhOallMckdpZ0hkWVpZcHJOZEZvYmc2OXRDYlBQbTdsMGpSY3JUTTNOWEh5dWNOUG5WbTdYdTM0eWEzalRXclM2MDNhdm9HM1NvWlRtcmpaUTQ2Zk9wTFJCY3paQTRUbFlyQTI1bjRwYnp0TERsZm1yVDIzY3VTUjNkRjFWKzZwNTZpbXM5eTQyRzdwTzV5dTE1Nlg4NFRvbnVuK2JsaGprRjVoT0lYWmJ2ZkV0NzNpY01Db0ljd2Iwa1Y2K0huQldWMTNUZFBkYzZ1dkVxMU9MTzhReEIxd08xLzdvckRKR3k2eVUwZkZmcXV5M2UrSmIzdkU0WUZHMFhlLzhLdGRsVlpaczNTQXdsMGd2SFdyazJBUEFZTnFtbWxpTWplMk0yMXQ2bEJXaXRSbWRmREJXT0l2b1NtbWhFT2F2bU9xczlyZ1ptZy9Bc3JYSTd6U2ljbG92SHZsR3RoYmVwVnhLYzJWbWlEUyszZ3Ftc0xIUjZGb08wdHhYQjltVWl0UVczZElWdzJvMGphMnRlZEY3bkZ6anJKN2pEV3JPemMzSlA2UTlmY1JRazBEamlyWm1ZakUrem5YZXJlVWNPYTcyWWIxTHgxcXpQemVrNjAzRGlkVlNwTE1ZKzhnY0dwM0s1REJtQTF4RHRPOVZXSVExdVBxWFByaTRJUHM3RENSUG1pTDFhNDBWcGhiM3FlSUNoTHVHdTFXc0prek43UFg5dmNONThqYTcxQkExMTBTTzBpbnlDSVJ4UnNOMCtVcG51NVpvclBaV2NPUTE5U3pMamVOM0FxS3lCMmlwN09INTZKckx3cXI4ZngyWkNSdVFMaFE5eEg1cUhUa3MzcjdpRmpzV2w0QlUxa05td0F2QjJjUE1wKzhYSVdDbDIrZGE3SkNWbDR3alJ4NlZhWjNNNzYxMmlhOUNaYUEzdjhBZzRtdXhQYlBpNm1pemVvRE5HWkhUeVhScGNGV3VhZHBuYkhKZGEydFA5NjFLRFV3Tml6Z2JWV2ExUU56YlpOYksxcDNCazNNYUFyMUtnbXE0cHh4VjI2NXJ0MUtKMDhiQ1plVnpJUHYzNzJrSDgrNVI5dFFPanJWelhOYlVPNk55N3hicjREYnhEblgrdFl0aDRGN2dyR1NPemdzdmNIODBIUUVURzdyYnRLZGNmbXBBYjFDNzJvNTIwaHBwcURVWVk3YTY3ZndxMXBJVnBsanRHZmtranBlZWJyaGp2WGJGcWl6SjRMMjh5WkRJZk44M1lzTWsvcTYrNnNVV2E3MjloTGhlT09Da21raU1qTStXY0xpeFdpbVlPL1dWcmExVWtKMFdCL3dWa1pIWE5tTXVjYThMVXJOTFoyR0VQbHVPYmVxcllJWXpISlo5dDZ0NVNUeXNyTmNMbTQ2dDNjMmFncmhSWDN1ZUhVNUJvcXdQdjd3OFVQdkJHR1FOci9aV3RsZnZESDFvdVpuYktHY0tDVGsxM0hhMHJURjZJNmtRV1lkQ0lMUGd0SmxLYXFMdmZlbkJVcjdFWVlEVzFIMTV2blB5Q0xlUmV6WTN1TmIwaDZnb1dNWm00SXFoakRqUnU3blQ1Vy91dWJXUC9DYnBYbnNBeDNqWVU2Nk1LOXhhUFNPNjh0cmZQSG5jMjJvRjZtOVdtMWRwNE0xTXpwVm5qYURtWHR2T2FUcVJnTEt3Rmw1b3FwMmtkOUZvREd1NWpSVDJSa1piS3lPOEpiK3RkalJFeTY2WWFXUFFvc3kyNnh3MzdWSk1OTzBmMHFTeU5ZUk0ySy9uYjJ0V09LV011bHREQ2I5N2c0VlFNMFpuZTZmTjRPcGR4b3BZbW1yV25ESklmcnJGaEhxVkI2MWRZTlg3czZuODM2cWtNam1OMXh2R3VtNHJTbHY3c0tFTFB2cGUxYUk0U2lhWXMvMlNtNEVJNE1RK1pVVm9rbDdabGovQUhyajN1UGVHK1VmZ3NUZGNGZGFmYmxMWEFPYWRZSXdRa2EzVnhZZGptK2hPRFh0ejB4cEUxNk1XdDRPbERJNmoyOUIycmdHSS9XSXI2Z3NSVDZTYU1jcGhDYTdjYXF0ZTRnRUV1YkJCcmd2Q1Q3b1hoSjkwSVo2azdOdUZDbVRSbXJIQlg0blhIM3dLcndrKzZGNFNmZENraW5sdmpOMUdDdEVqRGRlMk1rSDFMd2srNkZPSjVjNEEzRERLNkt4VXcxeW41S3ZiVW5xTkZqTG5tN25yT00wWERoTjNLejVpWE4zcTF3WGhKOTBJU1NPdlNBa0Vyd2srNkZJeWViT05FZGRYT3MzRE5jWmNCcFJlRW4zUXZDajdvVElwcDc3S0hDZ1djZnBPUEFidlhIWnB1NW1Dd3RjbnJOVTJDMTBEandYanUzOUdXems0YVM3TlBlMHRZNXVpVHR3S2pzNGRkTDdQb25uVmhheHBlNWsrbnpZbGRsSW1hVWhnQUE5Ui9OZGpwWHdSMmVWMHVsZFpkMkZkbW52YVd0ZTNSSjI0Rk5zWmZwOXJVdVUrS3RJMnNkYzl0UHpVSHI2bGFjM2NtajdiTlkzTXJkeDFxMFdpenk5K2dhTkFOclZZNFR2c3VJVmlpZm95WHVDY25UZ3Nkb3lCZHIyb3VrWlV1dk54cnZWTTMycFBxYWZaNmtUWjUyeU1wVzhmT29GTkkrTU1iSFhXZGREVEJPWThYSHRPS3V2YmRkdERtb1V2ZTFERUZZZ2p1WW1iUnBKcmR3eVdqMGg2KzRzNUpwaXV5TnBtdnN1dTczdWNvNGIzZXpEZXB6cXgvem4vVVZKSVdPRVpHRHFZYWs1MW9EdG9aVnRNRjJJelR4RyttQlBRbTlzTlpDN3RzY0VVcnBhMTJTRTQ3d0dETkVqYlJYWW9YeVdxYmhYV1Z1OXhHZWZJMnUxYVBHTk41blNyZkk3QzhRTHU1TWlsSnpiUmVvblR2YVhlUUdxenlzcUJVREZXa25aZS9KV2w0Y1h1Y0x0U29ZN002NUhDM1RKNVJ5Rzdyb2hmMTl3M2NHcGplYkpadlgzRm05SzNyVS9vdnlWb2xra3pWNjBjS2xkUlhaV2dyZmlCQTlSVnJpYzBzZm5OVGhUY3A3SzJUUzdYQXpkTlhPdnNGUVV1VFE1NDYyWXhyc2c2ejV1ZHVjQU1MbTEzWS83M0swUmc2ZmExS2UzODFZSW42TW5rbnVEN0ZnNjkwTFdtTmV3UG9zUlZyaGlGUFk4WHZqeGl4LzNzVm52c2U0d0FpT1d0M1dteFJNcklmM2t2NUlmdHJJYlF5S3JvamdTcThCbXVyOXZRcExOWjNGemExcXBEUG83T2tMUnM3T2x3cXVKalAyQWlZd1lIZlUxZXhYYlhFSHNpTldrY3IvZTVSdTVXV2YxZGZkZGpwbU5Mb2hFYXUyYWxOTkcvUDJlUzBFT2pwcXgxcnNpKy9tb3J3RmFWdS83cXI0MVNNQlhZek5TQ04rWTVXM1VyTUgzYkxPNjBZWFcwQXgxcTM5dE5ZM0NsNWphWDhGYlhORW9qYkNHdUdHckhValRWM0JPMEJIQ3JhTFdya2cxY0YyMXZRbTJZNk4xdUJUb0xOY2tkRnhyZGQwZEh6VFdsMlpsT3ByenI2RHRXcFZPaU9kTmhiT0h2SjVHTk9sVVpyT0tsWkVYUkFhY3RxZHdZR25kNVR6dlVyYk9Ic2JkRWNVVFcxMFFkdldtdDdUTWQxM2ZKM2J0eUY5OXJKYTJuZWJQczZOWlRuMmExNStHUENsMjQ1djFYRGNxRWk5dEZVMWpEV21MaU10bzlJZXZMMlFjM2hCbFI4VmJMUzgxZm5LdUt0ZHBlL3ZZZ3dkdS93QjBWaG5ZYjdUQVJlM3BrcHdJbWJmOVJWcGxtdk1oYkVDSEJkaWZxd2wzd0NiS3lUTzNKanBVcHJWdTg1U0cwWnR6QkJYUE5iU3FzTmJrME4wNmQzRm1HcE1mWlJldjJ3NXpvdkg5RmFMdXF1U1ZuUFZYYzRMMjZxTmNRcXErMGNaaU9aLzZxRzB4VkRaTVd1NTEyNU82Z2pkaHRjVHpCVHZtd0o4SWNQaEVQbWcxclExb0dBR3hVR3RWWTlyZnF1V2swSHpYTEdONCt5dFJIcVdMbllPcUVKS2t1YUw4WjZOYmZtZ1piTkhPRCs5STBtZEt6akl3ME9PSE45TmFJdklrTGZpckhKdmhiWHVMTjVweUMxaVlQMFE0dHU1Sm8vSmYxcUJtK1N2d3lGanRZVFI1VENGYS9RdTZzbHA4d1pKM040UkYwZXZJOTBETHpXNnlUUkVIQWhNWnlaQmRLc24ydmxrdFVPN1N5VGVoK1lROUVNbFJaWktlYW1Qa2dmR3loeExVV2NtTm9DYkd3WG51TkFFelBzcGUxVU9TQ1U2eXpIdXBPanVMcjVYdmJ1TGsxMmVmZWJxTi9VbkZrejJrNjZPMXErMTdtdjNnNHFqNVhQRmE0dVFEcG51QTFWY3M1bm41enlyMktjek9PdU9OWEM5Z1ZlWTRzZHZCVG5ObGUxenVFUTdXcjdKSE5mdkJXY3pqczU1VmNWV1I3bm5lNDF5dWZydlk5QzVrVzJkemMrelNhSEdsVmFXZGtNK3d5M2FrY0p0RHM1aytZQmxuYTYrNlp6M1VldzhtZ1ZqRmt0ajdQTmFCZWpqa2JUcVhhTjd0dDEyL1FDOWhXcWxaYWJDMXpKVGpLTU50VmFiVmE0UzZON2RCbXU2ZGl0TnBpa2N5VzlTT0tsTU5uZGJsZmMzUnUzc3RvOUlldnVRMThyM2dhZzV5djUrUy9TbDYrYW9EUFBvRFVhVzFlRXkvOHdvWjJSMGxOVjUxVTBHUnhEZUNLNmtNNUk2U25sT3FneDBybk1Hb0Z5OEtsLzVoN205dkZWV2xja21hR2tYVmNONmxBL3NQa25QaWFIR3RDb25Gb1pLVGpSVzZWak00OGJQV21HbDB1a29VeDBFbVlGMmo2YmNtaGdhOXlUeWN0bTlmY0FnMEkxTE9aNStjOHE5aXJoa2NXYTd0N0JWN1lscjU1UjcvQUNZNG5US3ptZWZuUEt2WXE4eDdtTzN0S055VjdLNjZPMXFzY2ptSDZwb3M1Zk4veXE0cTlJOHZkdmNhOXhJem4xSnpXdmRBNFkxMkptYWRIYWNNY2RlS3FXWEhBN1FxMG9vWmFWNUo2d3BJNGkwUVh4VjE2alJYblZvaGxabXBtYmQ2WkwyUXBMZE5hUGJwRWM1K1NhNjAxREJ3STl0T2Y4azFyTkFEVlRZcnpHZ3NHRkhsVU1EL0FLMU5pb2FqbmNLSy9YUjV0YWJhSzV1TURTQjJJU3Q3eVdIdlRlWk56bkRwalRKUDZ1dnVyalpYaG5raDJDT2JrZEg1cnFJc3pqcmhOYnQ3QkMvSTU5TlY0MW9tMWtjYnZCMHRTckpJNlEvV05VR3ZsYzlvMUF1VG10ZTVvZHdnRHI3bW05ZXRlU2VaVkV1cm1WQlFUVXdjUnFYN2JDNTcyR21lamRkbGpQVHRDOEl6bTlzMWx4K0NMTExFK1I5Szk2ZTlvQTlxZnhUYnUyVnpuMTlxWVpXOXMyeHd2eHdFM1lvVytXOU5rTjJaOU1YdDFWNWxFQzRORFhWMGhVZXhhYnBaZnQzUjdBdUkrKzVITVN1YTdZSkhYaDdkWVViblBxUnduT1BDUFNyMGtMTTQ0MEFNb2VuU0hXOC9ETGFQU3U2OHJneDdtQjNDb2RhTEd5T0REcmFEZ1ZkTThoYnV2bE5EWjVBQnFvL1VpeSs2NFRVaXV0WnN5dk1mazNzRUtUeUNnb05Nb3gzM1p2eWE0SXNEM0JoMXRyZ1ZtODY3TitUZXdSWTJWN1diZzdCSE55dmo4MTFNck9mQk9mTEErdjhBYU5YYTdKblBJT3FSRWtZSjhlMGpSNmRpdFZpSXdEZTJMUHplVTNyVHBHdHZaclNBM3U1UHhUSWRaSENPODdUa3ZnbS9rdnVkUURhU253MmVmT3lORlNkaXZFMTNxbzJvY3psREdLWHJuZkhGVnBzbzNvK21uM1BvOElSN1lubHZ6N2l6ZWFjbi93QXUzSmF6enQrYXNqZk9PU2R2UjFLekhucDhGYS9RdTZzbHA4MFpQdGpJZlNsV3YwenV0V1R6MVkvdGZMSTVubHhrZlBKTjZINWhEMFF5UmVZTWxwcnZIVW9waGpjZFZXZDlra1pkclhTSzQySDNqK1NqZ2tJTG0xNFBUM1RndU5ZdU5ZdU5ZdU5ZdU5ZdU5qWEdzWEdzWEdzWEdzWEdzWEdzWEdzWEd4cmpXTGpXTGpXTGpXSzg0dGVHN3NnbFpkcVBLR0NraGN3dGwyVjB4NmlySEhITGN2MlhPeXVyZkFLZm1UZmZCbzF2VndwWFVVeTBPZ1liMkY2NWR2TkdvS3oyZDhVc01jUnFBeDRPSk5TVTYwd3ZxSDhpNWR1RExUdUJ0YTEycmVWZDVSeE9XUjRrWnBPSlhHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHc1hHeHE4NXpYdEIyWk1kZVMrVzZlOUVNcmp2VFozT3EwY2xTWExRWTJ2MWdCTWJkdkJnd0J5aDFkWGNVSENPQVFQTmhsaXVPRGJ0ZGE0Mk5jZEg4VnhyRnhyRnhyRnhyRnhyRnhzZnhYR3hyaldMaldMaldMaldMalkxeHNhNDFpNDFpYzh2YTdEWXU5dFpLMm1reDIxYWNja0ZNT2hNdVB6clFLWGlybEZKOVVnL0ZRVHVqN1lBWndIQ2d3VHJYYTdqbU5PaTA0Vi84QUNiYVpoais2YTdaejlPUnBhK2pSczNvQ3FMbkdqUnJLM3FGNHV0ZUhidGFqRmVXb244SXN4ZDA1WklXbWhkdjZWeHJGeHJGeHNhNDFpNDFpNDFpNDFpNDFpNDJOY2RHdU5ZdU5ZdU5ZdU5ZdU5ZdU5ZdU5ZZzdPc3dSQWVHdWFjZHhWSmU5T0cvVXRFclMxclBVNE9Fbm0vb20wckhNd204am15NEc3czNLYU1zYThpbWhydk8yRDVsT0FmU0F1ckxNY2M0NzU5UVYxcmRIV2J4clZVYzI3ekk0cldycUxLa2djSWVVRkZFRGczRERZaFRabGxlSldVYzRsY2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4Y2F4VkV6RmNjL052OHNhazR1ZERLemtQYlNxNGZzS3FteTV0K2JCZU5GdGRZUXZzSXZXZ1ZxTndya09qVnUxT2tmUmpBTWVaVHNzYjgvT3lJdkdHQlU5bHRUN3pKb0hCclFNQVZBRHlpWXloVFd0Vk9aTlp5bk93VXRvSTd5MDRjLzA5bHRZR3JRZDh2bXByTWRVcktqcEhjV1h6VGtGbE4xc1FBR0F4TkVJNDJsN3pzQ3VPNHh4dlBVTGQwWHpVVGQ3Z25IZXdLeXUveFIxcTEraGQxWkxUNW95ZjZneWY2aFZzOU03clZsODlXVDdYeXlXZC93QmZKTDZMNWhEMFF5Tloyc01CVGhvd21FUjZOYTNrTFpHS2xvcEowYjhsUnBSSGhzVFpZblhtSHhwekg0dGNLRlBpZHMxSGV1ZkpmamNZM2J3cFJveXVlSGFiOWVPdE9oekpEMzNiMVhhTGJ2a3FHR1ROdXV0MHM3Qjh3Z0xMRTB6SGxSU2FMY25QM0diYWFlVTd5VUpMdDFnNEE4V2Mxd3EwNjA2S3VISk84SjFINjBLRlV1aGJlNUZjQ2RTcGxxY0ZuSGNIWjR2OVU2a0tUWDRxNlViMWdLQmFIdFQ0WEVzYzhiTmlqekJaTGg1VkNvWUpJWE1zekJVM3VyMW5JNXJvNk41OXFlL1ZkQ3VUU050Vm5lY1NKQWJpWll4SEpCWnI5QUNLWHVjcHRuWk5ucFNib2JFTHlETHVNZXNxS3pzT3JFcTYzeFl5TTNhU2JFKzZHYnBNVysxRzYxOEYzV3c2bkk0b3RkaTBpaFRRUm5KNHpkMGh3cnZKUHFXY0dnNjlYUjFLNjRGakdrNTArVjlRZk5CclJRRFVCc1JEaG9xN2QwZWRWdTRxdEU3Q2lkdk9DTGlPK1BOVDlIVDZQNndWNXRqempkdDExQ25QWTNTSW9xZ3FqNTJzZjlZb1pxVmo5K0t3UVE3WDRGdzhHbGIyeXRkaUR1MW8yeU53YzlrR0pGTVRYblVjc2RtemRwamZwZDg0TzA2TzVHZHZiRVV1ZEJBYVd1RlRpbkZ4dWplaFhXc0lpR2pndTJEblRZbURSSDA5cGc1ZDJyT2tKc3NUaXlScHFDRUlaYVIyemQ1ZlJrYUNhWGpRYzZzdm1uSUxTV1ZpcFhBcW93S0lrTjZXTTBKM3A0OGxvQ3NvL3dBVnZXb1hiNHZtbXUzRld2MEx1ckphZk5HVC9VR1QvVUt0ZnBuZGFzdm5xeWZhK1dTbTJnT1NiMFh6Q0hvaGxkNkkvSlk2a2JUWmgzamxOOGpKWFhDN2h0UUl4QjFlTllZVE40QlJqZTI2NXVzZHlNVndsaTVYaHBjeXd5WFdhaHJkdVF3cEFOZjFrQU1CNHZ1a0hCS090anhyYnZXbmdLRFNSdWtHbTVZakpva29CektEZW5YQ0hPM0xUcGU3aThSM3BVSGk5MCtwT1k3QjQyWlk0NDJoOHV0OWRnUllZM0Q2MWFoT2xaSmZ4b2dTNjgzYnpaSE5FclhiNk9Ucm5mSXVTYjRkMXAxS3hEYzRsdGV0T2UxalhUVXdOMEQxSjBzeHZTSFlFNldYam42K2J4aDEzZ0htclJFTWZtbmU4MHF1UzNQYXh3cDN5TjFOb29VQkcyN25icm8rWXUvTEZNaGpHaTNVaUswN21SemRSS0QzN09DUEdMN09GdENwa2s1bXNIV1ZaWldVYXd0elJkNUx3YWlxYkkzVWZnaS9idVZXNU5TNzFHeHptbkNqZFN1eWdQNXRpelRjNDRqK3oxS3B2ZERqNGpKZEhlcGROaURtbWhHb2hOZzdKWWpaT1Btckl5SjFiTEZmdWZXMFRpck41cHlVL3dDRi93Q25KYVcvVUN0Uit0UldjdmNHdER0WlZtZEhJMlRYVzY2dVNWMit6Vis3a3RQbWpKL3FESi9xRld2MHp1dFdYejFaUHRmTEpZMytYWldINFpKdlJmTUllaUdTTHZiZUFOaXFHQnZRRkxBTE9IWERydktLQTJab0VqdzNoSnNrV0VNbXp5VGtncnJibytONXdhRnBEZEYyL3BSamxZWTNqWWZvQmRGVzdFTCtpUEpHc29QbmJtNDlqTjZEV2lnSGpOMDRQSEJkdVFNZ0xUdjJGWHBZN20zdlpWR1RpV2cxYlYzeUl0Nk1jRmpvOUlXd3JSMFR2QzBob2pXNVZ2Q2lGeHZyY3I4bGNkcDFwckdDNjBhaDR5S201STNnUEd4RVBZQzhld29oa2tjUjM2eXBZNDc0MnlTa1lxelNNbno4TDI0djFERlR3bmhCMS8xS2gxY3l1U05vRGdCekxVNXVqZDExd1F1VGtNYWEwS05aamFOd0NBclE3a0RRRjQ1Ujhab2NRcjBlTGQyU2lrMDN0REJlT0d5dEtxNHlScnBHNnhURllJbHA2Q211RXZNN1Q0VzhxL25LaXVvdnhvbkIwL0MyM2pWcWNjNlhPUHc2RnorTlhoZzVhVVY3bjJLUzAyb2xzWWZ0MFRJNzhnbmh3RWxuZm95c2RxSTJJWFg1eUo0Mm5yNTFvTzlSMW9VTjFhbFV1THViWXNYVnBzYXMxRldLUGJSVnBwZFhpVHJnclBGcE01OTR5MlQ3WDlKVm04MDVMempRZHEvOU9TMU8zTkFWcGR2bGQxOXhYL2hTUGhrdFBtakk3bWVNam03cFZhbkRVWlhkYXN2bnF5ZmErV1RzWEx1WUcvRDlNazNvZm1FUFJESkYzeHZBRzFZUEI5YXRYVDhsWkhIVUpXOWFadnpvcDdEa1p6dlBqbHkwUmg0MmN5dldTZTk5U1JYYlJFNkxweURMM3VOeitnTHZ0SUcrMHFyRzNuK1U3WDRoWDZRdGVBNXAyRkUyZDl6NmpzUWpuWUR1dk0xS29sdTZWYWJFQTZYVjhTczQ3RTNMdEFyclJkQ3VzRjRxcEdiM3VkclZRTHo5NThjdXZGUXI4VGZqaW1zSk4xdThmTk9GcXNwcHNMTkpCdWNkM3ZnVFhkZlNnTlQrYkZ2dFJMZGU5Y2FCNjFoZWs2bGpnTndXSGpsWW41bC9SZ25oelRMSC9oRFdyeE9seWhSTmxCclRBanlncjhicjdWVm51cWhHS3dhcW5CWWVPRnJ4VnFySFduTWRTUFZJMWFNTWZUbkN1OTFaMFBxRXlPUitjZnlpcmtFVHhHT1hUV3RPKy9tSm9FTTVQVWJXdGJRSzdHMmc4VXo4WS9aNWpVZlZPN0pZL3RmMEZXWHpUa0RYeXVjMGFnWGFzaG1kaG5EWDFJbmVwRzJobDlnanJTdk9qTEJGY2VIRGxISkp6UlBIWGtKaGtkR1RydWxlRlNlOG5Na2Zma2ZYRjNUZ2kxd280YXdqbTVITXJydW1sY2pyU1JvUmlnNlZaUHRmTEpIdmJDeDJTYjBQekNIb2hsc3ZucGxvSEJrYlE5SXlET1N1a3Bxdk9yUlVHSlVFTzFyY2VueDZqbWh3NTFwV1NQMUNpNGt0NkhsY1U0OUx5dEN6UmoxTEFVL2dPbkV4M1MxZURqMUxpZmlVQVlHcWpHQmc1aC9BTVZqRUZpQ3JyS3NHNExUdnU1citDMElXajFlUDQ1Tyt3c2Y2bG9zdWRCVldTdVlzWkh1NlZxVk5uOEF4eFhCcDBMYXRxMWVMeTJlWGd1K0hPbjJlWVVjMzQ4NnNmMnY2Q29USEkxbDBjcGNmSDhWeDhmeFYrMHk1MzZnRkFuTVpvNk5BdVBqK0tsZkk5cjd6YUM2cElHT3VsMUtWNlZ4OGZ4VTlqYzlwZSs5UTlJWEh4L0ZjZkg4VngwZnhUSUh1RGlLNGhaeHB6TTIvZXNIUk8rMHYybVlCdTVpYkZFMjR3YkZEY2UxbHl2Q1hIeC9GQ3l1TmU4M0NmVlJjZkg4VStWOGpYZ3NwZ3M4eVJqUmNwaXVQaitLNCtQNHFHWjB6Q0dPcmduUlROdk1LL1pwMmticEZpNklmYVFtbGRucFJxM0QvQUNNci9jVERSdFRPTGQ4bFo0cFczSkdsd0lQbWxXWVdWNFpmQnJvMVFjWkd1SFBGclRleU5tNzFQZnV1R3VpNDl2OEF5d3JQYUp6ZWxkV3BwOVlxR1d6T3VPZExkMVYyS1dXMHV2dUV0M1ZUWUZIRlp3RGFKQldwNUlRYytVU3Q4bDBZK1NndDBMS3l6NE1hZGgycS9udzV2a21JVVRMVFM0N1U5dTRxZTBRRzdLMmxEVG5UYjh6YnRjZTloV1R0VjkxMGxhNFZWbnM4MG9kRzZ0UmNHNVJXWjhvTVJtdTB1QlMyWmtvRVFsb0JjQ3RGbmdsRFltMG9MZzNLd09zMGdhSmJNSHUwQWNWMkptaWtBZlBFVEpvREhVZzR5Tkk1NHd1MzdQU0djUzNINFZWcWx0VDcrYmRoaFJjZTMvbGhXbWVaOTZaam5VTk9aUlFUeWgwWkI1QTNLYWVCMTJWcEZEVG5YSHQvNVlVVnNscExhNUhscmNNRmZ6NGMzeVRFS0psb3BkZHFlM2NmRmEvd1NuK1JPQzFybStrZ3QxTHM4VmNSeWhTaXNYbXVYWW4weit0eXRQOEFPL0lLMTl1U05aZXUzYWl1OU1sczV2Uk80SkNzL3Ava1ZhUFQvSUtMK1hIV1YyQXcvY0hxYXJCTzNGc1VyNzNyS2k3RVc1N29Mc2w2R1J1M21UNFlYdmUxejcybXJUMHQvcUNFbXd1b3V4bE1mMk5ydldWWlc3bk9IM1NvUDVsV2owNnRuMmY2UXJDTnNjWmI5NG41cnNCNkEvOEFTckNmK0tQL0FGSzFmelk2bDJZZnVhZjZWYjMrUkVQNjJyc3F6Y0svQS9rb1BOZDFLMGRMZXRXdnR5UnJMd2JkcUs3MVpMYlpPK1dkanpVdEgrOXlpN0UyNTdvTHNsNkdSdTNtVDRZWHZlMXo3Mm4vQUpvMkx6WExzVDZaL1c1V24rZCtRVm9JdEdaelZPUld0VkJacitjelk0VktLeituK1JWbzlQOEFJS0wrWEhXVi93RHg3MEI2bXF6c3R2Rnl1ZUtYYTF4VExkWVhGOWdtY1F5dXRwM0x2eHZTUk91VjNxMDlMZjZncHBQSXRUZmkxZGpvM2FnNWpmVUZENlIvVVZCL01xMGVuVnMrei9TRk5DZVE4dFhZRDBCLzZWWWY1djhBN2xhLzV0dlV1elI2QjdWMlp2dmExMlpGMEU2OGFyc3F6Zlo2L3dDL2FvUE5kMUswZExldFRnVDVuTjA1RlZaN0ZicE02MTE3OTN3c2YxVExiWWlYMkNaeERLNjJuY3UrbTlKRTY1WGYvbG5oNDlZdk5jckwyUHVBTWhjVGUzMS84clRGRExhTC93RHYyS2JNeHh2emxLMytaTXRNcld0Y1hFVWJxVm45UDhpbnc5clorOCs5WE9VVmc3SzV1NUhMRGRJMTNUVXF3MmR6QTBXWmwwRWJmOTBYWTF6bUc5RzRtUWJyeWo3RzNCY1pMZnZwMGp4VE95WG05Q3RYUzMrb0xzeTNjUTcyWXFJK1EwdStGUG1vUFNQNmludkxOS09hODBIbEJNZUdhVXMxNGdja0syZlovcENuM1BBZVBZdXdIb0QvQU5LZzdIWEFHUnlYNzIvL0FIVk9lOFV6dHBEaDBMc2lQS3REQjgxYWJRMllSNXJaZDE0SzF0OHF5UFRMVm04N2RCMGIxRjJSSGErWXpaajVkYTFjcGpBeGo4NVN0OVdmc2crTm9NVTdtdXVic0ZIMk51QzR5Vy9mUmtlS1oyUzgzby91THpmUWMzOTVjZkVOYTEvVE43WWdaTVJxdk5xcnpiRkNENk1MTnpSdGxaNUxndkFZZmNXYmhqYkV3YkdoQnRvaGJNMEd0SENxOEFoOXhkclpwbVlwUzVkd1djanNjVFg3RGQxSWdpb09zRlgrMFlhK1lxREJHS1pnbGpPdHJncElvck95T04vRGFHNjFmczltamhmU2xXdG9zOUhaWTJTamxobUtIYk5uWk5UVmVhajJ2WjJRMTEzV3AwczFraWtrT3R6bUsvUFpvNW4wcFZ6Vkd5U3l4dlpHS01CYndWVnRnaEI5R0ZtNW8yeXgrUzRJdzlweFpvbXBiYzJwMGNFREltTzFobzFxOUZaSW8zVXBVTVhnRVB1SjhiYkpFSTM4TnR6V3ZBSWZjUmhoaFpIRWRiUU1GZjdSaHI1aW9OWGoySm9xQjFVVnFLd0t3TmY3a0QrNW1zZTMrNnVKeFYrb2EzVlN1S3ZZYVhQcVYybWx0dTdVR0NoODQ2bFFHNzVXR0N1MW9laldyemVFT0VhTHZtS3FQSGVkVnFMcXBKYTIxM054Vk02NGM5eGQ1dERIdjNiY3Q2QWlZZjJjbnlLTVdNTnBIQ2lmcjhmMWptVlh0QllOZ0dzSnJ4cUlyL0E5STBXazhWNlZvRS9Zai9OZDZaSVByT2NzYlNCL3FKdWsvSFZpZzJRNTF0YUhlaTNVNGVMMFZPNnpZTlg4MnpMbUxQOEFhZjhBSkcrMHQrczExVmhNOXJONmFlUFk3eTJvdU1lYmVEaUsxL3VqZGpGNDdWZWthQ1g2cjJ4VW9ORGE1SFI5cFY4dXJSTzBlakZGejZZN1NGZmNkSFZqaXRJM21IRFh0VkNLRWVTRm9mQWFsZGR3dkc4ZHVvRFc1TmE5dWV0VCtMc3pEOFNnYlpNNXcvc1k5RmdYRnhSam9YQVk4ZWFGV3p0ek5vcFZsM1U1R0NkMSttMHJSZG9uVWkwNjFuS0hEVTl2Q1loQjJSNzdDZUJhQjgwSHRkZWFkb1ZQR3I4aFdHaXp5VTFqcGFEVVE1U0U0RnJielR1VmtQOEFoaks2V1YxMWdWWW1HeXczdHZLQ3JMYkhuQ2g1MTN1MnViMHVXbFIzTzN4cm1SaWdGVHZSdlMzUnpKb3hjODhrYTFkZ2pwdnBzOWE3OUtVMldOMVJXbUttYWRWejQ3Rm5IOFREcHY4QWtFK1FjSFZrdWcwT3l2aldLK3FqUnRPZ0xVdGZmWDhFSndkQVpIRGZzUWRham1JOWxGZXYxYnNLYTk5cEI2RTVoZGZaSkhyNkVXOVN1Ty9hYk41ZTFxcU1SL2Mxeld1dXMyN3ltdXdBSENOY1ZGSzBsd3BkeDM3MEg2eXFGYUtGNDRqWlJGcDBqWFpzUVpwT0wvcTRyVHdwOVZBRFRONnVLQVlMeExhODlGZU9sNjBLK3J4bStjVHlSdlV0dW4wMzB3NmR5ZGJMVmpOTHBIbzNLMG15RnM4a0RhbG8xYTFEUExnUk01amczVnpLeVA4QThNSjgwaHVzWnBLVjlOWjJieVZRYW00SnZNTWNqaXh0NW5LWXIxbTc3WlR3b0RySFFteXhHclQ0MDZNN1VXbWp3RFRCQU1jQ2E0Unk2aytQZ2wwZE9pcWppYnFZMmd5dXROcHdzbG5kZGdqOHAyMXhUbzREMGxWZklYK3RheWZ0MVFkSEw4VUd5NE84cnhMVjNSY2RpcTV1YnM3amdSaVQrU2ZjMW5hZGl3MFR0b21STkg3VGFOWjhodTVOaVpzMW5ma2hzNDg5eUxmYW9MQ3pqWEc5TjAvb21STTRMUXBPaEVnOEVDaUVWc3haL2FiUjBvRVlqeFdtU3BXNXF3d0dRdEQ3bk9GcE9MRHlhc3E1ZDhsdlk2eWFKa0ZvZ2M2TjUxN0ZIWllpMjhkUThrSjBjY1l6U1phWlg2WmJXNXV5M3lDOWxkZS9wVjl1citNMThTRFJ2VDIzcmxjRzN4aVNuUjBMcWFSYzNtVG1uUlkzVlFMTlk5S2NRVGRHMmljNjlRRGVGZkVvb2RWVmVnTFM0Nk5SeVV5UnpuWHFLb1dGUXF1cUtEWHRDWWE0amJSWUNtT0YzYXErTHZqSEoxb001TEF1eDFoNUxuM25xT094aTRDMnQ4VXdQT3J6bXRhQTNnWVVKVW4xK0R3ZEZQdmdCbklBRkVMSEM2b3Jqem5lVUd0RkpDRlFCYyszSnd4N1ZWdUR1dFp5bmVuY1BtNS9HbnZ3d0dGVjMyQzdKWEV0VE03cFhjZStNb1ZnQmp2V092bVhDSzRYdFFoWWFEbE9UbWdhdFFjZW9vRnRUWENvMWhCMXJkZTNOYmd2Qm1Lc1l6THVaR0dYaHQyN3g0dVkzdmMwZlZVMW1jNFNSUEdJMk9DYmNGNG9YK0tHayttNEtlMXUxNmhrTG5HalJyS2x0VHNXM3R2d0NkTTRWamh4ODUyeFNXdVRGenNHMXlUSDZxanozQWUrNmViblRnVGUzT3F1MDVUcTRybzhYcFdnVkFkSHVNNXBQbGR5UVVIM3cxZ3d4UVkyODFydFQyNmxuR0R0bCtxcmRhYXh3MExQcFRkTzd1S0ZQMnQzK1VQRlh5UnVvL0RGY2Q5d0xqL3VCY2Y5d0xqL0FMZ1hIL2NDNDc3Z1hIZmNDNC83Z1hIL0FIQXVPKzRGeDMzUXVPKzRGeC8zQXVPKzRGeDMzQXVPKzRGeDMzQXVPKzRGeDMzQW52bWRmZGZwcSttb3NTQXVFUGF1RVBhdUVQYXVFUGF1RVBhdUVQYXVFUGF1RVBhdFk5cTRROXF4ZVBhdUVGd2g3VndoN1Z3aDdWd2g3VndoN1Z3aFhaaWk0REVPeGZWTmxCTWgxQytOVkVHTWJtZFZVK04ra3gzRXRaeWlqbjVLdWNNUTFET0UxR29CeUxtdWMzcDJxaGhPZGFPS3YvRk5qQkR0OU4rN0xpdHBxcEF5dlFtT3FIdTFPRzVYRHl0WGl6M04xMFRubmxKenVWUldjYTZOZFQySm5tNU1WMnZCamFaTUI5VUxQUzZVajhtR1RUSzRTb0haeG5rcTgzVjQwYk5tekpHekY1RHFDdTVCdUFQcktmTEpveHRGNS81Smo1dU1kcEVidWJMbU9WY3ZJbWxXMU40Sm9CT0hBY25TSEI3VzhIdUE3bERWNHhGdnphaHJWcExLZ2pjclJ6bWlZYVVxNDVJN0dEdzhaT1pxRHlkVHZhVkJEUTV5WHZqcWMrcFJ4RFUwVXlPK3NhS2hPSVlNUGlvb1FibDl3RmR5anRsbjREVHAwM0pyOXUzNkRYOUw5YzZnczY5NXpnMUZDbnNRWVdtOXQ1bGNmcldCVjUxYjFLVkJUN0NRNlVFMUwzQlppSzBCdGNkRlNUU096dDBWRG1xKzRkOWxPY2YzTGlHbVE3Z250a3dlRDRwTDZ1dnhTVDB2eUgwOC9xNnZFcisydXBFU0c1ZTROekhCU1hJOUZnMGQ0VWpKWjgwOG1vQzdkdEZkVkltN2FmcW51dmFielUva0VKNUpDNk8vaUtvMGJkaFlONnpMUml6QjAxNmxPWk91YW51cDBZTFhrS2JkcmRDdkIxSFUzYlZKVTZld0hhaExTamR0TzRtYTJhalE4Z2FJWEgvZEM0LzdvWEgvQUhRdU8rNkZ4LzNRdVA4QXVoY2Y5MExqL3VoY2Y5MExqL3VoY2Y4QWRDNC83b1hIL2RDNC93QzZGeC8zUXVQKzZGeDMzUW1ReXlWMXRjZzBhZ2lyS2Q3eUZINXVSNzNhbTdQS093S1MzMm5HcFZCcXk0Q3BPcEY4anI3aHJ4MFdxN0ZHSGp6UUFoZmlkWlRzUEpUc2F0TzN1WnBHR2p3TUN1UCs2RngvM1F1UCs2Rngvd0IwTGovdWhjZjkwTGovQUxvWEgvZEM0LzdvWEgvZEM0LzdvWEgvQUhRdVArNkZ4LzNRdVA4QXVoY2Y5MExqL3VoTWp6MmpyZG9qVmtrTVF2UzAwUlZhYnIybHN4cXM0UlZ4VExKRmpZN09iOHp2TGR1eVltbVMwTS80UWRhQjJBNGptV1BGblZpaGQ0d3gvRHVYdDltV1FCK0FkdVRpSk5tNWNmOEFkQzQvN29YSC9kQzQvd0M2RngvM1F1UCs2RngvM1F1UCs2Rngvd0IwTGovdWhjZjkwTGovQUxvWEgvZEM0LzdvWEgvZEM0LzdvVFh5OStpY01kNEsvZVh2SnVwMDc4QVRxM0JSVGplNW5xVDNLQm4xRStSNW8xb3FWYWJZZUU0aGpQWCtpc2xraGNjeHFKTzNlcktPUzZXbzVnTm1TcE5GUy9kaGlGWE82MWFaSE5wZWNLRDVLekh5WndDblJ2eGE0VUtrc2pqcXc5bXI0WldoanFDaTR6NEp3RTJIbWhjZjkwTGovdWhjZDkwTGovdWhjZjhBZEM0LzdvWEgvZEM0NzdvWEhmZEM0NzdvWEhmZEM0NzdvWEhmZEM0NzdvVk05OTBJWDMzMzcwWnk3VE9KYVU5N3FHUnU3WWhQTWMxblg0VitDckd3c2hhMjg3YzlWQXVkQzBYMUNsTnQwNHp3YUhhcjhnY2JqbEJaTE8yOURjems3anMzRHUyVFZPSGlrdnE2L0ZIK2srUStubTlYVjNYYmQ3OTVkTGFLRnhsNGNUcE9EdVFmZnU5K0VlcmVyV0hPeGg1dGVLbWlaTVhTeHR2VU1kQWZpb29NNXcyWGk2bXJDcXRsWGNSemE4YWR5QXMyMmw0WWV0QjdPRzNESFYwcU9vek1iYU9KMUFjNmloYTNUZGk5d090cXpFZkZ3NERwMnFLRHl6cEhtVmxqWUx0ZGc1bExNNGQvYzI4ZWJjRkhISkVhWGFQZlhidlVqbXMwTTVtMnFsUUtZclduWTBBUW8vWHJVYm5QeGRpVldVQzl5RFRhcTNhQWNLNm1uTFA2UTlmZFJ1ZTJnZUt0NTFKZlpkdVV2WTZxcHBheW9jQ1JqdVRiamEzblhSanRRTjBFRjEyclhnNCtwU3hobFh4aXJ4WFVzN1R2ZDY3WG43bU1IVU5JcVRtbUhWa0tzMXAzV3FpSFNVWGV4Q3lsL3dDeVFWTXJodDMvQUpKa2JSZDdpNlAvQUF1MUxKaTB1cDBxa1lENWVWTFNwcnVidTZWUjkxM1NMeXprTGRBOEpnMUhvUUlOUnM3aTBkSGROWTNGeE5Baloyc3JOV2wxUnVJd2Z3ZWRQTDJVRFhYWFk3VTdSQXVnRTFlQnIxSnpTekZyTDV4MmIwSjd2ZWk2bDVBUEZDUlh1WHpiWEdpNTFmelVqNDI0TXFib1d6QTdOaVoyUGhybnBORjkwWSthaEZyZHJrZHZLak1FWXRKZldqcjJqZ3JMYnc5eGE0TW1aanEzb0VhaW03blJ0Mm95UHEwTnhOMFZUbXNaUnBHQTNLeFUwZGg2TzVaempMTU1lR1U0WTZ1NWprYzJqSDhFNzA0dlpRQm9jY2RoVWQxbGM1VzVqcm9nV05yVjl3WTdWZUxRVzFwVnJ3YWV4UGdFZFpXNnhWR1duZXdhVjdrQ3QwYlNxdHhpRzBZcThCVG1HU09KbkJhbzR4eTVBRlJNZ0g3dzQ5QVZtaVkwT01PbWZPS3Zpb2RHMnJpZktLaUxTQm03cEJPcE5lUXlONTJPZitXdE9jWmNOanpoNmdFNktLdWJMcW5EV21lVGVDdFR1VzNUSHRWbm04dGdLaG1HcDFLK3JMSFhhMWJVNXc3aVJ6RzFEQlYzTXI3R1ZiZXU2OXFrYUc0eGlydVpDSzUzeWxhVjlhWVEwYVFxMFh4VStwTmtMZEZ4b0YydVdkKzNWN212a2lxQTVPd3BsbUQ3Mk5YbFMwWmhXNjFHKzIrSUJWMUYyMUkyNitYR200SW5jRkcrVFN2WXlEY0UrTzlmWlNvVkpZbXY2UW41bXZmTmRUbHh3N2d0T29yNGVKeStycjhVZjZUNUQ2ZWYxZFhkZHI3WkhPcDBpaFF1OEVSU3RIcXdUUDV4aXRjM0tGSTMrcDJDdG5vbmYwcVY1ZUdBV05yYW5uVnZlRGVFa0RIVjdtSWZXV2xpMjlXaVpIRzNPTmRpQ1J0VWtNazlIVnF5bXA1VnV0VjY4KzdScUx0cmlyTTUyRGIxMzJxYTF2NHFBM0djN2dwZWtkYWtMbzNIQ29hY1ZhTDR2dHJxMWY4QWhPWkd3WDI2UngxaFp4MU5MUmFDbmdscmJtTzZxRkhqVDEwMkpyblBBSjFydlpZMk9ta2E2MVZyYm9yalJBREdtV2YwaDYrNjdITjhpN2U2RC80VnRmNVRJaXJKSjVNRXArS3MxemkzV3E4em9MVmJQU3gvMUsxdmF4ejcxcXVHZzJiVTVuazJvajRkemFYN21VVXp2OFk5V1IzUXBEeXUzQmRYclVyOXJHVjlhZ2NSKzBXeVNwSjhsVnZEb1ZjZlV0aHlXbWgwdUNwN1RTcmhvTVZmVmtvZFNGZUlrUHNQY1Q5SGRXYjByZXRQdFBsdGJUcE9IeUs3SGVhZjZsYklIZnZaN282YVlLMitoaCtTWi9KUC9xV2F1RzRJQkplcGhXdjVGUStnWjFkekI1bFZtV3lYWm42NkNwQVdJYTUzK0s2OGZZczVvNTA4UzNWNjArMzJpamllSi9OUzJhMFEzckxuTTI2a3RINFkxcHVYL3dBUGNIMkdHTjkvUzAzVkkxQ25xVUVEYmF5UHRZbU1QbkZ5L3RwNmxCSEs1cnBtc0FkZE5WRFZ1ZytMRjlhVVVjdXlTSk93MlhGbkl1RXdZYzJLQjJFVjdpRHp2bGx0UHBYZGZkV0tJYXc0ZXdraFdwNDFHR09udkxzYTRheG5lcFF2WnhjdHFZOXZzSzdKZWMzK3RXK2FOaGNSSTF1QXJ0eDZsYkkvSnRYNTl6SzkvQldkc2h2VTFzMm8vdUpOeEdpZnlWYzA2N3ZvcUJwWGJCNHFJVVp6bklHSGd4dEg1b3VCb1h2T3ZvcXJRT1hlQm9oZkJKRzVOanM0YVplVlExdW8xckkvbVRRUlE4NjV0eWphN2d2MEQ2MUxaWGNLenlsdnFVTDlWSFV3VER6WklPZzkxYWc3Z3VhRyswMFVVUndmbm1QZDcxUGt1eWZvbjlhWThjT0Z0MTNRV1lMc1I1cmY2bFpHYk8yNU90V0thUmpvM3ZZOEVPRzZ2Y3l5SnJyeGp1dW9uU0hiZ0NvNFlOZWMwbktiTVNsdDkybGV4cW1NR29DaWZYb1Vod2MvNjUySTE0UitHUWxVcmZkdWF1OVEzeWZMS2ViUTRCcmVDeGdvRkhHK0Zrb0p1ZzdVK0I3bXdUdDF0dnFqSkd2NkZ1UnB0eDhUbDlYWDRvLzB2eUgwbUdXZjFkWGRNdVBwY2RWdUNqSWZ3SzNmV21hUUZ4MTVvYXdBVlVyYjJFbkQ1MDlqcG80N3cwM0ZvYlZPWVgxYWFEVnUxS2w0VXUzYUZnT0N2R2xlWnRPNGk2VTJ1R090RU5iUzZkWTNLR0M5M3lVVWR2YUUyd1dhSUFobW1lYllGMzF0RHN5TXNjdEdQSEFmc2Y4QXFwYlBUaENpTHJTNjVhT0xJR04xT2pyVEhSZTdlaGNrdkg5NlFNZVpQWTVoa3Zpc1ExVTUxVnJMdHgxSDQ2MEdUWFFYR29idFQ4NnlPNDdBQUJBTW9ZNDloR3RhTGMwTnRlNG45SWV2dWkwUi91TTNyK0tlMThWWTNSdGFRSFk0YlVHc2l1eGlKekFMMi9hck0wc3Y1bDk0WW9zaWlMYnp3NTk1OWEwOVMwV1p2dnBrMTcxSTE4RHFPbHptakpUWjBMRFYzRnFQUXBiUjlkMVBhc1dxaldEcG9yRllhZDdpT2RrNjAwK3RXcnpBdXhGMDhCcGFWaGswNHdVMXpHM2NVOGY0cXMzUE1TZjkrcE1IMWNybUhjb3cvaFV5ejlIZFJ5VXJkY0RSUVg3T1doc2hrRmNMMys2cUZrMEprelhCbytpZFVVZVpzNVZXZ3l3bWtvYURkZlRWNmtXdGlwSG1jMjBYdFhPcEpzM291WmN1WHRsS0pwTVRoSUdCdGM1aGg2dTRZT2RNa3U2SUdEZDVUM2wrdmhhVkU1OGhBamJpNHRDQXpEbnhjb0E0TllnMW1pQmdBcEw3STg1UWd1ZXpXT2xWamE2SitzUGEvRWM2ZVk3VWI4alMyVjByTDE2cFUwcml6TmtZQnFzazdYWGJyNkg2eWZHUmRNVDhQWGlweFhHdDcycWcydXBRS0p4T0xDV2R4WW1iYnhkOE10cDlLN3I3cGdFZkJpTE5mUFdxdU9pckhtZ3h3dmJ0cWh1UlVqamE0QnBkamlvWXl5K0k1czRNZmdwR3hSRnVjZFY1YytxZU0zY3ZTM3pwY3lrYkpBNmozQjJqSlRVS2JrYm9vM1pVOXg5ckpXUnQyVHkyNjEzbTIwSFFnYlZhM1NqeVFteHh0REdEVUJrdHc1V2J3OWlPTkdubERrbllVSHd2N1hjZVhIcVJpTnVkYVkrYkFGZDhhWE44bHFmZGMyeWc2ODNIZmVWZGlpZEh2ZkxyS3hOVld1R3RwVFR5TFhGOFZVYTc3ZXROSE5rZzgwOTFNMERGOU1kMURWU3ZFZDB1TEMzSGczVk9ZNEN5U1VVY1Mrb0hRcEpnekI4ZHd0cnpLek9kQVhTUXRvM3ZtSFVnTTNWNHY2VmRybEVESGZ1UEpHbHZGRU0yeHpmT2ZYNWR4TUF5KzFOYmRMYVlPYVVPVGQySVNNYmQ1bERGNnprYTEzS0tFbmtnMHd5V2kwN1dOdzZWMzYxeU81Z2FCT2hiQ3llK2E0NjB4OW9KWTdZRlI4OFpBT2syOXBjMkNmWm13RU8xNTVyc1BZbTQzeTQ0S0ROWHI0TjU1R3dLMWlWOStNT0Z6NnFPUGljdnE2KzV6dG9MbU5QQUFYR1MrMGZrcElXRWxvcHI2TW9BRlNVSDJzL1lDNzNDeHZxeWQ4aGE3MUl5V1dyeDVCMTl6SjZYNUQ2ZWIxZFdTMlR2amJLWW1hSWVNRmFyVkRHeDl5RUc0VzZJY252anMwYm5PczE1ckMzQzhyWG1iTkZKTUkybTRSZ0hZcTF2ZkV4c3p5NHRvM1ZUY3BaQ0FYUGRjWnpiU24xaVptV1ExdTNjRmJHNWlPVXRub0w3ZVQvNFVWeUNPVnMxb0xhdUZhRG1RRFdOcXkxYnRiYTZsTTA2TVltT3JZS29PRURZNDg4MXNSQW9YYi9tdUlZek4ybTVvQ2xSVGFvclJOQzJOamJRNWhERzZ4aXJMSm1td1N2cm90Rk1GRjV5eE5HNzFuT0FBYXVJVDdTOFVkTnE1bXEwU0hHODdEb0dwTnpwZGYyRkZqbWtGQno1QTRlUUUyeTJrNXMxNzNKdjVpbjJ1ejZSTGFUTXBXbzNwcnBIc2h6YnFNdzRhYm1YTm16bkROUGdyOXFjV1A1QWFOWVFpZ0RZZy9GaGZ0VE1IZHREV09kWHBUZ0Q2Z3E2NnFSdDQrYnU3aWYwaDY4a1VmbFBBVml1eE5FYnpRdHU0WUtXTXhOemZrM2NOU21aUFlvb21zWWJ2ZWFWeDFxMzM0bUh2anJsVzdGSzRzQm1jSE9hYVk0S0NRTUdjYStwTk5ZcXV5dmVXYU1ZdTZHclJUM0dNWjRndkJwamduT3RWMjYxdUFkdEtzRXI0V3hGK0xtTUZBY0ZlekxJWE50T2I3MktZVm91eU1JczdJKzEyQXNjMFk2cXFLTjlsemtSaXErVVIxY0NzTlN0cnh6QlJNeVRTSGNwclkvaFN1dzZNaGFlVzI2bVJFMGZGYU5YY0htVTlQUENhMC91cHErb3BuUlE5M2FPaktXNThkc0JsN04zZm1yRDM3d2o2dkJWcHYycTR5RTRuTjh5aHM5OE9iSnFkekx0ZVdVRFJ3Y0c0VXB1VG9ZN1plYzBHLzNyVXJQbTdRSHd5bWdmYytTdERwYlFJb1luM2I5M1dvN0tYOFBVK214T2hMci9BRDBVVjYwQmswamJ6STdxYTZhY1FGNzdyRzNhMUt0TWozaHVhcnoxb21WbkRiUTlsNXNkMzVwb09zT1YwNHQyQmFPT2xoUVlLUHNmWnF2MHFhUExjbXhYcjcvM2p6eWlqZE54eXF5OENQWFZSTURuTVl4M2ZDRHova252aWM5c0JkUnBCMlVHejVxME5rYzV6UWFSM2p6bFROTVpMQnBuMUtoZG9TdHVBWEthdFNZN2tnNlh5VlJ5Vy9FcDFtTHFSRnQzN1NwdHl6SDkzREhkSFRsdFBwWGRmY1dJOXF4eTMzVWtjV2FoamlyYzZDenN0SmJOU09yTDI1UXNZeHR5NWVlellyam1ETk9qdnNic1ZtaGtzcllyUmVOOW9ab0VZcTN1RVRBNXRvb0RkMVloVnRSR2JEYTZXMHJzZks2QnNMcEhHOHhtQUlvVDhsYUpYMmRzWWd0RjN2UXBVVlZqaWlqREl5eXJxRFlyUG1ZMnNCYnlXMHlzdjhBNEhtVlJLd2p6bGc0SDE5eXkyV1RqMmF4dlJ2TWRBK3VJcGd0R1JZWHBEekJkNmhsYjZxTFFMMmY2eUpkZmw5WWV1K3hOaGw1bzdxdXV3MmhRWTR3U05jMDgxVTJQZThaWWVnOXhINXdWb2pkWlkyUXRqcUpBeW1LN0VETk0wMjZlanJ3Q3Rja2RuWk05c3RMaGJxSE1GMlJrZ2h3R3E4M1YwSzljYm43dCs5VEhXbk90VjI2MXVBZHRLc0VyNFd4RitMbU1GQWNFKzBTV2RyQkZQZElpRktoRUNGbWpacXRaVEFtcFZrZUloREs5bW14b3BsbUgxbFFxaUNlN1hkQ3gwWEs4N0IxS2J3cjE4ZEF5UjJhK0daeVFYcTdrQkxIRzRVd2N3MXdVajd1R3B2TXFCelhRVndpa2JVSjg4amJ6bmJzRTRTU3Rqa0kwUTdhbzdVYlBueFdsd0doS2pseGdhMEVacmYwb09rbE04ajNhVGpreDhTbDlYWGx1UnNMM2N5RWxxMG5lUnN5eitycXk5dHlEU1BBNXU2N2FqR2k0NmZUM0QvU2ZJZlR6ZXJxeVR4ek5jWXBXME56V3BXUGpmMnM2SVI0Y0pUWFd2YTNNWnVOV20reVVDZGpRNjZCckNoaWppY1lHZzFMZ0x5czdDSDlyczE3MWFaR1FrdmZRTnZqRERlclcxakhoMHQzV055aGpuWSs5Qys4eTV0VWJycnIyZUxuOUJVa21PYmRKWG5wVlF2aUV3ZERUTnNOTGlHWWpmak5uSkwveVVUTTFJWUJLWkhWcFdxenNabXpoMTV5bEFPWlJ1M09UR3huVHZiZFNCdE4xc1lOYzB3OEk4NmxmNUxDVXp2Wk5XMXd4UjJWS3VPYnBNNVZFY0txam1wdG50TGlZZVJJZVQwOHk3YXMrTUo0YlJ5ZWNjeUVFYjJTc09uZnUxcjBLS2Q3dzJRaTZSVFlOcWJFQTE1YkJnWGpCRzhiNTh2YXJ2T3VoTUc4YSs0bjlJZXZJMCtRMGxXYVdFdUxXV25sYy93RDVUNTNOcEUrdDAxNWxibnoxeGdmbXlYVndRdTh1ek9lZmdyRlpuWHM1bVNPYm42bFpHbmc1OXpIZTByc3g2SWYwcXoyUTNzNTJ2U216L2VDTVQrQkdkTlF5VHN6Tm14WkhwQlVuSUJkYTc0Nkx5N0tUdmNNM05HQkhqcndvclBhR3lmc2doMDlMQ3FlVzhHdUNmRHpYaDBoTXBxb2lvck8zaFNGTmFPU0xxQmVhVk5FZHRNVlVjQ1lLT1RlTW9qTzFYcWFUTmZRamhlZ2ZoVHlnZ0w0ZjYrRitxNVh1ckVodm5GUnRqYTRzcmlkWGNUOUdVd3pzTUZ0YkhYemd1d2YrOWdYWmZ6dmtGWm4wNEVCSzdIeXZGSHVpSWQwMFZyemNXYm8xMTdTcmUwbDJLWkMyN1ppQzV2c1Z1L21UMXBqclU5c3JtUTFiZFZsbGVLUGRIUjNTamI3VzhsckczWVF1eFR6ck05VjJjOUYvMGxXTCtYS2w4OG9VMUZhSEh5Tndwc2FqYVpqeGcwV0VZeDVDMTJJS3BGTGZaWEZrbU5CeklpVHNlSEN2Q1k0WW90N1FmVHlzS0xRWUFpSFl0T3RUTk1mZkdQcEVXdDEwMUpzNEZHelIrd3FqaFRTeEhRbzltTjhwaytwMzd3ZlBJNW1jcE1SZ05xY2NTWEhFdU5TY3RwOUs3cjdqc2ZtVFNrbFpNZVRpcmZORHdHMmdhdnMxVnV0VHE1dk0xdy8zekt3UzUxMExTeWpYN2ViNXF3ZHNVN2JEejBrVUs3SVJ4TnZQTnBPSHJDekQ4TG5HZXBXYVdabVpzalhYR2FRM0sydGtJdlRXaTh6SFdLcUp4aXp0NkNuQ29ySFNPaExhZzN0UTNaUnRyeVR0UklxSGJBVnFlRHZhNVVrZVo3UHR2Y0pxcU1SM0dtME82UXNJSS9jUTVQUUZ3eHJSbzRZSWFXdlVuVE40UXhjM2YrcWtyc0ZWMHFQbXl3OUI3aVB6Z3JiWmR1YURtcnNYUEhReHhONzVqd2NGYWJUWkpxeTV6R1BZNExzcG1hR294cHZvbTJMRy93QnIwK3JSWnQvQmp4ZW9aSjJabXpZc2owZ3A0cENBK1NlckJ6VlVyUWFUT3N2ZS9hVllvNVRXMGh1bmpqbExOam1vNUhGU09nbHpkU2oyMHhwSU90aHhSek5ydXVPL0Npd2JlWlRXZ0NDelVwN05FeS9aNGFCMTF1TlViUEd6TjNSUXZLdWNKamNlbE9qamJjRGVIVGVvYlJNL3ZHdWxNZVpRemxyWFA1TGdWYVppQzB5U1ViaHFBVElXVHVtdGViNGJzS0tPTFhkR0p5NGVJeStycnlRdGRpMHZBS3V4c0RCekR1Si9WMVpHTUd0eG9tc2J3V2lneVp1TVg1anYyS3VjSFJjQ0lJdVN0MWpKTEY1VGU0ZjZUNUQ2V3VTZjFkWGlVRG5iRFNxTU1McTQ0QnJWYURhY3lORzd6NHFReWFUM0RBdDJjeWp2MDR2VE1tMDdsYU00MXJ5M1ZtOE1FMjdMcnc5WTRTckc1emlXWGcxemNkYU1jYjcxTnRNQ21zZFdTemVSdTZFTFpZYVRXYzZSaS9KTm1hV2hydnVxbkp1M1NhYStaWUM2QXE2MWg4VmVPdnVMUjZROWZpSitzMjdWQllPVEs2b3hlVFlzNjZPS09DdWo4ZldvNWJMTSswc2VRMXQxMTQ3L0FQeWliZFVadzBqdXVyR3ptL1ZPZU9IQzZvVzhhMVFhOGg2YUpySG03UHNycWY4QXFuTnVpaDVEdmtxeDN4NmxSMDc2ZEtxN1NkenJEZ05iOGU0bjZNdDNRdlhidWN1NlZFeU83SEpjNEJlM0ZxbEJiSE5uSFZmbkJWVEUzZStOdTZ1Q09aUU5EV0hOY0dvVXM3V3RMcE5kVkF5Nnc1azZKSVV4dXNlMlYxNXpITnFGTzQzU1pXM1RocTZGRlozQnQyUFVkcVpHNnoyZDdHREM4eXF1aGtaYmV2TkJid09oV25VOHppank1Qm1nU0czV3lGdWtCa3ZTL3U5ZzFsZHUydHVucmpqUEo1OGwxR2xhVUpkZDEwWDdJR2x0S3UwY0g4MVUyek5iM3d1d0RUVzZONnRkbUhDQUQrZ1pZN2UwNHRGMS93QWlVYktYWHIvZkk4S2RJV2NHbzRPVVlkeVhrT1FrWnd0eS9aMkZyNjQxMUx2c3BlOXpxb01HekxhZlN1Ni9FUlRXMTRjbmQ4emJidTZyalhhZytLVXl3MW9RN1cxTjZhS0d1dHVqN01sMlI5WCtTekVyR0NYNExTRWpQc3JRdExLN2lhSU8xOUJRd3AwSWF6NjBEaVNFNEYxWkNORmlPTlM0WFFtNFlWN2lIb1BpTEg3aW5FQTRHaHJrbWY4QVZRbWJXOC9XMUNRT3ZPR3c3MVFOQW9OaWVIdmRuV1NhNjdFRGZEK2tLUzB3MzNYalcvR2NVeHR2dEY2UW45NzFKL2E4VkdPSEMyRlN4NlVrOGhycTFyOXRqWkU5Z04yNHBZZzJYdGl0YU4xRlp1UDFnNms2UjdlL0hDdk40ckw2dXZKQVNhRE9EclhoTVgvTUNEV3p4dWNkZ2VNcy9xNnNsbjgvTGFQT3lONTJuTE8zYzg1WCtsK1Erbkw1SXJ6enJOVnhBOXBYRUQybGNSOFN1SUh0SzRnZTByaVBpVnhIeEs0bjRsWVdjZTByaUJYcEs0Z2UwcmlCN1NqM2o0bGNTUGFWeEE5cFhnNDlwWGc0OXBWYk95NDRJV3V6bWxjSkFSV2hRZE5KZnB3UnNHUVg4VHNZTnFjNlRDcDFEWWdXazFHcW14UGJmZGZrNFFCcVhxcm81VzQxeGJrbzQvczcrSHpjNkYzQ0MwZkJ5SWxhWDNPQ0FjR3JYa3VjUGVxZHc5L2JGTHpxOEJlRS9oL3F2Q2Z3L3dCVjRUK0grcThKL0QvVmVFL2gvcXZDZncvMVhoWDRmNnJ3cjhQOVY0VitIK3E4Sy9EL0FGWGhQNGY2cnduOFA5VjRUK0grcThKL0QvVmVFL2gvcXZDZncvMVhoUDRmNm9zMTZLYXJVQ21TUk96ZHBad1RzUE1WQTkwMUo3ajNpTmpRRzdqNitkU21TYVdkNzJobFhSM0JHMnRjVTRIVTlsRkxGekZYaGdRVUhid3M0MFY4c1pMdC9PTit1S29BQm82RzkyK0s5ZHZiVjRUK0grcThKL0QvQUZYaFA0ZjZyd3I4UDlWNFYrSCtxOEsvRC9WZUZmaC9xdkN2dy8xWGhQNGY2cndyOFA4QVZlRS9oL3F2Q2Z3LzFYaFA0ZjZyd244UDlWNFQrSCtxOEovRC9WZUUvaC9xbk96MThIWmN5aHlMcGVBY0U3dGUxT2pZMXRURWVDUUVKNUdOZ3EwYUkzbjlGMlRtR3N5RDlBdWZjcXZOeHU1UGlkRUN4d281RmxSbkw5WTNiMHllUFUvV054V09vclhSQm9Ddk80emR1N2lTVHRpbDV4UEFYaFg0ZjZyd3I4UDlWNFYrSCtxOEsvRC9BRlhoWDRmNnJ3cjhQOVY0VCtIK3E4Si9EL1ZlRmZoL3F2Q2Z3LzFYaFA0ZjZyd3I4UDhBVmVGZmgvcXZDdncvMVhoUDRmNnJ3bjhQOVZYdGo4UDlWTmNsek4zRHBWcmhuRkpXYStkTXczSWVrY3BaVzRPcFFKc2JPT2NMOGo5dU94Y2M2cTA4Zk9hdUNCMEZkNm1mSDVybFh0MTY4TCtDTjYzR24xVVNLdkoxMVRHdHFTUnEzSzg0VWVSM0RIWjNOM2ZxMVhoUDRmNnJ3cjhQOVY0VitIK3E4Si9EL1ZlRmZoL3F2Q2Z3L3dCVjRWK0grcThLL0QvVmVFL2gvcXZDZncvMVhoWDRmNnJ3cjhQOVY0VCtIK3E4Si9EL0FGWGhQNGY2cndqOFA5VjRUK0grcXVPa3pqZWlsRlE2MDl1OVp1U2U1SzNnVlZYZTBMT3VJSVFlVG9UNEZ1N2RrQnFRR2lwSVBzQ2EyMHNiSlVWTjV2QlFmbVRBQ2NLYWlyOW50WStzQ01VVEt3MEp3dWxNa2RTOVc4NGJ0eTBSUW5YM2RmcDVmVjE5eFovUHl6K3JxeVdmenN0bzg3SkgwSExhZlN1NjhyL1MvSWVMMFZlNHJsMVpaYU1Edy9ZZHF2WFpiT2R0Tk5WZFBKZE9xa0txMjFOZTRqQTd2VWplbnI5YW1wRXcvdFgyc0UySnd1bHZCY3dVdW5lRjJ2YnhmR3g3ZHE3WXN1akpYU0dvT1ZIaTh3Nnh2VWNObUljSWNSMGhTU0dKMTEySjMxUUJzN3NlZFlzY3k4YU5DeDRYaTlkb1Y4Y0hXRXkxYW9aMjB2YmlxeDNmck5PeE9lNXRUeXFPMW9YMlBianVWT1pUUDVJWWNrZlJrMVhUekxobjJMUkhqWE5sNzNCMndmSnZVUjdZN0hXbW0zdlk2d3YyY0N3MzYxZEpyb3BRNGh6bnZ2VmFhN0Z2ZGx1NE5sYnhidHlrc2RwQmFEZzZ1L2VzV1ozbkMwZUJ2SzBkT2JhL3lWVDZTZzdrOXlYYjlhTWdIRGpvVXp6azN6M0thbXpGQit4MGJmeVRnRFE2bHJKV0xDQ3RHTjNzWEZPOWhYRnY5aTRpVDNWNE5jYnZlYUxPek9FazNOcUM1dTVwM0I3am4raG9ycDlSVElwcVZlN1I1MDFqWVNRN1Uvbldia3IwRlNCK0kyQXA4Y1lBYU5YTW83VHl0VGg5WkZyaGh0QlFrakJyd2NOVkV4MnAxSzBPOUViMVFpb1dBb28yUnR6dHJtTjJHUDVvdW0xK0t5K3JyN2l6K2ZsbjlYVmtzL25aYlI1MlNQb09XMCtsZDE1WCtsK1E4ZG9lNHdSYTVYSEdtNHA5T0ZzVlh3QjUydWF1S2FRUEthcnRta2pncnJJVWJJeTk1ZHIydEN6VnJZQmpSc3JEaFZPdlNDUURaU2lNRm1rSWg1VWplVHpJbU1hV3FwSzZWemhYMzY5ZzhaSmQ0T2R2OW1meVQ3Tk1LeHUxRUxOMnFwWnlaeDgxV2paVy9WV2hIUk9zOW43OU8vQ3JkVGQvL2xab2FSMXZLcDczTmswblVXaTJ2U3NCOEY5YmRWYmg0elJYSnRBNzlpcnJHVW1TTnIrbHF3QUhSM05KTUhiSHQxaFpxU2JQbmt1dTBQclFGVDZsdThZZkdmc3A3VGhwS201NVRtSFU0VVQ0K1ZFLzRJT09vaWg1a0RTanh3VDgxQkpaMnRyZDB6dHZiYW91eGZUWXhTMmRrSlpDWSs5VDd6Uk9iYTcrY3Y0R1RhcWswQ3pjQU03K2JVaGVvRHRwNHhRcTY4ZDhid1U2QTRYZ3MvSy9UYUthOWl2Yks2MWU0ZlFwSWdLeHUwaU55d05QT1R6MUk3RHo1YzdKOWx1MXliYVhSVWZUVzRZc1FZM0FlSkhMTDZ1dnVMUDUrV2YxZFdTeitkbHRIblpJK2c1YlQ2VjNYbGs5TDhoNHRUTGo5RFVLNUlGWFhFQnJDNFZUellPVFhYaUR5cXgxV0RJM3Ryc3dKVGcyUm05eWU2UmxLa1VvZGlyTGVrT3krNnFBYlFBcW01VkF3Nmx2Ty94bzExS3NZTWxtOGphem81bGpSN1NyMEx6Q2VZcnZscGRLM3BWMXJhTGF2SmFGU1BSRy9hVjN4MXpwMXFqVzNuYjMva3RGanowYUlXZHRMYnZrdDIrTjNYajFxdFhNWlhoeDZqMHE4UXkwMDFYZEVxNisvQ2ZydHdUYzFLeVFFOGwzZFVHdGMvamZiTVRhamxVUmlKb1hkZVJ0cUErcTlWcG9QRlVHdUdjWjhRaTZ3eTE4cU4rMVVuN0R1YzcvQUEzWUxEc1ZKOXVXaURJbXhReUhrc0Y5eUxKSkhUT2FkTXVkZ0ZkWU9rL1I2bHErbW9mYXF5REVhbmIxVm1IbE5JVG8zQWFWZUN0SEJPY01NbXBIZXQ2emJHOXNXbzhHSnZ6WGJWdmZlZnNic2IwSzYzRHhhWDFkZmNXZno4cy9xNnNsbjg3TGFQT3lSOUJ5Mm4wcnV2Sy8wdnlIak9IMGxRTGgrcWpjTjl2MVhVS09jamtjZnJDcUZCbTZhOEtMVmhzWEthTm1DcmQxNjZoYWVtZkhpK0YyWWw1dFI2UXRKb2Y1aTB6YzVuWUlPWWJ3TzFWa2UxblNWY2psdnYzTVhlTE5tbStWSmd2Mm0xVityR3NJL1dWVU5GZkhhT0ZRcjBKekwrWllkOFo3VjM2eU5QcW9nV1gyTzVwQ3FDV2NmYnF1T2VzQ1Q2bGpvQkFISHh6bVdmc1VuYXMyN2tsWGJWWmpMVDk1Q2FydGRqQ3lwMGk5TlplR2p0V0RhN2d0UTlpcEcwcXRvbXpZWGUyNlcxeDFxNjBVSGptOExuVk0wSGJpMUVPYmlONG9xTng4b2pVTXVKdlAyTWJyS2RuYlFiUFppZUF6Q3EwVzFkdlBqRXZxNis0cy9uNVovVjFaTFA1MlcwZWRrajZEbHRQcFhkZVYvcGZrUDRLY3VyK0NZaXZTcUdPNzVodXF1YmNlbVFsZDZqdWRDMm4xckFVL2dXTVk5aXhpQzRvTENKdnNXcW5pTmZFS1NNYThjNFdOa2o5MWFObWFGb3d0OWl3QUhqWjd2RVZYQVdzajFxaHFmV3U5c0RlZ2VOUytycjdpeitmbG45WFZrcy9uWmJSNTJTUG9PVzArbGQxNVpQUy9JZHdQRmNmbzZkMVR4bkgvQUNabDlYWDNGbjgvTFA2dXJKWi9PeTJqenNrZlFjdHA5SzdyeXllbCtRN2dlTmorRFZ5MC92RHplTDRkeGozRkJscjRqTDZ1dnVMUDUrV2YxZFdTeitkbHRIblpJK2c1YlQ2VjNYbGY2WDVEdUFqNHRobHIvazl6ZDFUdWo5Q1VFZm9aZlYxOXhaL1B5eitycXlXZnpzdG84N0l6b09XMEgvRVBYbGY2WDVENlkrTEgrNGRmN2lIeG8rTHkrcnI3aXorZmxuOVhWa2lrOGw0T1hQZ2Q3ZjE1SDJralJwUnVSenpxQXFpNDdjci9BRXZ5SDB4OFF4eWpLZjhBTGlYMWRmY1dmejhzL3E2c3JEeTI2THNoYTVvYzA3Q3IzYTQ5cFZHaWczRElZeHc1TVBWM0QvUy9JZVBqKytOZjdoRExoazV1NWw5WFgzRm44L0xQNnVyTGUxeG5oaENTSjE1dmNYNVhVM0RhVVpYK29idTRmNlg1RCtENGxjSmExZ2Y4cDZmUnkrcnI3aHNqRFI0MUxqL3VCY2Y5d0l5eW04ODZ6M0Y2R1FzUE11K1JzaytDOEYvRS9SVWphMkw0cS9JOHZkdlBjdjhBUy9JZndYSFh1V0dIYzcvOHB4OUZMNnV2eFIvcGZrTW1yeGZYOUFjdEJ3c25hK2NHZnUzcm5Oa2NZWkJJR3V1bW05T2xsY0dNYnJKUWxnZUpJenRHU1FReUI1amRSOU5oWDF2NGhUKzVOU2kyRnB0RHQ0d0M3eFlnNGVZNXk3L1pHc0hPeHpVR3p4bUE3OVlYaExIZVpwZFNFa1pxdzgxUDRRZTRQY0ZwMUZ6ZXRjdjJybCsxY3YycmwrMWN2MnJsKzFjdjJybCsxY3YycmwrMWN2MnJsKzFjdjJybCsxY3YycmwrMWN2MnJsKzFjdjJxMHhNNExac1BZTzZPVWZUNGR5UG9iTjllei9tajBLMFA4cTBGV0RzYTM5OUpWL1FyWDJPL2NTRE9SWk95eC80bFZDci9BQkN2akZrdVBMZUZxUFF1T2Y3eXJVNC80eWZCTEs4U04xNmE0NS92TGpuKzh1T2Y3eTQ1L3ZMalgrOHVPZjd5NDUvdkxqbis4dU5mN3k0MS92TGpYKzh1TmY3eXJBSlpCdnZZTE56bVNOKzR1WEd2OTVjYS93QjVjYy8zbHh6L0FIbGNnTXNydVlsTk5vemtZT28zMXh6L0FIbHhyL2VUcllaQzFnYmV1bDV2VVhIUDk1Y2Mvd0I1Y2MvM2x4ci9BSGx4ci9lVE8rdjRYbEtuZFZWZm9HV09NMHZDc241Smd6YlpiYTRYdFBneEQ4MVdTMXlub2ZkSHdXaGE1ZlcrOFBpaUJHMkcyQVZGemd5K3JZVkE4WVhvd1ZibU10RVVFREphOThiNVdLLzlTc251SDhrMnpUaGt0WmhFYVliZGZkUGxkUFo0R05kZHE5cFFBN0lXT3ZtT1hhRm9ZeDJMaGViaFM3M00wMUwxeGhORTlzbEhOYkpjZUx0T1hjdzlmVC9BUDlSdjlTRXpIWEtUTXIwWGxhWm8zWEpNQTArdkpOYUNMMXh1QTNuWUZaSmJSYVhUaTB1dVRnNm1QT3E3dTNaT3g4RU5wZFpteVg3NVlCc0hPbldHMXZ6cjdsK0dhbEw0MjE1eGt0elpiWk5DeU1NdU5aTmRHcEJqWkh5anludnZISlpaSkhGNzNNcVNjam54aTlNU0dSTjN1T0FVRU10cGZhb3JTRHBTY21RWTRjeDNjMlN3V1hQUGdobExyem8zWFNTQmdLKzMyS2VHY3ZmbTVxUlBmcmMybFZiUDVnOVF5YXN1cjZVeFF0dnVHc25Vc3pKRUFhYXdnQUw4cDJMdnNJdWN5ZGFHYWJibDRKa1dZdVh0dDlTUzY3b3FtUTVpN2UyMzFIM3JPWHZyVVdsQVFPWjFVSklqZUJUbTlyMW9hY1oraURKR0dLdlBVSjAxeS9UWlZlRGZpZm9uUHplYm9hY0t1U21Sam9iTWJTUytoRFRxNTEySms4cXJWYVpQSmpKVUI4c2txWi9KczBOQXV4VnQrdmNmazdKbi9pTWwzSTV6alFEV3FRUWluMWs4dWp1WFR2MXJ0WE1jc052WDBaYnQvSFZWT2t1WnVqcVVyWElZb1daeHcxazZsbVpZUTAwMWhBVXZ5blVGMzZFWFBxck90MG0zYWhPWm1zM1J0ZUZYSTluYTlhR25EVElzeGN2YmI2dk9GNXg0TGQ2cVlHM0ZucE5GdEtsSE53TnVjNkVwYmN4M29zczBZZjhBV08xWm1WbWJmc29tdXVaeXBwcm9oS0JkM2lxN1R6VzNoWHViSVpYK29iMVhNdHphdnR3TzBic25hdVpycGh0NjhqTmR2NDZxMFQ1czNjdW1sS3JOWnJONFlhVlV4K2J6bFRUWFJkdFhQM2Q2N1ZTZDd6ZHluS3FudzVpL2QyMzFTU014YzlhcXFZek5ad2tWNFZFeVlDbDdZb3htczVlK3RSYVZuSUhNK3FFa1pxMCtNMkw3WHl5UithclY2djZRcnpMTElXNzdpck5aNUl4dkxlNDczRStUelcxVkpHT1lmckNpRFdpcmlhQUx3T1gzVVdQYmRlTllLcVdrRG95UWlMc1ZPZEFYYm8wVU8ySVN5Wnc3M0hUWXZBNWZkVkRyeTNHZGo1WmRJNmNZNFNabjdNNnkyY0hSQjJuSjJ4TllaclJkNHNYZEgxcDBkUkRFY0Mxb1JiQkU2VWpYZENMNUxOSXhnMWt0N2hubktpcDNGVlZWN2l2Y1pzOEcreHZVclRJZGJwWGRhbWN3M1piOGJHdnB3YnpxS0J0OHl1QmMwdmRTcnNBY2FKanhyYTRGV2wxcGtBc2tKdVJIbUN0OCtvT3RMS2ZISk5MUGFvN083UFg0eHduZE5BblMyZTJzdHJXNHViZHg5bXRTVDl1UldXSzlTandQeVZCMllzMVQwZjhBYXBUSjJSaWhESlRIVjdSaWZZZzF2Wml6RnhOQnEvN1ZNMDZ4YXdEN0hKdlNwclM2MXNza3VkZVdjcDFEekl5UTIyTzNOYmk1bHlocDBhMHd4eE9mYVhZWnJjdS9XMkN4SCt6YTIrNGRhME96RVpPNlNLNzFoWmpzcFp4bTNqaHMxRWZOUlR4UE16QmpGVjFRUG9hK0wvNmpmNmxtVzYzek1hUGVWakEvZXhtWS9aako2NkpwM2hXT1BZKzJSMTl0ZmtwSGJXdlk0ZStNbllyL0FGUDZWMlBhM1d5T1I3dWpBWk95WnRGbmpucG02WDJWcG9vUndzYkZHTlRXaWdVaDNOWFkvd0RsMmRXVHNURnNOb0x2WXh5c1R0b3RzZlhUNTVPMVh2dXk4TmxEcE5weWdueHo0V3FGOXlXbTNuOWF0bjh3ZW9mUzRyQVpaSlBKYlZTeXV4YzM1cXRNZDZvN0ZvZjFLVTdXNGhXeGg1RFhVOWlzOHU2VDhrLzZ4QVVIbS84QVNyUDBGQzh3VkZucURUbVU4ZXpBcWpoVVgzZk5RdVkwTnZWclJOY2RkMXRVOHVZMXh6dTBjd1dnME42QjNGbWJESTZOejV4aTByc2RiUDdHZFRVT01sR3RWbWk4bU1WWFpTMWYyazlBblAyeFBEbERMNVVZSzdJZnpCeUE1SjZidm1wSGNyT0kwR0tIcDJwL25CUDlMOGdwWlBKYVNwcG40bG82MVdtS283Rm9mVDJLWGUzRUtabmtrcC9vdm1NbDBpb3pqL21xaU5vTys2bVE3TUcrMVhBMFhOeWhqOG8xVVZCaTRWS25Jd3dwN1ZMTHlyMTFSVE13SkZmV0ZBN2U1V2l5bnBDOVovcHlReGJtMVFndTZGMmxGTENkbzZzZzlPMVA2UXAvUFBVRkRhTjBpaEk4cEQrWEhVclQ5bjVxaDFaMXZ5V2VZd01jMDdBbWc0bGh1cVliR1IvSk9iNUwxWitncUpwamJlTUkwcVkxb3BvYTRVdkR1ZFhpbGorMzhza2ZtcTBaNm1EUVdBN1RRS0xNV2w3VGMwbXRmcVVFcjhiN05KU3NqRkl6cEFic2pyVGFCV0Zwb0crVVYybllxUXNqNFJhRkpZN2Mxc3p3S2drYXdySTF1TUw1V2xudHlUdHNsbGlEZy9Ua2VLbHhUamR1eU40YlViWloyWEtjWTBhdWxXUDBMZXBkai9OYjFuSThDeGR1a094a2tmOEFKQ1dHek1hM1VXNXNZSVdtR01SUHYwTjNVVi9xbFdiMG55VHJYYUczNTJ0cTQ3dVlMT1p3QnY4QVozY0UyMVJzRWRvSXdkejdpclMxMkJFZVB0Vm9Feml5SzdwRWEwQi84THF6eTN1dk9RUGE4VG1FWWFBVVpnRnhrZzRPNU04NVVWTXVPWG0rZy8xV2RRVC9BRHoxcC84QU1XZi9BUElvdlNIK2x1UzB3WHptbXlraHV6RldqMDBmenlQTEh2ZkkyYk56T2Z5alN0VkRJTmJYaFdsZzFOdDlCOTlONlZhUC9jWDlTaDlJT3RXcitlLzcxbzhMWW52WTk4anMrWTVYU2EzTzNxenVHc1NCV3FTUFJrejVoalBrNjYvQlJ4REMrOENxaWREZXVQdkRUMTZKb24yUGtQQk1mMVhnVlU5anJXTzVuVzgyL3dEZ0E5STMrcFdUK2NpL3JWdFpJenZFVmxsanN4cndyK1A1QldWL2xSTlB3UWtoYmZsaGtiSzF2bFVPcjJLQ3gyUjJkdlNOZFBoeGJRYTQ5V1RzYklJbnpudmxHUmpXYUJTMm0xVU5ybTRWTlRCc2FNbHY3YWt6SWxiR1dFalhoUkY5bmt6alFhVlV3R3U0Vlk0MzJpajJ3TkRoZE9Cb2dScUtzMXJqYVhtelMzM05ickxhVVBXckhGWkhaNktPVE96UEF3Rk5RNmE1R1dtMEc1Wm4yZk41elkxMWE0cTMyMXZFeXZhSXE4b05HdFd6K1lQVVBwY2U0dEhtSzAvWitlVDdidm1yUjVpN0kraitSUWR1bXA4Rll3TmJ4ZVZOeEkrQ3MvclFxN1haNmZCVHYyWUJaeVEwWUh1cjhWQ3l6MWZUbTFyTitTR2hHTVJCOVhWMXBreGJkTHRuclJ5OWlJdktuVTFtT0Y0WUhjVloreDFxb0k3RWUrOCs1VFNlU3dsQms5b3VTbDVjUlJXbUJ0cHE1ek5IUU90V1hlRzNWMlNidXRHVUtTTHlnaTNWdmFkUlY1dWk0Y0p1NUQwN1U3emduK2wrUVZvOHhXbjdQenlmYmQ4MWFQTVZ0SE1QbXBQUmZNWkh6VXZGcjNZSjBaakROR3V0RDB6Y2xuNkNyUDZKdlVuOUlUL1NmSUtEelNyRWVZZFNzOW81TG10ZDhNVjZ6L1RrK3dNbjJuWkI2ZHFmMGhUK2Vlb0tmZkhJSEt6YjJQdW4ySWZ5NDZsYWZzL05EMHpma3AvVjFxWHoxYlhiQ3gzeFUwZTl0VlorZ3F6ZWliMUw3Qjhac1gydmxrajgxZGxMYmF4ZmlndTZHL1JWSDlqSWN4ekRGTmJFME5qMkFML1RHUmdHdHJ5SEsyQjJ2T2twcEdwckRWZGlXOHZQL01aTFo2VXEwdTVHYnhWc0x0V2FJVmo5QzNxWFkvelc5WnlTK2NWTjZmNUJIMGdYK3FWMk9jL2dpMGlxbHBzY0s1TWRzaG91eWwzVmoxcTErYmtzbm9XOVNzblE1TTg1YzY1MWlzVml1WmN5NXZvUDlWblVFL3pqMXAvOHhaLy9BTWlpOUlmNlc1TGI2VDVLMGVtaitlUzNmejQ2bkp2U3JiLzdqLzNwdlNyUi93QzR2NmxENlFkYXRYODkvd0I2YjBxMC93RHVMdW9xSDBnNjBmNTZYNUt5K21iMXF4K2RMMWhXZnprLytVK1kvZ0grbzMrcFJPamh6NzN5aU1OdlhkYTdXdE1Cc3RwcGVhMjllRHh6RlJPRGIxNlpqUGE2aVlZMkNTVjhqWTJCeG9LbE56MFZsemZLdVN1ci9Tb0xMWld4Rno0M1BKbEoyVTNkS2QyMElxOG5ORS9OQ3cyZXk1K1IwVis4WDBhM0dtS3RFTThRaW5oSXZYSFZhYXF5MmV5c2pMNVE0MWxKb0tVL05PN2JFUDFjMFQ4MUJaS0M3SkM1OWVjRUt5MmU3VVNoK082aWIybzJKeDI1MXhIVXJ6NGJPeUZzcm1PcEk2dUJwdVZsczltYkdYeTNqV1VtZ29uZHRpSDZ1YUorYXM5bXN6R09ubXJqSndRQnJVb2xZSTU0cERISUduQ3ZNclo2YzlROFJ0QS93eXJUOW41NVA5UjN6Vm84MWRrRHZZZXBXdjZyMmxkakdjM3ovUk85Sy81cXo5QlVVanB6UnpRYUJxRWNZbzBLNUlMekM5MVI3VTZNY1U1MVBVVkwwanJVbnBma081N0ROK3NUazdMcTJuL0NJVmxjK3l4dmtMS2x6bUlqdFNMM0FyVEFkY1U1QzdNTWN3dGJucWlvN2tza2JYZHpKN2RoWWg2ZHFmNXdUL1MvSUswRC9ES3RYMmZua29mN1IzelZvOHhXczcwLzBmekdUL1VmODhnM1oxcHlXZDNTclA2TUtYbXAxcC9wUGtvUE5Wa2J1L0pXU1hheGpmWlJXV1R5by84QXBwa2FkN01qanV2SElQVHRUdWtLZnp6MUsyUm5VNEFkYXRObmRyWklEOGwvOHVPcFduN1B6UTlNMzVLYjFkYXRVdlRUMktZelNYWE8xWUZhSEZ1Y1FGWitncXpuL0NIVW5IY3p4bXhmYitXUm83NWdQSlZzZUk4OVk3UUFIc09CMVVXYy9hWHQvc3kwZGFGOWoyTzNBVldlaHJjdUFZNUM1b3Z4TzRiRUp1MlRZN1JURzh6V25pQjdyWk83V1EyaXMwMHV2UE5vTjJPUzBYcDNXUjJjMHJ6THdWeU8xQisxeHBpNVptRUZsbkIyNjNLQ0V3UEpaR0dxelcwUnVESXdLdDJyd2VUNEp6dDVUNG54T2VTKzlnc3d5SjdEZXJVck1QaWU4MzYxQ2pZeUp6THJxNlM3VDdJalJ1M2IrOGM2cU95MFhhLzNrTEwyTjBxTm9IN0dxV1dSanBMemFZS2FCc0wybDQxbkpERVlKQ1dNRFZDV01jeTREd2t6emx6cm5XS3hXT1NteGN5dzd2OEExWStvSi9ubnJVbjh4Wi8vQU1paTlJZjZXNUxiNlQ1SzBlbWorZVMzZno0Nm5JZEt0djhBN2ovM3B2U3JSLzdpL3FVUHBCMXExZnozL2VtOUt0UC9BTGk3cUtoOUlPdEgrZGwrU3N2cG05YXNmblM5WVZuODVQOEE1VDVqK0FmNmpmNmxZdjV5UHJYWTJRY1lMVzBEMTRGV1grY2gvckNzZ1k4eE83YlpSd0dwWHBleUVscGJUZ09qWU9vS3lOaHREck03dGFUU2EwSGEzZWlKclM2MUd1dHpRS2V4WElvODlhWmJJR3hNMmNJNjA2Ky9PMmlSMStaKzhyc2F5S2MyWjF5WFRhMEh5ZDZkbnJVNjFFNmk1alJUMkxzUDVKWTlwOWE3RitiTDFESlAvTlMvMWxkakd4VG16dXV5NmJXZzd0NmRuclc2MVYxRnpHaW5zVVU5bThMZ042T3VwMjl2cldmaFpjdm52Z3BRM3RScnpxMmVuUFVQRWFKNExiMForSVRJaEZScDJwbHNZMnJLMVdZaWpjTHh4cXBXTzRaamNYZXhXMW04S0wvQ2pQWCtxZDZWL3dBMVorZ3F6ZWliMVpCNTd1b3FHWWJSUXJPYnczclJqRVlmVjFkYWtKWmN1bklSazdFK3ZKMlk2UXJUVGJRZkZXVnU2SnZWazdMMmJlYi9BUHYycWVLTjFYd21qOE1neVNTaHQ4dDJJM1lDSk9uQlNXZ2lncFJxYmFRS3RKRGgwaFBpaGhkZ0x6aWRpZjZYNUJVVHFzdlJuNGhNaWJGZGFkcVpiV05xeXRmV3N4RkU0WGppaXc4TWdseU1nWmZxMmlkR1lneWphNjFKS0JldXlPd1VjV1pBdkdsYXBscWo1UEM1bHhQZk9uQk5jMGFkTHdDek1zUmNXNmxMZWJjclZxbGluakpITW11dVVpR3ZvVVBucUtNNm5RQWZCUXRkcmJVZkE1R3lNRlhNMWptUVptem5nMmxkaWZhSGlsN0J2UmtiYVFORWtPSFNFK09HRjJHazRuWXAvUFBVRmF2cy9ORjQ0TWdYL3dBdU9wV243UHpUNU5kMTRLYkV5R2phN0VJQWRaQTZkcWpmTEVIUGNtbGd1c0JhNEJXYm9LYlpvb3VSZHFNU25Pa3drZnMzZU0yUDdYeStqc25wbTllUzJlbFBpYlBPVlZ6L0FFMGtua09ZNzRCV2h1d3Z2TjZEaXBHU1NOaXE1am1sK3JSZFZSNWg0a3BVdXU0Z1lBZkpSeGphY1ZhWm04RjhwTGVoV2owMGZ6eVc3K2ZIVTVEcFhaTDZ0dXZIN3dWVjNrdWZmdExwWFZaUzdVYWxENlFkYXRYODkvM3FxYzJFdWRmdERwWFhtWGJ2TXJPMGYyZzYxYWJ1TnkwbVg3THNQeVVVdXNNZUhmRlF4d3ZNaldYemVMTHZDS2t0UjRNVEQ2M0VVQVUzTlpxZkVmd0QvVWIvQUZLdzEvOEE5a2FaYUcrQTJhdWJkL2F2MVY2QXJKL09SZjFxeC96c1g5V1N5Yzlsay9xWmtrWVRjZUxJMTBjZzFzZGZPS2ZET00zYklzSlcvd0RVT1lyc1o2T1gvcHlCMFFyTEZaREt6cGJJMHJzWkpFYnpPMXBKUFVidVNYK1psLzhBeUZkalBNbCtXUVJGNUVmYXRXdDJFM3Nma3V5MXppczQzM3J1UHlWdDlPZW9lSlVjME9IT3RCZ1owQlk0aFZaRXhoNW1vZlMxeWRpRDA1SFBEQUhPNFJwcldPT1V1dWk4ZFpSb05lU3VXOFlXWHQ5ekpSelE0YzZwSEcxbm1pbVdqbWgzU0ZSakdzSE1GUTRoVlpFeGgzaHZkM2hDeTl2dTVLdWphNDg3VlFLa2tiWCtjS3FqV2hvNWgzVjdNc3ZiN3VXaEY0YzY3MnhyUE5IOEdzZjJ2bDlIWlBUTjY4bHM5S2ZFMmVkNGhIYW1qUWVMcnVsTmh0VFhGcmVMbFp3bWMzT0ZMSkJhbzV4R3k4UmkxMU9oTnY4QUFycFUzSjhObHR0aXMxbWQvaUcrNGM1VWtEcVhvelEwMUtTSjhHZWE1d1BHWGFVOVM4QlAvd0JUL3dEcXJSbmJMZkVzMmNvSnFYZmd2QWYvQUxuL0FQVlRUM1c5OWNiMFp4QkIyS3ZhMDRQa2lZVTZrMkY5aGJjYSs4eTdOVDVZcHJoWWNRYStFLzhBNnFac3Ruem9mTG5PTnBUWHpjNmE3dEhVYStFLy9xaTYxV2VzaDF2aGRkcjZrNXRsaU1OUlF5dmRWOU9iY256MlZqcnNQQ2VCZ3RPeWx2UEJMUWV3ckN6VFA4K1lBZkFKa1RHVnB4Y0VJd1VrdG84S200UThrYnY0Qjl0djlTRVZvdVN4M3EwTGtHdGV4clJxQUtZSkh0TjE0ZU5QYUUxc2tqYU5lSGpUMmcxWEd0OTVNTXpoZVp3WE5tdWtleE9kRkthblhmdEJkMWxkczV4dWR1WE9Ic1Vkb0xtNTVnSURyK3hNenpnYmhxMHRsdWtleEY4VXB2RVUwN1E1M1dVTFJmYm5ReTVXL3NVa3NGeGozNjlQcTNMalcrOGl5SjdXdExpN2g3U2FwbWVjRGNOV2xzdDBqMkl2aWxONGltbmFYTzZ5bVoxOUhNNEQyUzNYTjlZV2FoYzFyZGZEclZXeW1JejU2aC9CZXhNME1aZm01ZE9tejZEbS91VFp1MW83OTI5ZTBnTnk4SC9FYXZCL3Z0WGcvd0I5cThIKysxZUQvaU5YZy8zMnJ3Zjc3VjRQOTlxOEgrKzFlRC9pTlZSQlFqL0VDMXkvL1VmcWk1ME41eDJtUUx3Zjc3VjRQOTlxOEgrKzFlRC9BSDJyd2Y3N1Y0UDk5cThIKysxZUQvZmF2Qi92dFhnLzMycndmNzdWNFA4QWZhdkIvdnRYZy80alY0UDk5cThIKysxZUQvZkM0ajc0VFRtTnZsajZiSEk2R1psK04yc0ZFMlMwdExmSm0vTUtXT1dPL2dZNVdWMWhmLzJtOUxXbjVyaFduL2xEODFhSjJnaHIzMUY3b1ZtbW1zclpKSFZxNCtjVjRFeGVCTVdGaVlqK3hzWGU3Yk14bms2MEdHejU4K1hKaVN2QW8xNEZHdkFZMWRGbnpIMW9qUXFza2s4NDhsejhQZ2hGREdJNHhxYTBLOUxaSXk3ZmRvVmhZd2Z0bGQ0Z1pENXJmNERkZTBQYnVJWGc4WHVCZUR4ZjhzTHdhTC9saGVEeGU0RjRQRjdnWGcwWHVCZURSZjhBTEM4SGkvNVlYZzhYdUJlRHgrNEY0UEY3Z1hnOGZ1QmVEUmU0RjRORi93QXNMd2FML2xoZUR4KzRGNE5GN2dYZzhmdUJlRHhlNEZTTmdZTnpSVCtDVUlYTjNmTXFEKy9lZHZtenorV0JXdlNGL3dDcGYvYi9BS3IvQU5TLyszL1ZmK3BmL2IvcW9iTGZ6dHl1bFNtMnYwbUg5M3NNRnZYQks0Slc1WTQvMzRwNHhqNGxoL2tGcThRUCtRWStqcVA3cGEvRUtmUjEvajJQY1Y4Uy84UUFLUkFBQWdFREF3TUVBd0VCQVFBQUFBQUFBUkVBSVRGQkVGRmhJSEh3Z1pHaDBiSEI0ZkV3UVAvYUFBZ0JBUUFCUHpLclVkOEJScFdHdWdGQktqSlFEbXNJUnBvWG5hQlRuUXZCSnVVRXZSVkpTdWhBTTRtS002QXc2ZnpCVUlTV3Jwa29ieDVScjNUSFFXbHRGM3E1NkVJd1JXS2lHQU02WGpURXpEQlZoaTJoejBEUUdlQWpSNjJ6VU5kUnBwY3lnRXZBaFF3Tm9CWWxtcmhyUUlTejBpdWgzYWtZT2tUalFPalAvSUtTK2dDMU1hVzZvUmFGb3FxQUxSSE1RMVFCQ0d4MEJVSmVnMWs2Rm9EblRZOUJiVEVVc1l6RzNqd25EWm9RTjlBS0hXeU02RVdvYm9BSWdBR0VvYmF0RkFTbmRDUWhQUTg0Q3IwYmJVYWlRSWRzQnJlQXNSR21lZ1FPb3NXSUNFSE9wTG82NEJUY3dYQktITXpGUmpGRXV3NnJvTzJOdkhoY1FVMFZ6Tk1PRzZFOUJ6b0NjVDVhWGdvSWIrbGhxWFF1RTEzak1NdEFXTkJTa1I2eExSZUVMVU5xU3owSnFnVjBNWWdaMVZOY1FCd2hhQVRSQkZOTFR2MUNrQlIwTFFLYVhhMlM3U3lvZitQZnBaQVhFSDBBNkIyVEV4b3U2UTJndHFURFdHMFdIUVUwaW1tM3IzbWVnYnBUbVU1bE9aVG1EcERiYU9ZVzZReG5RN092MlFvRjZsSWVvSUdzQk1KZWhRWkc4Qm5vOUtDK283WThSM2pBaE05dWdGUUZJanRvTGFRMEVvUW4yak8rcDFXbUlhSFVXUzVvYk1aSVVYZGw0d2xub2FqUWFEZEZSOUY1YlE0b1FZT2x4Q1FqZWs0Q04yZ0FIUnJLNkFJZEF0Q1VKN0VOOHFUQ20xR1hxQmNEVmdPcDJRYjljQTFGdW1OUmhRaFJqb0VUS2FCTUVCVXVZQWdvVEEzekVDdW9MR2w5QTNhRzdRekRkcUl6MGhTWWhxZEFUcVN6b0FoMDJhanJGNG1ZQjFOUkFFTkNNNkF6b2tBcENrYUF6aEJ1MVdqRzhZM2pDaFJpbEVCRkVJQVFFS01SalJOTG9ER2pZUjBzNkFISGlRcWRMTm1BNjZFcVZjQ0FNdWhFNndvbytnbEEwbEFpQk9JTGF3Z2tIU1NydzlZVU1CWWgyekVkZVNoTG5vUTd1aGUranhDRTdvQUVNU0xSQWdyTXdoSFQ1YWpVQ3FzTnNTMFI4WW9rOWhtYmRVUDMxK0k3RzYvM3FmRTgyajJRNmZVdERjQjd3dFY3RENqN1dQM1B3TElKaHVGdjJENGhJYjZmSmo2bkVtUkJBUytzeDBMZGVFOFZpVURWWGdwc3oyQ1lUSFNRanFOMmw4ejBPb0s2RW1DY0hwTnZDRUplQU1Udm00aUlEanBBeVJNdm9BekRhWmxTWUtTZFFVWWdMMXhvZUJvZFFneDh6MW5yUFhRdENrejBycGswbHpCZUc4S3V1REx0TDRDNFEvOEFnZGtTR3BnQnhRZG1oZm5MSUxhbTUvNllsekduZkhpVUZkTWFyRXJBQlExV1dFSlFnWk9scElCbmZGRGpHZGFtTnRLNkU0dFRFd1lXREUzbFdZMEp3Q1JBZTJoU1hQOEF4QlJnTEhSZTJFQjNnTldaUWplSGJLNldrZFBZZEVpYnd0Mmc1MElpTXhDR0lCRUF3MjE0SzBXSUNySWYyVDhnZXNvSzljZmphQ2lOdWNRS291Ky81QUlzc2VVSmhPM2Y2TWNBcmZ3eEJhdWdMU3lNdURmTDZZbEVIT0ZJYkF3cVJlSlRrWUtqMWhJY3dIb0lZaVIxQlVRM2lDMGIxQWVwQnkyaGdhRFZDMzBSYlNTb0JTR3ZhQ0JvczBFeG9wRkw2czZtaGpSbzhaZzBlaHRyWkxOQUw2QytoS2dxSXY4QWhTTW1Eb0FaMU5vTDYyYUV3TjBJdm9ycUxES3VZMEpnNkZIMENrcHFVbE5VOURET0FuV1hnQzRSMjZoSTVjd0JEUlYwM0dZbEJpZW9WMUFaaVFrZ3FBNFFWRllka0JVWW1YMElHOFRiUXRwbUFJUWtPa2I0ZzBsZ3gwQW96RXV3WDB4VXlpbW03Q0dKblh1OUJqcUE1U0QwQUxRUjdRMks5RjYrS2pnYndyNVJmOFJwNnFtT1NjZXM3dVJMMVhIMG5ISEV2dnZEb3Y3dWJ2dTEraTRlc0VVdUcvYmYvZ2VkRHBCZHdRWHowTDBXZThiYmpGK2NJWUZ4Z05QWm55OER2aG1NR0NMb0s2aXNtMGJLZm1DRUJBc1ROWmFaZkNXb2gzaEJCNnczYVkweHBaT1l5N3hya3p0bHhTRVZnVmNOVjBOc1FjeEZab3BDWk14MGhRNnpTOEFMMXMwZWN0QkJZMEJCaTB0MENEUVgwQ0FvNEMrbEl5ZFBtVmFJUkRVT0RkMFpXaHYwQmhJMzFHZ2w2dUFjd2xEcUs2Y25vRitzQTZDeHBtWTBTOGFCNWxrVGdDMEpVN1l3Um9TbWpQVkpjUXBvS0dNU3FBQWE1SmliZW9oaUFMU1M5VE5jUjNCUklXNzlCNDFONWxEZHFDUmVFeThkWEFMVnczd2tBaG8zYUU5QkF5Z1E3ZEs3cDFGVHlkaEtxRHNMWUNWOCt2amZ0TURXbS9mZUFNMGlOVWd3V1Q3b09JSjhoWEpha2EwRGN0SHNEQ2ZuajZ4djJ6L1l3UDhBRU1LWjkvNWxCM1p4blkwZysxVVVxQkEvd2NUMFhsOXM0bEM3cVJIdHYzK0pXM2xUL21lWUYwVGxmUDNvRUpvcGVXMEl5THhiMGdJZEJNMWdoQ3JRaHhvTjBKV0p1YUZMZEkzZERabGpNUUNqakNTZWhWMUZ4bUpjNFU3eXNHN1dBWmlJeXgwQ0VmVGlPQXVHN1EycVphT2M2WjYyUmN5bTg5Wm0vUmRMdE8zcEFPQUtFcURjeDJhUFVkZUprMHU2TStoSk9FNFl2SW9LeW82Z1VjdWRHVG9Md0JxRllIU1NoSFF1SVdSZXZSSy9RM1N6b1NoMEFoR0NJajBJZVlRUkNyb1FNWVMwUTMxM2JwdWFTb01CZlFka0cvVEdvTTZrQkdjQmVvVWZRTFM3cmdNeEJnTXdtdkV3d1VJMElTOUdhRXJWTnZyRVBVelM0ak1KNk9YSWVGSXluZXhZS2kvdWR2Yzg2UTN5eTFKZm9PWXRmY3JSK0dmU0ZRc0wwYS9CeXdGQk1hcDBHd3RBNDd1ZG9XZ2pJUGNFcEpkQ212MWN6Qmc4YmVGL2pQRU55VkVGOXdUazBrMVBma1MwRFFBRFEzeXlzdlZCS3J4QWEwZ0ZaaEtFcVYxeEJ2bHRDMFNnRGdBR21EQUw2VklwMUVPV25OZFNwb2ZkR1ppWTEzMGFOL3pJZ1JweHJrUXdWREZGMEppQUxWUWN3RVFrQ2RrdkMxU1ZIcjJhN05RaGpVUllRbWtGOURWQVdtYWROVW9LRG95aUdvS09IUXpBQkJ2MDhSMkVWNEtTR09qT0FzOVFxNksvb2FDMnVOQktoTHFCd0JEU2lvbkxRMDZ5QmFEdGdEaElTMEdvRWVyck1TaElxbUVoSWFaRENQZUV2VGRtSVN6QlhvRFI2SnhOdEFMaktzWHlwUDNPQkNXajdrT0lNQjlhRWFFS0FlQUtHR0hwNm1hZnQ3eGY2ZXFtcCtBUGZvc2FHK2xrZnBMTng0Y1BreFlwcHRHWmVSR1QzYzZEdEQwNkFJSzFTWkc0SnRGTEs3VXRBSTZqSkVoTk9zTVZIcGNRQU9wYU5DSlFSSXNUVUs2WE1wWXoxMUdCZ1Ixc2xZaWRBc2hMcE5HVzBGNGRrTEdxS21YUUU1WXRHanhHRWpyZC93Q3NTb1dFMlE3aURkRWxqMG1OUTBBdnBmb0xvSmwzU21sRVJuYUppc0tpMGFOWW1uN1RIUTQxRUcvVWhqWE1xSjBDR1lqUUJSZk1kTm5PcGFTeHZBRkNVSm1FdWdRQW9TaEpNWmczeWtLbG9FTFFVMUFQUVVBTXdCRFJDRzhMR2h2Nks4YUMyaGUyalZvNEFZTjhBQWhBUWx4UUJHWUF6TzZCWW04NUp5VGtpYnpraWo5c0xuZ0NNOUU0TVFRS3ZpMitISHZvTEZoYk1JQkYwdWFWdVpIcDArQWhHTUV5VVYxZlJSMkloZ0JOUkZHM0VPcEpDckhVYzZEcHZkT3grUDdsYUZKdHR4eUlGd3VjeE43L0FBcmYzM2pBUEtySXhCeUFZK1JCdnFuQ0NxUkJnQUhRZHNaM2g0bUpWcU1NZWdoR0FxQXNhSkdDcGllYTZob2tSRUdnMGhoTXYwVFpNUm9DNkpMTklFMHlRVmFHL1FGeW8xbGhHMHR3Z0dDMmhoRGVVM2xONVRlVTNpRzhRM2xONVRlWFgxTjJnUnZNZEFHTmJJV0pabzFxRGFDK2hobmVDMnBNOGFDZ2h0QTEvd0FEUnVrdjJtT3NFRytkb3oxdEhnQ0VZakhTMjZCV3NRY0lZaEVXYzZGV1BVbG1DaGh3Nkp4TitzQlJsTkF1SlFRbkNYUWF1WDlGZ0VaM201clk2QVUzeWlwaDJ4azYzTXdhZ0UyTWJSa1dnZThTbEJRbUlidXErTlFMMVAwLzJEZVJkMHdUU0M1dWYrRGhMMUxSK0daVFZqZWpYNEF4MFJaR1lBZ3IyaG5laUMzRFJ3TkhLZ3daU1dJYzAvRUpEWnRVVktFRzZoR0dCblRlZXdsMThLWWNJSklnanNrN21BallVQjBVNDJGU0ZodEt1NmcwZ0VrRzVnbytScmRnSkZPVDdJejRhcUFOd25JVTJiWlFOeWU1YmIrNCtzaG1DSmd4YWlSZ1BYL1lSbFVyRDZucTh2cXdVWURLZEpVVUFjb2dYMVdFSkhTK2g0aEFHRnBmeHJkTW1nakdweUV3VG05aUk1OGlyNVJ5Qlc1R0I5Nk5NUVV5QzJ3bjVXNDdNTDA5NE9pbHNTWWwwemxUS0NKcVl4QkJKZ2cxNG41Z0xHZ2MzZWtMUFFob056RW13OFE3WWR6UE9KUy9URDRUMk1JVlo4d0lZTEhFQmdsMTR5RFhSbk1UTVo2TE5YSFNIRFFPbHVYTVFpZ3V4eFFDQ2xObGRLTXpLMEgydWxzaVF2Q2JRTzRPdjdUSFFZMUVHL1hFdkptTklMdkRlVWxSQnUwdU9nSUpXZ0ZHRnc0eVVMbUFHV3dZeE1YY09TWTRsdnZGa2hybkdoL0ZJRGllNlBCdjZqdGlJMUpHQXhDUjE1aERnVU9yT1hkYk9yUVVxbjJSd242RjJoRUxuaGQ0eWZrQ2l2RHZDcWU1a3ZZSHBGWFpCS0dzTjBuRURWblFRNFRHZ01DSG9OMHpNRXR2R0NHcDIxMzNlajhyUkNiYnpiT0ZPWU9jVmtLQzhEQ0VKSmJlQnN3SEFBdE5GUUR2ZjNpcTNMeWFuNFh2S2dTdEVUVmh3V3I0OUl2dEduWmtWL1NYd3FJandVYVFEU3ZMdXhMQ29wRUZVcVdHc2ZXSzRvRENlT2lnS3ZlZ0k3Z2hwWmUwb0FGZGdNa1NpY0ZxL3dEclBXSnpJWmdJQVY4STBOakY5L0IvajZRbWV0NXZyaVZmdWFnT0FqUTc4TUV1SVBxQmhiQmY3OVp2Nk1hNDBFRUxhdENFcy84QUFGQUVQK0N1OEJTNjNRd2JwNHlFdnMyZlRBS1FsbldERUtKdjh4dmlnVjhSUzY4ZzJqcUFzR0VqcVNPbUpuVUJFOUNxUkJ4bzYzZFJSMEZGSUFONEV3a29Hcm9kZlgyaEEza3BLMXJtd0VxaFZ2QVR2Q3ZEam1EcytxclF4bERCd016R29mOEFBQ0RRUTFDWG9BenFVamFCQ0UxM01ka01iY0VlNmdSUUVYYTVEeHdVUFJZVHNEQlNaNUxSd1NsRFdwVU04VjVrT3hoOHlRZ1hvRlF3SHFiay9QM0JhRWp3RHRPZWdRZWh4cUlOK3VOUFpxb2RreEs2dVprNnhpVWtMdFdVNFRoWmlIWkFhRkVWZG9PZmtZOHRiUXBFRUdnUjduN2hyRGxrMEwxRlBtT2wvVmlHNVdvSWNvMEhLZkNBYUxEK2lOZ2hWQ1B2Tmk5bzU2RTB2SGl4RGFFaG9kSUdZSWs0QzBHcmhZMEtSbzlWaU5MVTBwczRZQ2J4UmNtTWN5LzdNb2RDUjNSRFUxM2h5S2poL21FWVpCdlBoMmkybkR6RExkQmV0K3hFRTJsR1EzNHhjbWszZ0hQTUd0YkdNdkNVSXk3d2I5TW1pQlNFeERmb0FKRmFHME5EUzhYdnhudTkvd0JhTEFwQ0hObXpSVWxWVjVZa0MwUWdWZ2FRclFBRlNTYlNpVllLanY4QVZ3NjdPTDZtNTBHNjVQZGswUFpJUXdOWER2U2NCK25NSWlIMDE5VWVqU3dqaXArMEZ4OEorQW05RVdLd0pmbmJwZ0NOUjRvbjAxUUJIYTlON2lrQWNXTkY0TmlzeEh3dEd6ai9BSXFSdDRkc3FlSDlqOHRYTTF1czlENmhRSkdlVllUbmIybHEyOUgyRDlURVNNUmlMOUI0MElXZzEwSlowVDByRWliUk9uYkNrQUhRM1RHamJzb083Q1pkY1M0KzR5dU5WSEhybVZpa1NvTE83UDhBTUlCSXl4R2hDR2x1Z2xGSU5ERFV4TUFyWFM2ZERjZ013RkdnZEVVWTdzTjVhUjJDQW8zYjRnUGczd0JxSVMrZ0dTWXVHS2F1MFZrSHR2ckJLbENVUHBHb2dEZVZSY0NJZ2hVeEJnQmluNWo2QVJUTU5uU0RCa3hMcTZabG9JSVdvdnBaMWdPQUlhNTFZUWdSd3k4MDRjRVErOXJINGkzeGhhOWd4QlV5QlhFNU5RRWdubEF2UTMyUWdMR0FoU0dEM0tBUG5BbXRGaXJQRTlkOGlJWEVTeDRuTGRhSU4vUUM1RXU2Z2ttME1jVEdnZFJla3dxMEM1RDl3aHpVQlUyTEQ5dlJFSjB5RW0xYkRlc0ZWQWpzdkpmczd4MExROFFBOUk3NEVvRDBFdlpHeXJ6YjZlNFU5UkFDQU5BWUxnZ1ZFUUNiUVJhc3MvcU13bDQ0QXE5WDRtNU5pRW1hckFxWEZXR2t4S1dVNHJ2Q2tyQ0M1ajJSTm93WVVpa3JBYTgyZGNVMUxLQkxHSFNxTVRKRFdTZG0wQXZtRkNRQmtiN2tCdFNBTXZReXlsRThZY3FTSUE0ajRNUUwyYlljWDBaRU5EOWVnTjRPeUhFbkJRQS9KR0lRQ2hRaVcxQ1hBYlRXV05MOUVRM3dYbVhCSW1zSytLUTBGVnZGamI3Y3hsajN1MlpXZUdsZnQvb1l1aGJ0TzZKeW9xdGVXb1htajRnb3FGUElQcjBORGowUEI0Z3ZqcjZsOVJRcktRNkViRlplKzBLZGt0Z0g5bWRHS3dPSzBQTXZLNWc1QnJqbW0xQWQ5WlpNQmxiZm5MMVdOK1VEVGlaS1E3WXlZTmo4MmRQbENTVWl5Yms5S2V5RjVCY3RVUTRZNktub1Nob3FhZ0tEeG9OOFlHbG96S3h0NDhBOVo0MHFtNEJmYWoraFlZRFlSOENDM2pQNEJBWGhXZDZ4TTU0QVVQTmNOM0I4d09rU25iTDNsd2JwZzdkWkNyZ0ZlZ2RYUUtEUzdMekxkUTVTQStZVXB1d0FhbFhCUlFQekFZK3h1RkthaU9SMGNNd0JOUStvcUhkait4TGhDbjBFT0Q3d05BNmU2L3dTZ1N0T0RLaEpNWWllQUFLaHZNaVBWdU5vbW9GZEY0SVdnLzRBQndVRU5wWkN4cVUzVzhxbFV4ODZLSytlOVlXTVZ4TU5mNGhzaVVSQys1anlFQTdKYnVZRFRZTzhWRGdZQURjUmVCYUpnaTRDSWVzVWovZ1lDaFRHbFVrQ0RZQVBXVFVaVFZ4cUlOMmwzVWRFQnFCNkZYVEhFU0ZzRzBhNUFHU3JDVjRsQ25iK1ducE16bkZRL281WE1GOEJkQVFodGZFSUxObmFFQ1kyd2xSeE03K24wWDU4NWdGeEZNVGpQMkt3U1dnTC93QkFwR0RkazVkUFlBbGNnY3dyU2FpSUxUdGlFTVM5RldVR003eHNpR2hpWURDRm92Y3hDMENoaERHdVdtQVFSSWdVb3lvVFpRSkZhTEE3QW9TMFdCVXpzM1ZZMWVvRDRaN2JpRVZUUTNKYkRtRUVXcERLTDFnNFFNWnh4TUFxRmVJRXBCVkJKUWxEQ1VuQXBNUkNxZ0IrcFgwZmdRQUxVZG1BSk1IUkZTSFZhRTV2aEtRUmdodjBhQ1VJd3JyY2ZUcENuZ1MvUEhRYUdzaTYwRTNLZTY4TjR5RVc1bUs3RHlUdStrYUlrbzZqeS9YWGl2aDdiaU9XRlEvcUV3RUpqUWtDRThhdVlaNGhqOXRDZjFTTHAzak9FSFNJeERBaFpFZ1F1V1FCSkVGUCtBcXhNZ1NqV0FCUlZDOExqcksvUmhxSDJPbFFvMGtHRVd1alZKRy94TTZuSmh3bWRPTkFocEFEbEFoMmFOMml4Tm9oRVU0eHBhRGQwRXdkWUdjUW1Fbjhaanp4QlcvWUFEOWs1MUNBMkhyK0lXa0dLK0VJYmd4VVViVWpFRkJHSUFWd1JYcHh3WWtpbGMxZ0NsRGtaaEFlanp0QVR0ckFoSEh3bjZ4Wm5RUU9vV2lNUmwrak1tYjVab0x3N2FLQmZrY3dSREViR3NyWlFHZ3NwUkdKU1dGU21nVUdEZ0FXRUcvY0lmdm1Kc2VvdU9PVUV6Q0RhQWI4d210YmVBRmsyQ05rb1ZSUitzT0FsellkQ1Jpd2xuUzhJV3A2UWFZNmhwQVhXaXVKME80YlIrTWc3NGdJQ3Bld1UvbHdEVktiWWN4czM3UldZSUFrVUFJekdraW9kcjdGRkFpRW1vRXFZTHl3U1FSdWt2WmVFTEVLOTRqdEdxTnpMclk0L2NLaXNIcUg4UkVJaldVUkxLdVJPK0FLTVJhQ0NLNmt1RGREdDFDRUtxZzNhWUJwM2llZVptVmdtOUt4cStHRU5sbFBubU5FaVdWQVdLcXQ1ZWdEaThRUlFBbG92QXdFbFBHQWdKSmxIUEdWWC9LRldFYXBEU2RCNGFJS0hJT0ZCZEdGTVVCQVV2VVZaMWFobHpGb0dSUGM2dkJmUWM2WlRBSWdYdkszMEo1SlFRYUFDaytZRU1SYmpLc3BYQnZBVlA1bEx0dm9DbktWanlnaXUxaDJqb0ZLRlVaSHZEbkJObXNMYlo0UVFBRW9HZjZsT1VXeGxmNElpQWFIdEVJWUxFTUZ0Y3pPaHJRUXhCU0cvU3F1WlUwaTZDd2VnRmZrbUJHcmtIdWw4a2ZpTTkwVncwa0pEMi9aTVVpMFVLaEQvd0NJdmliNkI5d2Y4Tmwranpvb0hNdm9BOUEwWTdJdE54N0ErZzlscVR4MitlVFlOQ2JEdyszUlFhL09IY244d28rVlBGN3RPWjFEeFE2TWgwSkprTTh2OVIrZ0FINWZ2cElBTHcvMXFoTjh2M3BBRkR3LzFxVEFQbCs0bFlrS3p6OGZuU0ZtNHhST0g1aUJ3RkRLQmE3QlZBZ3FJMUV6T2ZSdmVaSjNpbzJiNWlCa2xYVmpYRzRJbEVlOUxpbUtSbmFmQ0FWR25OSjYyUTdxZ084SmNnQ0pmR0o1bEI1am1wbENCQllJb1lnbllsUEVWelFIaTcvbUFwU0FQVU1DUXB1Rlpxdnk5NTRmNjFJUEYvV2llSCtwNGY2bmgvcUxQbCtaNWY2bFR5L004UDhBVUE1Tzh2M1BIL1VPRVRzZS9uTUtCcFFRUlR2aFl6R0lZY2FGUzhOcnZNdWl3NFVHU3FpdkVZUXN3QkgzVXh0b0hOU3d2OVF5Q1dUVk9EbEV1TUhBcVliSmtIb25DVUFWWi9FeG9KakNDM0grSmhKQ0Ezanovd0JUdy8xUEgvVTh2OVR5L3dCYU40LzYwYngvMVBML0FGUEwvVXFlWDVuaC9xZVgrcDRmNmxnOGovdUFNdWFzVzVoU1Z0N3lwNi93aHNUcFJRd0x2bHhDSEo4enczeGlGRWlyTkNEaXF1SndVUDBnU1V4K1k4c1EvUmd0QnBKRTdna0NBaFpWa1ZPUkE0YXpUQ2xtWmZkRCtKRkhTNStCRzk5bzdPMFV0ejJWck1lSXlvOG9BaVh2UDg3b2FoNWY2bmgvcWVIK283eS9jQS9MOXp3LzFQRC9BRkNYeS9lbmViK3A1LzZuaC9yb2ptRmVSa0lNRlF5d0EwREtEYy9IQmJzanVsOXlrZXN1QUJCSTNaTW84aVIyRnh0RlZCWW9IRG1kTGZhWU9VYU5BektoNndmMTBSWTZ3Y1FHckl3TXc1V0xlbFRETlZVVWlJaHZDZUhYTDNHOHBwV0I0bFFyQytJWlFPMnV2b0dDQWV1Vnd3YWFNdkgvQUZwMUpTQW9lWCtwUjh2ekFQeS9jSmZMOTZBQmVYN25uL3FlUCt0SVVOQUZjNENWaGVXZkJ1MFNDQ2JVdmFXMkVWMFl1NEEzMFlvZ1l1V05RMGkzZURpVk5WUGYvS1Zld2xoTnpZRFpnaXRJTVA4QUJqQzdlSWJWVTJKckhCOHRCdTBBRDc2Z3NURkRZaUpLSUJXY1pkcC90M0VZbkwrb3F2ekVQdkJVakxia3BVYnk4My9GL3dBcXJXcDQ0Y3dVUVU3YUh5ODhvZ2p5YjNFK0ZnL2JueENQd2llejhUKzQxNzRKZlFUeVcrT1NvV1l2VVJUOUQ5WUNBUElkRkRvY29NRnY3Y1hEQktDeFIwWTczalFhaE5UWGU2MGNNMlNpUk5rTU1vN1MrSi9RZXlONkUraExxT3BjQ1NmMFFGRU5ZV29hczVVbnNuTjFWL2hEVWNJQlExZUREQ21BNktyT05IYXdjbmwyaE1FV0dUQTNnSVluRXRZSFp6YUtnVEcrdEdGZ1hybnppRldHV0ZvMFpWRUFiREZsbXltNWpJRVJBRWtVZlBCbHRvYnhDYmZtc09rSktpREFWbm9IWUJHd3Avc1dRb1Fyb0FkN1JNUUhyaHdiZVgzMTcwWDdqdVl0ampOMmFReGhCVlRVUmtHWFZWLyt3TWR1VXFRN2lRVkVFTXQ3NklMWVhxRUFOVzhxNkNRRlhTS0tyTkNjUVFZY0FXQWdiUXFqQkpJSFZYOW9PSzVNRjdPOHZTeWJEZ0tBY3MybDJKN0VUUjdkU2YzSVRlQUt4U2VYSkVYM1FtQkw3NStvbUJXRUZUUzk1M1I3b3dJVU13cFVZVGptRmZNUk5EdzRaSWNCc1l6dmNWSGFIY1JKdFl4S0RjVmNOb09hQklRVHFDVTdUeUZDbHN1Z1ZmbTRIZE01cHlSdzd3RUVPQmhzYnpnbzYrRHQybEN3TkNvN3czQ0JoUk5vVU44cmxicXhoaEZDQ0I3UnZxWk1SSlFFOGdoU0piSGd2eHVZR1ZTajc2N05LNE9XS1JRYlBYQW84aThNaFlkaGk0bEcxaHNnVzhDa0xSWkQ5TGs2L0dGUGRDUTBHeDFSeFRDRDBOWWN1MEs4QnNhQVVtRlhzbmtLWStHNmRGaEdnR1RNOVNCSVVJREJnQkRjMmxjaVhSUmNTeHJtUStxRVpZQXNYOSswSkdaUmZrUWhEVndJOUp3ckY4bUNrUVQwZ1J0UXUvRDIrSWZpRkVkcFdheG1CakhhNGgxclJ6cS9RTm9CYzMzMEhjYktNQ2xZSW42RkVieVIwN0U4L1FoamlWQVlpL2dsVmVRNHBXNWxCMjBEN3JGMnJGOWlNVmtubUNFaXFoYnZwYm0yWnlyMEFqUTd3TnFpWUZYU0tLck5DY1FRWWNBV0FnYlFxakJKSUhWWDlvT0s1TUY3TzhCa0ZKQnJRR0VPRnZQdUU5aUpvOXVrdEIzQlM4S2NLSkF1QXU3bVVpbzhEUTZmZ3g3TUFmYlA4SXdJU0FML0FMaU5JamFzdVBmSTJRUlNDS25tcnVNUzhRTjZPYnZIQTR1WUpsSk1MbzQxOGJFWmpzaUE3WUVMTlFKeUdmakdJdlBZTWhiMEVZWUZkSUdNSWlHTXg0VE1CNjBWcG1VRjVnQ0VLZDQzcC9uTGlFRDNIQUphSWFTdjBudWFQTy8rUS9YL0FDeHI4R3BXaGZJL0VPZTRQN0NBZkV2M2x3OWovUUV3azkvMlVBQWdIY21NcFBiTVMzNjBGczM3RFYza3Q4SVBXOVFVc3lyQzlIK3M4dHQwMCtlZ3czUDBpeDlhVlJ1OTQwRUJRQlJxRnJRVWdtWG5xUWFtUWlnTGJtTFBqWWhOdmJ2U0FKZ0xlVWVsZTA0Tjd0K1FVVUt4WElBR0hTREZTK1ZIZDhRSlpMNjk0WlFJcHZ4L2RQSDdZaTBBNmNuNUFSaFpBTWlXTHJrT3dTZ0tnWHRoWHdVOHh2b0FHNkFzK2tNWXVTNFZKUXhtSitBWWRZQ3RWcUVTb0ZBd1djbUF4Y0lob2U2Q3NQU3ZjYUZSV0U2ZGRSYnRpa3FwQnBxZW5xU3pNaWsyMFF2ZUVJWnlaSEFucG1laXpsMExwbUdRb1FRVkcrQ0dVWFhRMEFYYUJXZ2lXMFB0SVN5ZUwzZFF4VjBwZ2htNjd2Wk96d202RU4reU51NEk1UTBBT2FJTUh1M2o5SVJxMytDZlM5Z3hVZEpLQkpnSXdNMExxU282cUsxQVlUb2JZMWg3eWpIS0FnQ09CdGJBUHpLZmpqZUtlNUlBbFYvb0FhUGVGRDhRYUdmN2UwWlhMQlpXaEw3aUpkUGo5UmJkQ2R5MTh5aVM5UkVENGp5TzJDb3J2WE1uNUhwSFF4S1k3b0VlRjhBSDZnVXJBbnVBL1hVNVVZd3FBTnVZK0RCeUdvWUV2VnpISEpCUHphTGVISU9jQjhJRzk4QnRHY3U4ZHJrQmRkOUhLSGlZSmFnR25US0MyTjhhNncrYUFDUUhaeENVUjNkMEZlZnpzSUNJQUpZVEJibDFnSkhiSmlycmxXTzh4aFF0d2ZtSEJRS2w0QWw4U2s4cmoxdUpRWHJyWWVSM3hVUGk5cDdFNlVPU2phUnpiQUtxTHh5LzZKNXpiMHJKVjVnbS93Q3d5bG1tSVFLNzh3dnBRMmdRQjl0bUVHNUtjaVlKQ3JTRDN4MmFzVkh3cGlCMlVvZ3ZFUURWcmpNRENBRkRpTGw5Nkw4dzQzcUM3S0hjKzVBMnBHMklvZW40UWpSWWhIeEFyMGhJRHpMbVdqdys3cUdLdWxNRU0zWGQ3SjJlRTNRaHYyUnQzQkdJRW9nNXBnd3VqL2d2MEVhdC9nbjBrMU1ZUzVFMVVHdEdqSXduKzQ4eThWMm80OVJHdmxlcHF1ZksrRkhJQmJsaU8wRnRHWGVzTkhZdWN6a0VFWllZOTBTOFZOOGJrL0l0Q0dvUm50U29VY3BhQ3FIY2hJTjRhUGJyTFg1RVYvOEFKUExpVXpGTlcwQVlyMEtGNzB3WURUc3RBUjBaMEFDR29RT2crQy9KbklBdmhFMUp3VjJpS3dsNkU3djluOWY4dWV1OEJuMVA0MHdZMFRNUzVsc1NMU0lQSjREdEt0WlhQUHJwanpXK0xJVUg3a2YwcHNqNjRTUDJNOHR0MFVHdHpqSWhBRDU5dFVkM3hvSWdoMGpXSGlDKy93QlZvTHY0WUo4QTdrQ2o0RlpFVkYzM2lGWXhCWEsvQWlvS0JJSks2NzJoWndKR3RCRzZIOHlJVHN1b1hSektISHZkd2tvaE5NV2l5RVoyZjljWWU5b3JsNWdGT3lVeFNESE9CQndUb0lKSXkxd2sxSzVsRE42Y2tEejNiYUFoTWVRbE1Fb1AzSXdpd0lkWGlHNUZPc0JNdzRJTjR3Nmhxd0kycktvZnpTSkY5MWJRcVplVnBIY2o3VGJ0cStFVnRuRWNjQUYzc0xTTXN3YVRLaG9QdUZYNmFEVmJCTi9scDV2ZDFCNTVLbGhJRGUwRVoxWkRjVTZpQkZ6bkFCczZEMWdBOGR4dCtZQmw1NEZvQlU0MU9IalliQ2hoU1FEQTdCSXN5NWNwYlFrSTlGbnlwQ2c3Z0dXaEFnQVFHSWEvY3RqdVlDOTJqUzJneEwyckh1WlZDNVFyaVVOeVpqUkJVbkJ3d2dnQmdIZU9JSnd0QVp0NEU1bnltbnhlb0ZqRjVhWWZhRTBLWURIZ0ZYbUdhdXZ4SDB3eVFOZ1FENy9tSFUvQlFEQko0UGFDRnBBUXBpekF4dUpUVDVPOE1KZVZmaVhTaTU0Z3JWVDdqVytRMGRuYVdKbkRFZXNHaUFrL2twd1B6Q1VRYVptL0pNQnljZmVSV2VJeFJUb2c3Yk9SQUF2QTVpTTNoQ3BpQjJuK05UbkozVWw5a0oxaHVQOEF3Z0xxUlQ5K1F4dkhhMXZpTm9ZU3kzZzVyNTNoaVU2WTVpSTNqVHhPUFVJOWpJdmpOOEVnTnhOZVl0eEs4c01WSnA4dzZJR0gwS2ZFc3J5dWc3SVNKejNTeG1mbUtwNXh4b2RMR2hhRHV3VWRVQUh3YmRMeERqTE9JVXVZR2I3SUZodVpqYmxVdUJjbjFBTGNhQllLRDlKUVNKajR5cDNFQUVDb3M3aUlGQVBOWWJROTREcWw5b2JTMG9FanAybVhlWGFDUVk3WHhpM3BBUlNacFFwdVhDWmZSWmZ1UjA3Z1lBZ3RaY3lJcFdFb0M3dzhUemU3cUR6eVZMQ1FHOW9JenF5RzRwMUVDTG5PQURaMEhyQUI0N2piOHc2QitRQ0xZSmNyOGkxYWdBS0dGSkFNRHNFaXpMbHlsdENRajBDVCtNbkl2TVMrN3ZMY0ZMSC9BRm5JaXgyN3poN1FnNFBFRzlJVkNlNGdIYmpISTdrNFFpU0NpVTN6QjV3WHhtNHhTUUFvZTRaakFwUVFyVktVVktUNGc5b3FTQ1llTHZjdGZwSTZhOEVBbmdML0FMeC8wQTlyQzNxYklyUFVpbzlPSldRMG9LU2hGbnRDNFFFZ3Bsd2hpRUxSdUV2UzhaQ28wTVFNL2t3K0NOOEpXaSswYThObHJ3V3k2SjlUbTkzNmdQbjNmcWVZL3FjbnUvVUI4Kzc5UWp6N3YxT1QzZnFBNXY3djFGOUdWc2pKVWdKSUViQUd2bUdnS2lCMEJtaExLYUlmei9jb3RONG12cEx6cG10RWp0RDEyeEpQcVVodFc5QTMrb0wvQUxGQWJhVTYvaWlhQ1Y5OGJZNWVpRU1iUDNrTHFmQS81bEkyRG9Gcy9jSU9YSUVWMENrNWxIZWEwUXBNV0lhSTVINzByYk1DeGlNS0xIckJSZXMybEg2aCtOV3lwRTNoaFJHQ1VPYjRob2prZnZTdHN3MGkyUVpaczdRTU5yb0Z6ejhRM1k4U2o2SDJqSkNobUY2NWcvUTJxYVBlTWU2dlc5bmVDa1I3QnA2bnRwNUhFVDBORnlMVVFuZllSK2pMeEc5NVVaZ2NrTm1iNXdaUmxSZmFDcmlMczRDRmlaQjlvdFF5UW9DTFRaN3o0RkZBT3oyd1pjVlAyVEhCb0VreGNvTzg0WWRQSDd1Z053TkRhODNCbmZ5ZXNDdTlMZk84TlM5TjVKWDRseVJSd2h1M0RxN1FlN3phTnNWd0lCK2tiR1dpSElyM0VIaVR3K2F3N1FzRWJSb3FTVnVna0xZUjhhRUlHNExpWEJ1dG9CUjhJMXB1ZVlaWHF0eks4andkMVB1RnJxTkl1dzRnRlF4eWJtVWtWeDJVZkFySUNwUnhGR1FSVVowQnNvQXRRR1JRTk80aTArTCt2UU9WSE53VEdSUWJKQ29VYk9UZGNtL1NWdEVkZ2oyZGhIckYycWRuckxBRXpYSGIyallSTlVBM0ZpSEhwUVlXcTd3RXUxNUNsYVJ5cmNSdlIraGg2SXRXczc5QkVqUHNpQThHdTVVaFB0SVZZeGNFQVVDbGdSVlVZczhPQWlUV3hmSW5kUUtsSFZTeUYvUk1KNUFBNHk5SXNldTFoRG1zTVdyQ3JBOVVvL2lkWXZLZGcwRWtjb0E4SkFpL2ZKaDloUHEwSDZFQk42bUtMQmZwQkMwVFEwaUo1M2hHb0VTUGRCZ2xsenA0bkhxQWZjeURjeWlDV0JnQk5vUkdqQ0pIMXpEb2xPOW4rb0ZDdklhMGRyeHJadXNNMXIyaU1Xc3lTbks5bWVjS3NQUjlOY044RGN3dFVRSUlVOUlYSUxXNC9ZVEhxSlpVWEVCZXc3V08wSmF6RmNUd3MzbkVKVkNNanZ1SUVJdmVpSENvSEVEOFdBL0VQWVNMZnZ2SExBa1hzRVZBTnNqL0FDZW9UQWllNU91RTVMcVNxeXJuMlJob0N2ZG13ZG5DaldCOEd4OGd4OFFaTGlVMmE2VUcwOE51MW83VzgrRHRER1F2b084ZmZMQkhNeVhJZTIvZHl1NzVrN1NuckIwWmtFVzdXZ0pJRHNXVHk3dzlPMmpHZzF2R1dnb1dTQVRoeTFjUlZkclJkckNNZGhEU1UxbHcxTzB5UGdlK25KZnBGbzBwOWtTcFZzQXJCVk10Q1U4bHNkc0RLOHN5eXFWRmxaRUNxaEJzOXlpWDJEQ1NmUE1BcUVZbmNFZmtoVUpIeDFqc095VkdJTnFDQmFMWWpjejEyWXZTVXpsTk1JM2MxRDJoOEx3d0I1NGxlV1pqZVNnOTZ6SUJ2UFFFKzVqVk1FdGFPRU1RaEZUT3RsYW1ia0pyMFZ4L0xpRUIzSEFWQ2cxR2d0QndSTWdGMTVuZ1A2bmdQNm5wOWg2Q2xWRlFoOC9ncDV0UE9mMVBPZjFEdTc2QUtvMjd6aTluUkVQOG40aDZ3SXNBVmVOU2lrSkFOOWtlUWo0cVFXTzREYjlielpxam1weHh5S1lGcGJ6em45U25xNTcrQWlMOG40aGp4VUFSRlUyZ29WYWlhczdpZWMvcWVSL3FGZEhNVXNkcHN3UVRVL3FISkI0aDBldDR6a2VhOEhrWlZFQ2RpT2dYMEtwK2YxT1NsUHZTQjF5aHFiVDNFU1BHeURBTDdsR2pVQXlseUFKRUk1UDhVb1dvQ2dkRDhRR21ZSlRhZTRnNGI3R3RWRGFDSjlKTitVK2IrV1YrbkJBeXhmbVdBR3N5VXJBYmkrZjlnMlM4YkJ6OWpURHNQdXBLY0ZpR0QxblE3UVRNd25HMUViVXZEbENSVUEzQmtpckpsZkIzYVlURkdid2pHUkkzNndtYXcxeE53TU5GeXRVZ05rRElBUkVYTUhlM2VNZ0t6dU9nRVRRZjRsb0V0aENLUEo3dWhOSlRYa0VRd3k4Sm5wV0VROVZKUmxweWdTTXB0VG1EUXFsMTRuRzk0R0VWa2l4d2hpMnd0QVA0RXdoUGVlMEhxb1ZDRlVSUG56MEtuU0lkOFFsZ3crblo5dzloY2k1eGRJN3NYZ0RtaU1MQStJb0psNTdTcE5CNklReUt3Z21JVTBsY3d0dEFRS0RHZ1F6MkdzekJOelJlOEdhUGpmcjBlUTJUNDM4UUJJSTE2Qi9NUURFT3NzUDVFSVpJaXNWbGp4YnNtbTlSUEM3U3RpZFNJYXhaZVA3RVZtc09hSUF2RlBjZjBRQ01JRE53ZEJLdXRBL0VRS0FCTTRBczNRNXZoVmpiTmhrRzRpMVZUb29tRHk2UFNDV2dlS2hVMzdSdEN0VHBjZ2JkektGOEgrSjZ6Z29qdmF6SHdldkxEeUhaOFFub0FrZ1hXQ21zRzQvTWFLaVNZQWNuVjNPa0doT1czS21SekJEUUNWclF3NFI0cnpXOVJXb0FpaC8xRnpBL2VvL3dSaVFCVDJnRkx2QVJab2I0K284YnFTTVUwUld4QmJoV2ZQckZhaUJmOTFiNEVNZ3dZQkNQZnZmaVpCVlI5QUE1Z0ErSWl1RXhJRm9HWWlxRmNLN3VVRkxMT0tFV0JOWGpZVlIyV2lraE1KOENCdUZEVzdvU0VLU2RFVSs4S0NDR0JzcS9VQWZKYXNoNlEzcEI3cVE3dUJ1YWtkNWUwMFFna3JmNGd4QWQ3UmQ0L0JGY0FXbVVjejFkNFNoRGxDSXU2OHAyaGJUeis3VTBTREp5b0RRNEZMMmxlU0JOVUNYYjNlOHNzU2FvdFQxTU9PQVkrUTE5cFE1ZzhBbGJrUmt3WThOekZhck80R240bStWRmZhWmRISzRrK1hpRWo5aDl6NDlKbGkyQTYvMFFJTEY5MEg4NkRxYXFzQk1FcjNCS3BhZThYb28zdVhZeCtvOXhMUjZ6ZzRXN3NYQjczTXJKOUgxQXkrMS9wRmZIRG9Cc0l3VnZaeXVSQ21JOTREL1V2dmpjZmVFQURXYm5IbHlBSUhCNi93QVh1Z3g3VkM5Sm1HS1FSVm1UQXhJRnRDSkZvYWlGTkJoRXNJVkpiWC9uckpBZzZuMWhWK1lMakRCVWVlMzBBbUxSSUhsNlB2UVJIby9rOElrWDNweldVOHNhdjZubk4ybmpOOUNqTDNBWDRlbGtxUU5XMEEyd2lEaU5KVkE5R1B4QVhaME9kZ0QxQ1A0R256RXZBYm5RTUprR0M4RGZqMWhhTVBSSTdobjh3K3RBc21HMGh2c0doRFpqUHlLSDU2UEdYR0Y3M29HeHhZc2dUQ01UakRpRW9hek9HNW5KMktQZE1lMERHdThzSnVGSUU0bkt2UjNuSk1FemNpRDRoc3NSTHBkbEI3b2NrSzU0UHZDZGhPWDhweWVzbHBtQnl1bXdIRWMreUF3QVlvbkJ0Q3dFaUhWV1FITGlHUTl0Q20wUVpWb3Y0ME12M1FYcUFMSEc4VFVCNGhFcnlLVEpySWxqRWVjWndXZ0dBdWhLSklnc3FCVDd2UnJpVU1RYU1CR0FRSUlWTkdYQUdXY1J2WUg2aGJUd2U3cHVFbUFnU2twQ0xCczRBaDBQT2h1N3h4QkpDTFlKM3c1Sjd5NCt1TmR1MDRseGlTOXloQ0I2VHliOTlBb2VZVEdDWWZWQmlPNVhpSE1BWTBzNU51WUF6TmFYbktGVGNiUXhwa0RLdERBQXY2aWVnTmhTRE5xemRlenZveXRRVmVJR3F3Q0JXTU1MY1NLOUJlYklZK0IrdlFSc2N5QnFJQW1JU0NMMkhlVkg3VUtyZFJKVzFQRkNXb3pESUVXUHdJQkdBeUNMMkhlY2g3b01Hb1RQRDFRdU1keVVvRm9MdFB6VHV3WU9oMTlUNkpWUmtRazNtQWhHQ3F2ZTlvVG5wRkZ4VXlrTFFJWDNpTnVUNUVPT0psTUdBVmpLMEs0RmNxMWVaUnlrRmxyM0R4Q2lFMlAxUndsRHhiaFFoWjBJcVR6NndoK1lWRDd3Q3d0c2hBUXF0b3VMMGd1YWVaRlROYW5obk12SUVySkJ4enh1UFVjbXZKSHNsOGRkalFrTk80WXgzVUdVelRzQ3ZQOEFJK25hRDRRc1N4ZXhRUkFnQmJJbUIzNzlMamFoV0ZFV0lsVG56UkIwaXVidVgzYmVqRDNneFNENGNiNjRlSWVKSXRmRzd1ajNVTEZxUU4xVFJwUkFvQXRMSEFKVXZPMy9BSmRTVUJ1QkRUMkVsOHFzUjNyakJEODRrOTRPQVdZUDRpSURueGZNQlBkUnh2allNQWxHWVViTG9lemc0S1JIdmdnVUhjeS9xbUtWRVpPMUo0emRxTm1DQTQ5VXZ6Rmtkd1FtUElSTkJHMHRVRmtIb25McE9pM1VDZ1JZaitFR3lwRkFiZkVBaFJHV1h0NlN5dmVQMUJDVjVRc1pmQ0U1QzVnTDBnc0VHN0doSkpFbGszT2o0NkUwUUVRRjlQYVl5RlF4eEc4U0dZeWNMWWFsN3ozN3gvMlFTcEFjZ0tEM2ZFQXpKM2V2dVJwc1pNQ2phVUdJeVlsOTRhcU5xbUFKUUN6c2VONEV4REE3UnVIWjJqSDRrRUdBajJnQTJubUFva0hXWDVIdmVKei9BTUZJUm1HSGdhMFdFUDFBcjhneXAveHcwZm1BUkJ2aERqeVcrbDN3b05BTzBncWQwK0ptY1ZmcG5KUis0aEJxK0RhZVMzMHk4Zk9nV3NzOWhLQWVMejRXZkUwbm9hZXZEK0RvYTdpQnZ3S25Ud20ybSt3ZzlrT1BVS2J4SXdKakQwb0RYU1ZmL2NLbFNQNzF2T2xjZ0lMa0VRRy92OVR6ejlUeno5VHp6OVR6ejlUeGo5VHd6OVR3VDlRRkgzL1VTUHYrcDRKK29DajcvcWVlZnFlRWZxZWVmcVYvditvUm43L3FBbysvNmhFZUcrZ1A5L01xbHdHQlVCVUliR1VBR1VSY3ZjRVdnNGtBWUVacXdJQXBNWEJBazBCVnJMdXdiaE5meFJMSStSNnhnZ1V0aXc1T3BmRm1VSU5GczBIN0lmdUtEdWVycUhTQVFGNU04OC9VODgvVTg4L1U4OC9VOFUvVThzL1U4OC9VODAvVTg4L1VwL2Y5VHpUOVJQOEFYNmxQNy9xVmZ0K29SLzMrcDVKK28wZmQ5UWczWU5IQVpDMGNpVjNxVWdDT1E5Y3BUanEwdmhZNHlQMUVtN2RadEJ6cUlOcHlWRWdoUVFRWXkxVGZNU2dpcnhxUnhRWkNqc2cwdWUvcThxZUVmcUw4SDRubW42bm5uNm5ubjZubm42bmxuNm5qZlNlTWZxRWY5L3FlZWZxZWVmcWVlZnFFZjl2cWVNZnFlYWZxTy9yOVFTVzVuTDJtZVU3d21Db1VJdGwrNHlHaFpFcWxZWTdFbTQzYkhBaFhRcTdJZ1d1dDUvWDRRZG9xTW8zZ3EvbGpZUUNDTG9Ma3hLZmxZZ3hCQURFS2ppVkNnSVZqc2RvSWpmcUEwUk5rS1NhM29ZU2VFT0F1L2lDdWdkQ3lObEFNOE0vVThrL1VCZjdmVThjL1VCLzcvVTgwL1VwL2Y5UUYvdjhBVTg0L1U4QS9VODgvVThFL1U4OC9VSVI5L3dCU2svei9BRlBCUDFQQlAxQW5hWFAxTDlKU3ZBWUdEWWdPWjJSbFZtNXBLSjN1aDlXSWQ1citxdnZHWUF3UXhoQTdLYjRrTGc3clloV2REUU0xK0FQWUVLQlJPMllnV0wrRVBYcng4dHlUTWhUVUZnVGFhWE1vaXFOdVlDVmk3VUVlZ1hDYWhCN1hCNGlwVmNCb0lOKzVpaEFnQ1VQRUlZZ29rRkJlVFBIUDFFZjMrb0RqN2ZxRUg5L3FBLzhBWDZoQi9mNmdQL1g2aEdIK1g2bmduNm5sbjZubm42bmhuNm5qbjZoRVB2OEFxQXgrMzZubm42Z0NCSXRmNmcwN0lvYjVCaFhCTVNyektxQ2tCbXNZellXSWNKUjQxd1lQUmt3U3JTWUYvd0RMVGFUWlloa0hvc0JBTmdNU1lWekJpVXh0MUQwYjdoL3NvV1NkOXlsb2lMTDlCK1pZanZzVVh4TWFFQnA1SXp2b0RxZG5vSm1BbStZUGY0bDlDWXltZ0xFOGx2b0tlc1dSWTZ5MnJRRU9GWnBEQjJqT2FlNWZVNFFYek9XTCt2MU9ER3g0emRvYTg2czdZQStYT2lpOHJUeGUrZkJ3bjJkQ3RxQUFIc2FIODZmTnc4UnVkR1MxczMxQVF3R3BzajdsUHlVUFpvdk45eS9JNW56bGdPRDBaNmQ2WmlJYUF0bkM3SlgwbGNRalZiRGRwYkRzZ0t2cDNFZFFDQXN1N0RCZ0VLQTJsRUdBekdnTVF1VzBubjFnQXdNTlNsUk1PV2IxYkJlWUt4RnVrWGJmaUtHbjRTbkFOTTVXbUREN255Sms1amlkWTBCVk1xWlJBUVlvb1FqQmVzSlpnTTZXTUpaaDRtNkhSaUtyRkJMZG9QMnlFVjlzcGFHQSs2VUo3aFZZUm9RMmFTd1dLN3dRVE1VaXNZdVI2QkdCRVFabFc0eGJUWnRNOUFRU2hvSUlBanhML2lDTlFrRENGUWNCN3hvTUxpQUU4R0JhVlpSbUtHMlNRY1VzNjNNT3htV1ZSQXJkNm5hWGFuTU04dkVCaDB5UURZUVBPVTlET2QxeENCdzU2UnJNcXpnbEp3V1NRSWdwdkExaDRmaWtBZ0lhcGFtb0N4TGNUQnpvdmh1NkJGd1JCWWpRc0xnRG02MUZEOVlSV0JOUk5IR0VDR2JadXlESEZUQWJNZzdnd3hIeUtYSmVvd3A3U3lvbEN3RGorUWdrU3NwaitpNzBnd0F5R1FEWVMvYTI1TVl6Z1dNbnZINlFnVkE5bEFpRzNibm1FZzFRUkFXQjI0Z0lTcXhVcDVqMnhGeEVITU95RGZDZ1FnQktXTUhvQ2tNS1dwWjFzdzJIbmlLYUlRNnIwekQycW9YamFWTnhhRTRpUmFMMmd6UG93SmxSVWo5eGplNUVvekdzdm9Ga1RIYkpJVTJLRmZadnNEZUFVam1IYldJQis0aStBc2NRSVZvVm1GM09IOVgzRkhBKy9PaDJXbWRSdmlBaHJPVXdhQWpCS0FnQnRTK1JENm1keTVnWVIwSVZ4NWZTQW9tTWtKeVJQNEJuZ3Q5QTl5aTd5QWVJUkNRZ3NST2JHRURCODJuaHpCL3ZST0k0aDdGOXpoN004QnUwOGx2cDRIZlM5NVdubDk4K05ueGRBU0tueW9ZL09uek1QSWJuWHdHOEFBbytVSTd5cVA1ZHRCQmlVdUxmdUljTkprTTlIZk00Ym9EN1NnRVdMRjBVT3lYaG9hR0FvNmxHY3VhT0lvcC9tVEN1cjh1SW90RmVmbVdBUU50NW1zSlV4VEJGNGhoUVFUZ3Joa2dYUDhOekxwR01zbEJOb0NBMFRSWk9FRFIwWkdra0VhZ29kVkF6b0tHR0JYUVRpeUxqdmR2anRBUVZxUStCNWhEWUY1c3JBWVZ1YUVtU0UxTkloYUcxeEEySnNUVDJqRUh4bCtZSmlSTGdORUl4VUtnYlFEa1FQQWdMUWw5Q3B3QTVVcHVoTVFoai9odzZVREdsdTJNUXJJM0RjY1FjY1FBZ1JUMHNudER2bnRGSHgwQ1ZaM2pkQUY4WnpHdWtOMUlHVzlvQnFaSWF0WVJzbFpUMklIOXl5Ylg0aVlRZWNIVUhxQXRBOGJNTnpzSmRzVmh0MjFZT3VtZ2xGeEJVSXdSYUMwT3pUSm9NWmRMek1RdGEwVmtJSWZmUndJaXFHYUI5d2pidEJFZ2lsdEFiaDdiUUVSQUl0S3FYckJQeUtpc1greUpBRFhMbjFsQ2tocWJRTkFjV21JSUxpQWJ2ZWpNSitzbm5RZ0djWWducmlnSEFBbXpBSExSZVRvdzBqd0FJZEZBdkxSQm9kMGhNU3RGK1JIUm9SSno2ay93UXBwdUdDK2VYN25Ma2pka2VobEZhVTlVcjJUUll0QTRBOERpMERpa1FBc2x5MWRkUGxDaTE2M1JaSnBKUHRvVTZRVk1BVVIzamNxa0ZGQUhBQTB4Q083U3dYdFZiajMvVVBRT1pDSU1JMVd4S2p0ejNFc2ZCc0t0UG50OUFBeXFEWHBPTVFrOWovWjVSSUtNK0lKVUJTTDl3RkJMYWN5K2g1TGZUd2UrbDd5dFBQNzU4YlBpNkZsMDlZQ2ZvYWZNdzh4dWRQaTRkcDMycEVHTjBNcitJVVdRTmR5dG9FdXJYeE8yaDZKczlocDhLRUxRVzlOUytrYitnS1BRRlR0bVlLVGM2b1lYMld3Y0lQUHFvZFFab0E5NEJSMjFDNkF4blRjWVdFSG01NkVLQ3ZxT2g3dG9PQU1nQmpVSVZSSVNEQUpHaGRSbFFpWW1abVlsc0NzQlVKZW44NFJJQW02QVRNU1dBRlpsekd5Z0J0VHU0NFUxM1NHK0lETTJlcGFJcDBXc3JlQXFJS1dRVEtVY250QXhVRjNLTW9HLzFRenBBYTNRMkd3Z0NJYUJqUVYwRy9SekJvQldLalRldlFtN1d4cUtjSVdOQVJFcUxnL3FDVWd3ajdNRHRnREgyQnpHN0JxR3U1SDNCUXJMakVwbjRtTkV3T1NvZmtRTGc3aGxHd3pwWnFZQkFEMXBiS3dQU2h1QVd4UmxNYWtKOGt4a25jU3doUGJvVmoxQ1ExSFNWT2dQSFNkUWt6b0FTSVR3V1hCaGd0eVpDVnBtRVJ4Y1RCbm9Pd2NRWjhkeDZ3S2xkcVJvRWxLNGpCV0ZBQUFSOVpRSGFHQkdUT0J0QlhqamFVUVB0QWJ3dVNlaGtJUVY2b0FoMWtxRWpBOSt2elFTNWdLTGRIcHNoMFVEbjlPWlUvc2I1Um0wQ3JlakEyS0FSQVZoUEtLN0c4RUZWUGk3QTN5RTRHckpQRkdCNDFwZUJpb1ZoSlBaQkFJaWd3WTRlMlJxbVBYOWY5Y3d0ZmNZQTRBaERRYUF5ZEtvb0xhTWdkQzQ1aGl2VmQ5ajlEb3Y4dHZvRUxJWDBNd1BkRC9KemNQbDBNLzhBRU1hZVMzMEIwcnZSK0ttWTlCRHBzOEQ2b1FJY3ZpZkgwR2JuUFVUbytXbDVEYzZDdlpzZG9CZ0piQ0ZBN1Q4SVZsT2p0Ri8wUWZuRWUvUmVNeTRFdm1ZQUVRMmlLSGJvQ29DNFZHSWRtdVNGU0Rub3NtNTZtZXd4Mmw3Qjk0OXR3Um9leGlFVU45dlVHQVZOb0pUM3FQeWViK05EWm9rSzM2UlFlb0ZYUUZuQVdUcHpEZG9rTWRKdklvQmd3L1grS0tzSVF1S0N4SzBrTEVVYmlWelFMYXJ1bUFxWmdGUUVFd2c0Z3QyTUdvVnZ4ZFFYcDAwTEJDQTlHZEFZTll0Q2FEVG9wdTFFSFpBYXdta0ZUcWVoelY2NzRBZHdaZ3dvcktnQU1Oa0E3bkZZTWppUmlDYkQyaUMwcjEzYjdUWjFUMkVSQkY1bFVBNTRPUENlWUFRQ0hRMEcvUUZvN05CUTZob0JZMVJYUW0vUU5FQktpRUZWWVdqYjNvTDBoc2xGYkhFNW5aWk91RWp4aURhQWZ4VUg4ZG9qc20xeDNFSldKQ2cwQmx3QW1CU0Fhdkw1VG1VWHJrbThDZEJuR3BERUFEWEhTSm1YdEdRV2VsekxhUURRR2pNS3VVdjJoRWhFc0UxcVI2eHFIakNScDJnTWg3R1U0N2YvQUJDVnk3Ny9BRkVhdi94TXZSR0FkL01wZzZBQW1BSWRFRUV0eExTaGlPMG8xdnFENVI2blNIcS9zTlpmSmI2WDduOFJvRzYzdDl2M0RsN2s0eXA0TUZVMjlZS3U1RmxQVTlCdUQ4b2lROUhsUkNLYkkraUg4R0ltREFkSjA3b1hyZ2R6L2srTG9jTlI2QWZwNmZLUTh4dWRmaTROSzhQTEMwR29vVTU2RUFoTUtBR1l4ZjJhcCtlamJBckR4Tit2YVV4Q1RDR0pZd1VNeEdqWFJDSWFHc2dVV3FodGJWcnh3REV6TTMvV2hPbkZFaU13Sy80TEV1Zm1JUUEyQTB4QmVCbURtWjZraHp2aXBFaWFOUkNaQ1cxeFlwalFPZ1UwQldQeFRjRWRpSHVJZ0pvUGx6R21PcnRPQ3FLMXpvR3VPaElNeXBNZmVGSTZhMk5SZUVxQWNONVlKYm9iNXZoREV3VkNHaVg5eFNPZnV4OVFlVGRrZnFPUkQzSDhJRFpiY3NmblVpWTZRVkFRRUlXbHpvZU5TRVlDcFE2UVZPWWJvRDFNQ3BoSzd3WlFndEczZERYS3dRM0o4MXhGMHJ1VUZxL2VMUUxoR1ZLaUI2b2RrSkhqVXRWcXc3OU44UnBTMFpTWmdDMEcvcEJkQWFnQVFHZmVnbFVQdWwxUjZ3TFIrOWVuT2lIU2RzUjJna2tMUXo2YVgwcVVnZlFKZE9oeWVBak42b2NEZ05CVzViQnFxNTVmMGhDVjR2U0RTRUhLTzVsRXpGc2lsSjR2MGltZVZGS3dFeXFMUWdNVjR2eEFoOEFiUW9Uei9wUEYrazhMNlF2Qnl3MUxoSnZVUXgzaUxJemRoK29XQnk2dVQ2bUFRaDBDSHRZYXFyWDFQRitrT0I0cUphSGcvU1UvY3I3Zy9xRGFiSzd6UEIrazhINlJnVGdNekFKY1RibU5Ec3VJSTlSQlNjZy8xT0ppcSsvcHpvMk1jYkdYaERnUWpXbHVscGxrN28wQXlZVXBNNkpHZ0lRVkVTMFZJUXRPTlRxMEpKLzVTVUpaMWEyd1ZhTWJ4aU1Sd3hIQ1JqZU1SdzRjSnZFakc4WTNqMEdJeHZHT2dGR0VzUk5CTDBBUTBKZW9JT0dzWk1xTXRsbi9BQUthTDRRQWh2cUpUV2tRbUlVNkdhRU1kSWkyQ0docENJaG9JQWcwTGF1c0lhUnFOYXhIYU50R0ZmVUMzUmNPbEE1MU4zUWl1WVNyNkVxUEczamJ3c05CQ2NJQkVvVmhBalFVTWVOdkhnQTlZb0ppQXUwd1ptRUtZakFZUlNVVCs3aUhrM3F3TXhuUXR4c0kzbU8xUUpleUxRVldRczNuamY2Z01OTGtzRDlRSUZvSkdoam50Qkt5NEVEUXpIZUV2NHVSdkx5MDJILzhIMkF3SzdZUHZOMG9OazEvQTdQNWd2VnBFdytPQVJtUEFiaU15cVF0Y2Z0QllNd3pJMEJiOTRXWDZRckdmMUNwN0ZoT0RWM2NxU3VKbkd1Si9jRjEvd0M0dDNoR2JFeHY5bUVlMHRHQmFDQ29BNVQ5SUUwVmdOQ2VKNUgrb0xjR0FFV0VpbnJDTnZ5QUN4R0NMT0lCdUlnQjVmeEJVNS9wUWJrRGFEeE5Qd0t6K1lPZGVSTUhqOWVsQjRnT3NGRERXc0JVQmVpUFFub0dvTjBKUWpLb2RrckJRZElSWFVNOUYvOEFsR3NsUUNyT2hyb1RiTG9LMGhnMC93REtIL0FDZ1FpUWw2aEx3bDB4b0E1WWRBN0phQVhxYmFDeUVNeG8wSFFKUUhwRUlTR3U1b0hUWTlHOUI2RUxLbHRQQkVpNzZiYURYUVUxRzZVa2VoRFYyYVk5Q084SUNQcENHUWppSTBWTkEwN0dnRGhaUVk4ZUJoenBSb2wwTURuUjFVVWxrYzlDNGlOWXM2WmRDQ3BUY0NRKzg4MXVJQWZtRjhETUV2ZFhaVlk3UU5jSmdJR0UrMmw4ck9tRGdDVU1nWmhIMXdMM3VQbUFGQlRvREhOam1NQ2NrZzJnTUFiUjAwSU02ZTBBL3VGSHFueFBhTUdwbkh6bjVNK0YvVStiRlhWa3Zrd0VId2NSYWxiMGVYMnpseWZPVVh2L0FIRkgvd0NteWVZM3p4KzJHd0RVZGxWaUNTZ0VvQldqOTA5WU00Rk1nTVhXeHpIWkNXRGFBd09PckJOalMvZVZFRTlzSkowM0lhQ0p3SkNrSVN6Q3dJRG1JUTlRdHF4dkNXZWtRanFCOW9VQkF6QmRHb3liUURRa05RMlFod0JkQ0E0UXBiZUFPRUtXUldRb0lHRVZWTFlBNFF0SURNSVVzaXNtWUl4MU9NNzZvem1Zd2hKT2czUWxVRUZUZVZCUmdwb1F6Q0dJQW9TRURnNlJLRUpRWTM2Q1VJMGFQRmpHaWl6dmdUTW9nVjBSZ0xRRXhDR0k4TldBZjhaREdnU3pCb0xHak1EVmVncHAzSFEwbk1Hb0x0TzZQM2pJZ0U5S0RxYWdsTkx3cWhWc0JXaHZsTFZxS21DZ21VQU5zNW9LbGRXTjRzV0VEUjFZbml0eG9DK1BtQkJ2Y3B5TnBkMFRrVmRvRmZoTDUzWGY2MmVrS28wcWZ2RW1DQ2dzdjFGUXI4ZHhUQitWNlFhc1JIaXIzWWcvS2gxZzlXMWYzb2IrWS9KbnhQNjBhSmMzdGhVOFB0SHlPbXp1cjhZZnVOR2RERmduZzN0UENsT0FmaVZ3ZzgrbVVFR1c2M3lOb0U2Y1hhRlJZcktGOEJRWGhRRnZxTzRvRUg1K092ZGlFV01FSVJJa1FHcVN0bWlTb3pMUXdkYjZ5aG96S1NuUTBGcFRVQjZ4QWtsYTJFdWRCcHBOVXFMb1I4d1dNNHhDbEtyM2xtQmFJU0ttc05EU0FDQldodERTMTRoQm5HSVVvS210NVkwdEtkVkduZEZpUkRhVTZtRm9RMHFNTEVhTjR6Z3E2RkJ0b05DVk13TjhRV21JVEdoNmpSOUx4bUJWd2hqUTR4bmZVRmpTNGFuYkdlaHQ0OFdVTVNZaGU4WWFEUjZZZ1FveEZDaGdvSmpRSEJLR281MElDUEh6b0NSQU9ZeHZwVFVBS1lpRVVGWXlMdlFPMm1ST2dJd0JEVWt3WUFCQklTSSs1TVRNeWRBNTAzWVFXbml0eEw4cXZVeUpndmNNRUhZb0Q5b0Y4VFpwVnNSdktzSncySG1mRlNPTCtKa0JXTzBYeHBnVUFSUGwvRU5iQ2M0L1NVSmhaVVRZZndJZjFNV3JtbnlaV0lkbkVBSDRPZ1NsRmZQdTAyNzA0STZuQmRJRFdQY1NrZ0RWQTFuMkUrWEUrcGVxbFh5RFBEN1E1c3RlcFYrMFowWW1lS0g0TThqditJSjZ2VzJhY1RiOEg5VEVlTWxoWFJqVTg1Z0RhSTQ0Rm1pZXhHOEhXVXhLQkNxdkloMVV4YXVhZkpsWFcyY1FCK0RvTE8rZDhlUE9LQU5yWVNzWjFIZ0hRUWw2QXRTUWxtcGdRc3kySFpIaDJFQWVpb1RxTlJxdWxvSjBsRlVUUUNMb0E0dEZqaHFwRWRDc042U2tpaHJEVTB2QW81eEQ4d2ZPZ3FCZXQ1a3FVa1VOWWIwdkF0QTNNRmtJM2phM1FZSTZNRHJBNkFRU2pwRWxHWUN4RGNhQzhOcVJCb0NqQVhEQXFaai9BSkk3UWJ1bEcrSnRFZzBMT20zL0FKTU16bkdEcFFjRnRDTkFuU0dtT3EwRlRvU2dCbUFJVU9NUWlrSVd1WWdEZzdLYUFGTVlJVktWZ1k5RzVsQXNGUnFnNFFudmN6b05YR1V0QWNMaU1XYVQ5NEdITTdxdzhYOTBrR0FiWTJJWHV0MUFuK1BnU2N6Q3dpZG5DWUdmNHVONDFJWVU3S0FBN0xUOW0wR1dHUURCbjY2bDdXbTNBc0JNdG1BQmdlVW9FQmpXRjVvWU9TMmdXWHhJQ0FPQXpKRGlPeGlCbWhCUHJMSkY0Sk9JSEJoQTVJRzBRdTA4Z09QYUJZbHNaVmx3NmdRVVJCVklobUdvSTE0ZzRQQklnVWJpZjRPQkw2SUJMWndKL1RqNmhFT0NkNlFISmRpOXJRQUJBZ3NCL3dBOFFWRXBFNlNWMEJrWVN1b1dZKzZPTFlLQ2thYW9iMGdZQlY0aE93YnNTeFBZZEN4QlF5NlVoZUl3TUZvcm9rQjZHb0k4QVFocVZLSUxwSXFGQVZReEc4Ym9JSXZXT25NK0doMDVudWJTOUlDcUdJM2p3Z2hPc2RGQkl2Q1hHZHBZYVFYcWRuVG1VN29BNFJCS0RvT1dvb0lERVVFY0U3eTB0eEFXTkNCMXNnRlRvYnV0TWpRV2NSMHBVWXlZd3pDWHlndExYUkFQU3U4NzV4YUhGb3RRZmVBVDBLNllqdUNvMUJ3S1RuVEk2SFdFQkRkRmZMSWlZMUFTRXM2aTRJb1FJTVZCY1FRN0lCblNjWGlJQmFnVWVOWU1IQUZaY1JDVkJXY29SQ21qV0NFdWNDZFljc1JFTkFGeGZNd0pMbUNnVUFUMElZZ2Fyb1NSMjZ3M3diNHVsNGJNQVFqR2hLS0RvVGJ3RnZxUmo2RmpHK21JU1NncEIrSUpCcnJpWFBTQXpBZzBZM2xPSHNEaHhWS0RWaFNoa3U3Z0VwQzByWUtqd0hEQ1g2aENJNTJYM0plSUJxUWc1VEtzMjBMdERIQmc0alJla1RFUkVHcExLR3NackwwWUVUUWtUUm1kS0NNZENDaHhGY2ZTTTJ6RmNKOEl5S1Mxb2RnaGN1a0t0UnlmcFBkUUdvazg2TDJSQ0FFWVhEaTlBbnh6RWIyVmoyMzlJUTQxU0xPWUpPMEJucXAxSXhvMFIxWk1BSmxreG9ndFE0d0JDZElEdWc1VVVhRGlNd0U1MElSbG9RUmVBcUF2UzcveEJHQUxwcTJBWmxUbUhvWkdtdStCSG1YWmJDbjlnOUhuWnZ6QnFSWjhZQ0VGeUd5U3ZERTBZY0dadFNJL1dibUY2QUVpRGYwTzRLQlExQUI2M3lkRlppQ3hLTmh5aDQwSE1QUVRhaGtma2dEMER5Z2JIS0E0UjRjQlZKSEVRT1ZWSzQ0M2hTQ3BWUUVkNEc2RXpvbDBOeWgzRXdpakNRNFFWU2ZTWWdxNkViWG1ZTGFTUlVZTW96QUtHc3NNb01hQUV4SFNSRUJlSmlNRE55MHhDRDI2QW9kTlNSMFZkWVdURnJneHJrT2hJYUxqb09xMFlNWXo1U3lMbnlndE1RbDlJaEtFcUNuZ1J5bDRmcURrTHFuTW1VSE9DaE9aSHNDQVM5RWdmS1E0dFlEYWdRV1dBZVp4RFVBdFZjSHBCUzNEWGhDMlFTQjJZQWx3QlUwRC9FS09YUkNrR1JqRVFsbW9BeDBEZkRZSm5vQTZtTDNndHowQ3hRaUVpcHJEbExzLzQxdE94U2NITHRENVoyTC9BRnh2QWk1WDhtRW1qSTNJS0tnVGx2OEFCaHc0WGZFY3l2cTVWQUZndkJPUWhTSDRPMDI3QW9CQ0ZZSlNkMUpjMzBBV2doaUk3YUJMS0doRFVhTnhETytBTkNYRnE2QzBKa0JnWk1OUWRBbEQrWTlnaEdWM0hNT1ExQnZSQ0pZazVqcmt4VTc4Q0cwdFFVOVEvVVo2bWtKbzVsVjhxSU0vM2U5Tkc2N1I1RFF1cFhWUW1hQ2tFT0FnUmdTdkNjTlRFb1RSQUpNQVROZUNqR1cyQkI5UVhyaUc0bFZYNUlUazdnUS9BelFGb0hRYm9ydWdhcDFIbjlobFhXNGNtRUFaTnN5dlJXVVB0b1FSZlcwRytNYVkzaGJyQUdZa0pldGFJZXNJVTRsRUVBeTdMMWdEMGNCQUJ0a0RFUUVyY2dBTG9LamFEdjNnZ3NVR1RmaUFtR2pTQkd6SDZnazNzUXZMUXMrNzl5ME5Cc3dBNFNBUmNrUkt1U1ZINTI4TU1lMUVkbzhSQWVrSEJxSVRxWlRVbHJ6ZHAxQmdCZ05BU1NDKzhJRVUwSTRpTkNrWDZYVmF0WlR2MEFOTGlLK3FFT2cxZ0FEVWh0cGFCb1FjTjRMeTNlWEV4RTRrUTFUZVVHMG9SNVp0Qm9CMEw4Y01wMEY4MkFmcUFZS1RIRElGOHd3RUw3c1dnTXJacFNVU014VjVpUlZMSXlOSUVxUVJ5VVMxRDZtR3NZU0lRYVpSSFlWd291RXFRSlgrVVFKYkFRUlV1MFh2VzM2VWd1QzBNTkVZUGlBazBGTkc0eTRtSXRwM21SMUJibUJmdEI4UWltMEx3T0szMHNzYm02d1FuZCtuR0VEMDRLMFdYaE5xdThWaDBUTEpVZTRwQ0wzc2VWYjFnZ24rNElwcWlGR1ZEeURKQkRFSGtQZHI3UjRZM3M5VDZ6NU9PQjJQTUo5WXRvZEJFQ0NHSUNjS2FrNldNQmVqT0RTV2RSWGFCVy9FY0RFMjdEcTlZMVlsQzB4UFMxY2V3ZGdmeENGVkF2UitwVHJidWg3V2xYV1RTSmVBSEYwR0pudGdmK05ZSkFXb0x6RU8yVVNwaDUzeDR5STJYQzhvQldCSFFRZjJSSWhxSFpGOElsa25ibHRkY2hiMVhQQ2dMV25LZVRvT3JyOE5oS2hRaUMrSjJsRUY2Ryt3OUVCZ2tPL01KcVg5QWhFTGljYi9BT0VSR1RCUXdSblVFWWJyUWI0Q0plQW5vYWxyZ09wMnhrUjRBU1pSQXdSa1FqSkxSTGI3c0FDd2hkUm00bVZ4SzhkR3F5V01JUWdJbG1qQVBMREljdUpqd0pGbjdnaVJJMUozM2pTejFMenoyMElhTjRwUVFMaCt3M3pBWXIvQ01FNmtUSGo1ME9pZzNRb1VhWmJ3aGlKcXdnUWx0b0FZS3laMHNZQ3hBRWN5Z3pvUTlBcHJCVWFFQkttbG5SQTU2Y3VtNUxqTFFDOWN6cGNNMklTQXZHUnFMUFJ6czVqVWdpVHNqOU56NnFTTW5hQUNVQ0pOaHZpTHY3bE5uNDVtWEJEV2Q0cHJqQkNwZ2RpMDhDQVRyNElSSThic0dQeFpCdnVnR0N0dVhoUGxvVFZDdTdHRitxUkFpQ3lBc21rRnpBYjF4V3NnQWc5WWRRRjYxa2xtQVNpNDBFSUl4SzhoTzJWNENZNkNVNDJJVUZsWHhEdTRueVl1eHZIbTB6YU9MamRoYlQ2Y2ZPQUZyWGdSYTdCSlVXZEZ1YVFnQ0lXbjRDSWNqN01uRU1RaHVyRTNIUGN5dGdURDRDcFhRZ0dKUTVqRUJUQllpR1FZZ3lNMnBmWVgzb0NvOVlyTWEwT2owek1hV3d1bHVBV2t0SEtReUNad0lMcThSTm80aTV0cVp5TzBFRStvTFNvWThrcHNIMWdVZE9ZcmpZa1NrdEpyK1ZnVVF3dlc1Z3dmUll0Nm45UWpBclhwZUVpVDdIMmg4QVB5dXFzSERwdWdDNmk4UTRTbDg0VmhFZTNxQXNUU1gxcVlJZ2Z5YVVDZ213ZDB2VzBPQzFuM3FuOURRRTRWa3dKdXNnQWVray8zU204M2V0ZlNIczZ0MlpPbkJ4emNSRnF4RDBHVjVrZHdKZmVheVB3OUlTMUc3b0crWDAyT2hIYVgxVGFGQkFIR0lLaWozS2hXR0EyNWlsNGkwRUlROVRBM2hNRzhWaVlNQUJ1cUNFQmF0K1BjWGxVZmphMnlHVjlTb0RFb0FnMGYzT1JBWEJlaUk0WU9aalF3Y2M2ZWtxVWVZaXhSQ1FJcXZxbFZGRWVZQWVYOFR3ZlRQQjlNOFgwenhmVEcrWDhUei9UUEY5TThIMHp6L1RQSDljOGYwenhmVEcrWDhUei9BRXp5L1RQUDlNOC8wd0N0NWUwVFJEQW9LSWJRbWdRRzNTNXBualFXaDRnQ1NZT2k1Q05EWVpRaUE1NjduR0dFTlRyQTRXSW8wa0lrMjV6RHhGWDluVmpHTVljQVU0WFRKc3R6L1lrKzArb0hlVi9nUVdMNUoybmVmbFA2b0FJeXluQUcwWklZKzBDUFkxbFgrSVdZbFMwT3c1aW9NUzJBWmN4WVlJQUdUZFlXRW16bUlHdVRjTGlJRFFWWitFSlVzVkcrc3FhT1kwRitvaGpRT20yYk5RK1NBb2dhTkhIRkZCL1JId0g0Z2hBaEpBWGdHK2hCbS9aZ3FWWFBmK0NBRkVNY3hhQlF5RFFyRW5WN21DcUI5cHlzSlFkT3o4VU9ndkdBSVdqTzJpQ042Z215TTlEVkJzNnJvQnRDMzlHeUpHTGdYb0RZUFdEN0Q5OFhNS2pIcWpiMERVcTNWUEFhbFNVVURJd1lVQWp1UGVmbXZwNU1BWGZVU1hLL0lnTERGdWtiNEExYkFEVWdKMjZOQ01oQ0pLYkNiSmJzWU5OTGJqZnVZT0VKWFMwQ2pLM1oxZzd3SGV1bFpnZEREVSs4WFVCRVBjOWhTUGdKdVFhQjlwWTVlZ1FtUnphUjd1aDlGSzZrRGRRL0p4RDFRWFlQZkJiUWE2b21QS05SYUVFSFVGUWJvc08yWmdJUXFJUnAvdWg5NnpuWllFYlRtcUFCRXcybG1nVmdxd20zNWhNaHdwS09jV1FTTFMzVHFsd01MYUlpUEpOcGJWVk55VFo2cWQwUm5GTDhFdlo3SWhYQnZERkZOaUhpSGJIZ2JYT2dwaEtFVUpaMGZ2cDg3OEgvQUpEOXhBMTUwWU9kVzhESmgyd2M2WFlMSmNkcFVNODNqLzRsWkxDdDlvYWRncXdEWGllRFZWZFB5WVNvMHhxZ0szaHVrYXo2QUhOeGlrTFBhRFlHd2dneEN3ZnBCa1NwQXRlMFQxY2lOM09HTVFBMEJkTms5RkhMaGkwS1lZQXB4RzBLdGZES0FscncwSXloNkpFQmJhb1NrTVQ3VHpmWFBIOWNkNC94UEg5YzhYMXlsNC9pZUw2NTRQcm5qK3VlUDY1NC9ybmordWVQNjU1L3JubSt1ZWI2NTVmcmhaTklDQXFSeExEZ2hQZ3h6VzkyaHRjTkNYdnhyN21IZklzWno1K0lnRVNEQTBCaWsyTUVwUEFib0NGYkR2N1E2d21aekNyNmpoa0VDQk5JYjZnak1NZWhxczhmMXp5L1hQSjljOG4xenlmWFBOOWM4bjF6eS9YUEw5Yzh2MXp5ZlhQSDljOG4xenlmWFBKOWM4bjF6eWZYR1A1djFwbUFyVUJnRmZXRmtid0hjY0Q5eloreis0UzRpUUxZdmRvVEFBRWJNMzBQNmQ5MFdMOGdJZnFJSzRGd1BFSlp1Z1IzOUxTSUFGVTJQaDFPbEJBQVRlRXNzR1JSUE45YzgzMXp3ZlhQQjljQVBIK0o0dnJuaSt1ZWI2NTRQcm5tK3VlTDY1UThmeEVlUDhTcDQvaWVENjRERUR4K2tIb3YyUU02SllDT3NEZGdRcklDNVRCRWZtWG00RUVLQ29KN21zZFVVa1FwalBZNGVsVXEzRWVzRC9NRHExb0xBMEk2QnFWVkZRYklHcjlEdkNEZ1MxVkRLSHNoc1QrNHdRa0FyaE1hL0N2NFE2SHBaN1RuZXlMTEJiL0NlRDY1enZEaWVINlo1dm9uSTgrSjVQcm5nK3VlSDY1NGZybmgrcWVINjU0ZnFuaCt1ZVA2NEdnYko4NlNrVUlNTnBYbkFnb2RoSFYvb2hqOENzekVBYmIrck4reGwrQzlrc0ppQmxNUWtsbVc5cHVmWFlsUjd6UXlGL1pCdjM2aWcxMEVZbU1ZS1hqd0NNOUJPTG5RcjlNYUN6VDUvd0NML3dBbnplcGYwNE16R2g0MGFWTThQajFXaGh3aWwzQVZDVXpCR3I1bVo1S3Z1aVVSeFRkVCt4MDN4UUFNb3QrSllPQTR2M0lvZ2srTXgwcTI1S2xoSWQraFNybTFSMlZoVmtBRGRtRUVDVklCRmsvcVVrbnRXNStvRUZTc3Q4akJETUhwWXNVV2FXamthU0FtYnh0ZjNRd3E3eFZnWmdEU1FKZ0ozRzBGM2dYWjJnZ0RvbVkzaFJxYXg4K3N5Uy9kTFN6ZncrU0RERmhYbDhCWW5oOTNWWFFmc1VUMHBqNEpRbXl3cUxvV1Y3ZURScUY3UXdIZ3lwSEd5UVdYbnljTmo2UWlqK01tL0VKRTlBeHhJeURuQmxPMkI4ek14Rm01eEhJQUd6Ri9xYUlQNVMxdHg3UmREeks3MkZUc21KYmZQaW1CSW5IdW1uTENWSG5OOGpEeXlkNnV3OFJuTXFXaEJEU0Q5citSMURnUkEzSmhNb0NKaGk5YlJVTWJON2xLK1c1Q2thaFM1TEZBYmhNMjNBSzRqbjBoRWJiTFppeDhqVjBOdWtKc1c0OENJSnJjY0NGeXBwTjIvckd4QktqV3g2c3d1YkFJeXJEbmVER2M5a292TVZJM0NrSFpmQ1pBbXdmTUZXUUdJUUJrSEZTTGtHa0xxRFk1U09nYmdxQjlZb3FSSkdCUitlNjZmZUlqeEhFSnNPQm1uTUZrT1NGdWxib2t1d3ZMRVdnb1JDZW42SEpGTzRxQVZXRVQ4SHNMWXRTTHBFbGFpZ01QU1RiUFM2QkRVMkJPTUIrQVJBR0NEY3A3WGpOUXdNUTgxeVRjK3NBWlg3MkFBaFlSM3FzOG04RlNsSnNSTXZzRUlOY2d1UlArRTQxYlpxUHZNY2hXZmE2RHFvaCtTd1B6RDhHd1VjUjJFRHIwVW9RUnRTeERHRi9oSmljb0dTUy9CMXEzd0x2T0wyd0ZvSGZvcnNQM1pMYjNkQlZZUmlnd0xGQXZDY1VKYUtoZnBDTStOL3d6bFJ4aXU1RjVUalIwdG5lMXVrQmZsK2tSMGl6Y2dFMkRpN0NIRWd1V2Q1V3p4RTRpUWowSDB4Qms2aHlFSUk1Y3ZwcVVDQ0FnTFhEaHdJR0NFZ1NGd2h0QlRRUUlTQWJtT1BUWkFET1pyL2lic0JSaExNWjJocVFtWUFJT3JNK1YrRC95QSs3Z2RWYzFBY0FRaElFSkdBakYzaXhaVDViZW9oQThHWG9ZRmZnK0EvVFFZUHBZTGUzNGpSellTWFZrMmdSQXhYZUFYUUdHV1Ird2VsOVdTQ1psK01sYnl2Sk9BTCtrRVlYWVFONzRoMEVESzZCREhyQlpkYXlHTmNSRTRSQ0NyTVFMZVlmU1hONjVnMHZWc0tJQ0NpYWN6bGJJZ1pXcXZjaGlBZzZBOXpMVUxjNU1SNUsrOVJpT0Qvb05FQm1PckVYOEVwTWplY1VnVExTMmVGM2RTMWJ6aUovZWY2NlRoeElaVTdxQWRkTzNDUHFlMi9JZzdxT3JLdGo4UTVtNWYwNllzcXQ2enYzRzdMT1J3STNzTU5kdHVWSVJGVUxLNUh1b1AzQUQwZzdZTFh3L1dYejdBWUVZSnljRlIrcENYQ1VvK25UNjArNSsxUnpmOUNaMkpDSGpKOVN6b0FvMlVZUXJIOFo5WmpSc3o0UDg5WGtOa0VBQlFEWXhwZWUzU25wSEtjVi9rUG1BUURRaDBYK1kzNllPUjNKTmVvZ0d4b0FCZXRZL05yTzJIMWlEWkg0bkNraEFnaUFuNmZtTlJTbzNPNW40bFdRSzdJZm9KeDY3Nm81RDljTFVpUkVCd1lpd2ZNWTdIMmhERy9lb0pUK29JMkI2cUFteFFCM0poSzhBVGxSQUQyWSt2UXdLTjRQdWhNQWtXbm1OM1ZRNnNlclAxQS9qa0hVTGxCRUR1UUsyYkI2RmpUeTV3N1pLZmhGRUVBZ2RrblM0bENCVE1DdmtOUzd0djJnRmFiMXgrM3hEN0hqQ2R6c1NFQkNERWE2T2U1MGVlK2ZuQUYrM3hZZmdRWWNvQ09FT2xoRE43WlhUdU1PelMwRkIyRVVFY1JldmxzaGxiM3dQcUVmMXNoQXZDMFIyRVErVUgvZ1lnRnlQemJ3b3ZRenVZVDVIYkFBbnVaMHZkaWVJM3dodndYQUEvcUpSQW1GaCtwSFMxaFlLQ1dnRUJaRnlZVGNDS1hpa1NDSFZCQytTR2ZoUDNLY0tRVEVzajVSdWJKTldLN3kwQUswQlFkdExrTENMUzVrMTNnR2NTS0JDSGJOQU8rODJ2Z0JwY3ZLZmJNTWlrWUtBamNOekNCdXlDY0xCYUF0UURLZ0NDMGVEZk1RZ0pyR2Q1YUE5STFjK1YrRC9BTW56MmhERFFhZ2oyZ0NFT0kwM1lDYnJRbW1VeHA0UEhxQkRXbEpRa0l3dUVFeU5XeWh1a29BdHlBZ0VKVkFnc0M1aVlPMEdDUUdlMFNueGtJWTdVQlJNdFZJV3FqZUhJUkxhSDJIVGhXaWJNTzM0TThCazRPdzdrK2tHTmlkbVE0Qmt1VUVTVlhhQmora2srSEtSSUtST052bUh1MVJDY3ZXT3BORmg2T2ZXZDlrMGdMS1dnb1Q5VnVUOFFLdGl6SWJHQ0U4V05EUHRML0VFYzl1WUtid05JQzNFTWpKRGtvZERLUkFvTkxhVHp1N3F2MmdmRWgvdVliWStkWWFBVitvcDBkM084aW9pK09XbGc0aWMwcVp3Q3hRZ3hjSzltejJVRVRIVWFFcHZoVG9RMUFTK202OHczN2orSnlNZVBsVW9wTk1tNU9VeXdOWHJXRkJGMlFtdUFEc1FJQUFDb29POVBrUkVMV0JZRWQ2cjh4ZjRxTS9wT3hnMENEbGNEV1FGT3ErRC9QVnlXNlRSY1NhK1JRWFMzS0dNQ0wyN2FORCtwaTBKTnFKUTZBR1dCNzBJWFphOFdMWXFzTHBYOWh1bEI0ZG9CWVRYMzZCQkFNRVdJRTBwQ3pnVVYwU2JaUDJZUHZGQjA0NU1JRkZrVUFZL21uckN4Z0NSb2hBb1JTWXdHRFhPQ0xpUmdvK3dsNm9iWmd3bmc0bE9CYmpidndFcVZsek5CWTVBVnBpSHJVUVZhaGFBR2thQmxCMGhla0lvVmhEYVZYalR1QmI0amhPcHpPSzRIOVE2ZklidXArSzY1bEZtSUNWN0hFSlpnQ3FTNS94SkVVU1N2MUVyR3M0QlhWY2RDMEtCVmkvdWRWc1ZvNHdFZ255RjQ5Z3loaEhRajd2b0lQb1QvcVBEM29nZmd6ZVMxRUgxZ01acXlHZzdnc1o1K1hEVjFVaTZDejVZeEtwVnluZUdqT04vam9yTGwxTXpkcElnMndWb0dZdjhOWVF0TlJjN3dxclNIamJXMmhndzhIU2NKaVArQkRPVUN0Zy9wQnRCSXFGejFpRk9VRUVzb3N6NCtrY0g4T0RvWkVvTkZna2ZhRkJWQW8wTHBZbDUvYWlqd3Q2d3dsNVYrSWRIRGFHcXdnZ28wYUs0aEhEa1BBY1lpTzJ4TzhMdURBcVlsYVZkT0JCQ1ZRaUtMd0dXeWRyOWtMVnBxZmp3aEtwWUwrOHFWZXF3SFBNTktrTW4wSTQrckd1UjlwVCtiTHc2amx2QmptRThtUUVaQ29oVzlaaVJBYWhSQ2hBeElBcmY4Q0Fid0Jhb1B6K0RwQVhBd2dubW8wbVVvMWpmVURxUk1jZ0JtQUpnem4vSitvamNwZjd4QkpVaGdPV3BQdkRPQTFQNG0vVDg1QXRBRUllSUp1Nk1vTktITXFDWmdCY0lyRm96M1Fpazhmam9va3BlTlhIcEtrZnczRG9ld2lmTEN4dmUySUtBSzNKbHZHSUdqUmk3ZXlzRm5DUWpDcCtCNndnU3hpVFdhV2hsaWRBVXdjSUJnT1JQMGhWNTZvTVZaYmhRZmlRUVBvWVNOOWIvQUVxM2drZ1JkdUpvbzZ5YkFxR1BRUVVGNkh0MGtlMm5BRGRCcHVsVWd4S2VzS2J4VW0rSWV0NVcwM2R3ZmhLYWlTTHE0aTJSemplRkZuRlNKSXBpR2c3Mi9NdmZMcUZzT1JDWTBQYVYzb01qZURSQVM0Z0tmcmVBYnV0eUpUR3QrNUVrNWhRZUVQRk9KbFpOY0R1YlFWTlFvTm9Tb21pQ3NFQkFFdU9uS2s3WWU4SnBxREE1TGFHbVJCUmdsR0lYdGFGaXVWN1hqSjBVR1VBeDd3eEhSMHVCOVBtYjlmSWRZTzlJc0J1VXMxdG9iaHg3eTM5UG1BNVZXMmdhYThrR29VOXBRbWw2cFA3U2wzbFU5NCtrcXIvVjNqR1lqczJvWmt3UjNtOVZ6MzBEU1ZuM0FmMmZBYi9vUTcwc3ZGTHozaDNlWUpIQnBMbXBmMVVLUjFXL2ZPYkc4T1RMOFpIcUJTRkJCek1BdG9HUGlmeU5NdzFCdWRxRUUyZmFITmJ3QkowaHEzUVhmbUVLZ0VZL0NOWURoWUdRYjl6TU5JaHdRRmV1ZmFBU1N1QklFSUUvZ1lET05uZnRCNURRUmU0dlNVZ0FBaWszRE5HeUNMSGVGSmhEcUEvYTBDQjhGQUZrL1NBbCtLVm9FZ3FCQkhyRHdRd1kwRVNrM29CVGZ1R3dCY0YwODhERUNQeS9BS0VwL3RTVWtLTjJsaTlOaEhwNDBCRUI3SWZlZmp0U2tOTG1IZEVEcWZRb3VHNktIS2tLQjgrZ1hVUDVpSHBGK0t3QzVVcDViQ0NvV0FKb3NhRlpIU0NVK1dYdXZwUVVubU4zUVk1VXhKM0QyaWtOeTB3L01FSFIwWmhmSHRDR2d3aEY2ZTVnYkpTTkFuZkJoSHhBd1lXQkNGRW9CWnNSYmJJSUFQdzk0ektMVUxEOXhZL1FxZzVobko0MG10cXpTY1hjNkdENVFzVWhGSDloMEhMR0VoM0VXVWVKMi9EYlJsQ0ZrRlJGTG5abEdIREtmblB3bFVTQUc0UHdEQW9BbDZuMVVLVEV4cUhCL3NER09aSVVDUG1WQ1RqNEZZREhWdUFCRU1Gd1BlVjBxZDdzd01RUW9GN3plVlhhbVJUZm9PQXlBZHV6WHNoQkd3UTRRM2RvRGxWYmFCcHJ5UWFoVDJoaUxid2EvY1p5UXZ5QWpPSTRwNVFGc1l6cXVWK2tNQVFJd3dQZlF6MXJBQVQyQ0R2Q0NpOHI5RVNpNVZ5d0dFdnFNSkJieXFJTVNCN2hMcmQ1Q0VNYTFBSStONGVzMHBhZTNFL1gyVkVxdEZGZHR0M2c4QUVSSkhHQzN5RzZwUlRGbkFveXNOTlNNT2lpaEtDT29KalFuR0RUNW40dFFzcFlHS0xGVURaMzNtTlBGNDYxMktZbkRmcUcwRUJHTjNyMEV1L2c4Rll2WmlXaDQwczZodk1oZlFCaWVQeDBmc1hvbnYzZ0pJSWNJQTY3WmlpY1lyZGFtc0pUVXdRR1BQYUMyNzN0MnI3eEVUbWxPU1dmMTdSRGpDZ0tkemt3eGJTb0pvODhRcW1TWkZkZDk0bjhJNEpiUWhVaDJZM0c5NFhmaUlRUkQ1dEM3c29iSWhJaUNEckRhRjdWakFoUGdCSXdiQU1HdHVMYXFwa040UTN1UEVlZEQ3TUpVYWlONzFFTXZXeXNVQVFiQlBlQ0FtUENnYTNPSVczU3UrTzZLRTMxZlZBNFJBWW9JaWxWb2FTNkhNb0FFSG1VNWhvZjNDS01xcWhBM1lZQU50WUFPQTdnR29ndG9ET3B6RHQraC9jTXpBRWxYVVhic2lvWUJLc2RsUERqM3BlQ3V6MXRMWHRFQVRzQXRGbW91OWsvVTh6dWpqMVZweFJ2bU1ua2VTS1VRdjZ0REl2UTVVTkd2Q0Myb3YyRUMxT1lkM2hDMDhZbEZ4dkJVSWpQWkFtYksrOEtUU0N4VW1xcEtkNEdPaUhwZjVsc0lDRE1HaTJDbmFuSG4vVk9JTnh4d3JPMDdRNnJVeDNrVjh4bThOUkE3YTdDbWVOd040bFlUdEllcmNQNEU0OGdvZWtCWEtDc0dQZy96b0wwdkVHM0M4bjRjL0doOFZMUGl6dVVQdUFxT3ZZUDZsc1hLN011SUJBcVBWeTNwOHp6bTJPNVN0WjBBc09ZQ2FYdnNIK3cwUkJ1ZTNzdmVibkc5ekQ4Q0FtVWVCV09IU0p2YURHSHRQdXU1amNKRDRVem9DSktvQlVRQXJYN0kzM0N2WG9KSmlrRmt3RDBuZUpkbktoQUxRUWNRRFdEYUMxWFlGRG1CeE1LMkRpeU9EbUI3cjhUZ1k4djZHT1lpOGFiMWdOM20wV1hvV004aHU2RGFVWEZGelFzQUJEYWZBeS8wQjdxdHFSdnRQZzRxQml0aEEzR1MwOUpUS1lZRDNJb0trU0QzSmU4WXA0cFF5WWRERmZDZ2hxQXY0bm9VM1ErMEpGZDFMWDhWNDFPQUU4N0NZbDVwc2w3d0NMQW1BUnA0UG5lWUJHWUdEdjBDRUg3OEFTd3p1a0JoVEQwQkxYQTlZUFpNanhBVXFFQTEwK0YzRzBKVzBIdEt4VlJmTUo4cjIwVjA4ZHYwZVczbFl6Ujd6WDZFQUcxbFhCOVFYTUpXQ3BGZnpEQVVCT2JXMzAyUGVHek1uZEcwUXY2dERJdlE1VWZVY1F0MUg4UUlCeG9JbFYveGhrQmIvQmErcG5VQXdVcFdVSWROYUhCRUk2K1VaamRSMUdLbFdxbGc3ckI3MHJGSHdBdThPOXZFWmp5b2NrVlViOGJ5c29EYzhjUU5ZT3EzZERIVlZpOWhIbUhJUTU0aGpWU0NIa2NTYTRSbHdUOXU0SEppUXh5akNHQVVlWWxyb29PVU5DQWI2b2d3Vm9OUjUvQm9DWkhOdzV3ZDlYUjR2SFMyMFE5WUhaQUE0R2dpQW9UMkRBS29qc0lQM1pkanlOQWs2c0E3NCtlZ0gzOEVwaDQ2c3prSWJzUkVIRXN2QXluYksvTGIvNGxZUlp3cUZXQjBub3dnaUNiZmFiV0xhVWZHQjFvL0NETXlRTDBCWWVIVW1BdVZWNFFwUTVaUHhLdnlRcXZ2T3dFSzRWUllWSUhzTXhCc1ZSZ0xqWkU4UE5vQ0U1c3h1ZG5JaUlqWVI5aWdPNkVTSDNlaUZBQVd3d0JLQXRSQlJDUXpEVUthaTIwQVpnb0o0dmQvd0NIYjNvRU83WUVxVUYwTTVqL0FGL1Vwbk9aMUJKamVoQ0hDYVNCOWdlSGdiUmxQUmdERk5qeWlVSjc0L3o4VGdBOTFmN1BaSmd2REYzQWFSYjRnanNkakNvMTZuWGxDVVljQXQ4aUllT1VTdTUrZE02c1JzV09pSHMveU5jRC9xVkFRRXlIc1FiMHJTM3pDRkJuTFpOM01GbDNZanFDSzE1anBWS0JRWmRLd09ud21uVUViOHpNYndUN3hneDBHcHJ1NWpCcXBnL3RHajZBSjArWWRQZGRZL0M4eDNKSzV0N3dFeDZHQmdabWJaRXZZUk0rRDhwZm9TNWcxY0pVelVXaGpNQnlRQWFFRTBGMHArNWhLci9rQ1MyKzR5WTdrR01kODZBUWRIV1JXdUlNUnU0S2Y4TGNRd0V4VC9hQ0s1UGx5QUlaVklxYUhneFVvVmM5RVBtd2lyRTBsbzBQZWRvODh4dS84SStOZWlMR0VRbUxHb1BaRDBzSlVUQmxKRmlwekM4YlkvZERhZHUza2ZVUllpcDNGdnhGWmh1bnpEcHJBZ2NNZmNUY3BUQ2dCVnVnWElBbUE5SHdBMVA4Z2pmY1JDazRKOUJEZlpyNWJmOEE4SlJNaTQ0SFFaaGdsS2tFb2ZmSUxDbUlpRTYyS0lGRkZhSm1EWER3ZDVhTEFDQmMxQ0pLY0w0bGpUMWkyYkpnYkZVTHljR0FGY0N3Qmppc1RYZVJzQlluY3c5c3ZjWE84TW1oQXNWSG1KcWd0d1E2NHROMk1xSXp2UGpxVUVGVmVsbW5wK2YrTFFDNFpTU2JSNGgrNWF4Z1FKMThYam9tOEQ3VjFNV2EyZkdoZ1JoSDIxU0ZnL25YNTZCaFFiMFk2RVM4SXJhQUZ2TVJvS3ZtQ2VWZnVlWmZ1Y2J5NW5uWDduZ1g3bkE4dVlDR2dlWE15Qjh1WUJSanl6UEFpOVpodThzeWlud3VaYW94NVhoQitMKzA4cS9jOFMvYzhTL2NOUlNuY244eXRDYlZXNGhYR3lyMFlOcFNJbXJjZldVeEJzRnJzMmdlZXMyR3p3b2lCRVlhS2hsRU1xMFlnSVF4QnZ4SVZJT0VLd051OFlmaUN3RzgrNmJrWEJGUUNBcDJpWmJBUWI1YUVCTXo0dUxQZnJRRUFFdC80b2lKRXhFRDZiR3AyU0FuRGtQYy9FRlhWQmRtSVJCMHBiUGhXS09ZRkZEQ0xOMGJSWEVBRE5SOENYdHFYbnJCaXJoQjdWKzRVU0lpb3N5TWRzN3ZNUGVFWlFZUlMrdDRXUEdWQUVHb1UweG1sUTFYbzd1dDZGM2NVTVR6WnY4QWdtYnU3dUNaWnRmdlUyQmlXTnBodTQyTkloL2lJTEFXajBBRDZPQVFwcE93WDRLK3NJODhBdkFOd3dJOG8rTnlJRll6QlpjRDYybHZCWHZJaDlRVE1FWnhBS3NtMXpFT0FRaFJocThlOHpVNmt3N3VMTDMxSWw2RVhNVWtEYXdvRHlYNm9pZVJvQWoxWUp1YWo5dnBOdUJ1NmhoRVpBa0N6UERNd2p5V2RpWmk3emFoZ0g1Y09ScEhkc3czd0J3d2pnU3Q3bnZIdnVyRUlISTNONVIxN3JISlF4US9hYnVXWlJYdUJUUXNxQnM0QU5oTXV1T2dSdWZNc0J0MEtzZ0RGU1hRWGF5Z3h5WWVtVkFBOERhU0JmQlgrNUNKT1A4QU1xS0tDRDVoSmtrcGtKdTNOQ1hnSUVJQjFySG9SS2Nxb0NSbVdjL1FaZ0lucFYxRUlxNytRVGRDa2VVdWdqME9JNUdDdkhENGpjaDBPcFlPSENRaFZnWGdoUFJqUkJVQkZPbkZUTVJIS1VrZW1TZ0FpZlAvQUJkSHdXdmk4ZFBDNDZiOEZ0cjRUZHI4OUE5S0dScUdlbDQ4N1kra3p2MEFFd2I0ZzRqeWhwUFNJVE9WeXdzUmdlK0Vhc3lqa1JVa3VHajhFOWlqRGxBZDJBOU16SzB1R09US3NJVEJmc2g1SDJJRzZJS0lVRHU5aEFhd0cwOEJhRTZzTjBHL01PbGFvZEpsakJoRU1FaTRLMHRsVmd3YVM5SVNLc0J1WDd3b1RYR21nZ1FEVEJtSVNJb3hGV0VnWGgyLzhScU4zU0VKU013Nmxha0tJYk0vY0lpajJLMlQzaWF1QVZDU2NwT3RCUld0UlJ4MklVcjU5NEs1VUg3bitCeHozSW5rMGdMdHU0OVc4aUdoWW1aSHJJSVJ1OFRlQ2J2YlF3bytJS2pRcHJ4MU1SbmVNN3huZU03eXFNN3huZU03eXRaUVFXWWxtU1VVRXR3NFNJbndtVml5ZVJValJiQWZ2U0FJL0N4YnVZSUIzY25FSkpxUzlERnd4YVBZZURDS2FRQ2xpUEIzak4xVlJYNTd3R3BMc0NucWJGUi9VdFRDQTBaSmlFY1NzSmFDYXgzb3k0TWxaaUdnbUEwaTB4SGRJenZFQzRLSEM2SGZFb0x3ZzdyN3BjTlNjNWdBOUI5SVJEMU5odENxRW52Q0lRUVdCRllJL0tUWk1sNFBFaWdNUVFaYzRGTXRweHNuSUIvdkhFT2dhaUNsVnBYdGhZUWF1QkdpQzJGdThKQWxsYm9PWmRneE13M2FHK2dCeW9JaGJJUklVc0NnN2hPM3RqNFFBcUJVWUlUSzJDdm1IN0xXTDhvSmdaRHMxeENsUlNrcEFBRGtpQlVka3AzV2N6bWNPMTIzMytURW9CQ1JyRklBU3l2b3p1WEFoR2dSS1lDNzZLSnRFN1FrSVRJR0UwYWdzU21tWFFBSVI2WFNKYkFhejVYNE9qNExYeGVPbmhjZE4rQzIxOEp1MStXZ3VvN2YrS01lQVlBTnBpSGJONWptVWNwZ3dyWm1FTk9pSmtRSFZCaFVQeENFUVNXR0Naa0xTcGNNUHJtVkpBWGJCR0JZVFB4TE5JSDdzNEx2UjNZL0VPcERUL2toUGZnMTMzOHVVWkVGMFcwc0NJV1JneEVmbGl3SFI2WE9oa0NWUC9FWDZMblFBekJRUXlBVU5JenA2d1BUUzdIRVg0ZFhzUUxnZUZ5YmdTSXFqeDcwaFUwM1BSTzdKT1lIenRQSk8zWVNuOU10a0FBQUFDQW9CTExudG1CM09kRU1CYXlvV1VEWkpLMFJBYm9nWmdsMUphR3pxTmE2WWhsdDREZ0wwQVo2QUhvSTdMWTdRdmhUaGRDVEViZ2dDWGVCaXhnSU54RndHUzdBZ0lJTlNEa1FSeTlhRjQ5cXdZdUtoMk9MSUJCZ1JweFdWTFFVaEpNQm5RSnJnMXhGYzZwT0VGbzdTSUtub29KRXV3d0lHM1FZMENVMkdZbWJBVnhQVlJpOVpwQXcvZ3pCVGQvVkdVeDRHUW02eTNCd0VaUkFDM3pHOFFzTndXUkNpV3ByZENLcWt6Y0FZU0JDeVNvVThmazVoeDBGRnpNbW5HUDNpUmlCS0dJWFRoOUFnS290QzFSQUZsT1JnRExPcVNnakZVc1lMaGlBYlFaR0JCYUVGN0IyaERSRFA2Z09pQmFrdzZJRGdHb0JhSWV6YUNOd1ZTSWdLVGplUXNSQUJEMU5DVXpCWWw3TXlZRW94VzBIM0xuaUNGQmVBWE5oTFlQQ2dOZ1lCRkdJRkVEYU9xMFZRV20rQWd3aGpVQlkwQVFqQW0rQWd5bzJuZEJEdi9pNlBndGZGNDZlRngwMzRMYlh3bTdYNVNIYkVpUllDOVZGbmRPNmQ4WFNRNkdoQ1hvZGtKTGl3MmpESHRSN21zQUVRYjRNY1RjVHNnSnhCR0JJd0lVSU5TdXErNERySmpzYkRjNE1JMnlraGZpQkZhQnRJR1UyYXFBNjRsVW9TeWpCM0JKSURZUUVXOUlUaXNid2dxM01DZEJ3dEVuYkZpeXFMaUVoMGpSbUpGakJ6RDBBUTBCUUVRUnVFQmdCSUlnNWhyblFLL3ZjSUZEOWVFTHBxZGxjZURJSE1YbS9qRThLb016NzJnb0xINzVlazlTUS9wTE1YZ0JCV0t0V2ZLR2hoMGpoV28xMGxTdXJRQ0dIb01vYndGUWx3QndoYURjWlQwTkF1Sm4zQStJUk8zMkJSNzlWK2RHMUwyR0JCYU5BSUVFTlYvOEFDQlkzSzUwSUdMQ1VFSU5JWGhFZEhWd21UcjBVekFzUnNRbGM1YkRiQWZlQnIzaENBS0lJVUl3dWdRZnE0RzM5d1dnUlYzd1FPeElONVdKWXdDdXh0QXVqT3c5WXNaWVlFNjRRc1UxYUpTV0szQngvMUxzcUM4ZTN0QUw4OE1jZXZqV0FCaUVSYVVHWUU1Q09DWWh3SFFOalNlYzBhUHZIalQyZTVDY1lQQ2tCQzBWc1VHRUdrQ1lNb0JlVklJaHFQY3pFNHJsa0VIWWcwOEpVL0pZRXJhK0tsc0VTVkllNUJWSUF0Q1cwZE1uVDJnNTFOb0l6cGtudEFRSm1VSTZRMko4ejhIUjhGcjR2SFR3dU9tL0JiYStFM2EvTGFtUXRlaUtDMUlEU0FQUVNCcVM1VVFid2tpN01zQkRVRktWQ0p0VUhybkZwOTR0dWdCcEZHTHlxQnRERWc5elM0STNoWWFJL2d5MU9LMWZ0RFlvUVFzUDNLSzhNUHhLdTF5TkNoSU5ld0NZa1BhQVVZUWgyeEU2U0NpNTBLQWtaZzN3Z1lRUWE5WVNGT21tYlVod3FxV3dtTkR4Q1hJUkN4M052MFlURDM5Ujh6R1hRUkNKMllHR1pnUXRWTG0vM0hZalhBbjZ5eStDVXdaVUp4RnVaaUUxNjF3VzZDMEpESFFDOUdOVE14b0hvaDdndy9NOXBBVlpCWVdtS0pIYklCWWlnVkEvYWhRdmh1UWhWeXFKQ3MvSEJqTVlKa2hTcGROenZNYUt3eURPb0srRzdVYWl4cThBSmFZNkZ1OGR5c05PZ1hyQ1d3UXl1REhlNWdEOURFOVhWSDZYZ1Voc2NHbUFJeTRIb0w5SUw3dVMzY3ltMyttVnFSdzR1TDJMbVhaRUZWSDZ3Qm9qc0FOQ0dYUjFZM000UWl4QTJpYlJEYnB3Q0NNOHpGWXZhVmVJdHBpa1ZlWVB6bGlVUzRnRVFnRnVQV09DQ2JwWlZIRkd3VkNOTkQ4KzhCRXZhQlNPK0NSV2FnVlljNWc0ZWdwWHhKbUlRNWpSUloxTitubDB3WXBINHdrME5ZQWNrTjl6OEhSOEZyNHZIVHd1T20vQmJhK0UzYS9MYUZtRjVsblFsN3hoaVFoWTZNUjFBeUtrOFFGMGFHQTVWYnBLY2lDc2hKbUp6V1hKYUdHeTBOd0JpRzROQkVHNWgySmUwaGNBeEVzQjZURXdCbVVHVktCSVlxalJ0QnVpR0VoQVNJd0VLZjhBWmpFb05vRzBETUppRVpFQmV0cytJT0gxWHUzOEpWSG02cGdXbjJoQUg5aFFkbjZJbk42SE9FRnhqb0lVRG9MUnhaMnp0aXhRSjZFb014cTVtSmFEZnJreE5KaFl0eCt3SlV4RENMRDJDSm9TRXVlZ2FXMU95Sk9ZbWJ4UHRnczBxU2hhUy9RMWkxcGFFeERRdEIyMEphU29sWWZDQi9Id3l5WHJMR1pYeHZBaFlGSUxTNzA1dmdBaExnZ1pGNEN4ekNNaUF2UXJIZ0xHaGFwcEEzRGNGT1ZTV0Z4Y1FjSnlwa0JWakl3VmJnQVJsVFlnQkQ3eEFtQWRzUklrY0lRUGNEa2JkNzZBd2gxZ1BaNm9IVldYTWFBVnFjNE5TSzBBUm5XczgvZzZQZ3RmRjQ2ZUZ4MDM0TGJYd203WDVTQnhEK2VrTllDMExha3J0RnhFZHBYcWdtZ1lRY3gwVUJkMFJHcHdFVzZadExlbUlkUnBmZG9TekJ6Q0dGQTBJWGdEbEFJUzR6cEJRa2VJU3UwTFdsakFVaEM2cjZOeE1iZ0JjSUNRWmVaTWFISVFOMEVPZDBBalcwUFNGNG1hd2xRVmFuYkVURmtkUGJFVmpHRUcrRUFHTlhHcm1ZTU1CTHczanBwYlRQb0paZ3BBUjFzSVMraUFVUWIxR1JOa1dtZXZWRE13RUlOWEFJVFJQVGpVR0kwRnZRbVRXQUU1Z0JMckFDeldXR1kwelFEb2JnOVlMZE9YVFpSaWFMTVJDWUF0Q0JpcndrMlcwQjJRdGVJY2RRMHhPNkRVd2xDTml2QUx3TWI1VTdKNncwcnZBTnlZUUdwbHdGdkFKaEdaWGVCazZvc3o1L3dDTG8rQzE4WGpwNFhIVGZndHRmQ2J0ZmxJSEhlWjk5SVJRYlFNYmFJSlRiNWo0ajRsTnZtVThNQU4wWHBPNkFSRHRsOWJSTGpvYUNOWURCUE1JMENBQUp1TVdkc1dDd3dZaTlZQ2tUYzBKUW1YSmdEcWROa3pCUVFrNkFOWFRnVkNHR0lDajFnb2N4MTdTeHdDYm0wNFF0SW9kQkdSZUFzYUVvanJRaWFBeEdURFNzeERveENXVkFBS21MdEtva2F4bGNUaEhsTEtHQmxEY2xwbU5VWG1VRjFMSFVSYU5NbGs2ek8wQm1XS1dnM2FFczhkYW9hYUEwUjBGYXMxVFZneFpVY2VBSE9oUTBpUUFPaEtYMG5qeG8rdFBBY2dzT2tiRUFNQkRUeWhhcEgwN3FqcldrU0F1RjRuS3MyQzBRRkNYa3hzcURpTHlvcTZ5cmlYTFZjU3h5Ujk5Q2hHZ2xwYUJuUmtJUmdEZ3BvVFRPbG1EUjZBS1BsL2c2UGd0ZkY0NmVGeDAzNExiWHdtN1g1YUJ4M2gvUFRGNElpNGFZeGxBczZVeEdVeTFTUUx6SkFRZE4ySk52R2xoV0Jrb1RJZGFBSVJKRWhDd0dQTytQR2pRQm8wSmNHME1DVUpsb2loMUJjcTVhOEpaME5JUnFoSXdjdzZ3YzlBTTZraG94THRwdEFqM2dOZTBJZXFxNDBJU3pDMk9DM1FTcGRCVjBZbHlpaVVQRUZEekdOVERUcGVUU0FJb0ljaExPWVNTQUkraHpNdEFLUHA1STZVTkMwRjRBb082Wk5Ib0ZNSVIxV0lzdXRBWWphRGFEUWRrdm96QnVnNW01MEc2WGlNQlJjQllsY05HalJvakdqUm9qTVNnaG9ReEJhQXNkRmt1T2dJd0NEeG94T0FqUFFLeDdOQmRPWWFBSnV3Z0dBZWhMV1JXSmFlaEYxTDBhVEdoTUJpOG1yd1NJSmtCR2hRUmxuMHJNeEFMTlBtL2k2UGd0ZkY0NkYwbmZoOXRUNUQ4N1g1YUZsSWo2eXB2QTBoYktqT3VsNDB1ZER2ak9pbUtBQWFHNHhGZUFJYVBwUVBRUTRGa2RVS3ovR1hJMzFxd2ppQnlNUXBERmt1ZWdJYVYyajZoTzhxb0lraU1KcExHWDZJb0ppQkJxWVh0Q0tkcHZvOHVxK2tBUVhUZDFsa0JZaEthakJjMHJEZEJKMHBBTXpvYmhDZWc2TXpMUWN5ZjhLQ0d0alhsZlRHVUZ3a1lvdDlWUmFrdW9LNkR3ZERRbDRBdEIyVDVkV1FzOUdkRmZMSTZaODYyV2loMlFrOVlwTVMvRVEyQ1dZYXRDTlhtWTJJS0hSaUtzWGxWRGFZZ2pFSWdESnJCbVoyeWhRVWpBQ0ZZeVRLMkdrUWhHVUZ6bmJTVzB2QlpvcXVZalZkL3hkSHdXdmk4ZE5yaUhvZFROeExPMnpTbWtQZkhPbDRIRkRYWVRPcU8rZ1ZGRm1VZ1VwektTbk16cGQ2TGYxQnhkV2FGb2h0QmVPVlVEbFdndzJnZENibFZqZGNPQ0VoME5TdzA2QWRzUjFSbk9CQ1ZvcmFKdkVKbEJZbS9TR2tabUcwdlpMSFF5bERlaGwyWTZLN1E0NDRXTk1RTTZnSWF1TWE3UUtRNEFReVptV204Mk1CY0xzaHZncVlsK21OTXpCbDB6QVhlRU9vNldvRTB0bGRlNlhPbG5VbEZVRFRyc09BTjZHaFFoQVFGSnUwQlkxQVF0Q1dZSjZINytvRGlOTTZGSmN3dlJxRy9RRytOd0VNUTMveUI5b2tOREpBTUNSSUM5TDJobHVZdEVCYWdFeXBQUllBbTQxZUlpRStqOG44WFI4RnI0dkhVUklzUHFqUzZXUURCbTRQb2V6ZzZJTUlBUUdnVGpEL0w2NlBtSUdNTkx0VGp0clhMalVZZ29kREtVYTZDUU5vU3pvU09seDBHOHpzcEtFa053d3hNT1JBVEJyVGZTa0pqdENXREVob1dRRVozd0JRRXN1UG9TQzFaUVFTOWNIUWtIR0tTdWcwQUVwZFF5eHhZWUpBTllSdFVhcFBRekJCRGpPRXBBWFNJb3FhazAxSjZkaUNBRVlXSU5YRG9vZUlHWUNvQU1La3pna2FaMEZaRjlXUkVLaGZvZ1E2U0VkQklRbkoxWFFET2pnQTlPTDRDTzRsenhMMVdtVU84Tjhvb2FpOEtEV3JtTk1IQ0ZHR0FNNmJRbHh2UVpCQUVOQXpBQ1JtWmgwSFVOcFhlRUxvcUMwUFI3MEpVWkdHb2x4Z2tWbUFhWmdYdkFTQVhNYkNkN1RnKzhJUmdrYWVtWE00OTBhdDd6RzhVbmlHMEJZME9oNG82UGd0ZkY0NjhBM2RIM0JVVDVHT2cwOGdWS0htTnZ0MGZKUUZSTUJOT21hV2hENVFFK1pVM0FneTNONVZTc2RYTXRjcEFXSWJ1aGdoS0FDekdTdHRNaEJYbEFqNGRHYkdLc1JtYUVYaHFhbVdJRS93dElnMFFSTENMRTFLWmpPK2dhQ1dkQnZpU3gwQ3lXd0ZvenI1cENWRlNsUm9tc3oyMExIL0FiNVZVUUs2a3drbUVJYTM2cUVoS0FPV2dsbVdNQlloMmFnb0g1UWxvQU5MWUlOMG8wQUtNTmRBVmhMS0VBNWlFT3lGZ3doam9TVU9nYjR3SWR1ck5UYlFPMHFsTVRFdGhnSkY2Q3NFT0lKZjBlWFRGM1N6RGZvUjBCRDZBdWJ0UlV3QnFidEFIVkxIVVREZ3dWSXpTeHc0QmF5WFJNUUJrMWhQdExRYkdjcjRnc2gvQ1dDekRRS0FQaUFvd2VnZWdEVzUvQjBOcFZrbXA0dnBuaSttYlpsaTQ2TnpUN3U4UXVVRlVkYjVHL0prM3pDc3BaWDBuUjVRWnhvMjhhTk9hTkdqbHU4TVVOY1RrV21jdm1JV2dDR2gyUkhhSXZwakJRM2hxQUV4b2JvaklnUkJieS9MR1hIUTJ5SjJJU3hSNDZMUUM1WG1CS2UyZ0tqTkNGMjBDTE5BUWo2TVhFT3BKZFkzUlFWTWQ1bUFLQ1VPZ0ZFZWxIYU9Nd1RGekFJYWlJNmw4ZEcwUTJuT1dvTHkraGlVamxKUVFGa25HbmF0QXVJa2RITXZmUWRJYVFhU0NHak9CTVN3WUFNSE16RWFFSlowRy9RTzNxWjMxSFVMMTBBVVpNWkNFWWRjV0x2T2FjazVJU1F2QVJzWVgwaGRMdWxtR0VFWFc1dG9PZGJEcm1BSWFzQ0F1Sm9ReDBXTFNzRUo2SUNFQnl4T1RwN3VZYkNscEVicEU4UTRNemFiaVlLd2hNK1lLbU5vRGRxZkovRi81UGxvS28yR2hVaTk1VGFLc3AzaUhhQVd4RWttVklXWXlhUUM0bHhpZEZvc1dPRXFWNkFTN1lXL1FGbUdzMElMbHFRUS93UWtrc2xtZThvVjVhRVBBTGdFR1pablVFc1hVMHEzR2w5S0NWWUlRUm9URU5SRlpwVkl2UVdqRXQ2Z1E1UlRVZ0hRQXRXZFF6Q1lKd3RDV3BhRldCWHFBeFVVQnVZSENRTzhaaWlPMGF6TnlCUndwMGxwQ2poUFJpaFdZZ25iS2hib0JSaERYUU9KbUdvQ0hiQWFJd1VnNnFBRW1BQVE3ZitMTkFZaTB4QXE5QmdJWVM1aC82ZDNWWURWNFNBQ1JBWEpnY2l5ZkxCejRQK0laNHJBeVlkbE1UL2VMS0JPeE5EeVVJWkt3bzBNQmR0THVvSWFFZ1E2UlF3RmpVYzZpK2cwZlFCb2dNd0xtR3FkRE84bzBGZFFmZU92RU5qQVlNRWJPaittbGgwU1VITmkyUHRuaS9tZUwrWjR2NW5pL21lRCtaNFA1bmcvbWVMK1o0djVuZy9tZUQrWjRQNW5nL21lRCtaNFA1bmcvbWVMK1o0djVuZy9tVlFNaG9IQ1BMZzV1YmwxbkRnbGFqbHhVMm1TTWlrcURsUUc0SEJHaWJ4aVhGNHlMMmxBMVI2eEVEQzZPNmhOTDRlVDBjZEgyaEpJVFU2ZW9YajJsQitVcThKVUxEcysySjhrSXBQbmdndlBXaS9KaEIzQkJqZ2hkcG1Db2lvT3VjUjFWSk1VdWNKUXJFMml3SGFHc1d1SUNFeFdiTlEwSUVDNkRxY2FoTllXb2FrTUpjT2dEU3ZaQ0Jsb0lET05BNmpSRG9SaVpNWm1lL1E2S1Z6T3VsUDhBbzRIaWdHUEJsTEpFQm00Yy93QlhQOVRQOUhQOVRQOEFXei9Vei9Wei9Wei9BRnMvMXMvMHMvMHNKQTd2RDNFcVUxODJhaWY3MmY3MmY3bWY2bUR2aEJUZDQ2SzFVRDRNL3dCVFA5YkNxQUE3bFUvMWMvMU0vd0JUUDk3UDk3Q3htMHozbndscUMwMkNjS3pjS3l3ZVozVm1LcXk5VHJtYUJXOHFjcG02UjBOc1FhY1BRR1haakpiVHN4WlBZUVE0KzBON0RDRWtBWFFoVWo5RzhBT0FwWTNFYkwrSmpWOEIzajZTUW8rZ2FTVWpJVE1CblFzUVZzdHpFdmJ0RE5CRkFmd2xXNXpjWjkyb2Rrc1lDeHB6WkN1aEN5STJFb013Sjlub2RqcmhEdDB2QnE5Q3k2akF4b0htWkIwQmVvRnZPUTBXUXZHRmVJdENXWExDZEFBZkdpRU1rMkIyR1BhRjRqQU80SkFhWFRvOUc5UW9SekxuNWd3d2Y0NlhJZWlKUVJZZVlOZFNTL29Bc3dpMkRwWDBoT3NSTXgyVzhldWo1NHJaTE9nWHA0c3Y5a0RhZ0pMRDBBUGhvUE9Ic01KV2RVQXNwc1d3RW5OeUh4b1NCam1WbGtNU2NWbGF3QWxoSUdKcW1oYXVZZUVESkdBVVpSNTNUdkVRQlRtVUhhWE8wc3IwTVdLTEQwQTNNQ2E5ekJYcmVEVUpQRTZPTzVCSzkrbzhCVXB2TnhkbVNEMmdHdHp3TDBoSGY3NlFtNDlXMHlmYlFOUlNRTUdVR01GeXRFQnRacm54QVJqdGdhRGdlVkZNZHF2RDNubURDYjhmSnl0cStvai9BTEtBb0s3ZytIVDFJLzNwVnRlWVVUUTdJNEVPU1Q3aVNQU01xZ0JoaEdXdmUyVXVaaXZBV0orclpvSDl3dkZZQnRSblVIYm1WNURMeUY2R0J3TFcydzNNQUF0dVFLOWJ3WUt6dW93VlZmTUJ0ek9OSTZLKzJhOUlvS2pjeDJtQnBBTUN0MThNZk1xRUVwdHhLSVJ6SlVMWFdRVlZvSU1ncXFmUUJBaENMZVZDZHB4L2ExSGdiSXFrWmhpb2RwckxTemJZRnkyaE12MzM1aTNxS1BsSEU1VnU4OHBUQ1dBZ3lNdDIwQWR1WTZua2lWN2kwNDBOL0tkbEhlQnB6NytCdmppWkttMjZkb0lEaE5xaDNpbEJVYndYcGkxOFFQY2lOVlV4VXp3TDBoWGZ0ejhDWTMrTUJVQXVyUzJoU0Qwdkt0aE9CYUFJekNXZGFZNlkzUU1IQlFLRU9XaS9SL0VmalNRZUwxbUl6a29iQTkraHhTTHUvQ2NHcktVSnVWREowU2E0U2dxZ3prNUIwS1FDZ0dwY0grUUpod09XS1h6b2tnbEFnS0kxR2t0ZzVCYy9pQWJVUDl3NkdMZmhzUHVTaDNoT1hEWWt3RUFtREVJTWFMb2c2UGd2enB0R3krbmRMYW5kTTZkaVlyQUJEVEw1ZW1JYjh5cXY3RUVId0lBMmRPRTFZaDVVb2dLSUJKVUFLTXc5SEFQb1k1SDBCVlNEK2hLUXNvY1d6RXo5RW5DZ2ZtQm9tMm9qY2tBbmFBSGl4Rk1DUVNnWDJNR0Q1RUFvQVo1ZENwMmxGelFCVVlKODQyQTU4SEVVc0tMazFVRzQzaStQYlQzTUFuYVduNk9YZUVvK3pnQUNETzd6RStxWmFwaFRLNHNIYVBES3lMTDlmVjZpQnowRHVKa1FKaXN6Q3BndEMzZUVoLzJaMmdJcU5MUGpSQzc1TkNFY3o0ZitSUnhXbVZWYUIzQWk3cDdzUVRWUjN0eDZhUGMvalErdXJ4ZThtTGFQbnBPY1EvRVhPYjNIU3VMMTljUG1VYmRmVi93V2hhekJ0YktuWUtnQlJ0V0pNRHdCQjZPUkdBaG1qL3d3aUFFNGJRZzRIZTMyaUNCMUFpZDh2aUprRWlyOUlYYi9BQ0V3QXNjYWgvMElDLzNLK2ZXRy9jUW1rUHUvMUVKSWlOMzQwbENqTHd3OE1EcUUvdjhBVURSSzZDSGlDSDBBV21sOXc1akp2Y3NSb3RBd21IZEVoVUwyd2xtZEJ1R3FBcUFSZ3NQMS93QWdmblNIL0k2Z2lzNVZaWE5XazRIK3hXMlA3cWY3WklsL3BjQUdDMEl0ZWcrRUZTRElUd2gvWWdZUUs5THp5bTRuZ040YTdxSCtVYUpUODVFN3RYNGhBcEdBS21RcFR0L2tLQ0NYN2VDR05iVHNRL3VmTFFFR0VBUnFCSEVDbGV3QngzR2srYjFsTkFBZ3RGRklicGVuK3lqOENiZDFpUTR5M28vY29mVlc0QWY3bERBMzFGL3hCaHJNSHRNVEhWNHBMM2xWb1lzVWQ5U3YxRXVHcDNReE5Rb1BjdjhBWVFJOFp1SjVyZlNzQjdxQStpK3pDQkl3YWZhZUEyYVlJQUJrOEdINE5tVk1FcUZOR24wK0REZVZMK0RQNU1kZHpMc2EvYzhyeEhXVWdLV1NHQkZSRDRQNmhhVktQdVJCYXNhRzJpSzg5eU13QXFtRXp4MENoaVlZMEJVRGNHRXVnSWV1L0VmaVZlKzBWLzJZb25zVUFOMGljQXhxcUUyTVZHZzViSHZwOXhEMmNRakxSQXQ5aHNwNW93eG1PSTN4TXMzdFk5TkJsUm5OcG1naHVEVDN4WEk0Z214blRvaHNFOGZ0MUJuUEVhV0NYVktsM2phdWVxTm9MandDS0FlSmY4YlFTUUNwa0xxOG1XUHhPRkthNGFkdDR3MDhXeSs1QXlVUURncEs5a1EybkVVazZvdmVSQ2dyOGRaRVJneHp0SWJlOCtLL014dWxtVlRMTUdwbkxRdFUybk9KZXNYSkltZE02NlRBMTM4SGwwZUpqQzYvTzZvbjUwMU44dU5HZzAxSDBJckNIS01BK3RZSmRMM0FBQ2ZGenkrL1Zyd3BNc25NUEE2bUVBL1JlRm82cCtxUHhIcWJCN2pVWTVRRDFuNWxZaW5DZEhTRVFzVzNZZ2s1VVZid0JHelNQZUVuRVFROTY5ekhSZDFJWWp6RU1NOTBGVDBJY1RnWXh4cGNVYmFJN1JSR0k3VGdqd0NPWmpUSnJuZ2RrOGZzZ2J3RzRTaEd6Q0FnQURiM1VJVVNQVzkxNm1na2xkaUt0NGtrQk5BMTZBY2t5TzNjd25TYk9EN0lmSk9qNndHa3BFb0ZvOEFEZUNRUmtwZG9IZlh0UUN4YUdhWUdJZ3owR1NTeGtwdlNKTHViVVo5Y1FweHBkT1YyMUlzTUg0aXNrSElGU2ZTUzEyMElGV05DTmlJTDZNUUZwaWdGUXdCMWdtR05HanVwV3NGbFFQekVBdTRobGVCS1dSdWU0UHFYalVEMC9zRHhzRG53djFpZ2dRQUhrckRCOXlmUGFHMWRVbmNCQlBWb0c0VjlTcGFrcDNZZ2J4VmxNQWZxRURqbEIySWZxVzl1dmdtNGhFZllSWXdMeitRT01lRklJQys2T1RIV0hBZWd4R0kzQmVobEkzSFg0RUdZS292YUtkZithd21GWnllTTNFQ3I0T2ZOUU1PNGxVZ0FDVXAzL0hIeTBNbkJCUGlLdTRnSkRnRlh5SGRpQ2pncmhzajdua09KeUVzSkF2RW9uZ3Q0ZFBuRHhtOE1TdVNtZXp2ZGltckp2d1psMExReU0reGxTbFBrVkU4MXZwMm8rdm9JZ2lNaFA4cytKNExacmhYazhZZFB6U0d2dGY4QVlJdHExN1QvQUdlVjRuaU5rSkg1V2dFeTRoMnhCcUZVRytNRUplcTBSTW9YUWdET2dJUjQ4WjNqTXlhZnhINGl1T0liaW1MUkwxQVNBOWtZbFUyS2dIV1h2TytueXBpTi9naWZxUVlsajRsOXMrMjM3bkdTZlRVQWtMQUhjNmZnejl0QUVJZk04ZnQxQithM255R2tXLzQybVVFOXNPMXBQYTlIbTAvdG9QeTRSRzg5YzhYa2FlUjJ6dzI0bndYNW1JM2NmTFU3Nmp0YUp6alJwdWlIOFBscjRteFBGNGFhNDBaZkdUeHVJK0xubDkrclh2aDlUaFh5MlBFN2VuZnU0dm9iNDZSUzJvbmJwQWFBRFE3WThCNWdBOVpJYXV1aDZkNFVBZkZJK1hjZk1oRldxQXloenJJdkE5aVhuQUUzekttVllzcGtvMGxQdDZpeEhEcWdTWkJBQU1ZMk90ZFBlQU93STMwRTZPMEhHdXBZREJCUVBvb1VKcUFBNG94UmF1OTNIYzNTV0QySmlUaVl2VkkrNFFWaTJ3dUVNUERxTXh6RVFLTGlCQjZZQUJkdTh4eGFxOTNEY0tRVXB3eFZUY0JSaEFaaWtYd0lJUFVZbkFURjBHZ2dQU0YyUWJvNkVta3VZUVNHZjBRQUl3SkpnMFRSZmhnRERLTnFQWS91V1kxdjRsMzJjK2g2QVBNOFN3Mk5xWWQzUHpXcEZPdUpta0pDQUNoRnJIczlNdmxOQUtua2E5dS9JbVpkOGllYWd3OU9rQWt5NVJFdjBDTjRJWmxIMEF0NlpnUUJ4THdEd0NLc2x2T2NiOUNKVDVsUkhlUldPN3FDdXFhSHRDQUlRSlptTGtINGlzTFF2c1hzUDdIcDc0UG1IZjRLQUlnd2Y4S0pISHFmeEQ3YjhjcHpJb0tqeS9DR0VaYjh5bGlvRXIwWGJ1RDlxVk1acWR3WmZpRzZiYUIvSmxZWXRBRnpCZm8vY0pUNXpjVHgyODg3dGwzV1VFWVJyMlpma1N4NFVhNFVTNUNQd2hEb3F6OHVZME5nQWRRZGhBbG1SdU1mcWVWNGdqVmhNWERsL0kwQkNBVHF1bG5wTmhkQjJkUWVBQkMwSlBod2crVENiY0lFcmZtSVNJNVlFK2hhRUZ6NWNQV2NBb1VhYVoyRURma2N5MytENVRsZmMzS1paMkZiRDNoNzZnanNPSTBBN3lCcytRcWp0OHh2b2JtVGUwTUYxaHlmcUVoK2lDRVVGQXo5Q0prU2YzUDlPQWlxQXBoLzIyTWJBZnFFS0pNaFVsWnNuUXF3aDdmS2JSdUJ3TEh5UFdFcTZ6Uk51MEd3U3BaY2xibVpXVHRXM0ZEYWdnUXJvWjZHSUlxZ29zK3cwVmFueFg1bk1ZSk1YZVV2RjRGYUcyaHhIRmtZc2hOK2pvc2FBUU9reVNFSGI4N28wVGVUdzAxeG95K09uamNSOEhQTDc5V3ZmQjlENG9ieE8zbzN6T0pZUWxTMlVDWDd4KzNRSkdsM1JrTk5EaHpDSU13ajBiZW9Ram9WWmxMeGI4YU5QeEZKRnZLRWg5dExSN3BHRUpyVFJwTGVSSXZkZ01hSlk3a1c2Q0lSYldDKzJwRWJ5eXBFWGtsZ0FRMkxHVS9iZ0JBRFlSK3V6RHdRRVFmSHo5RW9odnBLS2ZLNkJPOXZmekRiRUNJUHpaZm9uRU53QjJlRVRnUGxTcjVlVlVLSEVsNmFHQjBLTEVaMmdDR3RvRXV3bG9RWmhMbVl3Z0NTcU13L09oRmUwZThPMkdOWlp0SDVvQzRJb3ZXUFRCZlFKU0U3bEdPejBQWXlzZ1YrVWdhVVFMemJUem15VlhHalRuVlhJdCtZc3pNUGRIQS95cktZQS9VSFdVRkM0YlozcTArRkdaYVFMa29sSTBRakF2TzN1UmZTbktJNkx1bGFaTWJxdzhSbUtPbENBeXZITy80ak5nREd4OFN1VGRnb0VIUGxDb3VCdkJXYWxGZTBlOE8xQ05aWnRIUW9DNENpOVlOZ0FWVjlCRENLN2xFUUM0cUVsWkIvVUJHQ3VHeUIrNHdWS29IZGlMSTNvb3dTaVRaWXdKbHprWGZTdDhWRXg0bEN2UXl5R2FQUzhMZ2g5Mi9hQWpKTGhzRHYzbmdjUVVXS042QlcwTVIwK2xGeVVHMGxEKzZIS3FxajNRMWgwM1l6WStKWU1IZ29HdTRMWlcvWFA2bGp3b2d1UkNCMSs2QU1EMzVFT255WlZjRVNNbTM0ai82Rmw3MGkrV0pqeFR4UEV1eUFLMUNVRXhsYkczUUNITUJZaC81RXNRSEFOUUNUQW4vYS9rOXYvbEI4RitaOHBlRVRVemxTY29TYUJLZ1hjZmFNOU1VamQ1L2s2R203OVBnMHhIdkdZcDlKeHFUaGlHY2NaNTFBUWVib0xkcDdCa3dyRE1tN0lhYTQwWmZIU25qRjJDZnlFUUZGeWgwQnBFVWVSdWUyclhnU1NWSXFJQ0k3VzFRcjdsa3dEREptVXl0N3FFZlFqM1FaWUVqQVhJRFIrNndpb0pTT3dFcjBwd2NoM1RQeEQwclBTc0k5Tm1aMHpybVVFTDZrSXdJNHlieDJhQUJHQUFkQzJsdlFtNlJnbG1tWlJvYkhqUkNBTlFLeDJyTDNTYklvWU9CaDduaWVmMlM2Mi9ER2xIRTlBMFcybFNRZzk5RzdIYndNUzg0ZmpRdjV4M1EvVktWNXdROGdqUzZtL0RQalR2a0c3aTdnZktLQlpPbHFmWFNzVzB4R2FiUWJLRk8yZ0JNQzNoMnl3d1R3Z0RoK0JXeW9XRUFOb3h2dkNJSFJHMkMwZHduQU9YWkI2QnZtZFo3bFRTM2E1cTc0UUVBQTJPb0dLQVNUVXdFQUFiaUJmUkpIbTBCZDRtWVc1N2dPQlJTa01kb1FZaEVFOE1NbUFFeGNUczRUaXJBeENBVUFKZ3d6UE9HRExUdGdFNlVIQVZBbGpaQnhqT1I4Z0pnVUFFTm9HZ1BESERjMURVaFFGUTFxSmZTNzR1SkZoaENNVzRCaUlBWFlJZ3FZU0JWQXRXTkpQUllRbG5RQm1VMG5FeExRRlFGaUZvUVIxYkFqZE9wTEV2QnY2QVkvNlA1UGIvNVFmSGZtV1poQTF6R2Q0VG9ZclEwTjVsS0JxQ0o2UUVlMExkZ25IN0g0Z3Q2cTF0dy93aC90RjFYSWZ1UElFaUtYVlZsQVVoUWRzWU1kcGwvQzdIVDNtL1Q3eWJsdlA5REJXWlpJY2lPKzhEUzFPVUE2QUQ5YlcxdmVaVzRMN3kwZEFZQmxvcTFOekRkRWdxeEFnTFI0cjhMbkFrbVNJQVNVSDdWUWN1NGdqM3BEdFR2TGdRQWQwR3JOSm1Md2R4dkJWbmN0SG9GZTh2amUzNW9RTHgxWlE3N2s4bUo0WUNERmFDRzBaM2xWSFRLSW1aM1JONFVDaEFHWUFocmVMTytOdnJ1OUY0aHZUbEdVZ0RqRUZrSk1hRDlhRVpFQzJzZXNFQmhBUUFJSXhkdWtkZ3duZ2pBRmsrUlA4VkN4c3gwNWVwRFlSVUJvdnlkS3FvVjB5ZjVpSHRzbFZ3ZHgzalN4amZVa0RDTExBMFhzUVJIVzlEY0VIOGlXN0F1Z0J0QTBETFFuK0tqQUl3cXFDK1RBa2VZd20xQ1FNSjB1alFleEJFc2xQbGdpT0JEWEpYQ055U1N5WU5xQ1ZoQ3duVEtQQUtuR0V4MG9RSjVTdUdoQlpscGxwWHhNUTNRMjZiTXZ2QlFhSTlIcFF3QlBRQ1RhRlhqQmc2alZZR0x6UFdiaVhnQW9WSXNlTnRFZG8wNzRnamhJUm5lQ3JRdFZlblloSVkwQUp0UFhURUpFd3c0YW5aS2c5VmptTU9pMGIwNmM2clFCbUNnbFJ1QzJoMjZIcU8yVzFCVDBCVUtDUklsMWUwWEE2TG5nenkvWlBOOTA4SDNUd2ZkUEw5azgzM1JQbS9NOEgzVHdmZFBMOWtCV3N3UTBmTW8vcXdaQ1JVbVQ4eC9pL01YNHZ6S0htK1o0UHVpL0YrWjRQdW5oKzZJOFg1bmsrNmVIN3A0ZnVqUEYrWXZEeTVubSt5TDhYNWxEeGZNODMzenkvZkNxcEFrLzd3TkRmVE1vb0l5UldEWFNBQnBkMW9PQ1gyZ0RBeWl3VW1Jc2VHMEZ6d2VkZEg1Qm4wZnlvaHdtbFcrSUkyQ1h6Vll6UW5obWVHWXQrekdBRnNMTUtmY1lCUFdESmh1ZUwvR2hYNmNJUHBoRTB3VExpb0xId0NZcldnSVdGeTRzZW9sU3R5WDl4REZtNndUNndBa1hpN1F3VGlyaXpuUkFqSUFoMDFLR0lJSmpvVEd4VFdCVXpHVXRCbzlXWUM3UWlCS0JkSXdIR3RmVVI4QS9HaERmU3ByOUtMR25SY0E4TVIxT2dERFFMNm5LS0hNNkJCVFRpV09veGJvM3l3WUNZemhIME1FU2lpQzRKUWdZZUphQkRwVmcxeENZaFlQZUdTOVNVQVRoL2ZkMW5Ob0hnT2g5VjQxRm9HZ0I5T2h0cmlFSXdoME9xMTRkT05DeGdMRXhEczBGQW1OUUVJU2hDV1lDb0h2b0NNczZFZThCRTIwTzNwSm9DeDBFZStndEFnakNNWFE3ZERnS09WTEVnUTZEbUZqU2lBWTF0MkE0S0RuVElZYjRLSllsTnlVR0lVU29RdUdnWVVsUTljUVhIVUZHTWczUVNETWFWbWJRbjBEUUlGUmgrU0VHTXdiQ1oyMC9uR3N5c1ozMUY1Y09DK2hrRkRVYjRiQVNwdWRMQ0hCYUM4N0lid1VBSWdFTnd6QU5NUkJtSUJvRmRLR1VJd05Pa0ZRUENIQklhZzlSdWgyU3dhWTZFaG1ZNmlqMEJIb0Y2N0VMZDR6dE1wMThvTVZFSmFCQTNhTE9Fc1l5YklpMFpnVlowTVJxNVIxLzRGc3dFVE1TdlZZRmIyUlAwUUYraUUzamRXQktkV3l1bEVhRVlJWWp6ZDBJWTZLSXhyUWNCNkdJN28wRmRGQ0ZxSldvRlFBZEMvRVJFSjlHY0ZGZEFlTmFQR2dJTmJ3N2VnRWxBWVdoSkpnM3lvc0k0b2c1VGxEdGdTaGhERGxPa1VUUkZCRzNqS1FoSFVub0tBY3VZMDNNdVp1NktrSWxJRmhtbGFRQWJTZzRlTmVJRVZoMkd1TFFVZWlwWlFFMXZBbWdPc1FhNkVERXRRVWRCYlhBY0FBRTJkU0FpTUJTQmpPS0M1TkhVSXdHZ3BBa2UwelNGWnZvU09oRENpQzV0Z1ZoQzZRUTVnQXc3YVFrSlRyR1FVZEFqckMzYUJWNkp2R040eHZFM2liemttUnpraWJ6a2hKNUVXK0tWSVd4bkpMUkIwTWErTkdweHBFRkZHVkRFNnBZeThDbUxnUXZWQnpCZDB2aTlFZDBISFF1eURkTENDMy9BR2QwRytBZ21tamc1MEhva3FSc2FYOVdlZjhBd1c4NkFoTVZoMlFTVE9oOVRVYjRtOHhFQkJxOVp6aFNQRjlFVE1CYWtGOUpBdzdkYllKYVVIbU1veUpTSVpZaFZVRFJRczVoSXdpazZYekdvaE1LV090aUVzekVBY0FEUXBIbFZIUWpRVlNOUFpDd2g5UVYwWnJKUW1nZ3JyQmNub0FRMHNJTi9RUXgwQ0x0SUJwU0JaeHF4b0lGMFFPWm1NT2lnb1FoaUlnMEpuTVFiWVRzWjFCaU00NXVZQUJDWndtNndZNWdBOUE5QzhGUC9JQm5qUVNlTkJUUURFQnNNUzJJQU9sb2F0QlNBMHBRZVlBMExBZ2c4WmVGc3dwQVhRTjhhRUo5Ry9wdStWSGpTZ2hvQXpMQ0V2U3ZSQVE2QytZTkRvREhPZ0RNc1A4QWdUQ2lJMEJDWGx0SmlOQ0Z0UjJRZ2VpSEVBaTh1SVFqSFF6R29tWnh1eUlYMEdyMEhPZ0tuYkJhRUJIZzM2OFphQXU1bVE2RFZ6S0M1aHVZSkRWWUdSS3BFMDZQUWRLejBHbWxFa3M2YnVwdTZDY0VwR3JodTBiUTNPbCsvUU9aZDFiOEZUTXRiOURRUWxuVWI1ZlFoam5vQmZTQWhVSU5EUmEybGhBUkxURXVkUVkxTXhvYUhwbThLeU5RUTB2Z2FmL0VBQ2tRQVFBQ0FnRURBd1VCQVFFQkFRQUFBQUVBRVNFeFFSQlJZWEdCa1NDaHNjSHcwZUh4TUVELzJnQUlBUUVBQVQ4aFhrVHZLN01ZRDF0M2lzZGRQVllJekdzSUlobnRKZ1pmRkZlWkhNQ0thdHpBMWJ3cVc2OHcyeHM3bG1mUVRKRndyNWpkcmM5RUdYYmFPMDNySHBLS2pOVHRwQlVJU3RzVjJZSlhtS3QyN3pEYXVsVnJxSDBBOWNSVk0wZENxOWZUWG92TzB4VSswM1NqdTVwRDd6MGJxQ0dReXJ2ekd1akJGeGRUZjB4cXlxUjlHVitPaG1YRTN1anBiWEhJZm1MNFIxMDkyWVIxT1NQQjBCSHU3VFI4ekVRUENKSHZNaE5jVWQ0blVHV1dMOUJOWjRucjZTZzNmUVRVN2swZlJ4dW1HMzZLMytyZTV4MDR4V2lxekFWb252b04rL1MramI2eXp2TVBGenhRSGJvRUR2QWpmU2pLRGRvaXFtSjZxeExIVFYwNGFsK05kTHNPK2xTK1JObk1xTlBRVlRvNzVtdVVxWWo1K2dvbVVoVE5Mb2JVWW54SFcyS0RNVzU3enZxR3BPTGxBSmZyaVpNOFN1bE9jelIwRURrSndBOUh4TExYT00zaE9Ja0lLdVp6ME5ucUJsaWFFVXZBWHpjNDZHdnJPWm85T21aNStqSGVXZDVuQ1czTE1YVlFmZnArU0VieHdRcm5jY3IwRTVGV3l5cTV6T1l6REt1em42S01kR0NNZ3hLS29saW9MUzVnWUVZUFlJK0gwUXVsKzA0WjhwWGJFMkFJTU14OVdhWWlxZHltYm82RUU5QzdkTmtDMkNkenRCaXJwaU9YRTNCVVFUTU5IaE51WUQxK2pFQmtqcnhCZUpsMnh2UkFBNlhQVFIwWWRGa2ZOd2RNMEVDcVRpZS9Tdk01VktsL0hYV2VDYWZUVTd4V2pMb3E5UmNYTUcrcTN6aVM1dnpFRlNyemhEdk5QUVZLMTZOTjRQdzZ2NC9WdDZPcE1lWnQxbWNkRjc3Z1ZuREx2cFIySWRYQnBIYVlQZUhTU1ZYTVNqYmZUREdOYlBXaENIUm5wSGV6R3FwY0Yram9QV0c1azg0K2tDM3B4aE9WelYraFZUTWFiaXFSVU5kZFMzZU9sR1MwY0dzS2hxaHJPN3hOaHAwWnhNa0pmZ21CVldqN2xVN0dDYVpZZXZNTWVKdjZYUm16QkdKeU9sMU9TR2xNYmVpSXF5VHhFRzJIZUNremo2Ym05b1d3SkpKb01mUVJZaGVEbUxrZEdqMG1yMGhzbm5vZWFLMUMzTHJTdUhSTFF3V0hWMjBOd3RxbGFpUUhFemhqc2JURmtzWHJ6dUxkQjJYb3RmQkJQYTcvQUVIRjJoNGt6WGlPMXRVRTZxTGJkblJMQm5rSmhyWEt5Vm5aVUd5eHBlcG85Slo2S2xhbU9pYVpwdUExd1NPTGFKd084QzNLRXN1SlpkZzJwMFRjMUxQUjF4ZER4dWNzVWQwT25vSFVWWDZISnFYNGQ5T0psd3hxMWVZdjVPcjE2VFNNQVpjNW9aVkxGeFgxT2d1SzZuWVFSd3pLNzlLek16MHdJc2NabFdlaFhBVk5GbjZCbDdZbFUrbXIxelhoSEVqZVlhaTBSb0dXaUI5SXFvYzlYZmxLc3ptVUIwMlRqcFlROTBvWGRIVWJlb1Y0ZlFMY3dEQ0F1N1BTZ3BjWGRDWktGUFdpNStpWndMSXFJa3ZjSUhNU2cyUVZiSjU1NW8wbVpuMVB0SGRKUTM4ZFBOZ2JqMCtaYzU2SXNUeUVjMkhPTnpjc3hZVm1maUR6ejB6eUdadnFjU0FOc281cWFBK2owQ1dYNlFvQkZwTU96dnpDZmxtajBsZytZSWxtdm9HVHQxZyt0TmhEL01Rbk9ETGVKTnhtbVdLeFd6Ykticm1ObThkRytoU0lOTUd3OURqM2RYbDRaeUluaXBTOEtCM1h2RjgzUnhPNU0zaVRGdlMyZkRvdGZNUWk2bGJjcmpYMWRFVlMrM1MwVWxrL3VUMkU5emFyNzJuMm5RRWZ1NE51VDdNU0F3N2JuNVl4YVBsY3NUZm9Td29OUDRlS2VvN1ovd0FHVnZqZHY5NEdNVCtMdnlKNEhTQThOYWZETkpsaDR4QjJoeW1JbFdWRE5Bb0syS2c1Sm5wcGh3a0c0OUlwS3FEbE8ySmVzTUpqTlYwNzVuSDBUWGpJaFRxSm9jUnRaUlFNeTJ3d2RiN09qcGUxTWl6Yk9JYjZJcGpETFRNbmFidVk5U1hLcHN4WGs2S3d1ekF0UnEyaXBTdmpwaXRGVFlPMHBORXZRdzNqeDF3RWNKZ0RETGd4M3JjMGJhZzFPbHUranVjMUxSYk5zMjlBTGNRZHlHYVFvS090ZDRWc2ZTQmZjYnNudndVNVJYcXllWjBkQVFCY0lmVlpxODlMWU1EcTZpOStad2N5aTJPeHVjenBMMHFkemZYN3IvNktEWm5WbUZYYm9kaHVLMkk4ZHdXYmxOM2xqaFNwczlaZGJUSXFHUFBlWDdHQm9ucnN0bFlybk04K0diVG9iRHVPY0tiZW9KZ3Vjc1VPSzZZbDRtbDRuNHpaU2swcEVNc0dXS0UwVDBDYTFpc1pla05lWm1uTVZzZnBwcTYraExZRm5RNytacGp5UmUyWEJpK2JvbWZPT1diNlBwQmI4ZlFyRGJCemNUSWZIVWJsN2RNQnVjS1RreG5MQVhteERZeDBBbkNzUlJibHpLL0FmdDNIdkVyTTN2cWVYcjJFYUR0ZEJ2N3JOemF3K0IvK1dxKzd2M0pyZlJwRi9QQjZ5bTNmY2hmNUxKYnlRSTc1aCsySUZqTTNMZ2FFeDVUVVduNlNreXFpYVZpKzh5OXRPSFZ6UFV6MEJzbUhqWk1xaXVJRUZJUFZOSVlVT0laYlo2djZJWUs2SXRBcFJPOHk0WlhsWjNpdGpIaVpVY2VYck5QcEhFVW1zc3E3MWliSENaZTJWNXVub051MDRndHFhalpNVk80QTFEYjBkdnJBeDZpK29BYnVlS2VoRk5zb1hkMGZWdG12b2lJNmFlZ0RNUmdtR0dwejlhSG1JT3hNVHhIZmRscnZvM2g2N1lxTTRxSWpWUTB2UFN2VTVHL28rOStnNStyNzZKYmlYV2JHazd5eG8xQmZ1NmVPam0zUFV6M1QzVDN6MXZ4UGRQVXoxczkvUXJOSmlQSkNneEJMNVpiMlFYSk1EeE5JOVVOZXJvRXZ2TUtvNmNrVUJZQzlCeEtxc0FyRURNQ2pvZ3IxeDF3TURtYXFJalpZN3c1bUcvaEV1K1p0QVFFNk9nbGZRZUxFU21VdElmbWcrYVhkcjFDK0xpY3FnSnhjdGRBVlB1V2ZSNmZNWkVGd1ZHYllNRTFIM2dvMk5Tekh6aCthSWxHZmYrbERObUwwY1IzNGhURGlWME52VEVkTUh3bmREeDFlSHBOanMyeXV4dGVETXVOdUhpK3AvdDVqeGMyNTVjdkhxVXRPMzRQL0FHYWVzN29rRXZXMnZMT091MEk5eTlQa25yVDUvd0RSdDZrM2FQMEhkYUhreC84QUR5Mk1TOGlOaGV1ODV5aFQvSnZoNnpaNjBzT0UzN2tmWCt0NzYrVE1WTkdoUDZ6ajVncXQyUUt4S2dwcUxaRVh2UlBaSmlteDdJTFp5TTJGN0V1RktKZ2ZSdFBwMGkvU2U4QVJTbjYyZ0FVT2xobGlQWVM5QXRCVGpZSGRIY1JCbTQyakVzYTZ3Sy9NUmFEVUtyYm9idDNNaW5NOFRpYXB4MGFjWmxxeEJIWW1CNElGbW1VTjlUdkRkU2p6REI0SFRBRTRVRjd3VEptQjZhZW1JK0p1YVlSR3FqV1lnM0EwK2w0c3M5aEE5L012T01vTGFVWHFXYkpYeENkK29ST09sbms2eTRPVDBnYVAxS3hsT2FoQ01scDZ4THZjdXVldm1vZS9PTXgraW9aRmt4Yld2cDRoc3RkRjArWmpnbThweWorRXhzYytaaWczZnREUnhCT09nanpLZDBIaWFKY2NvQnZPSllHY1R6ekZHNHVtdWp5d1M2Yml0WXhHYjZjSDNqeGkzOVFLR1l4OWVseTlkcDFBRFIwclNjVFVGRUhscUVScDMxL3g5RXl4WGFES2l0T3BvYU9vbUJCK1BSVlRsNlp1WWlLMTJKNlU1Vk1NTGlhUGVhT25xZlJtM0hwUFR3dGQyNXhBem1YK1AvZnhGeTlPRjhCZXUzbWFWcHJCNXZUK1ZQOEFTNXpMYTh1WWlVbVF1K202WlZVY1pmZHFWR1hDcnE3WEtWS1AyVEJsbUsySi9QcmQySzMrYTl3elBzTWwwOFZVMkwxL2VCbnZ4RmRQYVg1Zyt5ZUpvR1FmOTMremlKL1U0UGZmL0xuaThoN3hjZU9POGJMVjl5UDBQdk5CSFBZZ2R1MmpEcGx5M25STHZCekF0Uk9DYjVXeXdyY01iZEl5bEhhSHNUc3l4SnhlQ0FCUVFCVThkeDlxTWNZUVdjWVR1VGV5UG9QbWM4YU1UM3ZvN0xNZDBsTm1YMk5FZnZsTVNxcnowL0V2aGRKVkthaEM3WEVPNGVnMHcrWm1CT01RN3N2MmlMV0pzVmJ6TWRwek5zZTNIUUxoaCtERElsdTRtVzdmVEFOWEc3Y2ROT3F0YmFsUC9NcW4rSlIvNWdGUDArcGJxM2ZRWExWeXlxMzhUMStJajdFRFRjSDFTM2tobDZGNGhqcnU2R3ZhTFRabFowRmZSRzNUZzQ2V0ZOU3MzRGJJYXpaTTYxUkFWMUs2bTUwck45SHBFY21BemRQVUhKZ0QyK295MXpIYVdLbnV4cFhCbmNOVFo2emlHYjZXR1JsMjI5ZGhrZzNBclhjN3hjMkZKVlhwYWQ0OEM0S3JNU2xqRDA5RHhqMHp0L1VuWlZBSDBWdFJtcUtMdUxUZXZvTTEwOGd6ZCswQVk2M3ZrZFJwaXNzRmRZdytweVZrOUdOeXgxNklpb1BXWkYyeEZqcVpycHlQYVhESGJNRzRyaFZTNWtKZkhQRXFzT0lLT0dLbk5FMFh4TWVCbHhPSmJQOEFveS9UbEh2cURUd2VQc0hpZjNKTkwrVmQ1NEozVnhkVWxJeFJPUEU0UHZCOVh5K2Nla0N4SEhIOFZZREJES0FNQktQWDAxdzIrbmpaWlUvK2g3ZWlRdEtDK08yT2tpK1k5dzdYeXVPUjd4RE5rck56dDNyZmwvNEQrV3R0ZlViOHFZeWZ1R0tRQmNkazd2RE5QVFVZWHhQSXM1aHVBcXlwWnVGQlFPSmV6cnlnRkRmbG40QkgwZThURlk2dTBLb0FGSFFNakRGS21MNk8vUmVJOFhhRXU2cU81Q29Kbm1HY1RCU3FQRWI2RTZjemZYU3ZFeGk0bDVzSE1NN1pxU3N5aHhtRk1yaVc0WE96b2JpdFUxRDFuWXpQSDFOUy9tWGJZWlpqb2gzRWRzZHc1Q0F2Y3dVbG5lV2Q0MCtLQVMvdUZKL3NJNFRUTE8vM2xuZVg1aUtJTnFqcElkN1V2aWh2RlRnTTlJUVlsVU9UMHV1cTg3NlBUcHhIQW85TGljOUVYT29HQWxYbkJmU3VrcFBlY1ppNWFkYWExMEJFWU9XQW9Qb2Z1UnhLNkxiYkJiSVNxTTlMdE1yY1RCOWRqb3VCMm1EdTd4cGJ6T2JBb2w0ZTBXd21UYklaNWxuaWRLN09PbFZ2b0Z6MWYrRUtub0l6RkRtdnB5NHE0emVJVXFHS1ZzS3RDcGR4MlBWMkk1UjE5UWwwVFo5MFI0Z25lQ3JFdnc0ZXZvL1hlZHArUHJnV29xYUxIaUErVXplSlNSQnJLSXN6SzRuSjdTV0ZyeFBUb2FUNktidHZSQXlYS1hvMU9ibFZSVXdmMVY5LzdseEVudUxiK0Q3QjRtSWpPNEg0Kzd6MU4ya3VSM014dWlaeGRrTnFwc3B4bm0rSUo2N2EzOXRmVU1GTTZjOTUwM3hkbjJlWjJLTlRtL3FlR1VtTG4xOWp3UDhBdW9aYWw5bnVPWDhwNTB4UUVpa0RmcGpWSis1dG45NXpWNDdQSkZIN1RkOGRibWZ0RVZYT1lSdVA3UlgzQnhObGp4MFRBL1dtengwVElMbGhTMVBmbnFkTVJMSnpLUENZclZNMGNla2QyMXFKVHk2MW5CRUdIcnFJV2Eyek1aVFRHSXVnSHAwNWdOMFpuaG13MEpwbTlqUGZwWDRRRUwrbWJVeEhVZ1hSRHBsWEgveUhIMGJQVHJVMU1DUmRCYnl3WU1Vc3RVYXNRdWZGdzU2Q3JRYnRIUlV5UldHSy9STWpPSS9jaDFSMmdCcm90WGNzYmgyK2lzVHgvRThHV05Ra3VrWFdjZEc2UndtK3M3ZlJPM1hYMW1KNnoxR3JTOXJYTTRnV1hOb2xTMFN3N3MzeGFmMFY2a0tyZGRUbnBkMEprd2dESFRMdnlnT0xQb2QzZ2dqRXA5MktiZ0dtZjkwVEF6QmdLU0s4OURTVGhsWnJyREtPQ1lHQlIwOFJOdUtuTzl1aHNPdTk3cyswZ1cxQlJJb0Z1SnFZSFFZMElwMjNFYUw2TFFFOG94ZDRKY0Z3MzJSS1NiU1R6bGxMbjZrZ3l5ZG1QOXFseE5XbEZ4dmdIL2Vad2Y0dUo5Wi95ZVdlV1hiS1BwS1hmMm5sNkdKV2gzWlVOYmZ4dEVjVVAveVFWKzBvck40dThTRU5ZWnUybVV1V3VlZ0VwUXVrK09ob0hRVXV2Y1RxdmVmYnM5NFZ0MHYvQU1WajRuZGovWDE3SnBPR1hTWU9JcmczdzhQa1ptS2pEUHgvSXY4QVdhOTd5dHFia3VoV0Rlb2lYbzA5WXRyT0V6MTRsSDdTemFuS2kxQjRwMUV3Wmp5S09uRSs4d0VzV1RNUkxLZFJmZkljSXhBeUtUVDA1bUNZbzVwcnhMc08rak10c1ZZUFdWQ3VJMDcxTFBGS3VqTEdvcmNxbEp5Nll1QUZ1K2xtRzR4UzhkTTc2TWp4Qkt6aU9hSGNRQXhQQ1RDdlN0N25nU28xR28xMVNhalVRYTJ4MDVndm9hbTB3VWlkSmVPSG1IVGNGM2xjSGV0VG1COG5RL0NiWm82WnFPSm1oWGY2RmM0aGhmWGM1djhBOFBSb1pMaXYwZFZrN2ZSdW5ycW4zRWJyQzVrbm5NcU9WWFRQUWdZcDVDZVE2OFMvN1JhOU9PbTNwNlJhdWJxMDZWVFRPVHJtWXNsWFBHUFFTd1FNc25xYjh6Nkd1UGVFV1lpUndYVVJyRXdDc251VTNrNGpsWnU5SlYzT210YTJnMjd3dzNCdTA0bkwwb0NYNHduNFU3T0tHMkJlcnVDZUlHcmdEV2V2WmlJOFRVTnhVMURBYUVZUXUrODllK3RJOXQrSm85STA5MktucXp5Vm54UFltSGhsZVZ5K3YwVks2KzRqM3pqMCtCRm5qU2pWNjVjcGdQSVNvUGVjbldHR21reXl1SHR6VUhGMGNYa1h4TFJ0VW5kMGVwamVkUzFONDZDeVdhWlU0T3dMRjJuQjM3UHpXUVAzdnZON0JzRWZVVGdEN1JJNDhqYzhrbzNPTG1wcnA1T001V3pPMjlFMmpJdXpIQVZWYlZ1Qk1kbjdPdXppZVVmRTl0L0RraFBrV0p5eEhralhpMU0xT2lZMytqK3c0aVo1emZuOUhZOHdjWTlFYndRS3U0SzAzOU5kRzRta2JiekZRWnhBODdsbWVlZ2RBY0NHOHdnOHBtQjd3cXpucGEzUnhVcG1ZWlkwbFBhSzd3UUtvYStpT1k1bUJtYXArOFc5dTM3TmIveEdVeVl0bnhVM0MyMmgycHU0NUZQais2L3ZNV3Q4cS9jSmFrN24wZnVvZTZydFQzaHIxeFVYNG03dEI1ODlNcE9sclp1STdiaG9renErWWtjUktaS2l5RTI0eE0yeEJySTlYRGY5S0ptZXJpTGdQYVZQVHdKVWZtT3I4alNsd1plVTRIdXIvWW1SaEJlRi9jQ3V0eXJJcDVKcGlLczB1RkYwRDBZSFB0RXBFS3ZvTmV2b2ptZDA3OUJXYzRsM2gwNTM2THhiRDBzU0pGcHJ4R1ZmYWRqeldweXpsdCtnbDdaaUVjYjU0bGhhSzFnNHRnKzM4dzZ1OTBTaTlVOU9jWG45RzdkZFUrNDZjck9UMERsYkhzbW1JQVFaajJFeWR2bzNkemdKbWZpV3ZNZndRb3pab1FaYkFKbmtTTDY0OEVjOHR2ZytrUWgzdGJNRGpPMVlKbm8yeCt4M0xPMzZ0UzlXQk84OUdVdVZ3QTE5RlM5WDRSM0RyNmV6S0c1NkRPSjBNQ1hjV1dMbStPbS8wQmt2VFhGWW1xRXQvSlJQVU50WmZGM0g3bExXdXFjUGlZd3NaN3lEVEhtcGVmSmhTaFcrTDE4TTd6aHZqNWdsbTFVUHZQVTJLcmxnMDRseEhmMENKbVRKMHdMcVdSREJVKytobWtVWjRzYlNJemRRRHoyOXdmYmZkMGQ4c1Bwbng5OGpHN0lWTklYekVXMmpIc3ViVkZpYVN1NmVzQU1RYzVic0Fub3B6UDdRUlcwb3pLdy92MEFXbXRzV2QwQWFlWWxQZzhXK3UvRTBRM2FhMk5obnZOc0I1ZStHMUZWYnV3dTNWblJ6dWNkNWcxenpOWTJzL05MZ2prOGNpK0xoOUwxR0Z4bkZtallxZzNnNG1mZk8xQ1BscUN2RVdwQ2tUa2h4SHJyY3A5SjA5cGVkUHIrMnVmZUlwdDh0Nzd2ZVY1bDh0b1d6ZWJwK2RUQUwyM09JVDJFZlNlelcxcWZmVHdJY0hVYktoMUxTWXRxeDBKYWFXUTNpY1JGa1N4bTdnMWVMbjIramJFWHdRS1NYWFAwNnVLWEdDRGQ1UVJuSk51eWw5ZzVmQkJmYmpDaytFWHpjeHF1UW83WjBla3JqVU9PZ1hVc0ZETlcxQUxINW1ZcEYyQnplbHpsWTVSMlpGKzlzS3dDV0ptNTRBNitqUzQ3UWI5L1NyK2pGdFlKdktka1p6UXJ4Tm4wak5pVjU2Z3RyS25CQU5HdkVldGY3TDA4dFdSTms0dHJ2RmlNcUhDWlEwdGw2bEZiWG1BMmFuQytFQm1GdkJtaGoyVFB3QytkdjFIQkMza2IzQ3VPWnJBWWkrbGhmUDAxaWZtNllGOXVodWtSeWkrSFQwcWNkTlRtZVNDOTQ3SG1PNG1UNGlkU0VlVE5hUEdZeEpTcmRjRjVhejdJTldpZjFYcDRjUzIrVk12TG9zajlkRkdEZFhmTTI3WVIyM2dhaDIzWUx2dEg1aUFlMjZ3TFRtc1dTY2o3bWw5S3VtL21Ha0oyYTllMDBmb25icnFuM0hTbzd6OGtmczZDQ2d4TWhTOEt0M2h5L01jNWp1S0JNY3RLQ3VhNG9XV2lMdE9Cby9DYnV1WXZYbHhubmQrMUw5bENpeTB3SDdUVjRNbjRzakxEOUFQZDV3YkNCVnN0ZEIzaEJsWVpYdUpuakJZRFI3WExIVnpXMzZSUlUzUFRnNU51TUVYa1Z3S0Z1enBjYTY0cmRFVDh5L0JQUWgyb0poeEcvZlBVYjJkcC92bFhIaUI0c2kzVkhTbWpUTVYvYWNwNWxRbHRYRU0xa0hlUFBZbk1PSGFEUzB2ejRndTlkQk8rVHNOUnZsK3BtTFhBc3BhL1djQmhuUVlqcDNJL2RMUkhXQUtyS3QvVHRMVEM4aGJCbngvMloyRThLNGFFUnpaZHg3bDdid2IxWE1Yb3VKMW93RitoTjlUWVJjU3BuK1pzN1Qvcm1LbFZqWFM0Tm9QbW4zazB5eitiaVVMNGVaVTMyNG5zOWxWOTIvc2RHamNiN0s0R0VjdkV5WDI0dGg4L0Vjdmc1amZzdk15clo1SlpPYkRqeWxxMkxqcDhId2gydURsbzlUNW1wdVZLOFFid252UmQ0aEFKWW1xaFVjUEdJaTdoRWVDSmJBeTlnOFBvbFVsTG9TWEFzS3BpclVMTG5ONmlsYjRSdVBDb083SHMybU9hck5qRE9pa1JmV0xScGJ0TmJyQmMyUkEwYWJoZzFKQkpLTUYwR0tqRFJZQjVDdHZtRWQweCsxNk56OG5ya2hQdkw4WHpSbTVHcWhqeGFzcnBLakY1ZHRvVm4zRDFJUzJSZWlEY1MxZTMwV3RPaTF2cFpmZ2wwWm1VNkMwSUxscWVSZXV2Q1FEdDF0N1MxN2diYm5yUDBKaThhalhkYitpUEhkNG5rYm45RTcvS09LUm11WWM5NTRicjRpZ2poTGc1WVArcG5nTnp4RnVicTJmdzQ0ZzVBV2l4TzhOemxyNks2UEU0Wm85WlpwTDJub2Jqb0tFOWtXN0hER3h2S2ZUQUlEa1FRTGxjZEFnd2VEYThTL1gzVFArc0JoY0xBL2hNUytpUFFxVW5KbzlyQnRZZEN1Q0xyUjkzRXhuL2RWUXZMdGRrYjJENW1UMnF6Y2RvYlRPV3JJNktYYnA0RUszYXI1R0VsUm5kUlUzUXNSd3lqZFo2T1g2ektxWnFaZXZqcnI2Zm4rZ1U2b3FnWU9uREZ0UFFpUjN3MCs3TGtOKzVDZDNvSVdldUtqdXJyNU1vdUpGWHhMOTRNK0VLVmFYVHNTZzRKaUNnc3dlbVdHbzNDYXZmK1F2MzVQWGEzM3VjVE9wbWxzamI2WG1ZUEcyR2ZaeWtSQ2tqTlBaaDNYNytpNFozNmFwOXgwUVZ1WDJaajFBR25CY3BGRWxiMXFVM0Z1RUZHT25PSUZ4RFdHNVRDOW11SXlmVnEydXZYRlhZVEw1dXRGNjBiVDJjeWlIZGxCb3hhUEZWN2pSM3pmQUQ0NkNmVktSbDNpRnF2ZC9uNW9iTjhNeVZod2wrYjY0aHdheWp2OXlDT2VkM2VvYkFZWDdvcHlkVzE4cnlFSXZkZHlZanVYQURacEM0WkNqakRFSHZxRmdaWm43OUZVNnZQRm10OWs3QWxKSzFmOHprMGlyMVNzSk00WnFLQmF6TnFEUjRpV2tWdDlGbGxHSEVDZHFPeUtacjZZWDNlQ0o3eWNLZHM0T0E0Q2ErREU0Szd4alhaaXVwZmJtNXo4Nm8xcHZRelU3UHZxb1ZyTzVaNEd1TG8wSjRnMjJiQnV1MUtWTzVEZmhtdUlYcmV4d3J3Y3dvTEZMM2lLcE13V2VseXhGVGR4dTNFb3NqOFJZdzFNVEFHSjk5TUN1bzdBM3lSdE45aWN4a2Y0NlcvYUtxcTJ1MW1RYlZ1UjhBYnl5OHkzK09MM0o0ZlRaekxXNHhwZnZmd2tzTWpmN00vZlhtQW1lelVSUXk0ZUpkWFNjOStIMnMra1drbHJaK3ArNStoYXVDZUhrdVZ5UWZDai83WlhEL2tDSmJnaEFQRXRrWmNvVXJzR2xCb2VjbXVQbUtjYWtPWDFmZ2V1WnkvREJqc2VTdGtyeGJXWTJXMm5XTVFmN2lBOWI4Z3ZkQXFYdFJLdng2Y1RzNDdFZlF2QmZBUGtlMGVFNjBaWDZmSGV1Nno3azF5QjMzVmVwcWRweE5ERTJkTHZ2eE84c3A0bHFaWUM2bUltU2tCZFpnUi93Q09QYWZNWithWDNNQjVRZ2plSU42NmhHd09VNGlaRTd6S3YzMWNJZjd4Tk9uajZZdXhLaGJ6VnFPUXpNV1J4aVY4RWNKcjVwNnl2MjJnV3FZUmM0UlF4M0tsSkRFWGVlcFpqYW5jcy90Y1BIbnBieTlGUm5NUHlpWEdZL2lFNWhXMTRsV1ZGRm5XcmFndy9RbHA2YVp4TWtjcmdJckRkTER0Slp0N2xYM2VrUGF5MzNXVjM5WWo1WkIxOFFwMXF4enFOUlp6ZURpZW1URXE4VHNLMUdidllmbEsrVG8xYkEzM1pKWHFTMHpmRlFObUJhN3l3WGdHdXkrcXl4U20wR3J1ZjhsV2JuRTlPOFhZaDB6dVN4MGVIL3dyWGlBb2l6cmNTNXp2TWRPSUF4czh0K0lvM2hvYUdzdTMrVExPbm5ONnAyOHhNekhXSjZUS3J2QVBkTmlZcmY0WU11alNqaU9hTGFEUkExbXFvVHRhc25uK0paS2ZodHRxdUNHYjhISy81RDcxNGozWXFWMzloU0lMN0dJbzlDanpyN3pMVFoxdVU3OU5VKys2SnI5NXhxSUxETE9WYzlNWG5wRGM3MW1aQzVldmpwYlRnZ2N1cGU3Z3pTTEk5cWl0UlVBY0FEbC9jcVNiUWFUbS9qUkNmN2FJbk0vR29ncmF4UVhmL3U0d056YUxJVUFOOEhQem1iS2FNcDdUUFlxcUFEcStzYTU3QXhvSUczZkFIWTc1S3dLMVpaRjI2UldJK00zWjNsbFcxaGJUN0FSUUtrelNoaDg1N3pVRXB6RG9HY01VWG8yeStBV0xpRTdKMjZSVkpyb2NJR3d4RitPaXlYRDgvRVNtbm9zRHBVZk5HZ3BkVnZtWTIyckhxY1ZuVVJUWWd5dHpYck1lY3V6aGp3RnQwR1dVRVNDVlYxWTdNWTRRSmVSNHRnbE84Z3J2RG5Ocm16RHlvb1l4MnVYTUpqQ1BSOFpxWnNRVHk3SVpyUmtYQ1luRVoxVWZIbWlyampXUTgyeDlERHNRVDE4cGJ0UXJMY0xzSVVRL0pIN0VLWGRSWTNjeWgwOVE1aVc5dytZZ2VhZmV3eXpjWU9JZHc3K0pScS92NWN4MlkvTEQzK2g5NklCa2ptMTNlNnVWN3NHWGVPLzl2TTcvQURNSjYyL1Q1VDFHSmorWTV4WmRhY1hCYjN3OFQrT3pmYjZNZXYxMXRzemVkNFg3T1o5OWFYZmwvSm1Ha2V4TGQ2QVpZckdCMDR0TVFzSjR0K2QyeCtMKzUwc2liMFhHTkVqRDgzczZsZUxNcHpqb2hmdlNaa2svUlMvZU12T2JITW9JczNyYmVZNERHY1QwWFRCY1A5VkhXWnF3VUYrNUZKNWJtakNRR29yMEtuc3RSWmM3VGpaOXlld3piVXlEdzZWbHU0ckdPMWNUMFVWeGdUSzkyRldXRDFJUlk5ZEZUbEVPTDlJTG8xMTFkSFZ4RXNPWVE1MXlZcE8xdVlybjFmaFVaOHpmZmptZG1zZnExNGhlUURvRm9GcnVUUGxIUjBKRlBHcVZYUldzek4zYnkydDYwNGxaZTVtYW9EWjlSSzhBODB2eEw1K0tYRDNSdW51RGhMVEwyNllYcFM1Wml3S1ZQZWxoNTZuQ3ByMnYzQUw1WWxMdDBWaG1lZjFiaHVadFNqaWJZM1dJWk5YNG0rYmZTYStqQzYwVHY5dGhPUTd2T2lYTkJMdHk1dDVsSmtkaTZIVUJoQXkxNUJmYUQrZ3NxN1RXdThaNUtaTlY1SlRBSzJnUFNXWTFOOGNlSENCcEFMdjNYS1JCemVNRjFkeXBnV2dvSnRWeWZHZVRuM25ycDNocGVMamlXKy9kbm9xK0ZHWlIxcWNSQVo2QTMwMy9BRTdqREdIMGFrcUtOdHFMOEp0Y01IbG1OWDEweTN0dTJyeXl5R3VmSHA2d1luMEsxS2x2TEhmeEFlL3pHbFd4aytJN1h6SHk0RHNJUThlc1cwVURBUGJEVWVxZDR3alBDT3dhdTRTQmRYWHE0dnY1bHJCbHpydFZ4aUc2b1JxSldnbW1VdXlpdmFUS3hMajB1Mm9meEU4MFVlRFBNY01SaUp5bHUwcDdNMVJydGRIQkZ3TmRFRVZUWFBSNXNyQlRUTEwvQUFsWTdkQW9OL0VjZnBLUVhJdjBTb001aG5QYVdyTkVZNXZISHNubWgycHE3ZDFBOTlRdFNFT0xleEgxQTZCU3BaZG80UDVReVIvZkxFaEVqRHM4UUs5TlY1ZUp4cEFrVWFxWWc5blkrYytVSzdwa0EzemI0RlNBSi9BandFdnRETTBzREJyaEpiOFI1UUR1S20veEJWb041dUk3emtRSzRvTm82VGlENE1Wd0tmUVhRbmlZZXNwN2tJdEZVVGhudnhlUHdMYWVKcXpRS3QvNHFhNkpCb0w0bVlPVzJYRDkxQjZZbU5XMTA2Ni9COFN2S0s1RC9hVkdPR3JUOVE1cnZPZGp5ZGJIUGhuaVhpa00rRHhGZ3IxMmhnK1ljN2V6YjNYUHdscFo5cmh1clpDeVJIVFdmaWVsb21keFd1NXZvNFVncFlqbFBmcGdlL1M3T1lBVDcyR0dDRm54aTFhM3RuNVA3N051djl5MjA5MCswZjdNeFdldm1ISjlrcW1LditEdmhzOFRPU3QydElKM05mOEF4dHZyZitVUncvNnlwR0U3TzRjQndrMlQxSkZWYnZvaXdYTERQQkVxVnFBQXRaWTRLOGNZOWtqcC9XN2RQZWZxKzJSNWQvY0Qwd0g5L3RuOEIzR0VENUpmUTRpOXVreHg5R0p0UWwrQ1ZmOEFXSGMrOS9zL3V2OEFZRmcrZVA0UC9aL1ZmN0tPZm0vMmZ3Zit4VjE4a0E2Kzkvcy9nLzhBWThUNUkvbXY5bWcrOS9zL2tvL3Mvd0RZby82ZjdGTC9BQ1J3NVVVUGZmb2k2KzBiaTJYbDVpRGpiR3pja3pCUFE5d2treDJYQkt5aDdyUURxYmtRVXVFemIwbk5pTTVyOHJOeUZWTE9xWHZiVXFZdVV4TE9lMG92ZllPTXMwRnNFcUdoNnJPS2l1amhRemNFRm42MjlwY0REcmtYSHErWllNdGcxVVFEZUlXTXI3cWx0NmJMZ3R0ZnpsQWVTT1h0Q0V4Q21oaWtxZ0JyRTQ2M3FqK3pqK3ovQU5uOVYvcy9pby91djluOUhIOW5IaitlQzFQdXgvSnhRbXJldUZEL0FGalJmZC8yTzU5MlA0T0JsL25jcmxkOXNSWmg3UVRDa1RZU1lWSEMvaU53amF0UzJIM2hVTGhQS0hKcmZyaUNxRnpjY28wV3dFSXpidXlPT0QxbG9JeGdzcitqeGRQRVRrdGU5Qm5aRVdYRmJodHNOVTJQWU9XV3BnSnV2Qll1ZElJc2d5eGIvcUViTzhHUE5xTjFVQzFHcUtEVGsxNnorRGp4ZlBIOWxIOG5HR3ErZVA3UC9aL1p4L1ovN1BGOHNmemNmemNiSDVZMy90aitiaTRxdm5paE1mQWhjV3JVdUhBUGhKZWMzanE5ekhGeVMzZmR3Ym5uVmZBUnltTFVPOW0vTUJQNUQySWhSNThoakVCaTN0dkFIalhkMnVYdWsyRjN1NmFkOEIyaVUzYmRMZzJRSEJIVTZuYTJkYmFDbnRDazFSOG1hRERPVXZ2QzlSanYrSDFJZHQzVk5YbHpudkt1QmpScWluZzZtWU5RRnRBTmd4SFRMa3N5VDk5TXVaQ3Z3VjJxZnljZjJjZjJjTzU5eU5FZkxIOUhIOW5HMFBsaitpLzJmMVVlUDVZL2c0Vy83ZjdBdVBrLzJiUDJmN0JsYksrMzNsK0pVOEN1ODFHZ2ZpWThmaE1aUHR0OGYvQVY1ZElBTWFUSWF5d2RDWEx2SWR2c2hZbXJJcXJzc0hHZUxsNWVkeWRZWi84QUFJT1llbU56cGpXY2NRc29CNXdMM0tDN2gwWHVRcDZpRGdwZEozYTlKVm5YWHRCczlVaWpWeGdQRS8wTXVFVWZOSFVvc1c0dlZaM2Q0OTVxMU9qK0NIS1luYUVRdHU4Q2F3UU9uNWY5Z1YwZlBHSC9BRS8yQnVsUFYvc1RzKzkvcy9vb1hwK1dOTDl5TmdmTEg4Vi9zMFo4a2Z5Y2VQNVkvcXY5Z29HL2wvcy9pdjhBWjZ5ZFlaK3hsbGk1TmRxWjlXY1puMmlFeUduWmhKWm9EeXdEVkxkRnphbW8rSEx4WEF3RTdpVDlwUXUxenVsNGFiZm1JZ1dwbG8yL3M1bUhYWXp5YjVQakJmS0NpNWM3eUNFcE1FZEZEN3VqVVhvNXhEeFJMb3hVdTQxQWhmNXg0bWQ3U1JIbS93Q2FQTXBSVkk3TXYzbUhPdUVpdU9QTVRMNmhOdVNiZVR2eC93RGtuN211djhiN250UFAxZjdCOXAvR3N0Qy9NdGY3TnhLMDkxRXJyTmZ5bExpcTdNK0l2T1BLVDEvcmRqb3JEdnNQeW4rWW1YN1BoZ3RXQkpmMysyZjBQY2FDVzE0LzBsamJSSEpiNkg3VXQxTjV5eXB6UEkvMVBYdHo0dzcwUk14WmxydXd1cFpZL0cxdWxXektUeFJlcXptdVlGb3ltZWdWbnkxS1g1VTNXMWVNUUtpc2FEMjVUOHZoZTNLNG5SQmdTb0Y5bmNUemdXZ1dPeXpKRGc0Sk10VkQ1UmJMejh1MFZkZVpTTkczNURTL0VHd1d0YmVoZXpEbnFQZmYrOS9PUFpOWWxmcFZ1SkxDK0J5ZkVlL2hZWk5yY0YxWGVvWFAwQVEwM3d4d0RBcERlTytVYURiVEVIWDZ4c3ZWcldDT0ZVZFdWVHpDdmR5bDAra1VPZ3lQSjJtUlR5blNyWmN6SHhHbFBhd3R0VTdsVU1LSGFiRHRhMkJaY2JtZkY3bENhUzQ0bThSeWVTS2RwczJJekJzM09UZG1TZnFkWU1Ca3pLclREUWo4UzRJY2NsZW4wMllQZEhlWEpGSUxlZ2liTUR4M2lWZVZnN3p2M2RvYktCUEdHdnNubnVmL0FMRm1XRlo1T2o3QlpVenZJbnJ2TFYxbXZxRi9ZKzl5d0cwekVJQ3EyWDNscStTMnpQRy80RFRsT3loMy9EcDltVUxKNGJSeGRvY1pua0JNMVZlV2FDVTNjZmVoVkh1bFR4TWsvWVNveWk1SW02L0Y3bGpTOTNRbmVGNy9BRnFyeU9ycUZEb1FYS2pzcjMzNWppZDZqMDNUSDgvOEpqNlNtcTQrZ0p6RkFYU3VQZUVua0ZBV3JuTHRIVnFBN0twZXdQTXErRU1iT1ZiZWtIS05hSzdzS3FYbkF0VGtXNXFLUU11M0I3RjZ6NmZVUzBRTExuQVN2ZlZuYjVkbTMyaUZsNVVtcW5HSFhhOFJzMHhkQlhaZWRYdElMVi9WL0lVakhjaXFRY0hHTzh0aTI3dWJoNUNDMVBjWVEzZVNvbDM4cGJ3cFdQZTNISkRIcEVubGpsV25zRURiOWNNUnlQdU1ZbEVxWlFSNkpNSWhkWTQ5ZkxNaUx2VmNuMmdKUFdMT2JuTUh6Y3Y1L3dDRTkrYUR0MytoRzRVK2p3RzRlT2xVNVN3N1JWWWdkbFVQY1BpSmdSQ1I1SGs1SlR0KzJyWktCaTVhcW9iaDNOZHh1T1ZJdEVOaG95bW1GbUZsbUh4OU5SV1E3b0lWOTR3bGhhOVBwQ1VVV2VXOTE5M0I3WDVsWnF6T09ScHpsa0ZlOW5JRERGdGx6QzhLZDlhWnZhb3ZySHZ3bzZITjhibE4xdG9xc2c0blltNDVzUmhLODNrMnQ2RTFHNmJhb0VqbFUyZktMZGhuZ2lWV2g2NGhRWENkZVFTem4yUUxPenNaRm1ieVIrUlhtTWc5WXN6UFZ0UlpPMkhhVUFEVG1INGx2WXc1SzlQcHN3ZTZPOHVTS1FXOUJFMllIanZFcThyQjNuZnU3UTJVQ2VNTmZaTGllRzZkaXlKVUVPaU50Rmt6dklucnZMVjFtdnB3OExicGtUNHFJeFhkcllUdTRQQXdWRlNRb0N4VHlNd1BEYjdiNyt3WW5HRnlvdmFmaDhSVjhab0NZUEJ6Y1BFY0N0RHA3VFZnamY0NDFNbTBLQTFOanl2OEFCczRKYUg2YlRXd3pWUEJITG1MNDVlNDFQMjRYaEFCNmFRQnVBV0FZdkh5c0ZzUXA1allBalFxYWxhbmJ6TGp1ZGFnMWpvS1dPSlVZZFJEdlVLVnJmVEx0VkQ2ck5CYVBkcUhReGl2RTVzdktYRHYyUmZNNWF0dS93RDVzcm1SWmRZQVdxdWlpZStQUjl5WVArMTh3L2hndThmWjlrMzlybTAxaDhsL3B5WFBheC9qU1Bsc29QY2VBZnlISFQrNTJPbnVnQjYrVCtaWXhyNzNlaWZmeisyZncrOFhkdnpuWjgvZE9jeDlIN1YyOFFCZ2llVVhEQ0F6KzhzRHgvRDFWa3ZnYW04QjZzdEorRmVGUElScGFYeGV6Y0FWRzFTbFlsWDluemlVR2tuS1NWUmVPQ0RORTB0VWxWUmZrU3NQVGRLYXllWURtWSt4ZlhicEc3cm95TFg0bnZGV21pNFFSSUhMeThGSHRiQ094WjNzYTZ4bFc3NER5ZnhHQnRpOVdZS0dBY3o0N3k5NjB6dUlSVDB5b3BkVU42dHJ0Y3pnQkxpQTJYVkw1dVA4N2FLeFZ5U1B1c081WVgzWEF6ZW1uNGpJWUx2Y0MxRnJxSEdKdk9xRWhLWGxqaDc0eEYxNkhnSTh3ZWpWUmRBK1JkbTNjdHpuVTAyYWtyakZyTlBpbzBYb0kzaDdBdG54TFRJMU1oRmJ4SFVaZ1RGVE9YK2pFOHRQMXhIeW9md0hiN3FVVzQzN3NKY0lOajhtcDRqMWVQMld2YUpMTjU4RlZ2aG52NmxGb2l2Smt2d2YxOUk2SXozRExGak8rWWJqQm1KSEtscjFKdkpHcnRNQWxBZWg2VHZJekgwY2l2RXpuQlhxUWh1S3hjeDljS3hUc1pxOXh4YXA3ZlYzNDJ3MzVWc0h1WHA5SmJyeHc0Z0ZmcWMrSlNxaFpGK2I5UkxvMi9kRFVSWi8xTGxnMzlkSHdZTlV2d1EzUDZiTnBmZnBRb1JuaC9Mc20yUndyQ0NlNHcrMUVuQWsvWkRjMy9TU3g5UXgrd2NIenpSQnRiYnlKQTBMemVZWnA1UXFseHhjRWRycnV5bndpNmpJc3FCWVVnZEllQXVOc3Z2K0gxanVqc0NxNzEyaGMrVjBsK0pmRjV5LytrdWt1S28veDVpT3NPa21ROEx2dnFOQ0tDZXUyRk9LTy8zbk9pWFpZUmdhYjJIclJveFVzTXB0RDVVNTRRWURnUDdpT0tLRlF3dyswWUJzeXVDdWJuMlgxWDdIK0ppSm11TFRYb0xwQmN1UUhMWmZmOFdmeWUrWGNLR3RXNTlnbXAzQnh0dmY2bTJlV0pmb0JNNG5uSW1NdUx3OEQ2UitNcUFtMVc2UW9IREtEc2ZPOUJ4aWViZ2dVRnV6ZyswMzVsckhtSmU2R3BlQmxrTDdwbTgwTURCdmxXK3BiOW9yZ0kwODJGY2tFMGlHUHRHN3krNFZaN3h4VzlJV3M3SWdJQ3VYdDczY0RGVkxFL2wrcFhtam83UnZCcG55TUs5T0svcU1mS2gvQWR2dXBSYmpmdXdsd2cyUHlhbmlQVjQvWmE5bzBxdmZnM3ZocWUvNjR0aUs4bVMvQi9YMG9HTjkrNE1ReS96cCtMM1gzUXVQcFdBcFR0WmhzTXpPSlhtV2RtdkxtRjI3UkFIYTdQaUs2Yjk1WWlmdUZORWpXWWtpb2p0NG1PSGN4blZwc1hiR3BYLy9BQzZBMVU3b2NDZGo5Uko1UXg1NGxrcWhVQ05vOEhiZFZtcG1WMFR0VFh2bTh4Z2JhT1BEZDh2UUdPK2lyeTk1ZEFKdDJMdjhUU1ZMOURtQmZlZUhUMHg2V0ZMZzZldlBROFdiWm0zNzlYTDVNeWIwOTd5YmJnSDNnTVlOaFV1SHA2OXY3My95NEh2T25aOWw4Q2JwblRaMDRZV04waHJyTTJMOXBiT29xNE9mTVdaY1Q3c2pnZUJTZUdmeXV4MHQ2MUtmUzM3cHRveDUvaFYwSDM5L3RuOUYzR0pmZHlIUkZUY3gxMkhNUjFpWExHemdTMGNINCtxUGhiQm82RnQxQ3UyeEZ3VzB4THBNaEEwbVJrKzJIcUE2dzZMd1lPWjJCSlZZbTZQY1ppdHR2RkNqa1NVUGpZWk1IbHBybW9vK2JsbjlxMTVsWHpSV0NDa1Z1MzBqN2tXaHBtMzNNSGVITjhkR1NLN2JtNE1HNFVHV3FBbzVXYXJMdjNib2NrVkhiMjFyeG9QUTNIMWZMSXNGMVJLdXNac2lETXpuQXppbGczQ2dsL0FsaFJ4QWcxbW1wdXQwakZJaHd0aU15Y3RyRUp6Zmd4RTdkcytTclkwMWJjM0dZejd4R0dYbXdVOFZaSzdOUU94M0RwMEpDOEJ5dDFwb3l5S0w1bWkrR1Z3VjR2cTAzdmZmNjBsQTBscC9FWXZ4RWYzN1VhQlVzOGpMbXhZWFM2b0Jya3lxblVCcnRNa3lLcmlvcVJjQ3hNTEY5MG14bFRhUVg1dVZKbWFiQmNvZDRvU0JoWjhPRkxhZkZ2MFlxLzBwZlR4TXk4UWhwSHNRYnY4QWxtTjlpYThvbnZzMUVwQXNOY3FPZkVGbGdVb0diZkZReWtQc0NXbEQ1bWJ1NG16dzJKS2lMRHNnL1ljS3FwWVFsZk5RUEpLdU9WZUovRzdIL3dBTUVTa0tsR3hlY1E4bkNBQzZGMnZtVVpaZ29PRTNYR0kweDZZMVZ1dEhuVWNNby9mY3JDMDV5dnY5RmQ4Y3FNM3o2eERTZVhBZDUwejlKZ0tXZEQ2WlAyK2s2b3R2bDVlRGJ4TFo1N0RjREFlaEtPcWZnTlF3T0E2UWg4QzdQeWhLL2IwcStvL1JOM2I0OGpQTGpYRVBsV0NmZ3ZVWnM1NzdpV29PV1UycXZEcVp3NkYxcjdFSUh1eU5HeThPYndlWTFybjJFcW5QeGltSm5JaUYwdC9Md0wzamxhUnRXalQycU1zSU5DNEdxdkxtODlwSHI1YWJaajdNTnlsd09qZHZIMVdrR0hCUjR0SldjaTdOOU9ETzVpbkxEVndsM3B4Q1BjVVE4dDhoeHFaL1pDNFlSUHdNc3QxU2RRWjNSNkw0bVdmZnUwKzhLN3NLNXVCNXJnM3Ura1N4MjdzYUF2WDdqZUdUcEtZaDMyOHBKNGprWGxFNGJ4MkVNK3F3TkYxK1FvenhNeHl1NS84QW9lU1drbmFhZms4UVI2WHNRbzV6QVdienZic2hIdWtSYXZERi93RFRtWHNiUGVZM1pGd2xBNysvbU5CWjhGdWtvdDhGVGRLc25mTTY5YTRqTjJFckgycUYrQjhCK3VJRmJlY1N0YkhDOS9ydVVEU1duOFJpL0VSL2Z0Um9GU3p5TXViRmhkTHFnR3VUS3FkUUd1MHlUSXF1S21GUjA2RUMydm5FSmdwcTV6bm0wc3pOTmd1VU84VUpBd3MrSENsdFBpMzZMa3c3R1ZkL2FMeUZ5WDFzbDZ6dmhGQi94SzRkNm81SXhiakFtVjJoTFM2eE5yNzAvd0FyREtKOXBkZTZ2WG9nbk9ZYWIxY2YzSVNKQjkzeXIzRUloODR3OFU1bHVucnN6aTJzOTBFWmpXb2UrcXlkM3lLZVRXZnRLaW5zNFNyZHZvWlp0cW5nOWtNaGJkU242MXFieVh6VnNMMFZBUTB0WlJtQmh4eEdhQ3k0OFFJcGhnWFVSMDlGSzRpek14Vld4ZDhFdVVicnB1NEhNWGRQU0d5aUlzell6SFBXMUo3TEo0dlN4MWN5aTFmUVp1cmhkbjBEdG9wQTJjZTI3VFJ6cWFrUWptb0QySnU5ZW1UNU9qK250S3Q0UGFjeTR0UGZJemVNMDVYMmh0N2V1dkdNVW5CdURxY3YwTTlOWldYaDNudHovRFp2anpPQk1MenFyNFFOT1piaU9LaDVkMkR1bEpZOW1MSjVYanRDN2U0TmtYd05IOTdic1pSQjdQeFRPTzMwSDg4VzEzZ3BmelQxc3RQYTJMT3pNeDdlOVMzNUJ5aS9hbTNmY0taanRxOWk2VjBhYWxzbUN4YmFONlhNdXNXZTVqYmtwajI5Nmx2eURsSytQamVqdFhkcVZNQm1yQ2M1R1hwalFyaEhkdnRSNUhyRmhQbjVLR1VaMi83TnVhaEJLc3lweGlaN0JUUXNIaVo5Y1JIOHpxaThtVGwwQmE5MmZmRWhwZGVrQWNKQUNDamtydU42N1Vhd1BSM2wweWRsdnpNNDVtRTQ5VVEyaFQ4OStJKzdZTEFJOW93TFkxZk1ORnlOcnQ2UXBsMldERGNwR1JuTEttdVViY0FjRFR1UmVTV3Evd0FydVd1T2ZPYWdpdnVzQkxsMzlXcUpyb05pZ3F2TkV4R1VzY2hiWnByVC9rR0hjeWNOM2xMQlg0N3RHQmt6TGtIRFUvTUM4eHR3aVZhRFhCVDh4eHJ4aG9MRGl6NElYOU5vQStFNUpZMEJZTFpiSGpGWlpjNnZKSGNuTFBwOUNqRi9jMUZYTU1uR0t1OGZaN2pUdWp6MVh0bUg1RUU0S085aitXRGw3cDIzK2FsV0lHak54WHN5dWwxTFJtVHZSTHdLZVlTQ1hUV08xeTY5clg5Z3hzUkphL0JZK0luOHRyOUU5NU9KdVA1cEh2blVLbnBuMzZMNkQ1c1B1bENKanhNZEtVdk5XY3EzY0k2L0dUZFdjYzJ4QzM3ZFZyZkl2elNwWjlYcjYxTzJ5TzR4RTF2RGF0UERpTE5Ya21jbll4eWJqa2FzZXdJcndOOTRDdFpPNXVlVkg0aFJYRmdXb3Z0WHZhbFNMYkpvdkN6Mytpa0M1SjRxVEgvRlpwYXNIYUIzRm9YWDVRbGdGZ0ZlTGNNUFRQZmFmZ2R2V1dENWY3clBoNHRKVTJkOTMxZ1lDa1hUY3M5Mmg3NDBXN2kyV25zTjNwTmY2cGcvb09jMWZMNERNMG1RZDBzdTh6MTk4VHk4TU1hRlB1bHNORlYzbWZCVmpuS1hqNFh4RzZ1eFVOSmh1dFlEelZ5bythdmVFSG9xMGlzSHorb3NQL3drdENyU3ZHRzhqSnhMTmNnT282YmFvVys4V21uMno0c3RoY3VhbkxqYnEyRDV5bW9jKzFrTjh1MEpZazZDdENyYlBaNWlWMlpvbDFqcm5VNzcwc2hvYWZKOUtadnQxckZQWlB5eTZ0aXRjRmNuM1lOWFpqNzQrZFFneHk3YnZCcUJlRTdzVzQvWldyOTQzYUxJdW5yNFJDMmo3cGN4eEZ6WjVmMUhOSVZyZTlZb0xVNTJQWTZRWGZEZ3NmQkhEdTl1d0ROdi9GVE84cmVwK3h3dWwyR3BWaWVmUzRkSk11ZlNKd3V1MWFTYUE1MUJEdXVMbC9ZR0E3U1RheWc3RjB6QlczaVg5RzhlbEJBTkphNXBLV2JsL3dBTDk2OW9qbTVXeUd6bFd1YmdmRFpYWHV2M0pWcHhYU1daVTR2cU1DOEFKMzlyL2tTdUhMblRrMXRxVXMzUHJLSmVTVzYrTSt5QUdCd2p6Q3A5VXNpVThXdm1aeUhpRUFBWWQxbVlhMlV3WUgzTTk0aTZ0U3RwQ2o2WFhSVnhlTDBLeW1PdEN2M1kxQUJnNEk0YzdsU2R3LzhBV0t5ekIxLzBYRk5VbGhOT1RjL3oxejRiOUdBc01FTzhnMzNQdFBRb0pqQy9xbnRFdlBMbWZnZUhMNUVDdHcydWYvSUx3TGN2U2ZKTDhNOXJoRENvWW5sWWppbE1YNGswTytqaUVpa2kzY0RYUHNnQTkrVXRNK3ZZSU10S3FXVnZpeVBvQjVoTkJzanBReXcveHhMa0dzT25Nb3U5RE40b1dETUMwSU5tVFBkSnFHUjdOek8wVmtPOU5ocXpvVndadGdLMGVweDdTSDB5L0toOGt5YThYWjNIeU9HSmpHSU83WGZpQUhFNnZ1ZE15cU5zQzRFVjdGOHV3UnpIZW5UT250c2ZBVGI2emlCdHowLzRLOHQzUFhMaVBpaE8xclYvbzh5czZuT3YyQjRZYitoMlIwZTcwTzRxdTBMRFpneEFhMDdWeXc1VWJ3TzdGZjhBcU1wWTVPM1VicFNiZTdDTk5DVVh1NHQraU9XWExGcm41SHpMNUU4WDR1UWpMaiswOEsrNThmUUxKTVpORS9wOXVwemRvOXdqN3N4dGxDUkwxWkwzbXRBTzBnc2ZsN1FQUXpiRVB5TStZZlpMZWFLdjUzSzNVQzhBRnllQ3dyWktJaVhxeVh2QThyVzNsWmNPeHh2bVlaNlhib0M2MGxYK3hPOHhXTXRibEpsek1FYU0rMm1YV0hyaURSOHZ3Z1gwODZUeDZIdFVQUVA3UjBiQXBOTnpnWXJxMnJ3dzM1b040WEV0b2FzUkNrWmVGRHdEY3RTdWpuMFBQNngweEtmRzYrcUJ3RHBsVEszbnpGeGs5VU9aRmxqNGxDZll3dnhqN1JYSEJHZmg1UlZVZ1RDWmhycHBMRTladUNGZmhiM1lSbUMreFViOTE5SlFWMSszY0o5MGx2YUhNNGplQzAweXRadWxDdDNWNjh6N2pLdk9oSjlabzZaVVg2cmtVMFBVOHc1T2c2OTQ4Nmo5VUFPTnlxcTNrU21yN0lMZTNMTGg4M2JOS0hBL0oraHNnb0hzNFluTm1lWVpYdTFEVEIySk9DNFBaaWJzTlRSN08rMm83Q2srY0hyM2xTVk5HUEFkaURDb0JWM1B6Q3hBVzZZQWF2V25FRmN2TEM4NXRQSjcrMlpkM1JYaVdMOGFydDRtQVJVZzRsMWhFbzlvRnhYS1dzYzVaZm13KytlbVgxVEJZY2cxNTRFbER1MThYY3FQRW0xVUI2cExuZDhBNGJHR0pBa2luakRrSzhUZi9XWXBNUFl6MWxxNVUxTjk3aXFaUXBPekdGaS9jdHF2NDNIc09FVVZjbkcvb1dpbjJBL3hBU2ZWWk1GUmpkSFBFTTdQbnoybHdCSTF6VW50Rzg3NFZ5UFlGMVdZYzJOR0dSZ09qd3hLRzlqYWFYaE9NV0s2anFxeGIwc1lkdTdNMkhrb3pyemZ0Ty85bitCV0tXTkxteDM0NnhSVThBVjl4WGkrVnpUL0FJVGI5KzZjWkRQaUJhQXRYUGxLemZNT3dlbE5ldzhGelBOUEtTd2VQcXJpbWJLMUMzelNYN0VHWkpueGtuRlB2Q1gwVlJ5QUdYVFVCZkJUeVA4QUpCYjgwdlhyTEhXZmFCT2pZQ2JGMXBSVDczcG9OamJQc1RIT1FWUXBiQThoWGVyaS9vU0h3SmJDZW9mZk42OTRwRk9YQVRyNHM4bW5USFAwaW1mVTdEMjBjVE5mRWxDOUo4aDNrektLR1BMci9SdnhCbG5tQkJnUTdNWHV3d0tibnpzSjlXUGF2bHRONVljam56NVprRjNMTlVoY2ZNQU9Bd3JsbGhNaDFZdnBYWEhGRlpUZjREVU1XSEE3NHl5TnZuMDhnbkhrR054b0F0Z011YlRpQW1WbDFEVitjN2kyNElDOFhNZXBtRUxjWFFVbUVxQVNsWHdGYWd3dlp2bXoyV1VmbE1RTHM4UVZiVjZJMFFIOW1WN0JscmR4QnNpd09wZFd0UFF6N0VLL25Wb0xhUFpUNWpwekRnY1NKNXUxeVhKYWFwYUl5aXZMNjJHV3Q5c0h5YWVUZ3ZZNXBUTG1OZDdmbTZNN2xUVmFmMUErY0xuM2lVWUVzZzdlWUF5dHdsTUMvd0F0UXZoYTdWdlRsN3VpZUNuRHMzTkRySGNuY3A1YWw0UStoTytBcWlPY3djcDFlN1FjRURCM0ZoWjNoa0krZ2VYeExtN3lTdmlqRVpPWmVYMGowNzBhcG8zUjcxZzlJUG8zZDBlMGxIcEFHb2xWdnhlSGtpZHk2OGNsZXZIYTRXc0RvNmd6TGJRRkRIZmM2WEo3UVNFVktnV1h6MWVqcjcxZnBNdkRINGsrMHowVTZQSThNL2s5blN6NmZXaE5XWFYrT2pLdjRMTkh6UDhBY1ZIcEhNSHFrL3ZRSklCZkgwcS8yN3dBTVNyejc5c2o3dWc5YUtBY3FYdGpxVk5zalpCLzRtckxYelQzaVcrbWU2MC8xUHBKVDlGZDRGU1FYNFNRVzZ6TTMvQUs3TDdEMmdBQTdKR2dnY0NOSzFiTWM1SUtJalNhU2VwdTRabjRQVXc5SU1rdzM5MTlIMmRQOXdzNUZuUFZzVjRQU1g5WDkyNW81WW51SlhPRzhNempRNzMwbDM1aXV4RitUVkM0bDVTbXZEOW1WMUx2UERSamtVdURMMkp0TnpYR3dtWTFxTFN1N3lIT2U4dDZaYXU5NFp6TXI5dTJiN3JtSzUxaER0YjBGQW1FamN0dmY2QzlNbnRLdWNvSDdtK3U4dGpHR2M3RTdPWUJYWWtkZ2tUalJlN0FNM20zM2R6dzNqRk9ZeGFkNDVGQVZOMlkxcDdIeUl0bGF2aVZxR1lpclVLQTg3aEZIVVIxY3oxdTdoZ3FGaS96RzdoN1E0SXpMM3hNZ2daVG9EdXd3T1crOUY3aHZKMkdZbmdmVmtNT0o5bG1RNkxpV0s0c0o2eTY4UUNHZzhxV3BlTEszNWk3TTIzd3NablAyY2c3cTJOVGFkWTNvYit5S3BBVjhZV3o3WFRISk5mVENTS05Cc2k0cnhpeG43M0tUYXYrczNoV0lXY0tyL2k1blJ0cm9hYitJV2RGaDRxdzhWY3BlTjRJSHViK0pUL01zOFdYOEVScHFzY3U4ZTJaVGJvTTh0cUx6NDRocWl3S29uS28zeVJIYzVKVDJpaEtCVkllUDRWTDlDbzgvcGJQTUNqSWFSN3ltU2ZlT05yckJPVlJTV0s3S3ZMOHdNQ1JadVJkRjNyTDh6a2JJMVN6T1UyZUNVYkI3eHh0ZFlJcFVCR2czZVNJZUt3ZjdEbUdTeWx4N2pLeS9Rd3QzNVhNS21xN1I2djBDczg4N1lwcFhVQnJnNkY5b3Z1NW5NRkhrMlBXWDFnczZ1SmxHNEpYaFV0L2IzSFhFM3J2WmlJTm5RZGxMMkFCZUkyZWNTMXJIcm00R3pYSGxnUEhrNUd5WXg2TGsycER6Zm1nRVRLcmY0RFVVNkFUNzB3OWFqUUQ0MmZaTTZ6WmFlTE13T2duazNzRE1JZGNIZnUzeTlvL0MrNENlZUhnY3pMRlJ3QmNCRWpVKzIrcTM5K3RrdmVEVS84QVNmd3Bsb1FDeUM3V3E3NWh3Vm9FZGkzRWJYalNxUHY3RFVGcFZMaDhzK3g4cDFGeEt3UmtKbkFOTXUrLzAyYzBSSGtvZWVQVmtEUXl6WjA0dzdoVlRLbFRzUEFubjAxbDZEQnRQT0hFNExCMTgrZlFZdkx1V09PY2dlbFJPb0Z3OE1uZ3RLVUVHRUFINE1aRFpsZEJxRVhDMlpYRXR5NTRHQUVIeHFkb013RlgvWnFvSjBlS3VKR3hNM28xVnJQWmRwcU56VDlZUVhCOFJIM3NldTZzaE02RHRPVGVlQ0NqZy81THR1cG8rZ29WWGFIVG5GTm1YZmVmNE9QRUJsZzNNM2lMcXZFdzFITXZteEtmdWdFalJmTTJGa2FmbFVZUzJIV3ZET0RESGdsSGZTdXU3cHdSdjQyRyt3TURiWENQeXFmZDZyOEJxYU1wenZWVEVmT3RHMWVtckhxQzhmbXBiRjhpVXJEYkY4VktWMUtnZHpuenJIckE5eDRDVlcrdEdmQUJDbEdhN0hKZllodkdJUUh4UmgzNnFyYjdYbFRLb3NBeWNRMXNhL25TN1N1NnpPZWMrY1pYQk1YRTlkbFVuYjBqUEo3b1UzQXJCa3p2SmdPOFo3ZmJ6TVZjeGxWNDl3MTdTbVVnNjl2VVZxYkdEOVBFckxjMmVzQTFlc0VEb2xuWU90bit6em90bFc5NTM3cDdRRXo2ejM2WFJEUS96VHBoMGg3N0MrRC9BRk1ON2ZZVDl3TG9ibmExUDVXWjYvbWozanBPbmZ6dStXckV4NDZTdHh0d2tHd0ZVTWVwZThPSGZRL0RwWWRDWmIwWCtQMjlCVDhKTFMzRFQ3WTVQY2wxR25jQ3V3SFowMnAvK3pHb05XRDhPdjIzUis0anVxR0w1SnAvcDVaYjQ1SXoxb1pxd1JtODZNMWFJMUpmVm10aHF4cVRHdlVhbkR0YzNyRFVNVmxDNk1qZld3L1pralN3VTRZV3ZQdmQrczN6bjhXbHlnWHNzcVBxcTVpY29OVkNDeWZxNUlPdmFJUUU4QWF6cGNVRUk0ZnN4MEx0TmxXVmU1V0xtRFhIUGt5b3ppNWhybm1LaXRRTEEyK0RiMmpvYlY2N3Jrai9BRVFSN2ZTdHNzc1pjZlMyN1M5WTRiZmpETlRuYWpEMm5hUFhnWjR0SlFwK0R1UHFOWCtZd3VUcDdNWXpoM1lZNUNNSkwxVndpcXByZnZDY3lHYjZURXdwOU5GL0tXRGE3aFRlWE1kWGxCaFcrRmF5b0JRVUJ4TXNFbzZieVFVMHhBckxFS3lrS2p1OCswWnhrUFNjKzdNa3piRjZtRG5lZ2VPbFNELzVoZE5OTnN4MGJUVFp1ckZYVk00QlpPRDlXVTY4anllSW5LdEJwOEhaREx0a0pXT2VMV3IxTVJJT1cranZHb1FWc05JT0JjaC9TeXJGQ3dFSGh6ZVVxNFhUMFdZMDVudXhielpjakRlaWYraUpHbTRZSll0bHFOdUgwaGt6d01MNnN5QVRDRDNXQUJSVHhDV09jNVRwaDhUSmM1TWIyYTQxNlMwbEdNc29lV0VpL2pwdWo1ZE93ZW5YWjdTU3NNWUM1eURVN1puQXRkVzZ5b09uZkNrYTNSaS8wTjFYT1Zuc1Z6aEdTN1lPdllQTXl1NjdwZmVoWUFOM2paUjM3UDVSZzE4em53OWRmb1JBTlVZNVlVTDdBOE1CTm01cVp0M1BpZUF1TWVoN3Fqc3N3Y1FSVnkrRm9YQm91WXAyMVZjcHZGcVVjeEdMNElOWXE1MkNBcC9oS2lsV0MzQlpIdmNhWllvTzl1d1lKR2RRbGVlMTMzM1ppL1FEdENMY3NTWnd6d3dSemp6MDJVVmJLMFR1UVpha1BwZ2FlUzZMQjBaSVVzNk1OWjQxRjZWTW55N1Jxd1I0WXZwY2cwNWdOcmhNWHZ5dFB4TFhxbFFkbXUwNGtWWk9HTjNSVGhmanMweXVieEtwODhYSnlyLzdDKzFTbCtFelZXMmk4ck8xS0JzZmsrMEpQRjQwcFIvc3hKQVBvbyt3Z3hqZ3ZUNG01M1VLbDdjUk9NMTgzK1Q3SlF3dTNjYWlOVUFBMEdqcHlGc1h4aWVaUE9sWE1vdDNuNWVtS3ZsTy9WZU8rcjMrY2hVdGQ5Nyt2RTFHcGNLM25tZnllem80eUVtb0tKWFkxVVZITlh5LzNlV1dsMlJNQmZBZk56d1pTWC9wbWtuOGxwRGl3OXVwY2J1NmRwMS83Wlh1bXRkSlY2di9BQm5Za09tazl2cHIwc2ovQUpzTDZiWFU1SDVnVVZGeDI3dFFxcWp1ZWpMSy9ZdHYvblRPY0MzRDhUeWd0eSs3eUhDZlJ2SDRwOTlPWHJLZ09ZNS9CSGtHWnNmS09Ha1Z2TTllbTg4ekl1anlJRnJDNEU0bTJiNStTWDlkN29ZcVJ5OTcwZjI1a3JNSmhvMFl4TldjbnA5SGhQREswbkFwaUlDYWhScHhFV0doWVZoMzNMN3pCL1BlcFFUYmZQYWZNNE9PTGI5RlRmRXg5cVk4K3Nmejg5K2s5alV6WjBDK3ZuWGdUaTV6N1hmM2ZQZUNQU0pOTVR3eW13eitJN1diVEROTVRJUm11Y1JYd2VTZVpKNkRPRWdyOXlaeWJvTVozaERHRUhJeTNrWWorR21XMmZKcGk4Z2x1akdTQWEyV1pTTDF5UjhYMkExOTh5OEF1RnFnNk54c2hCYmZXdkVLdTY3WG5wcVpSK2UxYUpRVUprS3AvckdxUlFLQ0RibzYvV1dMRnRseHZFeEp1Rkc0cmJIUlgwaTM5R1U5NmI1cG01aWx2MytQYjhSOTY4eHQyUE5la0hsRHNqMEVVRGNYRGkvREJpZ3ZiTzcrMFJiMXQ4OXZYOE1vT0NLR1FvSC9BQkkzRExtTHQzbzNRSFZTeFVER3JhdnNSenQyV0txTmRyR0RJdVBqWXB4VkZob25hRjZZbXpIM2kzeTREUFNLQWZiblArSG1WSithT2xWTy9UVUxMSnFJYXVnSDhZcVp3d2RDMnF2cGhTV1RGbFEzSUx0NTdidk1aMHY4QTU4eXMxUFJVYzgvZURIbloxK0ZIS0NzVEk0c2hCVHJMd0tmekQxR3Jna1lOU1BLNzVSVHc2aStFMDJoZGZDS2ViMTQraHA2MWVZYXY5UlRBSEFUQUFwdHozdlNHQ1luRDVqM2x3SXhvMXhMWVM5OXlQaTA3dGN1Y05LcGx1N3g4UkNBaW1tYmY4N3pHT1pYS0lHaEIwVHROSWJMYUs5aEdleUZNL0lZSUlndEU3OU9jUVVqRTdDYTNuNklUVmJxc2Q2OVpmMVl3OGRPbFBhWm0wdXpuZERpSGUwdHBVdlVzWXdUOTFQeEdkVEkzT2oxM0YxRE1sZjBqMTdHUnllc0QxbU5uRkRGcHVzeXg5UnRPM3BMMXhjZHJ4ZmVRcGx0R3kyWDZ2NXE0QnhXeGVMbHlCekt2dy9NZm1nV3FlTGVlNlJlY2dXdk51SlV5c0h2NWhhTGRSM3NqZE9aZzNONEp5cW9IMVhtSE43eDYrOHVhYTZjTjh3ZVc0YUJBYi9INSs2ZktIb1N2UXAyeW0rcisyYlI2VEtvWUtjQk83WTltWjBmeU9sWGpmQTFpN2N4YzRXaWtlOHJmT3ZiTGJ6czZKUVhZUnM5S0xQRUpKS0x2NEZ1SzFNblR2NDNkMDJkRi9kN2ZTSWNHeXlndlEvdEQ2NVJYOEpBaFNDeGp1V2N2NFA3WHAwckdWK0cvd0FjUUpwT3FEa2ZvdGZTRmV0Rng0VDA4bzdzOFRCWUltR1VUTTVZeDZBV2t6TUVUcFY1UTdSWEkwWTd6QndWVG45VDltTjBPdHRqTGkxQlM5MkZSa0FXV241UXk4ZTR5VXlnaC9UTXVReUg3Zk53MHNpVzRabmtHSEQ3Q0dmWFVmVSsvbmlBeEdIb09qd3JtVk5aVUxPOUdydGVaekRtUTdpVVY2K29TbmtuK3lEaXR4NVprcG1uVDJDT3NZZjMzdVhLN3JuL0FKRy9WMHg4RDlOa1pGZFZtL0h1Uk1LVUxhWlgwSTVpUnRZeWJ1V3dCMkh3UEVNVmJKYVAzVkcwaXE3djRRSmp3T283RVRMRDlZdk9oZGMvRTM4RmVCZjIrSndkdWxyeEJRbTZhSm9FZFQ0TTM4cFE5eVlHSlN4NVRwdy9RMnlkK2laT08vVE84OHZnZDhET2RYdjdYZVUyQ1ZXSjNqWHVXMTNseG1WdUVNMVpGOEJFZDEvZkw0MDdUUGhZc0FkRThDUWI0cThYYlUyMWZVc2xUQ3A4Qmh1OFh3a0pod3FHNnZPaTJ6T1VSV2NHSDAxL1lqTnRHMHVoc3ZtS3B3SzIvUmJlMExUdUxaeEg5OUFDK084R1luQ0dXZTdVVy9FOUVpUXlRZzBaZG9yTE9lS1IxTWx1bUM0TUZON3o3S05iYWxTc0l4T0NPNzFCMW1wTkhjYkplQ3ZNRTVwa2tnREN0cXpBSHk4b1RkMnpCQ2p3VDVsL09DOGtuSlgyU1l6MjNQYy9LdFh6TFIxN0s0OUlzOVRDQWZSQTlvSG4zRlF5Zk53ZnhDQysyOG5tYWdtU0w1WFBPNkYvZWNySFFPRDVSMys0QTNZbVhSNVRhSGVDZW9TaWptYkhTWW1jUjJsRTMreUM4YXlYMytzY0p0NU5rUGU1WlhsVDFLeWFoaTI2K1psNFVQM0RsMmJUK2JDQlA1TzJJeWhDaHNSRW9VOUdXOWhMV1ZUc3ZhQldscnMvR0RqeWtvcFU3TjMxZHZNSm9mYlo5RGI4UUx0VlcyZCtKbzhTM3VvN3prY1FOQnVFZk15d3pDdGxtQjBvN3hQT011aU93TlErMlB6UEZpbWx2dDN4MllCenlvRnBFMHl2bGJuNlQreDRZTnMxUi9IcVBIclA0UFowSytsT2h5aHo3cEhqVWZEL0FGbFJpdmF5Y3JGRi9oOGQwK3ZUa1g3c25wL1c3dW16b1A3UGI2WERoMklaS2Y0Y2ZTU21xRVZYTzlyNGxnQlZVVktxL3dDMVlqcUxEdUhVT0p0dVhaMTJBN1BsczkrbklGZjJlQkZubzZoeWRvcWtiOTVqeXhTMnpqcVkwMUdQQ0NPb21iNW01ZFJ4MGZYVXRXTXBhOUMrNnpSWFJkNW1RL2p0ZHZ2bm5aS0RTcVY5VHVlVHBWTVMwUGxxYU14MmRDQWVsTEdNcFMyNWp3eE50ZUZYNEovTlFFdFB2SzBMSG9IU3EzRGRwMDJZYmw1aUtUeEdnTy9wQW1XZWFDdDZaVm9aVlYxMGZyTi9yS3I4TXNXUUx4NlVLcFdPL3dCaDNKbUhvdDk3L2ZpV3VCT0VEaDZtL01TWTdCU3lxN2hYR014elRyeG8yVG53UXBEZzFTaXRpKzcybERmOHJEd2JxTk9zQ0tQRER3MFRaOUcvYVVpc2tUdDZ6cWp4dXpROVh0TVNDTU16QU9oOUFsaHRycGxWbzJwaG96OFVOSXhGaDRTOHYvZ2dnRHBsbktacVRGYkdZNS9YRmNrbzlRVUROci9YRVRwOGZHQXI0TW9jbzJ6OEE1Zk85WUNjZTBFbXNxdW5leExUbmxaQ2ZGOThpV3I1KzJ5aXlkS0trZmFVdE8wTzBtTm9Bb3JWc3dsTFh5RlJSV01ibDA3VlplVUdmSGFKUkNrV1R1c1JtYUZndmg0bE84eDNpV0p4TDEzRGIwR3BYUzZsNU9wcHloKzNxSjN2cHJodTBlRXRlM1RCQ2lDUExRTU1wbTNrL3dCWVpWeVJNR21MeE0xUy93QkxoemJQbzNMV2l0R29VTGRlQmp2RDR1Vmhpamx1R2FJMWExWVU1cDRnV0RMUGp3YVpxRkZzOHRQSHJKcFozVGwySm5KUkd5eTJNU2dYemlhSGxKVHdEeDY2ak1mWmEzMWgvWGtMWjRFalpZRUFDakVWSTZIdlhWV3JGVmVaUWsxK3ZSTGZuWFFOMTVsUGM1bExEOC9rSnVqWTVmMEMxSDYrT0JGc3RDSHJGbVFnSmF0dWp0cFVUSjdyTkYyMWNlWXpFcy8zZlo1OXJqRlRoTkhtUG9WaWlWN2tzZW40aXh2MVlQWG1oRDZNWUptMzd0YVo1NS9FTkU1aHYvWHVpb1JWNzV3dXZNb1ZoWGlJcUlkY1ZyTnE5NVhQRTErc0tUZ1lLb1N3eXRTNVJxSUtjTTk0U0ppTWdNMTZLK3krL3dCQTBLL3R3NkR4SVd1V2dlNjEwdDM5eUdhbGNDZW1ENk1oNi9sUGJwL1c3dWkxTmcrVS9mU3MzNW1jaDBDZTBpeE43SDRFL3JxZlRadnZwbjVmVElDODloamd4amhMb0xjVC90TTBHRXliUXJtY0QvM1RvTzFmYVQ5Uzc1dnFmYW1vUzlOUkROQ2VVWjRFdWErSlJ0Szc0WWl3d3o1N1JXSVpZWmhoWFRwOTVSbE5Ydk16MUc0NnBLeGZ0dy9mWVNsanRIc0J3KzVBRHorZ3pEOHhFSWNRZExoaVZudEJYL1pnZXdIVDVtSVRkVjlvTUh6TW1hS1grTGoyZEJRYzlITFY4Q2IzMU02bXlsWXFxVDZhaTlWT0FpdnBZR1I3d2o3S1ltNVluUEVxbFBvTzZGVlk5SjMyUGFmQnlmZVB6dTFYZG8vWk1ubWI3VFFGODRhamdiQmtzZkZXSzdUdHRRUWM3djJtWnUxZS9kWXhvKy9aN1NocVpVckduNTA5RGpwZlQxRmlvcUJTUEVIb3VNZGtPV0srWVhZVEROUDFMQWtXNGZkdUFOK0lkdlRoamNWbW5qeWRtSUxiRHhjeUNFV3NwUXpubVZENnBBTU9jRGRHNVUxRXVNZWVuTC9sd2dKYmZaWnIwb3lsbFBCUXlML2JmaUdsSm05bnpZRUVjWDdvcGM3WjlBZk1EV0U5SmF2anBid2RGbG5ucGQ2SmViT2t1bE5SeFdVME9qWmNROHlJS0M0NVRjSVhLcnEvei9pT1ZLWVlWd2FkK0k1c25VaGRoSldPa3orZExoQUZQWUN6NE1PaUwvQnNHZHNnQmE3c0ZxZ0xjbDdFcmRmaGY4ajg3aXhYMkNOSDM0VTEycWdpV2RhckFnMzFIWGNRN3ZWeG9pTEcwZUppWGE0bVY0T203cVZ0cU9nVkcvTDBwM3FBam0wOWw3QVhVQzc0Rm5wekx5UEJCZlp1SXNIbnlYTkhxUkdnN2FyZVBBMU1RUndCZWs2SDNoWFREQ3ZVeis4MlF0SjdFSThCdmE5V1lZNzlaekRhNktZTVErbnM2WTRPaUFHY1JOaExlSUFLYmppZDVlUENOYXJVTWJmNk9UanJwL0I3T2d2c0FGakJRdEhURC83ZllyOW52TndaZnV3dExnYU5ISTRnTVlRNU95c25qcFYrVXZ1L0NkTlpkUUFuL3RJUktxOWI3WjlSSERqTnBKcEdGSnRCU096VG5wU0NiMnBySHBmNU9vMklsL001KzdvVmZSa1ZWUExIWDNaNFA2N1BTblpaTUhhemlNTEdHdFR4SDBIWWZ3MmZvZS9qS3I4TTJmQ0RCR3pwWnREYUNPQzRPVGNTd2liQ0NOalVjWFNHVEVzNElBNnJwckVxcWxTaWVFdTgzVnB2SWRQWmxyVDhoL0dEWHhUUHpOS3R1bEQ5NDZPbEIrYTBHbWVxUjB3TVMyYWJscFRjRk5pS3FmbzBkQjhHYlFERGlOL2FCNTJ6SG9wOGVVK1BvQzUrUkRIc2x5NHMrZzRlc2VkK3daYjUrSCtCbG51U0l3eDJQejNuaC94L0hxN2RMOHV1cnQxQlRHWWZaRXZ1NGNsSlF1NDNKT1RvdE5uZm9MTTlZZ1d1Q3F3VkladlRHQXd4Z1lHNEhNSkw4VHczKzA1ZjloYUh5b1RwK0VDUEc1UCtDaVYxSFgzbFpnWXdkQUF6ZHpHUFAwb3NSQWN4MTRoRmZKMHc5SGVla3l6WkZYVDBEend6NzVqTGVkZFRTOHd0TU0xeWlMYkhFak1QZGorN2NZMllIUkFQSHIyOXNNNzdwR3lyOSs3bUZudENvN1NGV1JVVkh3Nk00bkVDeUFBeDAxdHZwMVROSFRPODJUTkpxQXRDWXJwOXJMNm1Xb05YUDBEeGpoTG1JemVTbUZySlhKL3lLaktOMXZHRkhxdjVRb0tDanF0dzBPODQ4VHdIMFZPZUttTVI2UmxCTVNWVjlDQXJvNVhqQ1ZPSHBkSHdmL1NCL3dBbW40anUvQVQvQURvNGJiTDhnT0tPcWowSzR1ajVZTFQ0aTNHd3V0YlRnZ3NqM3ZwS0c3STJEbGE4QWVCanRRT0p5bnJsNHZkOUpIdnNLLzhBT0NOS2xscmVVdGU1L3dDKzd5ZmVQZUN4K1ZKVEx5ZmJCWHd5aXNMOHg3cjNsVC92eEZSME1BMHAzaHpKMEljRlU1dzVtU0FNcmxjSzRQUFdpZzhIZmpwaWJXRHJhNER3bmVkangrd1liK0NZT2ZldjRuWXErODl3NWVYNCtrYXNTaU9mSVFDOTRiWUlMSTNPaVVVMUV1a01Ib3NFT01SQWtZOXhsaFFVYmxISW5FUTV1SzgxRU4yUlpPR0xzN09nUGpMM2pvNFB1NjdlMDRudkFpcHlIMGpUaWNNWm5IWDFqaUNzOXhhSW8xNjQxV1pUMFFVMlpISGpwdlBNZTU2YzlHZWxQTDAzbm5vVDBwNURvdkxQRW5pVDBKZmhNZStrOG5Ubm9tQmhqWEU3ek1zRGM0K29GNm1KbnJMMUd1dGl0eGZxamdMaHk4RTB3MWZ2MTdWNCtuZDRxY1RSTnh6TTMyNkJlcDNJRHhLbUpYWVIzYWZFM1J6SFZtU2MrWnc5TkJjOU1Uek5YOUdaaXhPN0JRSWl4bTJvdTdpTzB6dkRHdld1bCtKeTFGVlJMYXdXazlaYWFZRHRMbmtRU0xDZU90cjF2LzRxOTV6TXc5WDIwcW5yVXRBQzQyV1F6bUx6eW9ER0tUcGxXV2FaSzc3VFFjOStpb1NQZGhFYzJacU4vV0NnamhQRUlXb3ROTitURmVaK2luckdaa2FWNTcrZDluTVB4QzlDbG1kdGR0RFR6RVYvSW12eUIrR2FDZDdkMFRzU2s5ZW1ESEpIQmFIQmpRZ2QrMnM0N3lFcmo2UE9NOGxLckVIcFd2SXJkY1pSMnRib1A2L2NKbjE3Tmt2VlZHamk4VHVVeFY2Z1FGV2laWnUxNFJCNFlFMDhOTGZHR2xsczE4aTc1K0U0V2xNL3hCWWV0dEhrTDJJZUJyaTVpcnE0ODV5cUxuS1hFY0xhTXQ4cGUxSG9seklCcThWR2E4ZWdsS0V4NG96UE9BMWZrRDdNd3kydDI4dGhGZThIdlMxZm5hU3k0UXAxMDJzUFkybzk4eC9nTWhleUZ1RExTd3c0MHpTeDJQR2JjOXFNQVBkSjNDWmg5UUlHdlpFczNxOE9COUxFTWF6Y1RZVGdlNUhmaUFNUFRkNmF4eDBxOWNWdGRwN3ptZ0lYUGhnbG1UTW5kbFZ6MTB3MGtvY3R0MGo2SDJQL0FJRDhURjgzQnIxRGVJOHJqb3JlczcwT0lmUUlsYVRpZi9nNStuUk9INjFid1FERXZMRlhRekN5aTlTT0VTSnBBS0pmcW0zR0locE9JWk1USmtwdXBnRE01MHh2RUhuTUFORTQ2UHJ6THJ2MHE4ZlFIREhwbVdpbS9vR1ROdlgwNDlMSFltWThKZzlFRHkzMW41a3IzV0FDanBSZmhnV3hwYjY3MzBnNXF6MTVqeDlNWmRTbmJIbkdMZUo1RDRpZG9ZT256RmRrdEs3bmVOcWJKeExsM0libUE1elV4VTRab3I2UjRnaDJpRFVZZ05aY3oyUFFLa1ZFR3BtVjBXcmR5emJhNWR0ZklmUWxvOHdDNXViQ2FiaUMzV3B6TlBPT1dmOEFnTzVYZVkrM1FUZ1hFTDZGSDJHUzJGUzd3Z0hDOGxvMEljM1BPeVdJOElicC93QTFSdkwrMmVobklrdnhnbk4xZU4rM2FzdW5uWHF6Y3lLRmk2R1BTeGZoR0ovaStJMytHdlVzK3lLcXNCOUI2ZHY0L2VEUkVXeFB0dnFDcnpTQzRvQjdPa1psbWsvMUtKdFpTZXY0QzUvT2czVmNCNzRyakN3VXU1SFY4MUFaalF3VE41WnhYeXBXVlR6cjFWR2hHaFl0R01mcTVudExjN3dVZ0d1SXBPMFFNbDlMYVBTek9rY0JhUXRzczRtV2NEWlRCWDRnQmhqcGxKS3pCUk9qVHgwSHBQMHFtVStuMDFMVnVrZG1zem1lMHFTb0xaUXh4M1pTNXk5UFVXRlV6T2RPQUpsWnZwK2JvODJKYktrZFN2dTROdGNMWkprWmtibUdhS0UzS3pGUm1XcmNWQ1U5d2JlVzJabXFUUkZ6K201ZnZMR1B2SzdFSGhCd1lwblVMY0VWN0lKNVlGclF3ZG5JTXExT0dVRE1ES3ptWVhtSzFEbWFGN2k3ZWZvRzVZcDdFWERxYzdnU3U4VHl3RHpEa0lKcDZJZGs3R09rT2ppUEpsRnUvUWJqRXN1OG9yT2VKNmpCbDVpb1BPWnI5OXdveDF1V2QrbGRNQ3czcE1oTlBTL0RvSGduYk9oV2VoM3JMTHZNUmlvejY2TE55cXoxV1hwNTZMd1FML1UzR0g2Ymg0blBRRU8vU3hlL2NCN3BjVFdEa3BzTkk4ZW9ORUJTUmFrakp0ekRreWxXMFBWUGZSK3VSSmI2T1BIUyt6cnhjNkVXNkloWDRWcWwxYngzNitScmZmNmNDZXhpTXBKbGx3UjdZOWlxZGUzZHN3MjdIaTIrVUdmS0ZQZW9IbnJsbXgyWlJPakVmaFAyZEJSVThiKy8zajd1Vy82MzM1LzA2Y3Y0dmFmN3ZiQTd6SVJLdmozS2hkc2RUZGYrVGlyZE9xTXAxbVg4T0lkYUpsTEtkdE5EekZja0RvbTNlekRic2U3ZGcxbndvdk5VNmo2S01mS042blBpWjg1QmQ0bC9IeFBXbnJRMURvMVdZaVl6THhhUUI3dlNOK3FBZUtHczlkOWRXbWkwQzZSZEF4UGYwTkwwdU94VXM3VlBkMTl2M2dBVVRZbXFBMGxRZ2xZMTBVc2lxUmI0cVpMM2hsK0kyQmlNMk4vUnFpeDIxQ1BNdTVmZDY0Ull3bXBrWDJJdGtlVWY5RTl2MFRQdjZrczgrckZZWC9VekQ3RUNUbDVsNXo5Y0FDYjRtYyt4RnNIL0FJbGNudkYzTkhyRlNQUFFIZ2d2aWVjRWZEMDFkblM0MzIvZWJiWWZ4aTQxMDh5UTVaY1UzRjhxRnIzSGM2cUdUclVzUlU0bVZqdS9IU2d5N3ZCc2VqV25OcHZvNytvRHBoMkNYN0U4QVJkM0wreEFybGJJL3dEYUxiNkJUVzU2NTAxZW5EUGVSWGIxdDd5bURtcUhNVkxPckdleERCSVdVVUkrZDAydlJRdTZsb2RNRUxHNVIyRXJhMHdZQ09VVG1ZRDVnS3k3YmVnMWYyNllqYlBUSXB3VDBtTzFSU2NKVUhqSGVMVEtSM1ZaME5rV3g0NElPSURQNU0yT1dKbWpuaUt2VkxEdktwam5ZOHdxem81R2NSRVVHeDNHTDVZY0NNNE0wKzhHdmo5QklyTVFTbUJhaTQ3SEQxOHI0M2JYVWJpclJkMnQvd0RtUjhrRnVwMmZBcnlzVmo2RWFYSmZ2MFY1L0w0ZThkTFhZaXMwS29hT29YSjVoYjF0N1lpU0oyMWxUaXFieXdDNXRwZXpYNjVvd1drT1E5eVBzOUlXM2dEeGcvc3BoNjFmMlB1T213N0pXa0d0OWtuSER6d0tYMkhvbHBUNE1BNkx5M242dGRpVndFbkRpN2pzdmV6MHFadGtPejhidG1HN0tseU9QZHovQUhSai9YbVA1anRIem8zL0FEbFV1bHJnK0ZVREVMSnYyZG5nTjhrSGVYYlhzMSt1YUtOWlRrRXZkOW5wWThQU3ZIbTZvQmdKS0V6bUk0YW5aZkV2em5sWmZsS1hlQzd4QmJ6TUJST2N1TzAwM3FYdU5UbkU3VDFXSEo2aTFNb2EySUM5azdyb1lHenZIV2NFb3JVeUIxZDNnZ0FZNk9pQ3VJRnZhYVRNUzZJTXg2T0lTV0E0bjJZUFdaZGFFeWV2Y1FYdkxMNDh5L1RtRHg0bjdOSGJmdkFySW1xZ1RqWTQ1VGRwQzh0Nm1Nem41dm1YNmZhWVB4bVV6czQ3eldVMjFPRjB3cmFxVllXbkhWSXFqRnZYUmtXNnhNOS9wVTVnaVFGdnZBTzl5MjNYUlRjcFk1aGR1WkdhM3ZEZzdqSGc5eVdoa1BSSUNNUW84UXVDQlcxLy9JWnhCbmM5ZDByNWlWMlFPRlR0TkJuSFZMaDcvd0R5TzZRUENHZzMwekR2bWFmVHBZWnZ4S3pVUGJjNG0rdFZ1OE5KN3oycm9jTTFMZGlUR2F0bkFSdk1YYWNkQXVuTUpJcmpEMGRrNWgyNGxaYm50b3V4UUJieDBVQmF4YlNKZzVJaXdlbDFMNFZmOHl1U2lqUHBUNVlGVTBUalVvRGlVcWlHL0Q2VUpnZXNRWVFLT0tCVXU2dVpGYzJ6NkxKVVRKRHZOTk0vay8xSGhtR211MmlVUnBPb1V1bm1sbjh2K29WQ2JFZXM0cVVxNUJsZDdiZWtTdnlnQjJKS2VYMy9BRi9aQ2dRT2cwQjJsWm42NnMyV1BrdUpSNEhOTEE1eGlXSEo2Rnh5T0xENGlYNHNCWVcvTnMxdUVSOTJIdEExbkVZZm5abFNJY0laUzMwQWhUcG1rcWxuaTErWW81aXdWV0hqVDRtUkJLTlh5VEh2RkhlYWFZbjdob1FneXRndnpIMU1HdVNzaHZHSTdTcTRGWG9KUDYvOVRHcDJTL2RYTk9wdGY3L0VTcW1qelcwekxnMzM5ZjJRNEJLQlFIYjZ6NkhEWWkwaWllU1g5SHJEOU9ENVF1SWR1bFJJdjVUeXFaNGQyV3A3NmlDNStjTGVtY3dNZTFDakwyM0V5Z2FUZ2U4elJYcVRSUk9IN3g3OU15Z0JINUpnMks0OXBFRGN6aW9BY0V0aWVzdFEzRHdFOVVpL1BpMFJxWnY2WStCS0hJYW1Scm50R241SndPdThwMVYrNW5VUFJEUE8zTVJmajh3MDFoeEN0bzhyWmp4YTd5alJyVTdIMmpSVzB5STY0WXBvSzdlWnhEUGFIUm1GdTBkK0p5SXM4RTIxS0U3ekhwT1A2UzNhcWk0d2dsU3dkZU9rdWlYZHBtYlRpRUJGTVBFRThNcGtaZWJ2U2FIaUI2bzJUMTA2WlRVU2xHZWthNXlsdW1BZlVOWmhGUDVPamsxbWhycHVuNHBrTG01WjNVUldSaytFeUw0bUNkUHc5SDFsZTh4WWhYQVpsM2czYjVpSGQ2U3FjeXdkUXhnbkVLckhWeFY5WTRiMm50STh2WDFXWUhwRnR2UWRDeXZhRVU3V09rbDc3NW0rczdJMWU4em1id2JocXUrWnV0Y2RPWUZqb2xvQzRGZTBDNDJOdmFERjRZVGM3WTNnNnY4QWVReVhIVmU4WGxIYU95dXJ3UTk0M0FGc3pHak1ua1l6OGREbXNucWlNMnpsQzR1T0RJM2hkVE5SNGhERU1ZRFFiZ21QQnowUHl5cnZkQ2xLanpGUitqNHBzQ1lhSHZEdXdSeU1RRk9aVDVJRlgzbGp2cFlJTEhub1BuMHdRQngxQTFtZUlsdTBPWWwrdWh1MWJpN01TNzhaaTF5cGhsNng3NTMxMVppMnYwVzkyUGlod29KVzFTNGdHTXZhWitaRHp0OFFNUW1Dc0RlWExmeEFCcjJCZVBQNGpLeTdRNWN2WHNqZE1WTFpIbHVNWEZhVnNwdDlZdFdQMTRxWkR4aVphMlUwWDJaT0dkcU83YmlLR09hTTQzcCtLWlI3SlpheENpSHRJN2pMOW1JTjlQWDF1Q0NIRlRGMmduUDBXYTViaFV3ZjdVL1llWWNuMEVzMzN3eHAycjVrQzVlRlBlSis5ai96bVB4ZXZHUi8zMlpnaXNNZUdtSDl1M1ZmQnA5RDZ6aGc5K3U0SHpISzBTM2Y3UzROc016T1Z3MFQwU0dERTRIMEYxaHJwVDJuaW5obmhpWEhRN3haMkloaWFTRXBzWXRwQUFvamJkb21TNG9yZ2kzTU9YQ3dJVTU3WXk3ci9mRXl5Z3RLYVMvcHR4VFNzU3hZd3hqcHd2OEE0K0FJSnh2NkhiNlRYNnhjTFJxTGsrRXdyeVI0ZUlObzdIaVdYTm5UNUxpK3B1Y3FMbnI4UC9pYmYzdFBsUHhNSEt6OElvRzN0MXlZYjEwTmpPenhEOVVRekZ0WWVZMWprQm55UTB1WHZLYTY2Qmc4SUltT2prU2NTcWdJcUIzdUVicG5wSFVjZEJYU3R5b3o1SE10WlIxaklRREg5L1NuTGZFb3J5dzM0Z1hTdVhUeTBSOTl3TFZsSjU3Sis1Mzd6TXlRZ1BNMUpGVCtDY0YwNEZYb3ZjZUY1ZFN3UGFiYmhOVG9tdldXS2F2RW1KT0pwR0RkTXJORHg2SUs1RU01emlZZ2JoaDFxVUNjUjZlSTRGWnFFNGhxTGVEQnVRc3lEekJHM1RTUUQzZS9RYjExWXJmcEtsNFJ5anZIUVJYTWdxcEZoSG91WGhnc0w2OHJqcFNqMmpxbDlNMFlxRURwdCs1T1o5NVU5REczbDZYN3ZveUlJVlBNOXpPcFZjRVpxVTJMWHViTlpqbG1yTXM5aWNkS1lDc3Rjd0FvaDNNc1ZnKzZTOXZROHM1VElic2xjcjJoeGVQT2wzcnQyNWxPNDNPWjd2anhOTFNlV25ieEdQdm43WHB2N1JRV2tWY01lVExQZWRxcFBkWkZPcGU5VGVKVXAzUjd2amNTaWlUeUhCdTBMblBIYS84QXNXak9vSWxuUzJ4c21lRkcyS2JpbEh6bDYzbmpxQzZJa0FvVFFlWjNuZVZ4THhVTzFlbldKbTk5b3QraWQ1N3hWQ3hHT2lCejJnNVIxM1B3NGVZbElmaWo3TnlzeVZBUkQyeG1Ld2h0VytiSTZXTXdXdlNpVU8yVGxDMFAxVEh6czhNOXhxQThMTndwMWZ2ajNJRVpheGpaekFqR2Z1WmZnUzdUQysxR1o0WEdJbDNsNm5lT1Z5MTlHZXZkTlJsMzBpSHl3TGpvb1JEcU9DQXdqdUVyM1FEM2VseEZsRDM2WFJsZ1o2bkNWaXl2WWpueUpTd2NybVZ1a0xpN3QxbCtZdFRaNUJYVWRVdmZVckQxSEw1UXJnT1Y3UUt5RmdOTzlvM3g0NWw3d043TzVjMUs0VEpRY2VMbE5hSEd2MWNQdk5QWm1LWDlRK3FIYmZTQTYvRUxVREZoaTVjVU5RTm5NR0FqeVM0bGpHakwyd1FWTFNPb2xzanRVNGxpNkdibWt4eGNENi81RVhVeTFQaTlzWVUzUzNIYXZCV1c1Wnk2SHVubXl2Z2w5ZFdjL3dENU45RnJrNmNlazNscnZXQ3YzdnhLM0NIRWZ5dndUeG1YcWI4Uk53SmFadStmWXU0cTJpSVVPb3FzWndtQ2F6MFZNQzAzQjA0RkJIN1hYQXFXSXZFZHZhQytqbUNrdTV0WUo5ck1wWEV4SFFXcW9jeEE4N2ZNZFRnc1ZEdkJQNEpraExncHkvQkc5VFJxTHlyTU9Bb2pzUTgxOENMVjFPWEI4NG1CSmhGVGZXRGhMVng3dWF6N0xLaFd2Y0FlOGQ1SlducHdIblRtUFBndmdtVHl5NERmUW9seTdHdW5GelNZT2hNYjJJTWtBeDVpOHJxV3F0RXRZWUtiM2hyYTJNTlBkUHdCT0lRNVRVWnZUS0ZNaDZ5cy9RWmJUam81MWYyaVYraDlGQU9laUZEcUhNdnBwUEUyK25YTmFRQTRKaTY1Nlp3UTN6MzZWZTVoTHRFc0dPZzlOMnBqdmx3VFgzNW05SHVtbHVxd3d3Q0kybnF6eFFBMFRVVGdPQzBNKy9hWkFvOStJcmdRTHQ3ZTBhMmNtc3ZWWFJHckJaeGgzSC9pWkFRRlpsMzczTDZTckg5NDBVODhGK0VxOUZtaFhkVG1IZmdjRU1oM3VOVGlCZlJ6dWdkMll2Sk10MkQ1Zk1EMmxLWDVIQS9pRmJ1OURUWEw5MGQ4SVE4K01yY3M5bCtrVnJNRDNnT3NNcDFtVUdTb2JiWVIwb0pUOTRRdVhraHk0bGkrRU5NWmV0MXRGVG1YQXo2OVFPWHFuN09JRmZCR0phTGpmc2J1OWlYQzRENTNGMkt6WEJHUDlacWVIaHJtcG1JdGhBNzJjZDVtSzMwdHYrSUtXd1hQRThxaXZNUDBUTU5ZSDJJSVQ3OEQ4L2lZT3JQUEdqOVFGSEk3OHpPN0VGUFdHanMrWFY1Z2JIZ1Z5ZzRISkxEc1EzNlBxQUZIUjFxSmJJK3lKd21OSnNZQ3FZUzR6aE05QlllNjZIaHhGeFprWmJaNWNNdXB2Z3J3WStKWjg5UjVXb3RCSlp6Y0kvRVpiZDNJSy9YVm1FOWllOEl2Qk53aU9UeHJoN1MxekE0TGRsYjhpRnVoR0F3OU8zcEhWWGhxOW42bXZtaXg2dmIxL3dEaDh3RnhFNXhBR0pTM0wweDhKdUVMMklPbTZsOFNXOWpwUEJtSGcrc2V3TXlzOGMweFAyVGtLVDIzVTA2bER2b0d0UzVMaE5GSGd2N3hyZjN0dmFmR1RsK1BNM1o2dlRpZnZ3YUQ2NW1XTkJ1K0QxaCtaNlUvMEdYeHY4cktXWUR2M0x5dVlvL0NpMTJHOEY0ZU56dGY1NmZEN200SDJwYXdPa1pUVjEwUTFLWW9XT0p3aUlNTnlqQm1IODlIYTY0K0dGR3FsV1oxT2ZLRU9IZlJWQUQzbFZ1V1ZrQ0xEc25zUnIvc1BWQnNBZUNDRXpnMXg1UXlwR0RMYkprenpPUXMxamw5NWFhaVBQTjBPd210MllQZmNyOXh0bUxXRUgyWGlpZkZaMDhIM0R2QnMvVU5lNkZOTk13OFc4M3gyOFI5VXZkbTdLVjJUdkNwRytyRFdHZW5EbVVUaVYwYlpXbHFJZVNKeXlsd0Nsam9ybElZcmljWlNYSjc1NkJ3am9MWVFyNGl4WFJqQVVGUzVKNnpoTGl5MVhRQnpHeE9FYTZZa2puL0FPUlBzb29MWW12UndLelR1VHZOOXhMWGdSRXdjNkFvc2RNMG5IVFFkOFJOUjdqS0VxMVcyQzd4amc2SXNzN09lZ3RyRVZkdC9RZWlrVGIydnZ1YmpKQXQ3T21jNkl4T0FlM1lVSDVNNWhwSE9jSEJkd2VvN212S3BENms2QlJxZU9Kekd6NGxRcEpwZWpOaURESzg3MnpGa3pFWDMrWURBSEJVWUFCQU9IREduY01qMmV6RmJEVlhtWUJuUG5tYXpjOThXRjhSNXM2R3FlbFBNV2k1WGV0OCtKNlp4RDg3bVRXQ1VWdlZtcjFpRFNVOEtkMDRxZ0FVT3RvNDk1dXNlSlBXdFJsdkI4UzhKRC9EMmorVEF1V0ZPVGFmYnIyZkVXNm1KRUt0emJodEtaOTVSMnZMMHE3Sm5Bdmk1VlhJQTFieHdkMXVzeTdKYkJnUHVEQTd5bUpMWFhhL29KYTlzZUpVSGw5Ly9rU0I3aW9oNDEwTnhCNnpUL1RHZEJiSytCejI1ZDd4MHF2ZUtYY1M1OUFWR1lOaDZHc3p6RUFERXBkYzlCdGhPWFRZVEpSOC9RWTFESTVtUFFLU3RLdzZYZEh1MUxDdFdBOTZyK3VXSWlwcnJ5amltUGVBT21lcHd4QVozcU5mZVVFUUtmVGtCT1c3dVc0cDlZbk9PTnZQcVRuREs4d3llWldtKzJTVW04WG5xYmowWWxVNnh2ZHB5K1oza2hWdjFVN05IeGNBL0gwaGVwUmNDUnZoT09tZWpkOXBtZmI2cXo5b0RZYVptcjNYTVZqUXdvQWVxODk1VGhvZmNqNmtKcGluS1U1cnFXenplVzdCOVZlNkFkNFpnZEgrSzZQSmF4UUcyYlF1cjMvRVhFWEhQc2svY25hTGUrVTg1YStMY2UzVEV0d0dXZHExMnl2cE1lUmNwMEd2Y3hPK01mdC91MTRaNkpNZHB4UHVPb3BxZjk1QkJZMzBGenROTkpUMTBYTUNDelBSQk1seWwxaFZtK2w0UENjaCtFN2Qzek9Qc0YvSjZFU3NNTzhkWXNZQVBvd1IxVThXYmVWVGJBTXl2VVhoc3hGRXB1cUUxdXorcERkSHpHTzh5eFBtRGQ5NFNCTzVLRVJYY202ZmU1SVRtTlYwUmxGM0E3YzVoVU0zVm5vWHFqL2lTbmtxVXdlQXk4cVVOSEpQYjk0Y2FLaFdJanlTN2I2YThuTFN5T0d6VE5KWDZTdW1LTzdVRUxvSStHdW93bWd0OUJEVlc1L1VRVVlZUlR3SkhXbnJBN3NwZ3RmWnJwOTVGWHJtWTZQd1MxcktpSDdVT0htQzk4bGxDUGNPVm1mNVNsOC9HaGQrdE1QNlV6VjlsT0w3Q1ZJV2IwZ3VKK01JWUN2Wk1zRjZJNVNuWUpiK2ptTDlhZjhBbHAvNWFmOEFsb2Y4dEx1aW9JcS9NdGU3WWZIN0dDQ2trS2lnclp5Y0h6SEh6OVVKeW84dFF5SzFWRmF5Sm9HNWVaa0JyUU5YanZGdHFMRlc0RTU5NVpQRmFTY1dVMm1BWi93am1hYy9tVjlnZ0t4TUhBL01GNmFndGVaZXA4anhOSHRnM2hlbzJLTVU2SGIvQUhFdXptbXV4ZnN3azhTd0NPTWVqWFhpb0FHRHJVemw2Q0REUk01dXVtbjEraSttSnV2TTl4aU9zRXViaU1YYXVaNUlZNXE4L0xOdHh2SDBteU5sNUtqMS93QWlQUGlGOE5hZUNWei9BTS8vQUMvQk5VeWU1WCtEdTVsSWZpU3ZzK0lqRThibTJOMXE5aVpnTjhRWXJtM3IwN1RVc3FPeDVSTitsSEpvbU5HTFkwUmNuRUJqeEhReXhXejBmc3FhL1dESkdtVVhEcWFIWStyamw0NWVsWGF3djRnYmxQYUxEUzhzUGpjMk55RE5HQmE4R1BhWURXOWp6K0FPcDZpNjdPTStXL2lPNnF3dGpRZDZsN0QzUjI1RnpIMjcrb1dWZVN1R0hkNWJlcm1BOTl3ZnlRRFMwV1AwZmFJRlpSUFB6MHZHY1Q3d2RmSXNyZVlHeUp6UzhUQkFTOHh6bHROeWhsbk80bDhIZ205WFRDbi9BSmZDdzhTaVB2aHhBbjlxWVh4TWNFVWNOTDlDL3QwU0tmM3hNS2dvVlNYZE9YeGZLUHdqbUdiMDVLZk1BLzVJaGwrZWw3OGErYmZzUVZjNUQ2N2ZlY0o4SWt6d3JoaE5RekFwWWRIamRRenB3emcvN2g5NXA5T2xGK0hxYUJEa1FoWlpXR3N0OUNPZDk1bFd1cUxHSUhDZVdZZjJqYmJhejExM0tyRnNQeXBzNURabHcwalhyNmJvMk13QzJMSGw3UzlRRzZkZXBFdnVrcytxTkpGVnJYTXdpRGNtQXA0T1NkczRRdXU4RXQrSUg5N3V6ckd3am4rci9vQ3MrL1ZTN3FXNzRVTFpZdStMeEJoczlDck8zZjJpcm9wam5rdVgyYXFQZ21lc3l3ZU5oNDZlbWhpM2ZvNVJ6RkI3YWhzR1k5MVEzRWNoRkp4TGYva1dJdWFqTHVJdEc3ek4zRytjeFZYRGMySVZWdEw3WDBDREk1WGFMMFgvQU9NdlBveXRsZkM5Tnd6NExFeVRscHJYdkZvV21meXQ4bS9FZXppOGpKUG80M0xLanc2L3RpenRPUWd4cGNKbWlGZWRIbjZweEZ5UTBlbUJOcytXSzJOWkhDOFhOeUtRWTZYYStIbUczM2NRRENrc1d6SmtCd2FWemNRaUpkb2lPemZJVmVpaCtmU1V3aXJncUJqdEFBYVRxbUd4cG9NSXpYZTRmTWxkcHcrWEI1VXR0THcrVkFkeEI1VXZuUytkTDVVdm1TcmNvZk9nOHlBUm9hd1dhNnFCZndEVUVtaGd4M2t4U29lOVIrejl3ZkRIeGo5UzhibUliTDc3K0R0UGRyZi9BRWV1dlJBOENVQlFIYm9OVDd1UFVMZHM4dlZwL2VJMW5VUHNzVjd4a053cXI2L3BqeEhGOXNwUHQ0aXMrVHJvQ1UwL2FtaWFjVHpwZkk2WDN5SmZLaEMwNFErY05uS1VEbEw1RXZud2dsQ2w4dUh5NGZQbDh1SHk0ZG9OUXdEZnYxN3k0dStRRGZQTGpjcTNyREhkOFM3eWpyRkljMDdYdlFaZUNhUXpYUnplTnZRaHFQNEdqUmJzZDRhaUhYUjQ5M2Z1V2R2c0Z1TWVyTU9jZER2RmVvYlBlWE5YTlhkazczejlObmFEV3IrRWpFckZtWnFmdG9CVnhBNm5EbnIwbm5RZWRCNUVQa3dxV0tYeTVmSmg4NkhGdEQ1c0t2S0FLbHFnTlJ3N0ZyaDh5QVByZEVHdWZmUldIeG50UGxiemZhN3FQc3U4NERBKzMzV1lRR2JjTUc5TUpqbk5ueXR6QXBtUFl0OTJlQmx6QVFmdnZaNnoybHB3dksvRi9BaTZ2TDkxajhYUzJ0VVc3ZTBUdlczSDlHMnd6UzIvb21KaUxqUlZmRWg5VkI3TU8yZDlyMmU1Q3VEQk05Mk1idUJSemIzSi9NL3FPaFpoZnhIblEydzNueUhjVFZTSGxRM2JVdm53ZWZCNThYbndlVkY1OEFUZDRVM3F3UTZtSWlDdG1qSGVOeGEwRHY4QUVIWFZ5TVlXWG9ZSnZDV0xTL0RiRHp2TlgxSGtmdE12eUdoa2J0a1ZjQmJKWWwyWGNwQi9MN1RSUmhyRjU4eS9zeVZIaDc4bzFHVTUxMjY4UFc5bDBXUmJ6Mk14eTV5VFFKeXlzNWkyMTY2YmxDOUtabWlxejB2NmowN3VuMmtzdnY4QS9vNVBLMzcvQUVub1hNQUtIUzBwQnpLK2JsOFB4TGx2MUczRmZ2bTNkOFZVelFlMitwM0tPK1BNOWdENW52ZkhhZWkwcVJMdkdFNVJ6YjlLSU5MRHVKdVp1WXMxamFnN3hzbitUOXQ2dWZwVFFFSW9kWlBCQzBzNmF6QlZYaXVES2crd01jWXpjUW9VOTNWZTAremNOdmxYaDVqVkxUN3MrRDhKaXEwNjZERDJ3TmVzU3Y0NE9xRHl6dk9OUW53THRtQ2MwVjhsUDhxRDh3M0ZwVzc3ZTl4ZkN0YXFQU0V6QTRQeW13OEtwQXQwTGdBT2l2Qk9hNXpkT01OWVM3L1hsUldjZTRZdVd4RDZUUTdUU1VOaXJyRXRhai80WTAyOGhGNWNhOTRZc2E4bjJielhIdkhqWlBoOU9ydkhiYnhMWk1hWThoN0puVU1kUUc3NW9GNnhLNFZZTHJLNmZRdTVVZGlxcndLM3ArbksyUXZZMythakt2OEFiS3hVUzByQnJWNGl4VkwvQVAxUS93Qm1IZGZ1K0I4d0d1KzlzaDgwUUlTVXI1SmoyVUlKZE1wS2xwb0pVNU1BcGsyM1ZQbGZCeXZFWCt2aklXOFU1TlBNN3BGV2Q4dmQrU28vb0p4ejloZ25oZ1BhSGN3WlR2ekhiR3JYNnF5WjNjTEZCbnpLdUFvcWI3SHMzY3Y5M1N0Q3puR2U4ZGw3S0JoN2M2aHZWSGQrMVFNMlNoSGd5OE5Cb1o3b3prd016VzZxNzRaVlF2MXNkckhqNmY1dHRmckNxaEMxTWN5emtQVncydjhBelVRWDZaZy9CMlBITXU5T2w1T2FlMXdTOXl0M2xkdDlqUjRKVkdjM254MmZFcklHV0lEOEYwai9BTkMzY2N4Tjd6aE9LWmNtYkpSMzZXbTJoL3N4M1RPamVmTHRYbVk0RGxRVFhwMEVINkJUZWJ2a1JQM0NudE1kNWVrd2kzQTJQektSSmxqazlmcHdoS3EwZFlEWm52TFF1MTNrMWZMeHNtYy9CV1YzenhYbmZFdVlKTWdseVBZYzZqdWhIWDVRdDZ4SWdoNDIyYnJudkxPbE4rR0tGYjBQMDZSSHE4bmJsZ3NNMlpRN0w0OVlyNFBLSHV3UG1WR3g2NXhOK2xqbmFmTkRIQUJQbGVjRC9FRTJpQUoyVXZ1ZDFlOUorUXFSckt6MkpWQ25VZHJINFhtREwxK3BscGNYa21JaVZQdnh0N0JFcFh1NnpRL3pjcnZPeUVuVnZQWFE3dHN1QmlHR0NubWJmWXh6M1N2TlhmTGw5NDF2RkNTU2F2b25GMlllMy9VLzhQOEE3THFCN09Xdm8wejRFOHVYUHRQV1F2SFdSOG5pYzFrZWpTM25MeEhEMmI3alhkYU0wbG1qa1p5ZW5pS0pLdkxyMHJmSlBnRnI3OHVEdjlPdzRENm1QdVNjMlNSaGVJamRZOEZPT3hlSmtWa1pQSjVndkx1WlN2dDRjRTdIOWxEQlRJV25mVnhMYXkrSU9OMkE3cmNzS3QrTjlqa2ZpQUJLbWxpaWVtdkc2ZUlhVHNkQ3FuYVVFMThkNEYweTVvVk1FQmhaTnkzaHJyM21sK2xGenpjejlWR2VjUUNEU0s1YVRYUXdQU1p2L3dEbGJMUm1HcVRGUVZudUsrczd4QW9JYlBBazFCaUhQbDBmTXcwUHFQRHVYeGo5dmtqN1g2S3NxZjV2bUJSeCtXL01tRW94SkJmWkRodmhNRTZ1bkFqQ2gydFVhbGcrZ1BwTG1pZmJNNGh6cVRTajVtWjRNRE84Nzl2YUwrZU44Ti90NTJrNXlZZnRDdkdPdTBaZXUyVzNIL2JZVFhuVEYrNVVIOHc3eE5QWlB6TGVOWHVWdURzWGhSd3Vxelp4TFdyU2xITUxrNWQ1cWVwNHJDUEJMc2lVZlNEWmxhZU9DRGI5RHhXM2R4aUI5R3JCazBaODV0aHl3ak9KTzBzSXJ4bmdGYUs3azQ3dHpsNmNpcUczMmdDTm9DVmZRWlAxL0drRjlDWUxKM0NsYzlDaE1pSmR3MU44akhmNE0vQ0M3T1Nlc0F1Tzc1em9jWmo3cmZBSDBvYzNYc3IvQUpNQ3RNa1dCOFBXSzZNQTUwMjlTZmZhdXdhbFIydmZ3WEcrSWoydjdGcHRpYUhoTDlvTDI1Y29BZWpNZjd0aVRYcHdpNGhycStZeDFMMzhqRDQ3U3c3ZjNMNlN3OEgyV1g1THoyaHFjc2pINzhNem5DZkF2MmRYekQ1VGZIZlluOHp0K3NGVGM2Uk82akQxMkt1dndFQ0dtQThRUFFpL0FKc0Zhd3JmQy9xQmZjNkFQL1NPQnA4YzdqeWVJVzR3RFFNYnRvOTVhYXBKVHZzcjdvMFJIWTNIbkZ0RDZ6WkxvbnVnZlJ0bTVydmZaMjE1TUEzYVpkZUF3ZCtYZWxjWmhkKzNqUlErR2pOMTM0cmFuWXI1WExPVWp2dXEzN2tEYzNIUjFyNzBjdzNnNjZCS2kvTlhjVmJUR3FBL3VEMEl0S09JNFp2YW5FRXJENjdUeXcwYit4NlRUeUxWL21xcDNORmR5MDhYWmFmRUgySVJ0NFUvbnJLSXZack9DT05uck5mNC93REppdnBxa2hiMHhaYjMrNjlTUG8zcm53Tzdmd2ppVjdqOHBIbGx6ZnExMUxPbytocTlMNkZWT2E2b0dOem9WZUhBZlZEMmpwa2IzUVMvUzhUZXFzSWgyWmFoZ3Z3cXZBK0pqeThsYk8xcVpVV1phOXB5cXJWbS93RG5tZDJ4SGcvdEdndFBlNy92RXZ6aWx2OEFZUXhOTFBqb01uOVdmVlNVMi9xZ25ZTlA2RUsrN3BRTWxicDVQMm56aVkxNG1FMDJnN29QaUxnd2g3d1Ira21JT0hmZlorb2cvWXRZdnUzVXZNK1RGTnVHVjVwcG1iS2UwM0x2YUpnTDZyR0JsL0dNUjZIYnkzS3BwSVlVeURCemE4Um1Hd3FuQUpIZHJOa01kOFI4SkdrSy9WTzMvd0J2N0dXSVZhYXdlVjM3NVd0L1B3T2M1bW4vQUg5UGpSUENiaTVacjZkNWlWOENibTV0OEwvNU1sTXU0aHNhbHo1aDBTaDBseFV5dU1RN3QyOXBXbkVRMk5tTTdZbnRIU250Zi9tN0htYWJoTnFhaUZlMDVlc2dvTlQvQUdKK1pSbk9XSU1Zc2hmcS93RGhuUXo1UDU0eVpzS3BoTytvTGF2T3MzNWlIWEFDTHhRdnFSWnBXTlRvK21lMEUySXFKTDJmb05yZzU5eVVobFJ4L3dDd1czdWxNS0d1a3VadjZJZkZVUHQ5Rk1yVjF2MllENTllVnJSanQ0aTBpaFlETERYbm1iWE9tL1k5cFhsbWd2VGtuQjYxYkxtNHErcmZwQjBZc1BQRExreG1wRnRzMWVMSDhDUVhMN0lOb2JNaGhpOERFQk5LVnNleWVHVlhhSys1QUcyUWREYkxVaTZORERYcnM3eFVEeTVDeTN6V0s0blk0SktvZXJsZjFEd2pIR0hJTDBEbUdQb2duaGdTdSt4NEx4eDJtQ2dHc2MxaSttRkI5Y2dCSlc3OVF4Mkt2dkwyTkZESzVWemhXNHY1Uk5iYkNyYmRVRTNUQWlKNHRVcm43U2l1azlwWTBBdFhTekJOcTdVZGhwVHpCdEJMZ3htYk5MN3k5K1pxQnhiUmYwQXpqSXZ4bUR2WC9uTW50QjN2Rjk4NHFETGlBVysrdkwyR0l5c0duQmgveFJjc0RUWng3TkxNOW9EZEQwZ3VhN2l6VDRETVB0RUI1L0xKRC8zV0JYdGIrMFdQU2FWTW13cXhkZjI0L3dEVEwzckhTL1dmek8zNnZ4eFNJdmpVeWYxZTJNRjZqa3p1SVNOcnJ3K1l2dGFldHVYOEFLNDczQk9kalRUSW9aVFZUdE1mUk43QlpxaVpqbXIyS2ZRb2RUdnN2WG9admI2RlpMZmNMaDJSYk5mUjR4OFRUdWE3bml5NktudFBEMWkyWFFYdUVPSjB2STJZeUdNMllQUEkxQ3dBUkUwTGpEQmZ4NXVvNjZpa0Yxclp2Mk1TbkhEd2s3V0w0VjJseElyWmR5SnFiUmVxaDZvNXJoNWRlRnhKd2Q0bFZ3NVNBdDlURUZZNXEzekM4N2NORzJONlNrNVRuQW1PRWc0NmJXbTAyeTRHVkdDQmNOSDlWQ3R6TGI3a25IM2xqMTJ2bnVDMThJa3NFc2dhYWE3bURoTEV3amdCdlR1cmNRM2xNeFhxTWU1aDVYbnBGMWF6bnpGL0s5eDNyeklrZFdJVHlnWDhIMEFWN0kvajlSbUJHMGZjL3dEVVVpdmppbGp1OTcwckt5aWxvT25tOE45OUhzUlUyMXdmc0hOWkU1U1k3bWFaeVI0ZG96OXp0bHlEdnZCdHpxOGJXOXBpV3RJVTVyVjl5RWY4bGNVcDlNdzFGVlFmS0I3cmdjbzY4SlB0RUxRWjVxeWRoSFY1QS9aWllRbSs4RUM4VFgvaXo2cVozTWU5alZaNFRiYnVrSHMyVytKYmNlaXdEVHF4eXRUQjdYWVF0cTdqVHhOK0NDRk1oWVhSeG5aM2E2bDh4aTgzRHhvTXQ3Z3F6dE1CU3hzZlRCKy8wWnJzSmtQUDdRSmhVelczd1NBWVpWZzJYK1psb3hkdCt4bFI5ZkJSOU42eW5yTkxMZG12UEV3UXFGS2RweFY0bUI0bEg1RlZZckgzTWFFajlGV1lpekxZellIUWNSeWpLR3JYQ0dzL1NyMzdqR1p0dHMzSUd0WGZCbGV3eHQ5NnphSkdzQStCUlVvNk9xeWtYdHFiVWRsdjRqS084MlRNRWkzWm5rZ25oMTBMT0pmVUhDNFphNlZpb1lEOVBicXJrUHZzeDI2SnMvaFZGN0NnNzlUN0FIdFRvSnZtd3JWL2V2bER0TjRsK2JMT0NlRlJLODlyNFdmdk9TdUtBOC93MzZ6U2poK2xjZHVHWDh4U0YxbVVaalI0bHJnNlVXWXNYSXpZTXBVYlFLYWJrSGVqVy9vZDVsRU5zOG92c3AzMzdVVjJJa3cvVzZLSEFjT0lFWElyNVlYaTRZQ2NRSVJiR3EyNFpHR1hXMFp1aFhwNXZLSmVSRHBxYTEzbGJibGRzUzlVbHJ2RWNYMjhKcGNVeHV3dVlLZG9QbnRCUzFPb0NLQjJKZFllcUtlOS9oS2EyR2xsS2J0WmdCMkVER2JidWZXWU9yVlczaUd2dVo5c21WQStMWS9xdVVsVWJZdHMrRnpQYzdtbi9ZbTg3ejNGWHhiM2dhTHZoWGpPTkV6SjdJdDRlY2dUTlBtKzBQb3c4Rml0ZHEzQUdyRDUxakIwRUFHQkdvOWk0Um5ic2lxd2FmeVhOeTlBczloem5TelBjSkl2VEM3anRFL1RwNmpCNEs3UXpvSVhsUHFoVlpNdHBQZDh3R0FEL0Q3ZXJBTzErenB4UDRuZDAxY0VQRGw5b08rblpSZDBybjdTNjd2dnRGS2xVU3FzVUVkaFVQTWJqZHVWeVpHTk5RdWVVS21GYkRNTDR2ak5Za1ZoK2sxM2ZNdXk4ZVdjU3BORlZBNjJxdElGYlE1L1lIdmk0Ymk2c3hmWWZLVnJzTUh5SzIxdjRtUmhnd3Q1SENYdlRlaHFtdXYrUGNFMExJS3NpVTBHdnU5aCtaWVJUUDJ2dmNVTjZtQndNK2ovQUlQdlB5azEvd0NVT0N4ZHpuWHM3bVQ3TUR0ckNzZG41dVdVN1JHK0lZNUxqbDh4STVzTTdtLzJqc2FBOTZ4c0x4Zy9peXZ4T0s1cEhNcFVxVUhBVEtUbjZkZFFMUUxYUWN3SXoyK3JZNWR4TlRiajdtbjhDVlpydnFuQkYrem1NdVZkcDVMYllHcjk0ako3RjBob1M3SXU3MWZmR3QxNURETnpVRGwwK0xjeldOZnNFTUY4bkxBV2VvU3J2eUZzWDd5aTQxT3hlcmE1UGFMOWJpVEJ6ZkdFNGpkTUl0Z3BwTmxNL3Q1elR3b2xaenZVWnJwU0UxdTJISnhMYkVsd21VZDhneVpyY3hJSHMvTzRPK3BXZXRiUVpScll0RkxGclZERnZMbnMwUkMrUXIyNytIekRqVVZCMnlaOU5aZERMWTdhdExVODZJMUxMbTFtcnVOaHROcG5yZEhTUm5sNVpvQ0dWTHRSNVM1WjI3L1drN1V2eEhKY2RhZ05rWFVETDRBSjNQcmlrSStjbnZMcFpkTUs3WTd6YVdyWWJGcXQzL0VhWlo0Wm1iL1JWbjFyVzIvWnFzbUpVOEd2UzVkMFh5bDloc0ZLbmhuaENrUUhWVUZVNHhWQ29ubkE2MnJVVFR6QkFwNzE2eXNHWEVROHFwWUF1KzE5cHdRNGpNaDNqeEYraU84ZFdwOXNOSW8zbUZhYzFpMll4eDhNNkxSbnJiYThzdkpVZ2RXc2MzM25pTERYb01HVnVGbDhsc2R5WngybDg2VXV2ZWpUNk5TeDlYS1M5cThPL2lWeTI1eS9YS2JzZlA4QWt6L2cyeXd4MnE2eW5oZyt0VEZLbkFPL2hHNkI1MlB4U1ZXYm11N2Y3RXU2M3hCaE12NU1uMENlTUFzU2tFbTA4VzdHaHFocjVqaWFvVTVuSHU1Z2c5Qnh0eDNMSXJuNG1aNzNrZmVWbzVtQ1hGcTNQS3YzZ3JhSFA3QTk4WERjWFZtTDdENVFzeWkyUm81TGNNNDFPenZEeXU0WUdZN1R0K2RmZEk5dXVsMnByMlR1bEtlME4wd0MxR01DZzIxTWpqejFqaWVqem5wOElSYm5UUURJM2ticVBqVW1XRnpudGZieE4zS1RPZjNOanM4WnFZMmtSWmk3L0Uwak9EaytIdWxFdkZ1ZTNzZjlUdEhDYkZnOEhhRm1UazE0V3R5cXlzcXdXOGM0WlZHMERvc0t6YkQwOHp1YlMvS2UwSnVQalVLdlFJN3E2bGhkZGJxV0xSRDdqcFF3VEx6aHZpV3NhbDFlem84Zld0WUtydjhBNFR1clF5ZWY0YTlZQVVNSFQ3THJkK0lFOEw2MzhldjFZbGRWaE5mdTgrdjBQWG1acjRqeUVMSmJnTk1kTXRmZnBSdTZBcHpjeHFZTzB6NEZaZ3pySGllb25Va3YrRU1PNlRUbE9QUnNuZVcyZlBCRlhXblRJS2NiWnE5UTVvelhBb1h0ZUU3aDNESk1hNWZDWU54cER0VE5kbnBIdElPM005Z1h4bUhHTnB3bVNueE9SWm84YlZkMzRTc1FlcmJ5NjhvUElhZzMySnBjVTNXREVJbG5KbEtXeU4razVpNzIyd1BCdVpiMXNXQURCdnpkVERkMCtPQm1lOERhQWVsd3B4VVlFQmR1TzBMRldVV0ZpZG5aTFZIWW5iTXQ4eHIwTmhrM0FVT0VHa1pqQytmOUVnZzd5RzVTWDRMN2U4N2pVaDU3N25FdFdyMVBtSTJ0NDFGT1hxNE1aS0JoN3NUYXU0NEdsRlAyeEJhdnYydHZxSDNNeWRCVVBzWnpqYmNYckJWWW1IdStaUUZvMXZpZm1ZQTdkUFJaL043dWdieG40cis4KzMyVlpKVjBlS21iaUJkNmNEWnJrbkVEa3FpZ1pVS1l4dUMwWTAwdUYvTWRCME5UN2czYXIzaXJmVWMySDNGTk9IaHJDREk1ZVZyL0FIaS8yU2VjdjJ1RldRaHRqbG8vd2k0aS9VR240aUFTQ2JoVDNZWjlLb0JhV2FaK1BNb2FHYXFrNGxsYWgzTnNQY1dNZ1VCUFRmM21FZHFoOFB1dm5qN0gzbEc0cmZkOTdmRVYyQUZXVnJSbWpsMFFGZ2ZmcnJkZXBjUFhOZTEvNUwzZ0NPOTZ0UDNoY3ZpWWVab1RMRnd2UkErWE85djc3eFdoTlhKeE91MEtjU1lHZmpLR0ZqRFo3aXkvOGlPb2VWOXhsQkx4UGZBL2JCbXRISkhpZjNPM3BaUGN4S25YdFV2R2FkaGtkT1RyWUNYZzMyQko4TVpNUTFkbXBaam44UTJ0b3RIWG55N0VMcnFWRGZMMlBtdlRUZmZhRVZWem1ibWp3RnE4RlN6SFA0bFc5UmI0UHV3ZWtiaUhwN3J2VHQvWThSVyszNXN5REhmYWg5VzRiTlduOTE2eW5UY1dsTXE4Y2dhaHJERU1VVEtmY3llMDNqZkwyYzV2dDRSRE5tNlRSVTNWWEdoM2c1clZ6eGs5b1oyK0NiazRQMG9wZ2pKcVpPYk5QVTgzQTdGSElkL2ZFVm9KUFlhZmVXYXdYaG1ucXVudEFFV25pNlUrU0czc1NacC80cU9MRHYydVA3enp3cGZFRVN6VWEwWmdYMFZvQ0ZIU3U5K01TNGlYNG1tdTc5OEdQUldhaHB2eit4RzlRVlFxUTFmNVRQRFgwZ0N2Mk5QMWVKeXRqMHBIS0RSTzdrMjZzQlBJTVEyTnRqR2tZTDg2Q09LOE1TZlpsTWVtODVzcWJieEtQeVdUQzE1MzNPcEppTDRWZmc1dXpNY1BtQktuSlRuMmpKS1lHVXk2OXVDMXFyd0lac1lXZzVHT3V2Z3p3Zm5QRnEzK2NJbStSMDdMcVlMWktXKzZxK2NSTjVRYXRkYytZR0tYV0RtTzN0Y0FOOW8zNTB3V2VQeUo3SkU2WGkrb3I3MUcrSXYyUDMwS1ZkcC9VN1BvL3Jka3IxTXhPV0h6OHNkS2tVclVaOTFDUFd2T3VPZXlzSHZOSENtWmJJOWRYNWxudTFPNWVkUFNvcUlHZWdIemZ0Y0tzaERiSExSL2hGTGphcXBwNHI3aVhWdjBPd2ZWbFpvdEYwMmM1L2ZYZXdzZVRQOEFzdlAxbURBT05kczlKZnROV1FpZUdJRE4xeGNNMHkxYXNoMnRpRVZ6NWpHWEZ6Rkp2S00ybzc2TDl5WTEyQXhmd3M0V0w1RnJ4dTJjVEtiWVdqaXoxYkhXVjJRSDJlSWZDeWpGMXREdGVXYlhOTXJlY2c0VHpFVDlMbzdQRnVmYVp5VnlBcTNmV29WY1JUbno4a1VWNGdLRk4vQ0RTd3pPeXJjNTJSaHFqcVZ3WmdsMHQ2QVVJRkZHbzVFalVVeXMzek84WGFkRzhvK3pDSkNIYmZXOWUvMGZaZEw5OXY4QVZFOGVLVUNqcGQ2ajltV3RyMmwwWGUvNkYvZUZ3TVdZZnhlT09nVTdCNDNYdFJtbEhmMEF5aHdJWDEzNjhNMnIwSUdicm1lVWQyQ2h0M2lLbHVTNXZqQ08xLzhBaWZBOTM1bjZKZVpsWmNjV3N0TzN0S3NRYk55NlF4enQ2dmRuZHlpNmZBTGtacXp2TlJYNCtKb0VLS092RVowYnJ3TDJyYVRBYlo5MjRKN09GM2VDSE5RS2FzMkg5aUIvUnZQT3VJMytaUHgvYWl5ZUxTQXhmaFhhWWZHNHBIN0Q4eERZQVdsQW85MTRIZnJNN0RzcTU5WlNleUdzUFFsSkJoUC9BTVFRTGQyd050LzJxOTRuYWg2Q0tSbjZUc2tKdkpneDdRT0xOYVF6Tlc4eTIwS2VyQ2k2Qk93Tnl0M05ueDFaSzQwT28xRmgvTDNFZ1lnZUswTS9zR1hLb0cweWw3NWJjb1A5UDMyaGRqS3YwYjhvNW1uNWR3eXhwN3dXVmZ1dlBoOHl3cUREZHQ2ditRSEFSVzFXNWh1am56MEdWNlZkVWdqaXEvaE1xKzBVSVM1NjN2WjNpdXhaa3ZGQUs4VkNNVjBxakNtRzdtNXNYUStLQ25iNGFKbFBYOW0rQWQrWWRwNEhNbWppdnRJckZGZGwzWVpkdWVDSlNYYml3QlREZHplWm1yTmNPOExoejI0SnExUTZDcnpXNE9lWGxFTHo3bGJnSzJGSWl3WFJBMyswUjlhMElyWXJnNDRpcWxiWGE4eEhMdVlxdGpYZVZEWHJkMk1Ic2VqTFc5TjdnSG1tM0pPOTkyV2o4TCtKb2IyQXZlelhkalhlRjBTV3dtWGREUDJRMWJaaXFBV3ZKWDNWRHVibERUVDNsUExMdkJ2RjAwKzBMQmMzWld1N3RvaEhGWHJqajNhZzk4RUNEbnRxVnNjbk5lYXUxY2U4QnRPdlBHVmV2ZUpDVkZWR3RiNmZIRTFtY3Z1NVlZMmg2a3lYL3dERFN2c0ljWC94ZmFLMk5SbVpkTkRnWE1wODBOOEM3SmVyS3dhRGllNkw4S0Q3VkZVUGtIdjN1cjhwaTE5Ly9VOWFXTS9kQ2IrcjdDcExtTDY2bGJHdG1DVU1FVENocHMrN2NGNXV4d0xxKzdsbHZ3Q3R1dEwzM0x2MEVHVGFjRGxnUTlTZ2VmaU56YkgzV0FnYjZqWDltSC80ZDFJUHFjekRBZUF3c3IxRWpGSXA3REhmRlNnc3FvWGN2OFM5Vnc4ZEt3OFFKa3RNZ3piQmFiNjdRUDd6QzJCdUh2RmpjNjdLMFEzTTdNc1ZWY0F3ZDRZMjVscTc3VkhhQ0poc2FoYlBrVzVmZmVrVnF6OG1vbHM0KzRCU3ZzbFBNblFMWHV4TURmT2M3S1BGeW5MVEJOMXhDSnI1eWh5eXFqcnVXNE9PSFVydTh1b0o0NkdlbXdhT092UDBNcXdBN2dBdFhvYVlEbFBoNEI2L1pkS1MvSDhUMDZ0alkrSUFkRnFvOGxNdjBkUXhvYjdNK2c0MGRRMzh6QU96cFdaOUM0T1NDSHZFWXdLakZabkV6MVVyV1hZZDBVYWV3ZEFpVTR5dzhYV2xDUlJsd2JFOGF1SVFneWQ2Q0wrSVhjek1Ddk1GOUZyN0VaNFR5dm9qYU5HdmRrMFYrVHFDU3hTWmJadzdHQis5WXU3MTU4c3U5ekZGbEFQVEhzOHczeE54OEFPQVJKV0tMYTVUdEEzMlpzSXhhK25FSng1bTIrSnErMWsxWkZleGNQVjRLNThTdkthMTYzMEdiZUtNM0NoMzdzckVCUmE3UXJGbTBkbnZDNkFFRnZPOHZlWWc0UlJQK2VBQ2pwSHFPZDVEVit2NnlZbVlpLzBJaUkwYXorbUtpcWxlTU5lL3ZJMkJDSzBxN2VzWWVLS1BSeXZXbkR2bWh0eTNneVp5RFRFUm4wdW1VTHhWeXdnZnpzZXJHc1gyc0hxN0U4WUg0blY0bmFYRG1tQkdLWXhPMXg4WnRTMkRSOGtKeXo2WG4xOHdlVWFlanNXUHlpYm43RmViVi9Fd1JXQ3JDWUdEUEVwN1NudEtyOU9KeThPT3JPMHRKYm9BTGZVZ1JRQ0JGclNXa3ZKZVM4bHBMeWJCWDhrMDNlRU94RzNsUmFET25IR3ZpNVlac1VQYTF6N2cweC9TL3BqL0FDVGlYOHUyUFI2bExlWXhiYmVRaHUxZVd4SFd3YlovWEtMK1hWaFZRWnJtYUpRUmMxZncrZFRMb0ptVW1ENWx3T2tJTm5KNi9nbTF6VE1yKzV5Vi93QURBVzZyamlETVRQWStSUzk5OVVSTFY0RVNzQkFzOVY4RFRjeTZSTkNjb2FydzZDUEZlU01ScmJXbk1kbnNnbWVkUjhoanNyTVFST1dkbGhoYjBvY0hiNWxwQldEaFoyUTE0bDZ3RGU3bFp4ZFpiNUNVVHB2TW5pYmkyRzlmMjNDVmZhSzlta0VlaGtIdGNya09qT0QwcW95a095ZGZ0T1NyS0g4RVNZczg1ZVZ6SDRFUHRBT1BMbUdLWXEzL0FLTEJYZTF6MTdhQ2N4OUU4NVMwazUraWt0eHdsdzlVRk9LZHdMZElLeldpdDFraVhpUDBiRE83T1Z6K3dEbVV5QUNIaitIaGk1NzZtSExkbGJTenE0MVhvbFpwZWRmYzduTXJJekYvSUZqM1dIdGg5UHJPeHQxQmIxZXpCbFplazlGUlhlRFh4SENUQU5FQ0VrRzEvQUcwbGN1Rk44ZU14VWVzZFRnbXBiWXZvMWpYU1JjYzhhNm5JN21nZEFOR3hkT0pmR3V0UFV4TGYvd1pjK3k2WDdwK1hYNzMrT244dnY4QXJGUEtKdnVTaFBmNjF2bHY2TmF4QWVaNGlYN0o2YzhrdTM5RGh2bWQxTlBhWC9sR1hONjdwZHIxRlJYYVpucGlWY2xTZnc0SkExcEoybzU1RTJaemZlRVBmcDBLMWRoTmVrRXZXWUM1NGFZaldScTZ5enMxSE81LzMyVTVSRlQ1cU9Rdjdoajg4L3IxbnpLZVBBL1BoRW5INzNIWm9QemNwR0tnbjhJVGNXYVhXbFpYMmhNTmJVcFF2WUMrWTBvRGM5U243dnRHUy9KZTIrL2JjVllrZ1E3dkdvNXhWRkVBSnJMTmdxTTNvZlhYVFgxVko5QkxXMkRGYm1kbGhIYzVtbTN2eVExOXhmQnduR0JUQjhiblI4bjQ0WW5HM3hGVVJ5ZHpWN3VQVkxCaVB2NmRrRE0xNEhHbjdub25zQ1VhWDVsanRaSHBDSyttV3ZEVEhmc2kwUHRxV0h0NEEvTWYwVjJMVTFtR3VhZ3l6RUx5NzRSR0hvRHJtQjdWT0l0V2w3ZzJkYk84NTU2THlKNWs4eUZEVDlBQXd6d3prUW1wZzVpM3o3R2x2aU5ZWm82K0dzTzltWTBJMTlOTXVhZmhGQS9HQzMyRGR4V3F5MHJoQlFvYW0zb2p4TzRIaE8yZi9SR21McVk1WGd6dU9QUnVQd3lpTHozbEVyb0w3Q0tvY083M0ZMek9KZGtUV1dvRHVtYUsyaG4yeEhLS3dDN2xEaE1Sc0JWZHAzbEtITE1aVDM3UjF1Q2NqM2lzc3VreTFVeE5CZ0NPUjluVCtweVV1OXdsNnNvdmVmN0VwTjhoa21HVW5nYy9tVVVjMSs2UFppdVNVM0ZMYWVMbnBGQ24rWnd4WVg0YmlyR3E4bitvOXF1MUg0aUs3eVg2aTlPbFUvNmlnNnpTZmpjZDlpdi9BR3FaTXcrOHJNNDZESEhaMnZ0THhiNHpYbEV6cVlpc2JSVjZrQ0ZVSjY3MmpsWU56OW85RS9OUFZGOC9UemR1ams4SWtVVzVBY2tONkpUM2tabSsrd3Vid0ZjeDl5UFpFTU1IZVhzSlNTWGNzRzh2V1lKVTFwTUh1YmxPWUdTTjhYekN6TW5KT2ZSKzRYTk5Lcnl3N0dpTGE5TzRuZTdldEhkSU1wT25TdlNaNWhhQnpCcGg4a3FJRTFNNVpyOXBzdVU3UzJGTktwWTlwZHE4VDRicUVnR2lKaXBRSWJKN0tZTXpOWjQ2ZnNJY1h0RUxFWE8vVzNQc3VsKzZmbDErOS9qcC9MNy9BS3hWNURWNXI2S2xZbk5yS3JmL0FNQk9HQ21jUVc4d0dvdWt1cGRPYVYrOHN4SU9mc3VHVTFNcDdPSWtXNjFGZjJHY1dUMXpIR1NPbUIybDdzSzgrVTBpaXUrcDMxWHZMZ3ZrNUNjdmVvMDVMMVZQQStPZk1NNnhyemVyZStXVlkvcWk3b1BlVlNhcjNtZzVlWE1zT2pOZDZzTFBwY3BWdlpWYjFXTVRlNmc0ZUhKeXJSaWIvS1hrT0hhWG1kZlNaNklXWE0rVEEvNnZwaEhNcE9XVTluLzRDeWYvQUJrQ0R0Uk40Y1VySnUwNWJuMVB4ZmJYbXpYZDRmbUZNWmlFNndQZzUzNnlsODZ1QjZmcVhwSFY2ZStnOTdsdWVuTHh4NjJOQWFsQWRoNkRSZ013YjAvd3ZhRTJOUTRPSjhsVGZ3bDBOZDJ2K3k3c00vNm1hSUJwd2hlT2Q0VlhGTEgyaDZDS0s2ZG83K0dEVHRGdFhvYUhwT0hUZEhDalpyNW5sUVc4a0RSOXVvMVV2ZWVsam9nMCtEbEwxWFZVb2QvRXViQnNzbHduc2xlbFBSZ0JkbHpqNGhrYU1EOUJYUzhUSjFBaDNCc3Y5anM4UkdqTHYzSlMrWTBPanBIN045b2FSMGd3U3FZREZvUUJJUU1RdGlsckxoZU9saThUUVlpcUtKdk1SeERLMWlhZ1lLTUU2Z21ZN1M4dkpNbDlwbGtsSlptdENWaXR4OHB0V1lmMVFSMUJic2Y4WXRxVlgzdUZtSVpaU1ZINzQwYnh0Zko3dzhVVVM5VDhVL01hK3E1aFkzdWQyUldDa0dseU01ZDRBVkZFZXVMTzB1dmdqSkczSE5WM2pONXFWYy9BMlRhSDR3SWRTVkdwL3ZhRlhJeVZMOVpmc21hMU5Td0ZpMVlPYkNKNXlWSEtUL0ZSMG9JRGREWWJPMHdGMGVaY3QrS25FL0U3SkFJRnNxbElWTEpCUEZwallCWTByVXhVbjExS1lpZ25QREdsSTRRYXYybTFJNThWaHpDdGVjWVk0dWJGMVR5ZXNxSXZsM0NGM2oxbmJKQ2JiN2NUSFFHdGRuRmNTc0piNXBsTE52dExZTUNYaS8wN1B5eG1GN0lUajFYaUg5SFFJMVd5QzhEMHBmb2ZteU9mVW1rMjhUQlhVenE0aTBMeE1qT0dVSkd4bWZMYzBqbU9KVitrY3VCMmxUL1dYUHN1bCs2ZmwxKzkvanAvTDcvckZaS2R4UEF6MUo0bVVPMDQ2VVRKY1orSFV4M29CeEFORTQ2dVF4M25VTTBHNW5VY0E3TVIwUUtMMWlidVFiaU5BVWwvdUVqa2N3bUVzcjNNN3VpZ0hKQkE4YnlQZUo0dHkrYnRzOHRSUEdVczFyMFlUN1RSbDMrMkw1QnhxV3VzaEJONjcxbjJtTXkzWDk0T2VKblZHTjdJNzh4eGFJNGs5TG9JVklsSkRmNGVzVUtObVRzN1ZCQjY3ZmwvNU1EQVFzT1luNWlQUlBITFRtWDJvdGxWTGJrK21pS3ZucG10QXQrblVucUhTeDh6a1JqWG5jb1NPT3dkbWR5V1Q1My9BRlRqdEtRRDd3a1FtdDNFSkhCSFI3eWhFbVR5OWUvdkQ3dmpyV0pSMEQwTzZ5N2Q0eDhYYVpSQjNiMlp6OHhPOS9STWtNbVBRZjdNWGFQa20zZi9BQkQ2TTdjTHdsTDNFQzZ6THZjRzJOWkZrWExvU3lwN2tyYlpwVU5McnFBUC9STGxPb3FZc0k4ellPb3BTaThZMmp4RjdqRjM2RlYxeXI0MGp2SnBaWENqZHcrUEgremNMbWRQbk80dUJKM2xXeUt5Zzh3VXhXcDMzaVJMUG5mUzB4VU85ZmlGOHZLYjh3Tk5waXRJV0xUVXVXTU8xTzVVenYxN3hkVVNsZ3BObzlMSXEvZVlyS1dNQ0VFd2hWc0VVSHZIbVRoWjRlUmlxbHlqcDlJV2hodnlKWDJUelhNYnByNVduKzhSQ2FEYTRMNHlYNHVJUnczWUh5NWZaaDNyd2FpdVRSM0VaeWJRUTFxUjQ4UlJXMGFOanM3TWQ1VFRWdmJRem1iTFFFL0lvek93Z1lSNWR2bWVnbm9tWHVuWWpLWFUxYXVXRDdwVjNVLzRFOFI2WUxSMFJtWGYwV2tkOHp5RTh2UWVmN2RGNTVabjlTZ1ZKcWlSdEJ2UEg0Wm5IZkxpSDhWT1JyR0J6N3pSUzQ0WEt0cUgzRU9ORDdTM05IY0VDRHZwc0hzbmp0TW53L3ZUc1h0cC9QWEFnVDBUYVdCNUVvMFM2TTRqTHAybUNoOGRQYUtjcTlweDBGdTg0aHJzbG1ONTZXWVZqb3NTdFJXeUppcUl0N0kvZCt2dWZaZEw5MC9Mcjk3L0FCMC9sOS8vQU1CWDZDMm9yejFGYkFiTnozNmJDVjdUbHMvUXBTNWdpWW1pK0pmdmlWbE9aZGJ0RU54ZDBYaUNEVTFMd2Q5b08xYnRKbU9QVEdnVE85VGY0VHRjekRzSjVnTG43eWdoVG1YR0RzaTdQc1lITjY1VnV6VTRmRFE2dGZzaEhyaTRwMmRKV3hJcVVIWGNkNGJObnR5NUx2U0FhbTZDUy9NRklXMnF2UGVBZ1dMMVgvWHZLQUJhQ0o0US93QytBNVpaWnBub1MzRk1VT1Jta2c2ckNEV1lmb0NWVEw5RGVaTjFZZW5JOXZvQ3krVVVYd3dhTlBhVmNTK2QzemZBK3VHQmFDWmZ3ZXpHd1VjMzRvRWdLODBZcE4rUyt5WG05blZmak12dW1Qa3FqeFUvZjVKaSt1VXl4UnJvTkpVMDNLM3l3S3FOeDdBNDZXOVB5ZGJYZHhYMDMwcitac3ZvRithYWhwMXpUMWp2SytzbUF3STdHZTdLVC9tVVY4dEErUlBjQ1E3djB1NVJoVVYzbXE5aURWN2ErWjc4RUtiMHNmTFU5cHNzL0JCWGM0UjdFYktPMlZhSENLMXlUeHNSRU1UT091cWJkSzNFbUo5WnhPSTkwNkdPYWdCeExtNmdtaG5MT0lYakdnS1N6REhTNTVnTUkxQTNNc2l2M243ZXlGcU53R255Nit5VmJuc3FQNUZqWDd6QmRXUGVOdFBPZHZ1ZWt3WDJsd09zTEZpaDk0QjJYMS81eExkYWw2SHNQQlU3UFdNRU41aEJRNmFJTXBZMHBGVU9aVVM3aWZOa0k0M0duWmM4S0FjUHA1cjFtcUJwaGZlYzBGSGFZV3ZvOHlzTlVxWmU3TTVvRXZtTnFhcGNGOWwwaDJIY0JZemxIYXI4Ums5TWsxR0dWaDd6K3VZRHBuSmM4dERnWHZ3bGE4UXlxTU9HeXJuYWpYcXhIOGR1bDB2aGlHVjM3V1hrTzg0NlkxOXBnNnVEZG9KcElZcDBwWjVuMkgwVzFmTXIwWDdVQjZxNkpLa1lpYW02V29pWDYyNTlsMHYzVDh1djN2OEFIVCtYMy9XS3ZaQTh4S1F5aDdvVXM1bkUyVEhvUkFVRXJ3MzlINkxyZU80bVNhaDd4SEdPZ3EzZWI0S2NnbmZndVVGUm9MdWJVWXhNQmNEeEg4a0c3VlVHaHhDV0FLYzFCc0N2YUsxT0lsNlJUVFJobWJQRTNPOFZTNDdrNVRlSUlrRnFKZFV5ejFNQVc1WUpyTXZ1end6eHpKNG5yeUkvOG5rQ2Y0a0V5TS9IL3dBUFJwUmlMcGppazNPSHVlcnl1Sm56MFpveTdFZmVWcTNlNzVrSGRmOEFCWkFwNWF3KzlYSGNucTZCZkVVaXFVekJsOHpFUXl4cVZHV2N2VWc3ekFuVkMzTUNpTk5zZlVtc2YxY0pWTC9FQjVPcVpaaHAxVFdPM3BMbmxSMjZMbnhONy9HZ3dZa2VTV0tIY0JIZkxDV0gybEJEc3pGZHBlVnVIUHM2UDRFQUZIVEFXeGZBaHpJekJtQmVlRGZTc29hR1h6UUpuTHJ1N3dQVzZZY1dOelRPRGhwVGMrWTFPVnV2RTlBZWgxd3lJL2VYOFh3UHducEU3L3FiOSs5Rm5nSUJrZmNwYmJmWFo5WlUxZFBZQktpakpMdUFUUDhBdW1YV3l1OFBQUzRobGdleUZZVDFtaHZQU2dTdFE5NGRNQ3JvWXF5TVMxK1dkek1SVEZUWnd3UE1OeDR2dVFnWENPdTNEQVYzcnpTbEtjV2ZzMUNoVDBFc2lYSTFQclVWblp3Rjk1UWlPb0tIWk1VSEpOUEpEV2Q5Rm1TNXgwS0xETUc3RXgzbUtYclFqbGkyYjZoUmVaN3lzTHpxY3V1YS9XM1BzdWwrNmZsMSs5L2pwL0w3L3JGYnZ6emJINDUrTHJrVnk5TEUvQ1YzUGlXN3A1SHhBRGRNTS9RZHVJNkcrMDJzTkdGMHozbG5KQjJ1b3E4SW1JU2pvWkpuaDM2RkdDNXFIRW5NQ2lPMFZPalRSZXVmcjVhMjF4Rktjelh6aUpoWGJxWkhCRjlFM1hVQURHdWdsMUVzcG0wYWl5Ylc0QVhKZlpZV1dYL0gxQmFpUEREbU9BaFZYc1RpT3ZoUEd1MEVGa1RDZzFjYTliS25ub2E2QUtaZjBUZ3I2WEFCaU0ybkZjZEMzUktlM1R0YnIybVpMS1BSZmljSHlobnYzbFhKTDdMbHhONGpBaGpUdk9XRVJHbUsvc2gxSnJIN1U1TzByVmxLV3JVdGhlSnpINTV0OVlnTXdSNlhRckxGZ3p4aG92cXRpeFhuWFRnN3p2QUZFcXEzMVdFeVBhTGlhbGplT21vbFQ4czFaaU8wNVhNbzdUTHVRWjNJOTVyV1puNVExMDErNG1kNWhTL1JmVFM1dVd1eXhoT3N0VXR0eDNpK0xQRkhmUXZCUWhzU2k5VGlkK25EeE4wVjA3UFR2QjZuaUJ2TEtFcE1UTHRnVlExSG5DSHB2dkttd0ttd3BhVm9jekpiakM0d056MG92MjNVOGpMektMOWtzMkZkaEFpWE1LcnlnOXlaWU9jblM0T3FERzdZczdxRFRjVlZ5Z3RSaUhESFJEVEwvd0RTTHNocDlNcTZQL2dDNTlsMHYzVDh1djN2OGRQNWZmOEEvQVZPakpwOUp2TGcyZmVZSEQzNkNuYjd5KzVGTzc1bE83NWc5eUw3R0VzSzk1eDA0aldTYk5UbWJ0aEhjd2Y0RUZhdDlUY1NnMDJSNnZ5dVhXYjh6bE9kUU85RVFZQzUyN2xlNkhsSURFczRpNFlJMVpGbHVjRHBZckJzY3IwT0k0QzZRWUNlaFJMRWcxSFBRNG01ZCtPMERuSmtKaUtJcHo5T1ZkcHJPK0lsVWVjd2NscWFMcG1WYnQ3a1E5VG1JSWpHdXRjZEh1VDFDR3BRbm9hK216Y2ZTaXpUY3NPSWNLb01JdTd6ZDB1czVqbW9MeXoxRXErc004dVN3NlFrd1ozaTVSd0pJd0ZEY2Z6UTZqUkg3RXo4aEVVT3BzeldpdjM5QmJPMDd5eFVlbUVlUGRNcnB2eC84Y1EyZEVXVXVYTnI3emxtUmR2UlZUbWJUVTlKbXNUVGQ5cHlCbU4zQmg2Sk1xNVRCSG9FTTEzMmppSFJMRGR6enp6VCthZ042K0pYcCswcDZYa0lXN1BpV0V1WHpQRERYeTZyYTZSYnFZYm1mbjZPNnNreDdxYnU5d09SbUVxK2xNdzJ5dlJjdjBrcTB6REszYUs4VG15eHlla1BtUmFjRzFsSjhpVmhlU0RORGFGT1ozNm9VTWRiNnBmdk9aKzVMSGxpY1MyNzhkSHdoMHN0YW5wMHhSUFduUjI3VTFaeVMzdFQxaWVKVW4vd3pjK3k2WDdwK1hYNzMrT244dnYrc1ZjMmx0L201K0tmYXdsYnNxRXRPVHJEM0NiT2h0VVY2VGFmRmp0MVZkN2ZhQVlmYWNNQXZTR3pobDc5Q2lLb2dNaFpVRVoyc1Z1d3dEQXhMT3h5VHlmUVlveWhQUW5vczhNUEZBYnowUmxnZUlhbnNDYU9KUzAyUlVzNHZpWFdkelBqZ3IzaWd2Q2VsOW9GdGN6TlBGVDBpYmZUT0g3eW12RDlNempvbWhaV0x2YkFVdlZpbitVTVB6QnR1b3NyZ1RDY3RRYTNoT3RKVVM0bHMxb1cyMzlGSFVYNEVkejFEWFZ5aG1GdnRFcm1CeWx1RUJlendoWmhSZzVnMDNFK09mWnk2a29PSVBZWnZIQm1lYW5xR2NkVWwreDBiNk45ZndUalBScHl5bHhtWjJndXBNQVN0TFlDSXQwY2ZQUkcxMUVvWnFuZUo4endRTFdCbWh4S1o5eUNPYzlLOGJSYld0dlFEbVh0YlRnemg5ajlGODNlQXFpVURqVTcyaDl0Z2FUT1o0WjRaNFo0WjQ1NFo0WjRabjFPeVpuNjlBcFlLck5COUN4UE0reTZaQTFOZnRTcFI1NlJibnJkYWl5Y3pML2hpaTQ5Q0ZxYlM1bTJVSEtDNVBlS3BhakVsVzBrU2wyZXZ2SVFDc2NUN2hIMFZxelVCSFluTTZ1UFhydEhDbE8wRjlHeU4vS2FobUxTTWN3Yjl5Zll4Qll6ZmNmL0FCWmMreTZVVXZqOGlkZnZmNDZmenUvcVkybG4wRjYxT1Z5NXVvUnJFT1pvaDdjd1Y2QlBmcERYU1Z0NW1pY1BUVVo4MTBRbVNXOEUwSFI4RGN4T0VPbzZZanQwTkozOUE3ekJHTXpONkU4V05kME95Y0lZRWgza0ppT1VHVHFWcE1kcFZmdkhhbTZIb2FEVTExMGltc1JWY3NCV2c2VmRicHJwanRFTmt1bkV0SVZOMzBCV2lEREhLUEUwSGpjeVdVNDNETmFNdEVHZ1Z2N1EzNEdZWGNNWGg3UXlieDlLR0IxdnBUY2RjUTZkcCtqbE9KNmh6TGlHMWVKc3RHdWgzYjZUS25pZmppb3phVFBERlFWQjFMMmlHcHM2R2tmc2RHbWFad05kZlkraWxhSVBtNmFQU2RuVUNqbDJRYlBFM0VRaW5vRXZWbVlvZzNISFF4VmROVHQrcC9pNlc5empvbUNiYm1Cam5FSU0wZ0FXUHl5L0xQZVhMZTh4S3ZMZTh0N3pQZGgwT0NVRU45TnhDVXV1aDRuVU1NNElKaVViWjMrcFd1ZDNUTS9jc1dHTGdzODlMS3llOFJFRVY3NWk2anQrcG9zQkJpdkV6dzd5M3NjOUhDb3N5OFMxNlZMeGoxUWZHTnU0L0V2a09FNGw5SVhob1hpZWo0UnJnRGhtdDQ2ZTZqZDZ3d242OVhQc3VsRjlyMFNGWVpPai9SMFRCbEs5YXY1Nkpmdk84emtlZ1Y3OUZFcFo4QmJOOEY5WmI2c2FJN056UTNsTDhvRzFtWEMvS05EZWt4cGM0NmF2M212cm5xODMwUUdXcG5naVdkRWpvNlZ0d2tsb0wyaGRPbDFjb1ZvSTdqVTN3MnV6TVNxYlVnMFJrU0JxR1hFM0oxRmV1WTVpdGhscUd0eVNoTzVPVi9NOFVwN1NuekIrSVBsQU9NUzJwK2M0WWpHTXY1NkZPVHVqMlNwOXVuUENsSEpOc0Z3Wkp1Q3hGM3JVdHVOeTFxR216dUFXek4vVFJjdjZZSGtxQTRaZm96VWdwekJzeExlSFEzQW9PbHhQTEJycG5NZWliTzdNVWdIQnVXSXhOK3FmWUlmSVJ5K0pSS2ZXUEZwTXZRbm1CSFZmRU5SM25FTkk5SjVRVzhJSSt6SFFuRjZpY0VLL0wwdHBjU2xlT3BLWHhxS295MEtINkNhMnhsb3lodmY2akFLK0JNQkRjd0V1UGNsUVREMXBwbVpsTHFkSFk4UlEyeEhXWkNxSitYcHRsc29yT2VpUEVYSTEwTlBYb1JjWmkyTWVVWjh1aGs4eDBwMm5NeGwyallaaytZK1F4VnIraXZxcXdzQnA2TEdHNWhYWlM2dUFNUFZ0MnFMUFNOV1B2TzhKZVRMUytta0psOTU2WHpOT2Q5TmFsNVlWNHF4T0p0N3c4UHpGT1pRUC93QStYUHN1dHgvUXVlQjl5bm9WSXFQQjVHQTgxdXY4SjlwZ08rUU93ZE9MYm5KeS9IM2ZTVTNSK3Vad1JXd1QvaUlrVW1hcHROK1ZYMGR0SWxyMUhpQ0FrYnNvdnYwMHprM1BFeTVhTEdGeXpNd00xY1MyZDQ4cENYdG1JNXFhSWlNZ2tzQjhKWndKTU03RXlUSHJOUmllZHAzZUpnVEJBSmh4MTFFdkxMTm9mQUk3N0hUaVpyZTBOdDdURXc2WmdKbThCak55c1pqck1WTCtJTXA3MWl5dmNxNHlnampMS2NxRmdUMWwrRFhVZ1VIbkVETWN3M0NvRkVHNkk0V29BMG5FdjRnbUxuclV6dm9hMDBRYlNYNFN5N1JLUE5McitFdkt4MzRnRzZnakx5eldNYWVZdU9pVXpvdmg2OU8rSUl1QU5VRDQ5Y2p5eXc1bGplZWxXWm5wUFFXd3d5cno1dUYraWk0SHBRNlhFOFUwVkVHMm94aG5IWGZGaWVZdC9CdVdhdks1UXJJcmtsOW9qWjd6N3lmSk1Cd3hLSXdyNzJ3Y09aYTdZRkJUZlQrZUhlM0U1cVdoZzVXc09abFBESFVDeGxVeno5RUJTZE5IeWpuanhVZHFibG84elE1bDIvUVo0dUQ4Zk1IZVdiYnppT25QMEx5cHpNYitac3NqcXN1SEo0bDI4d1d3R0c0b29NRTJqRHhLZnlUbUF0SVF0ekNsWHhVS2FHSG52TEhIb1R5NDRoS0lMSjdRQ1ZBTkp1R0hrNWpnOTBEWC91SmtGMnNrVk5tUjZlNy9BSzl6N0xyYThHc1g1RHdudkd0SFpPSHg5QW5oeDdPd205L2hPT0VmMi9vQm5Kd1hEbUlTTWVrZUhUdU5JR0hyZ1VwbEVrREUwTTVMTUZBWHZjTlphUmNMNGxyV3pOcDhsemlFNjJ3THlaK2w5QVZhWmtvVGVNb2JYYnB2dm9yYThKY1BHNE5uYm93Y3hBSkgyTTEwVnRMZE15VC9BQW4zUFdhZFBsTERFOVJuczVUR3V5ZEE5S1haak1vcXRRNU1qcFBWbDJ1RHA2YkF0bzNBcks0c1l4S2M4VWZiMG41WjZpOUZDM0wwTmVFYThFREJMc3pHOXBNL1JIWlpmb2NMNnhUVTRvR0VGejBkUUNLUkF2cnRtK0N5OW8rR3lLOFJsWDNtUEVTd1lPU1pPYzg2aFBVbm9yRk56MWptYzNUZjZ6OHN3RHpHVTNOczlObVI1NldlSkY0bUM3cDRwYnNqTWp1bGlRNXVhdW5yN01yYzQ2YzN3aUhQd1Mzc2lydHVDbXBVODlUYlBFN2s0RFZ5d3JZbGIzenFZOWMzK3MyZXMvQ09qcFlBcGhjNWhzdnIrV2FUcjlPbXowK2tiNzdvNUpyNkxFWW1VZXZwQkZmajFEUVFXOHdvMU9JbnlUbk13ZnNpWUhxcWJqU0JMcmRwWXp0S04zcm9NKzZYMGxDZGJMN2RhWDcxTlc0ZzNvdmFNRFJFN3JqeHhPcGx2V2o3ZnBNMDk5elErOHVWY1dYSnpGUkoyOUlzaWNUeEQ2RzE3VDZ6MGNUeEpmRWx3T1JnMm9CZ3hvUG84dUFNZWxwOTRickhmYjEyZmFkaWdLQnZGSCtIMm0wMVZsNmVuajZoSWl5NTUrbTg4OC9RZWVXZVplWFFzRnlsTGE5SVpPQ3dPOHUwWDZTRHRMMWpVeGQ5SHl4bjJtOXQwZWtRTldqbWk2M2xodWV2SVdBeGU1Wkx2bUJMT1dwWUJLbFlYTlJhTlFiaXhZaGJHL2piNWlxMnR2VVZXTlBpVnBKWkx6eXQ5RVdHQmhwbkNTL2pvcWwxWGw2WlhsaURtR29ja1B4bjNVRjdsNW5HTXNSd1ZFakpqdkVFcHpLOE5UZEVWakFGOFVpT0xDQUo2eDlDQzVSeDlLUUxHSjNNb3lpcVNzdDNCZ2lYRnltcnJxK0xlaG1ZdUhlbGlRMGlHMnBod2ZNOUdISVBpV0t2UG1aZHBmYW5aWVRLOGVFZWtjekhkR09CTWVnUFNmb3NyekRhZkU5MnpPOHMwU3pzZEdNQ1NhWlEwOTQ0TmxZbHpDWGRoTUVSdlQ2akdZR09wUmFlYmhXYjdTbmduTXFDUDNJbnBpVUpLRmRmVW9TVXh3NlNMWXl1K1hWSUltSjkxMTJURE9ZN1RCZTU2OUxJWmtlZm80ejlRdWhDODNWMkdDV3BhM1U0cWV2UkVlcnlmdE9LalpERUVYTU53ZkN6OTFFTnRUeFpkbU16ODNXclM2NFN4SzNtTE9RaHNmZVdaRitZSHVKZXRUekw5aEZLZHFpeitKcGQ0ZG93TG1qNWtKZFoyaXo5UC96NG9qWlVNWFYvbU9STkd5QjV0N0pvNm5LUzJPKzBvR21iT0w4VEVVS29zaTNoWWxNcGczRUZlU2ZZeTV2NkY3Smw1K0o1WUIwM0IyanlwRmpGWXJLWW5OUUFXc3VZMzNjMk1LZ2JtQTFTZDRpNGhmRTN6Rit2UklJM0p0WUs4WjBDTnA4WHpDWVVKYkJQZHIzVGg3UFN2V3lzZTRsK1BJTzgydXVtR2R3V0RQdVpYRWRuanFEVzZLaDNUVk5ScGowR0NoaXBTQ2tOVGFFZXhsQVhLSmRGeTdUMTVVZXdhaVdTaVppZUdvcmJyaVNGYnFYVmxuajlXbTFNMGlGQnFDdnhKNTJGMXRndTMybUQvRUZwU1c0K2ZYQWRmTE1qdWxoMHhZcjJsbDJ4S1ZESzhRbEIrN3A3ZE16TWdUTUU4VFpDY3g2UTNCZXhsTDFSdzlxbElQbUMvdVpxMG5sbkhYajZOUjNESk1KRkZqTVVWdVdZZk1mSk1jeWhQRWJkaUkyNCtxWm1acUdldVpXWldhNi9ubjNFcVlHOFJWc2d5QUxSZ0pobnUvdHUvWXJ6UDVtdDRwa3Y2SzNUSFZUNyt3RDRZZno1MkxSZ3BPc3RpUUVwSFpMOS9TV2RkOU5veEhXT2l5RURxZjYrcW9zWVhrK2l3cmRSVlZZbEJDRzF3MnhXeDZhZ21tQXM5SU5hZzkvS0dBUG1NWWtkNGx3a3JIVGZraEQ4VWR2Yk5ucExIc2dDMnZ1eWJQRjhFZUw0SThYd1I0dmdqdy9ESGorR1BIOE1lTDRJOFh3UjQvaGp4L0RIaitHUEg4TWVQNFk4UHd4NGZoanhmQkhpK0NQSDhNQmVZKzFJNHBvM0xlUXdRbE9YYzA2WjFCMXBkekNyTmFacFRGM052b2lmTU13UTJvaVhMU3dPTVBhWEs4R0kxN2xnYm5oVHp4dkJTY1BmY1NwVU1tU1hFTVB1U3JlSGhpalpEcHpBMVpSTEN5QWFWTjJYczZGUE14Z2VIZU9YWTVlbVMxa2V4QldtaFB0QjVxSHhENjhYa3ZQam4ybGF3Tk03aDdYR2pwOFdvcElJZWRuWmw2NE1XSXNzYlFkNDdtcW0xeGZYQWhVSU9VQmNvSnBUdkNlMEJMV0lLUzl3MVhUbEJXbXlGdDlvK3E5dDEwVmx4RUNoaDBaekd1bUVham1ibytCcVd0UFI1bUI2TjRaWWNETVp0K1Zoak9XSDI0bmxnalVTeWRvcno3Uzl0cEZpcVE2bUtlckZYYmZVVGlVZnJoZ0VxREhSWmsxTzlaMXY3Si9WL3VON2t3ZE1IR0lYSlFNajJTZjNmN244dis1L1YvdWZ3djduOGY4QXVmeXY3bjluKzUvWi91Znh2N244Yis1L08vdWZ6djdpY29wRmwycVc5NWh3TTVBNUVhVERxZjF2N245Yis1L1MvdWZ3djdpNEF5a3IzVjBlOExtL0s4OXJRdnhQNFg5eitOL2NVcjY4Z0xlTFdjdHorVC9jL2wvM01QOEFQOHorbC9jL3JmM0ZJeHRIOXFlSHVtVjh6dE9TV2ZpZVRJek9DV1p4VzF4T1BpVGFWTFQwaWNSeXMvUExyck9ZRnJMc2wxWWhYYkh3ZHpMZFBjcFgybWRhem40K3JoYWlOdjI1OUtpVnpUdlg2ekI0YUZOUFJnVTB5bGZFalVZV2R0dEV4SlpCdlc1OGFVcWgxTFdhN1k2WktSUFJ1ajNSOVpxTkhTU0F6NGNIbS9hVmw0cno2Q05WdzlDbzQ4aUYzYWhkQW11eE5kRUw0OVk2WEcxeVV6emJzTWdycU50THV3UXhsOW9DcW1ZdEhSVWpTRThCSFhRbC93QnpycU9LYy9UY0gzUWdMYnF2YU5FMmxOSXF0YllpcUNtU2hLZFJ5SW93NzY2L2p6WWZFNXI4TWpUMEZlaVlyNDlwOXcrNUJBVnU1ajJVc09iVytqOFE0TjZ3ZXptWWdFRG9nTGhjTkVXam9ZWWtQcnpRNXpBMEpWSyszbDc2YjNud29TMzBycHJ4cnlTTDR1ejRHRTcrK3RyOE5yeVliNk5LNGRnWTgyVEJsd21mMFRUdVZFZTllYzdlNE5OV2sxUC9BTGxDN0k0bDZJRlJ5aCtSdm9BWkRRN3ppYWpTWHBla0hZNWptWG1mK1dHMXgwUENScHVXVHdBYmg2Kzdad0hQK2s0WGJIL0lyMGl1L1A4QVBpeWZaTWRLQzhJcWVOVkF3MWJTM3hXOGxRK2NlYXVhTDRscmZLazZWN2Q1cytHKzNlWGVWSHR0cjRmeVE5SjhWcFhhdTg5SzhLNmF1TGZqbm1jVzBWOFJ0ZUhtOXhURzhXU3o2ZUJ2VHZES25jMnpvaDY3WTlwK0NaUGpML2FiQ2ErME9ZdHBMOHo5VGpCbjQvcHpoL1gyTjhNOHN6L2czb2N3aG1lc1MzQnBsZGNHVmdiL0FJZkJpSys4TzQ4NVNPTzFmdVUrN29HNGZvcm52N1I3YTNUT1ZoNUNyRjBRaFZJWnhWcThNRVpNRWNBSE5tL1djSDNqTHY4QXc5SnZlMDkzRmtqSnVZTVVxNWsxTHhsQ3FRdldLTDJjL3dDU3JxZGo4T1BTZFY3US93QVdxVitqekM2MUN6ZW01OXBUNFN6TFkrN2lNMllyN3VVUUpsUnhORDNES0xkbExYYWd4NXViTGR0VzdISXo4STBTK3pML0FLYW96M280cDk1L3Q0Wjl0VzRGRlJvVkR6ejBQN2lWdncwbWI5OWZhVzZYWFcvc1BNRWFZdllTTFZ3K1QzbnZwenJhM1RQdi9VeVhTTzZNN3c3S2NXKzArT01iRjN0T2FMOVBtaDUzVS90ejNaWCtweHZSM0lPcjk1UmU5K0JnL21PMGpsZ2NNTDFtZkR1amx2UHhLTU10NzBTTHgybkxrZlR2Szl3b2MrQjhEK1NHTEoyRWVST0dYNmRkcGgyT2QvaWJMSmZLOFJhVTFOR1hFYzFjei9WRHIvMXk5aGtYcWlMOTUxQXp4QlJFenBoYlRkYWgrcVoxMGtkcjB2NmZaUHVaRGFaZEI2QzduOTZqMFY5SHRqUnZoUDhBd29VREMyc0Z0Wm9EM24vc0pqbmR4MlNUeVJaQjB3MmlFUFRacDNCZTRxaE1RTnR1M2VmK3dqK0xvY1BYZkZGeWJ6YXBCT1dvQlordGRUbmthdkJyTTNLUktQZTBqV0tLaVh4Wkg1aWZpcG0rUG9zcTVjT0lvSHkvVEZ3MFBXYzlybXpUS0h1dWQvSXdPUGZFNC9HYnY3SnkxcUxhZW5RMTdRMjRGQjBOOWRYOWJLS05acmU0UDJBbG4zd1RpSVUyY1FrTjRQbjhEU0d0Ulo3YytRWWhXNTkyQzg3b1BFb3k1dHN4aDlxbktYeEx3ZFRkMkVXUXVPRDM2M3FsZlAwQ1JjSHpRN2ZCWmxrV2JtWFp4ZG54QlV1dHBtZ2xNeFdEU29yM0ovUTd4NDRUVmRhdUppTlBUZkp2RXp2YW8vcS8rQjVIaWkzeE83RTU5bGw5YW45cEtZL2NRNjUycGFYSlZlYiswdlFadkpKR3JkcTVvYzc2NlovczZIT0pxcmlkNWk1WFdTMWRrOEM0aElHV1diTU0zcU1nbU8vL0FObGR1SWNoaXVvWDdhdmFFeUYrKytTLyt2Z1EreDltRGZKbUE4ZGtqWDQ2YTNxK3lGb3lqaTN2VjZSUnVHb0t1cVlsdzA2Q3kyME1HVlovNU82Wi9WaEhUOXlpZmlTWVYwM0FJWFUvQmxiZWZMV2E1aSs3RWFLUEMwK3FjZlFCMUFpTmp6LzhMTXNGWW9ob3hkNHUrWURjSXY1cXhuUDh0Nlp2MVpTckdKUlROZXN2Tmd2U05qMGZ6bG90aFhKbjdXUlVMOW1SK1VYUFd6UFpmMnB1MDhvLzRLTnpLRHplNVZKeitTZFhKZW9RTiswVkdVSHN0bjRRNEhZR1BpaGZmU2xwdEVQZXZ6MkJZRjhDZTFvekZsRzVBTDhTMHJ2YWVZSG84dG10c3NZODFMd0dYN0ZHVjdlODc5djVURmpIM2o3cmgvT3E3ajdKVGEvdkNmbVp4dTU5Ylo3aCt6cFIzQXhEWXlNemhKM29nL1pZZExwenFWL21NL050bVhxbHNrMDFOZUl4UC9lVUdHenpqMDF2VmxEdUFPU0QxbGdXUk9xYjdMOThXRlNZY0hOZklpNDNVOGYyWFJXUXp4TGZNRjRmQk8wNHhCNzFFWk1lSHVGL3ZhQW5BRmpzcVBTd1JPeDEvT0pSSnpMSS9wS0dyT25WSm4rVVBTdFoyZ2pUT3pJZjFmaFBlUEZ0c3VRbG85enQ4bFB0MVhDM0tsNS9wOVpXc1NvN0tibCtEek5pdnhCMDY2WlhnNllVVCttemdOUGNsbitPdTVmcWU0OUpJRmlRYXNHdHJocnlrdlFpdmd5UGdKVW81LzhBK1RDL0dDOUFmbEg4anZKQWdpaWhxMjl6QmNmYW8yZmY0UXZYQmxvNXhCMnBLek1YNm5uNkpZWXpDaXZ0RE1QMHo2RmxsZFFzU3BZc2xKUGNnWHY2U2tvTWVldGJHK3VmMCt5SG5ZS3hxVTdRUTlJYUFleGtXb2NLZnFaemFuUWFlMTNEYmwxcW5JOFpWNDZlUGpXM3ZvV2VyNlEwK25tUFhWRHc1bEgremppZGF1TS9wT0VPbHhtZlA0SjBzTnB6ZjhnZWhHVkllM0hrVS9FQlY3SkUxMkNPNjlmb3NYQlcwNURtMHlhMmw4YXc5UGVCWEkrak12OEFWalRqaTc1Si9FN1NDZGpBT2NwUjVxWTMreGJUdVBpS003eTc2aXZsZHhhRzhBNnV6V1Zibm1POTU2Z0pKcnpza0NORHUxUjZ6V3czM0ZPOENRMkJkeklMSFVzOWoydGZQb2FZNk5jcWIvek9Bc25tVDd6bFc3TWY1QXNPanJ4SzB2SHhLN2ZFbkkreWRwblBtTGE3WGlER1dWNElhYjNpakxVTTZtUmlYYXUzcXptZDB4WnE0R2dGVFYyc3orajJuTUxyR3lIYTFVcmxDVmN4OUJDZHRIb2xqNFpqT2R1UHR3RS9tZCtqbitqMlQrWHhHZ2JzeFljR1g5SDJXZVU1WVU2cUpqakE3SkQzU1BobHZlRDIzc0tndkU5dGFhOG5aMzNjNGc3MkNuQ3JCTWpOVHJ0QTF4RzZSNGFDNVZxOXo4OWFvcVplbE9JYjk0R1dGMmRRd0RjdGFzc3lsSTBmTXF1bnRHWXdHbDlDQzh6NGx1MDhEUEkrSmRBMjJpYktOS1pCak9UcGwxS3VhdjY2cmF0TTdibW9aM3VwM2RDN3NYbWllYWxwMzhWakd4akk4NWVsS3VXbUlYbzk4QVhIKy9XOHR1K1JWNUQwcEJySnRkUVZoUHZLN05kZ29OWkRoSXZJcWRsdkxPSHZnWks0SktYMkxXeDFDMnA4Tno4WS9NOHEwM0dCVFpPUU8rbGwrQVA0SEdMaTZ5K1h3dWFTUEpDNUxkT2FxdU9pbjhFZTEwTWxuUkxSS083NlVZZThEaytDTCtOTXhYeERONFFkUlBvUDdRTktKenM3dXVQVm9lVzU4LzVRTjB1UFhUcDVLSGVwWHlwVFh2V2VGK3AvQzd4ek94NmpCOTVYRGNmSmEvbUhXMHBkS0RCNVptUXFYSFRCdUVGcmFuSXUrOGM5aS9SZENNMjROd09RaHA2bjhkZmRkWG9QN2xnLzgrdm1nYzZYVk9BODR4T0VqNDVTb3BPR3ZXanNTN0crRGY4QW9seHI5OVFQdFUvdVBMMU5kMUxNOWFudWNQek05L1FXWncvMG1KNWtOcTllUjd4WDE5c2lsRnRZL3RBcXM3Ry9NU3h0TXpRVDRBVTkvd0RDQ2g2TWhGenhBLzZIQi82b3BsVnVzQlVKeTcvZktNNWhpZXhQems5WXdHZzl4Nlo1L0k3T2d2eFFYQzVHRWxYMytZYTN1Mks4cDZQbTRJK1lSdEovNlZSL1hTYXVLMTZHMFd3MkJSbTAvd0I0bWRoZnRyOUVXUDZHOUpGT3lMZmJNM2k5ZktnOXZ4THYwWTlxZjVIZnBkZXZnZm1QRlBtSVpDNTNVOGllYjdUelNrNVl2S3BnRExGZWVxalowTkFnUVRiRUVwK2lpZUlubHJvUEpMWk9sL1Q3SWhBZFBYWGZSUnJNUTNWZTdXejdDaUhXV0xWd0hHK3VDZkh2Z3JnTmRFYSs3KzhKWXA3eGluM0UwZmhlNVhmdlhUK2ozamJ6M1MvcWpUcllWL3dFZlJZdWYydTdwbC9zZVovRTdTL1N6M3F1L3RMd1dudlQvS2RDZDM5R095SzBNdE85Znl1ZmFmcG5GbXJIZlBBRVlMeWt4N2NUWGp4RFo3RTV0dk9jdFgzeDIrL1VNSTFOUG9RRlZ0bDUxUkRyMDVuNWRBLzZQYnJXc0t2Nlo5MWwvTTc5SFA4QVI3Si9MNGorUjM2Zi93Q3IyVFQ3L1pEcVFML2F6NUU2aEcvRTZmYlFXSEVGNmVzd2dyLzZsZVJpK2FtRTdrRm82RVh5NmZsSnlWZlZjcDYzZlVHQjBvWG1ITHdUTnM2Q2xLc2ZhTHVEY2F5SEhNdk51UkswQUdSTEFGbUtpQThxMEpmcUNHbDNOd2tKQVpjRHFQQkg3Y0VBWHFrcTA3N29wUnkvaEc4VjJCVnpnUEdwUXVieEZ5d0FwVkNxdy9sYzExKzBOcXhBa044QjdLNWhQOXpJMGp4VlJtY29PS2c0cjdNZ1NWbXlHbGV0NW5jT3ZZemt2V1dLcGRGcFhHbTB4QUg5QUJmRmJaUy9jME5JOFZVcWZmMmROcVl3NytJelBDTlNMSU5IV1htdUk4TXMyNjhaY1E2NUpRVzF4OUNMWmtuUkQyeVpzV2NFS2tZUmN2ZVdBT2s4MllqbktMNGhYc1JVelNuMm9uQ1UvdmlZcjUzMU1LYi9BS0NmWm0rRUhCd04vT1oveTRuK3gzakdVZFNvVXN1L2FjSmwzdGNyNW5hdkVWRVB1RVZqZFdOaWovRlQreDJSVjB2dVB1bjJldjhBWW1uK1Q5NW40L1BNSDRDWktXMGUzbFNiUUtIL0FKUjFkNVp3di9VRWhkWllQSGZaME5DVmNhQkZzckVNZHRQQUR4QWM1NlBOSis3MEpRNytJR3pxTVhxUEltTFJ5aS9udlBUcGJoL2xxQ1hZaS9MaVlsOHZxc0h1a3dMVzN2S21JYlpQZWFhTDJFcEdvdFV5RmZuRHFmOEFLU05RVy9ZVTgwbTlzei96Mm5qNFp4VkpwaWgrRWhyUmwvNWg2UWxQeS9rR0JFQlJaQlRRTyt0dzl3NmZheldFNUp1L1ExREV3cjFrK2o2OXlRQWVJK2I5VDVoaUtJUjNlc1JUdWN2MmxjOUZTVzc1NTRqK1IzbGU4Ky9HVmozejVhUDMwNXZIbWVJZWwwUkh6RjFncUxiZnB5RE1BN0VDYWwyUHBkNG0yQ0JmN0FjZWhxN1lQQkdxQi9jRkc2ZnVtK1BOTHdOZlRNemNQU0J2R3h4WEVlK3FIclhpL1BUQUNKV0ZkSndKU0toWHBhNExPNUcvSy9pdkpoNmRvRGZpWjRycEZ2RGdYZS9jN2lvdHV1bjZNbUhnNG5hNWc4MVlhSGFYVEpQdzdHZkVhZ2ZQQjdpZjY3OXd6a0pIaTI0RGU3V0Exc3NwL2ZmcWRtTytDMG9IZDhSTnhFS0pZNGx2VDI5WFZBMnJoTDVGaUZmQmUvUDJsczhsWXV6YjI2dk9aeENxbWpadjBuREg5K0hOUFNwazgranNaOFE3YlpXeHBYcDBTeFdVNFVLalJZQ0crdU1RejdLeDVscWVobWJ0ZmxOTkhhYVhKeThUSU0zbVdQcVFMYU13ODIrV0Q2USsxTEwySDQ2d21maGp1WC9vOXA1ZFBYOFR2UHVzdjduZnA1L285ay9sOFIvUTc5THY5WHMraTRnWCtOYjRGL1hSSVd3Q0E3Ym1Ud1ZCYVRQaVhYTDRRcHZNUGlGeXQ1SmVMangweURwdHJpR3c2WVJnRWJsZG03NktHNXhGaDZnSStsZExLOW9kNWVYejFtNzREWHY4SkMyL1NLdlBOVjJLL0YwQ3FyNUprK1RKSDJNOVlXVk00d0wyamk4UzhXOXZSb0M4NW1peHNwNFNwYnoyalZmR2pZTU9DY0pCcUZ3dFE3eVBTR2RpMEQ3QmE5NGh1eWZZajF2TC9IcjBkc3puMmZFVU1QNFJEQ1VhaGRqS3Z6SDZaRjBMOEhGOEJjU3NWd1JUeXZCejRIRlE1WmVYdjZaanJPWUJ3T1p0c0JRZFhBSzd6bUZrNWduZkViT3pIZWZpZjRVeVI0Zzd3c2J1a1gyRDJkcGVIMHBpSk1HaWVObzF5aTdVNThzNHVBSldtd0RlUWhnVWI3TXg3Rkh0SzQzN3BpKzg3aVEzM2h1L21WTkUvaTUzNVZaZWhvNXlyU2NKZjVQaWY0eXpQdXVNcHhmMHVoRmYrZ2UxakJsNHFlRk1PbW5MOTVoeTdwVjlkUjVNVktnRHpTNWdYek5jcW45OHdmYXFFSnFsM3JwMnR1MlY3eWhZT1R3SEVwMFJxcTkrNzhUendqWmJSOEkvRnVPd3Y3VDd6QWtGSVo3cmN0V090V1ZLRHpBSEc2UmJZUFpMeGt0TVN4ZzBSNm5ZcmtGMnB6NVlFNVJtYWJBTjVxVWVrUGJROWdEMmkyTTQ4WFlpM1hGdHFvUmg3Sm9EYjkwVklRQnFYN1RBR3E3MlgvUGlHVnVxdE4rK3I5dnZNdjhBRzVXL3MvSkZ6aEh0YjBPcWg2dHl6Um9IbmYyaDFBTmJneFM5cUFoWGRYRnBkMHZ6NG4zdjg1ejRJN1dLWmlFUmVDNCtibTFGWWI0ZGcreUgzalZ4eEYwSzgvTlIrQlZWUEo5QzE4UkllSXZwZ1BZZnFmZVpGZU5EUGRiaXdkQTljWUYrakEreTkrdTRkZzBMZU5DKzByamVZbDNQZ0NjRWFHdHMvZExoTmI2WDd1MVRNL011QlYvZFJXeGtmelNjZ0U0RFNHbGxpTWp6RHIxWlg2T2NwNWgzRXZGTnpuNnRYbm9UUFNKQ2hkMTF4aUVQUFJ0aGVQOEE3VXcvbzkvL0FNblZZejlNZE96TTdFVFV6NE9wZXVGZmVLdFVFdTVnbURUNGkzTkhqNmFkTU1Vc3JpMHJoanYvQUpVcjdKZDJ2bkRYMlplUlNkMEZWMktXV09HT3JnYXMyTlJTZVdjWDVQQVd6M3BFaUgzQW45SHRQTHA2L2lkNFhOUFNGbitCN3h6Q3lzTzh3WDV6YWllUXZJcWYwZXlmeStJRmphbzdzSk9UMlhQOEhSeGlaVlIvU2l2c1d4WFY5ZDJvZkZqMkkxQTBIRWc4MFJJekQwZ0Rsd2JkWmpjcVNQRUw1V2Vpbm5Idm5IK0ppcUJaczhURmZ3aTNBMHp1NlhpQlpPTG1BTks2czVLc093bW1OZXM1QVN6QjB4WVlLNlRpR1pwTHZ1UmJGRnRNUHFiaXg5WW9hdkFLSTBBYmYybnVsdXc3bTh1UzFGS21iL2FNL3NkSGU0QjlST240YS80U2U4bkpaR0QrYzMrOTNIYksxUFN2bFcvcDZNNUwvZFlmUS9mRVdUWi9sYjZLKzZtYmZIeXIvd0JQUkZzSDJscU9ZSHVqYnZ2bDFuNWpwcE9kL28yTUZFNkxUWUhybVVvRytTUFpDNCtadzBMTEpsV0orNm5qMGZIM2l0SzZaKzB4N0hJMk1lZk9WKzl3bVRUSk96Rml4czAwVElTNGw1b2RKSGMyYlY0bENGMlJzZnYwejNYNU01WlNDK25LdFc1ajFwMkZqMUIvZ0JyTkN4NHZYVUw4OUh4cCt4QmJ3bDVoRHB0elB5cUFvQUJnT0krQWJLbnN4S2YyQ1B3UnVXeFRVYjl0NThER25aSlAyaHd3cEN4bTlJU3Q3aEZMdXJpN3hPQVNucGJSRXRYdk84Qnd2blVlZEJSdG93OTBnZ0RRQTFBU2JnVDd3c2JhSjhSMFN6TVh5SS9MRW9lVHRQY3huODZ1V1J6TlRYenhVOW1LMm5ZRitJWTVvb2dyWWRVdVk0NEl5MjhTNHRpNjZxbUtWbFpZODVLd1N1aUt5Wm1INm9wbjZkTWR4bEVWY2I1Z3BwamhmRUJXQ2QxQUFveDE5bi8rMU1QNlBmOEEvSVZWeG1FWWp5SlkyUlR1RlJkcWhiTDY1WXdGYUM1bEJSRDA1NmJ6RVlLRzdXMnIrejY1Z0ZHcDd1WXY0M3dtV2Q1NEtYWDJlNk5sMTdyUlBOWExvRytkTk1PNW1MalVaV0d3SFE0bW05eXNENnQ2U0RRV0dJSWk3YVBnZ252VnlLZ250c1cyWGFoVFlTLy9BSkdCcS92TFEySDE5MTVqaHVxeE1uYnpWYXNoaVlndDM3dUkrMFNtMElrYnpDNUE4Q0liYnhzOHhOdGpOekdRTXc1Tk1xbENVK2lrdFVhYXJQbVpEbldlZ1A4QVNVbFNzLzNuRnU4U3hPTzcxWXpJd1hyN2o3NVYrT0oyVjA5bS93Q2VtN1QyaGdTbFpYUVhnMzZ4TWNPcjU2b0RPWjI4VHg2QWRMc2JkL28zUEU5UUpXV0hFYWpSS2duUDBqK1NFS1VPcnhFWVd1cndyckk4T0dIdW1jbG9BMFNuNlpqZ09lRTFNUmJuZ2k3N0UvaHYzT0d3dUwxSHFkR3NFV0ZIYzhQQWoyZ0dFMVlsV1NyN25NTXZJY25oVHV5RnFja0dVNGk1S2F6dzJYSytKZHVRNlpyZFhGV3dCVlhVcTYwNW5mcVUyMXRzR29oYlA0Yjl3VXNnakpITHlrVzgxSHd0dHc0dVZxQWFjaDB4d1pxNWZqZHc5S3BnczJhWUUyM0YzV3VLZHEzRnhSaDdHWTZCd25hR1hNUXJ4RjhNUjJ2aVl1Yi9BRW0rYS9TQ0E0ZHBlUXptYmVKM3hLY0hFV0REZ3pPQjBGbjJ2UjgvWG9tOWlBVW5ReWFoam91QVdRbFVjZEZSMm91V1g3a3dZN1hlbCtHR08vcjlkVDF1UUl3QW9uWlkrcjBXT0NuVUZ6QjVVOEpsK1lwRGxISk9KY3p0MVZFNHFYNW5aZEd2TEFGNzc0dEpqUE9PeEJWdHJmVUhzWlhaUzdNNzY4ZERUN3BxSm1kQnRkMzFmaTZXMGE2UDRvQ2cxT3hKUUlabXhITTV2aDBxcnc5UENXUUt2YUk3SFdsVGZSRlpoZ1pqUE04YzhjQU1IMFltSmc1K3VEVnc4ZVZEWmw4S1h4cFJlRU5IR1ZGa1MrRkxmeGw4S1dnNmcraHBHZDNCSGNDUTlQZFhPR29aWEFUTHMwbDhlVlJTWmZBbDhTVjNqTDRrdmlTK0JLYXhsWktqRmhoZGd5N2RLbDhhZnhaem5qaHhqSTJOTTc0ZWgwSWFxZGQ0eUZ6ZTNFUTZhbDY3ZTdCTTAzTXVsbVY2WGlheGlPRVZKSHozRTJKa1lzT2F0N00zTE9ZYm80QnB4b29kcGFmaU43Qy9pTGd3dEVyd2Fkb0Y3TUxqM0VrSFBZSi9ML3VmeS83amVqZjczbHlsZHBua3JHY1BtSnJTMy93TWZ4TWtDbVYrWEI4QlAvZi9BT3o5NXY4QXNGL2Qvd0JtY2s0RWZrZmNaNUJUaDYydnZEa1JSQmZIUG1adCsrOVdsWllmQ3krR3NVSGF2ZktDMzNteFd6QTlGdHJGYWxPeTlDUUY5REVtNGo4UUtBK2xpdnJSWXo4TTQvWDBKZzVJRElzNkhGN01SV1JiVEFtSEhTdExiT0dhWXIwN1J1ZE1VRi9xOFRCZjBlay9rZjFEb1hmMXhLRlcvcnRQNEw5UW1DNkFZcy9vOFRBTHY2NG45ZCtwdVYvWGFGby9tOFRCL0Y4UkgzaUJRb2Z4Mm44OStvZkMzOWRwL1RmcVVWemYxeEZvV3dLUGVqMGhwSng0aVdpSXFQV3B2TEhnVFo2VFcrSm40VUs2ajJKNDRkeFBMUXk5SGM5aG5wY2FyMm1DdTFtSGJFd0JORVJhaUVzYjZyVGR4c3BtNG5uTm80SHFpS2lZSHIyanY0MzFsL2toUUtIVzJXN3kzdkw2VjlPMCtrcXYzNkpwTm5YaWVCS2xZaVd5TFdsZVlEb281WVFDK1IwNHFNdGRlWVlwSGI4UVhCRHNKaDdvNDNwMGRxYThKeXdMYWdWa3lMRXNXSm96VXc2WjBuM0hRRGpvWnF5a25Lb2lZU3VtZWkydzdqNkFZTXBacURkNS9WenpJT3ptR01KanZQeE5NekR0Tlp4R0lvbzRVaDJYZlRqKzhveTB6Vmtmb3oxZWE4b0xFZCtDTlR4QyswbWN2UkxER1pkZDRtSFp6c29LL1ViazBqaVdsUnhFazBIRXVjeXFMQm1jYTZ1eVJhZEZZZ1VqY1VycU81S2x5MXBhOGZRYlAza0ExWnc3Mk01c2kvcWlQbGovQUFPUHdPTytxcXhMd0k2NkRTaXBYTXZNNWx4YW9oSGFtUnZmRUFORVV5TWE0TUlnc3dWNXhtVHJtSlZaNWkvMjhNcitrTlc2SXR0NGdWVGlPMURjcEFja1FMRytuZ0VZd01zWXZ3L1NpeENGT0dXSk5pZGZUanFLRHpDZTRkUmd1OW9yRXdWMEUxZ1ZRNldOMFFsYytsaGVtWjRmbzlBT2pxdmVHdnBDOFlwcEdUN1BSV3ZFMmN1dDJubHBxTHdJMTJNZk1kclRQYlpyTzRZd1kzTFY1RUF3TWY3S09YMW5GaFJBemlXUENBV2M5U2NlSVVhNjI3aXBzUVVPU1g2L2htbEE4bzdVT21rMVlQbG1VOXpxQmRwMjZsbmtmUlUwZVl2ek1hdGpBVWZtT1htVU4vQ1ZBcFo0c3g1b0thWXZPZW9pcUdTUFpxajZNRnVJMll4QVBNVkw2SVRNUmVPZ0xXWERQek5GeFZaQ2VoQ3pLTE1rOVI1bkxEazlwb1lxRm5xenpDM1JVcExKZVdtcUcyOXBTZEFkUWhneGZMeE1tOGRid2U4T3dpZ3RsS1BpWW9RcUNOMUxVZVM0V1hpVElwQ3pFdVpIN0NIUzMxT2V1bVZEUEd5M1BUT0pmU2hlbGx5aDZqS09Ia2Uwelp0WlJuYUJjNHBRVFUwVGN6WWRuYzZKZmVDTVROeTh3NmVsYnczalNTZ1dYNTYweUZwNStpeUdJSFVkUVZpSHRsNk82YmoyOUhnSHZGS2s2K2tkSGZXV2FKNTkzbkIxZWRZTnRVZG9BVUVEREpaczBudGs4Y2pHQmxqQXQ0WmpUUTBUeGtlOUh4MzRkUFQrZ09vY1E5WWc1R0JWR1dJcVN2cDhhaGY2WUxEWkVGSFdyMVJMU0lpOFNpK3NlV1crSllieFBDbmpUeHA0YzhPZUJMUnJuZ1R3NTRFQXArU2YyWjVmdlBQOTR4YU0rWjRNZDVJc2ZUcFpkWDkraTBtT1ZoMmpsak16TlVIZGVTTnNRTVlPOGNhbHpOUEpCejZ4RjNMSjZqRktjOXlqT2Vra2RST2pVT0N1K1h1TVMrak42Y3ptWDhrWW9tbnBmVXprZW5HWUk4OUxMQmMvUXF3N3dhN3VxbE9FbUxvc1AwUGc3YWpMaDAxK24wL3BGeTVNT3ZNNzlmejlmdHAzZ3JUWkMzelRZeFV1ejBianBZYTBPaHZFYzdvTkdQUkJDaFVwN1RIVEhtUE9vY3J0Q3dxMlVib1FSSG80MHowNjkrbFMvU2d6Rk5ybVJweDB3UjFFb0o2aVhZaHpKN3FXUGFPZXhHOUUzQnVJTW1ETU95b3VyNmFXRGQvRWR2VEV4RjZJb2ROM3JGQ3pIOGZFdXFFZGVPODFPWHBvRyttejBnVXZNV0ZQalFZWnpNaHZDWkJoTHFHaUJPZm9GQjVneDdESzNFc0RMSEpMNlFBOGViWG9aWWZUVXlUSndJSW5YSDh4S2E2cTQyZExFR3VaNk9MaWVpd3k2aW5oN3d0c3ZVMUJ6U21yYkRyZ01NRVhxVnJIU3hlWjJjVFZUTXlQVVo2aFZkempIMjZLMHAwVjRTdnIzR0htY2w5RmwrMzBCYXVZS1NhZlgvNGNmL0pLejRsUURvN0RNTmVnb09ucXhxT3VDV1d5U2ZQYm9BSXhScm83S3k4d0xHNWExMUtpUkVYZk10NXFPNmk3d0kzcG1ZNWZvM29iT29Oa2xTcGVqdEwzN2RMYSs4dHByb3pIdExyYTBuRS9JT21LaFZQQkhmam9yQnpFdW1vZUw2RVM1TW9KdzMwMCtrcG1FZ0ZIVytpNFpkYWw5RUxDaEVsVDFlVlNyeEd0by9TSXNZM2lkSFczVVNHTXViajZuVzE3UXB2RUZIVVg4Y0FzS3FNTERKczlJdTVnR0ZlazFxWDJhNllBZEdlSVBVVzJubldlMzBZNGlDWkk4NGNQeW5xTFU5UmxtdnRLQ09ac0lzTlQ3dWRnNGpUVFVvZWFEQVBXZWFFNGcrNmFZaVBIU3l6UjBzc0hSMnIzamVMb2puQW1qRU5UQlBvb1dYTExyNGQzVEhkVG1aTjU2bEpzWlRPOC93QXN0aXpOY0FNYWdTdzNEZ0kvYTZpMjl1aUxHSktrMlFVMHpzSUlMSG9mNVhYYjY5TVhVaFFWcHhCVkpUTHNyMmgySzZMWXo0aXpsNGd2ZWlEakV0NHVvdXpnQlE2R2g1aGVRMURBcktNdFd2Y2p2R3VnNjg4emhZZ0ZhNW1ieFAvRUFENFJBQUVEQXdJQ0NBVURBd1FDQWdJREFBSUJBd1FBQlJFUUVnWVRGQlVXSUNFeE5VQWlNak0wUVNNd1VEWkNjQ1JEVVdBSEpXRnhGMFJGWW9ELzJnQUlBUUlCQVFnQi93RDhKcG92K1lFL2Z6L2xCUDJQelg1N3VLeFdFN3VLeFdPNG4rTEVyR3Evd3ZoKzJpVWlmdTRyR25oWGgvaXY4MStmNUZFMHpxaS9zcldkTWY0RFQvclNKcG45ak5ack5acksxbnVackgrVzBUVFA3NkwzRVgvTFNKcDUvc0pTL3NJdmNSZisvcC8xdGYyVW95MnBtbWtrbEoydnk0cVJnNW85NUY3aUwvMzVmK3NwKzBtaUdMUmlaWGQwWmJ5SXhMZ3ptb1NtWWVBb2krRmVIZFR1SlMvdzJheldhelc2cysvZGVhWURlNDl4VGJHOG9EbkdPZnBkclpsZHJKLzRaNHNjWDZrZS93QnZlOENiY0IwZHdmd1BoWGgvMFh6b1dUS3VUalFRVXE1YXBXeGFWazZWRlQyYWFMK3lsTFJJaWlxTERmU0xKUTZjdUxseThGVDloS3hXUDRiZCt4bkZJWHV5SVFGU0s1Y1VJbVc0VndHYWJpYzdvNzJNMXlYYUZEU3Zpb1ZXa2NOS2h6NVVSekxNTGltSzR2TGtvcUVtVTkwS2Y4L3hXS3hXUGV0Tks0dGZwc2VDSzRxMXZKYXorS0Z3eDhtNWZqOGJVcHRUMnVTTnJiT1VJTXBseFI5a21pOS9GWTBYU1dQK3BMRUQ0ZHphMWp2cDNFcGY0SHlyT2YyMFgzTTJkSHQ3Q3ZQWEs4UzdxNXNySkF0RTArQW9SUklzbWM3eTJYYlUzQWppNjhyckFmTXhiK25zazVBTENFcU9ZYVdtaGJGM05QTkUwNFNWWTcrY05lVElFaE1kdys0OEVwVnpydno1ZkVxVmp3eFNxcWErTlo5MHY4S0ErUGlyZ3QvS1MrTkpvcUl1aUxtbVR3dUZaVVFlNWFTVjNlZGZNbnNFMHpwanVZckhlM2tqaFZIVlZsL3g2MG1uaFdLeCt3SmVPUGJ5cFRNTmhYWFowMlhkWkNtcGdBcHRwVXFQZVpzZHJsMDlOZ054eFIxMEl3UjIyNDdjWnovYmZpM0ZZWW8zY3JiY1piSVBGMVBkS1VGQWxFblNSV2hKY2Y4QUhEVjVWZzBodmUzVHdvL0d0bGJUL0NBdjVSRVR5MTh2R2hMZFM2SnBqM2VmQ2tYd3J5OThpVmdrb2tXa0h3cmF0SUNxdGJDL0cxYVZGL0dTU3VjWDVKM2Y1a3VmQ2srR2w4VS9mSHVJdW1LeCt3UUN2bWdpUGwzMDE4YXl0Wld2SHVZOTRxNitHY1Z0WFhPS3pXTzhLNVQyMTZ1VGM2UjRrNHFudVYwVkE2MjFFSnRxU0JPUDIyMnpuQUU1ZHhsTVNTYWJHN3ZKVDBhZGVXVzVjZTZCTWlRbWtCSjAyaUpUTGNVZjVUckZMNExsT0g3bDFoQ3dmdHYvQUxvbHhRNTIwMzVVaTRyT21ORnpuNGQ1ZmxDUmF6NFVuaW50ODFoYTNLbGI2VEtyU0pwak5lVmVldjVyOCszU283RzVNazR1NHFLczBpcldmQ3R4VWJxcjRVaVlvQjNFaVU3SEZHa2NDVEc1SytHUEdsLzVwUEtsL2VUeXBmY3JvdEpvbGZtbDBTbDd3SnVORXJzL0Fycy9BcnMvQXJzL0Fycy9BcnMvQXJzL0Fycy9BcnMvQXJzL0Fycy9BcnMvQXJzL0Fycy9BcnMvQXJzL0Fycy9BcnMvQXE4UVljQnNVYjBtU1JoeEhKQzhPc0tNZDI4eStGN2pkYnBNY2NlbDhWQkZ2SFFsOC9KUnJHbWF4M0VYV1Z4SFBZbE9ORGFMOU5uWFJpTTUyZmdWMmZnVjJmZ1YyZmdWMmZnVjJmZ1YyZmdWMmZnVjJmZ1YyZmdWMmZnVjJmZ1YyZmdWMmZnVjJmZ1YyZmdWeHlzT3l3VVpaODYyMERYT1l5NFFFQzRMYjRWQXVETFJZa3ZPUW4ydVl2VnRzVHhXWGQyMm5CQUo5d2tUeS9VeFdNMHdKdHVvVk9NbzVrMmxTdUc1S3g3bWlMcGZicEp0dkw1UGFpNDF3M0FZdTFsWm1QOEFaK0JYWitCWForQlhaK0JYWitCWForQlhaK0JYWitCWForQlhaK0JYWitCWForQlhaK0JYWitCWForQlR0a3R6TGFtVGlpcGZEb3ZuU1l4VFMrT05FVkZwTkNYOFVJN1VwYS9GS25qUnI0WW9WeW1semt1UTRKdk45cUxqWEJMcThRTEk2WDJmZ1YyZmdWMmZnVjJmZ1YyZmdWMmZnVjJmZ1YyZmdWMmZnVjJmZ1YyZmdWMmZnVjJmZ1YyZmdWMmZnVTVZN2MwQ21ScW01ZHVtYVhHZTdpczRyZlcrczBuZGw4UnoyWlRqUTJxL3pabHpZak9kbjRGZG40RmRuNEZkbjRGZG40RmRuNEZkbjRGZG5vRmRub0Zkbm9GZG5vRmRub0Zkbm9GZG5vRmRub0Zkbm9GU0dZNlRGYlpmVGxxZ0NTL0V0RXEwaEpXNU5GV2h5dm5VZHRWOGFOUGg1Vk9sMGhsRnBmRks4cVJhOC9hSisxaXNWaXNWaXNkMWRQeFg0MFN2enFsTDNtdnFEcTQ0MjBPNXpwVWJadm9aTWNoVWhRd1VsRkZrUnhSVlhwa1JFelF1QVFiMDVyWEw1bEM0QnJnUmRhUEcwcERBSmtrZllJTjZjd04reWhNQ3p0MHUwbFpNMGwxdVVQckNFY2Vwa0dSQzRZV0xYRFVkTFphM0gzdUcyT3NMNlVseTd6UnQ5dWNrTHdnZHltbWNxUTN4RkhPOExicVJ4dm1jdXNWNVY1MTVhTFNhU2VDdUpKVWczMnJMd1p4SEV1OGQ5N3VDWUVxb0l2TWw4cXV0RGxGSnhzUG1DVEhkenNWNWxCUWwzRHUyOTdqYTRMUDRnZHdsTmdxcHVwOGhkTlNRWG16RkJrRkFjTmR6UExQT0svTllTc1o4dHY0cm83aVVUTERBb0xwdkdRcUNNdUV5VzRYbU9jenp3eHNETlEzMGt4UWRTcnhZYnJlOW5RZXdmRk5jTFFaTnRzTEVXVHFwZ0tvaWs2MEM0TG1Ob2lLdk5hMmI2V1ZHUTlpb1lxU2lpUE1xM3pFN3Q0bGpHaUtOSU9OU1NoTEZJV0ZyZFFxbWF6Umx0b2YvQU95TDRhbWxZVEZCNWFYQ0RLdVVNNHNic0h4VFhBVmh1dGtXVDA3VWlFQjNFVHJZRHVKSEcxUlZRWEd6WEFsSmpBaUtTT3RLaUxTT0FwcUNDWW1tNGU1ZjVLTlErWG9LYTVUT21lNWhDODhKVzJzSldkRTFrOEY4U1NwQnZ0V2pndmlTTGRvNzd2Y0V3SlZRUmVaTDVWZGFIS0tUallmTTNJanUvVDV6T3hEcmNPN2IzWnp3c1JETlljZFNQS3VOQWVTcDhOcmxZeWxiSzJyVzBxd3FlYUxsS1phMy9FcGN4RDVUZlJsSFprMlNTVVFvOE94M1ZGOW9ubCszbXMxbXMxbGRVMFhUOFYrTkVyODZwUzk1cjZnNjNKZG9OcXN6Y1Q2dmpMVlgwZmVwSGVSZDNTV052R09LcTg4cmR3QnlvZzRnR2RJNFhVM0lxMy9jT1VDbTJMRG9vcUU0Q3BKOEpUaUlhLzhBcytmVUR6ZTBsdWNtTVoxNXIzWDJHNUxKTW5CdHNTM0lxTWNRMnlSZElTTnNSR2lzdGhyaENJcHlYcmc4SE52bkZTR0g0cGU2bmxwRCt6Yjd6TDZ4cGtrMXQ0SzJiSUxORG1PUGhUanl2Tm1wU2ZBbUZwMFZlaE1OSTBmTnVBbjNicExTRGJuWkZQa3JqbThrVE5PQTR5bkwweFNJUXJrRW1TMFhKYy94UlVKK041aHpvL20yVHlFdnd0dXpUQWdCRzlxMWl0dE5POGxjMUtUQ3BqaGx6ZmFSMDRhOG5lOWR5VUhHVFNTWE1uT25UdjI4V215SnVLYlpZUW1KaUsyNm9OUHVMczVGdmVqcjNlSTNkejR0NitGRjRWakZaR3RnVnNXazNwWC9BTXJuS1VubG9sSDVVbEF1bGw5U2I3MTA5UGNxUzRSd21XbForM2xVeVpNeVczYWgvV2owUGc2Z3BGWC9BTmh6cXRYMkk5M2lROHlSQ2tUdUxwblROZWRaV2swS2xyTkRyQit5YTd6TDZ4cGtrMXQ0SzJiSUxORG1PUGhUanl2Tm1wTytEMFphSVZlZ010STBmTnVBbjNiK2FiR3dvc2N2WU81OFEzcEpkUjRzMHVkVXJ4SktpQUp1N2FCeHB2NmNkdms1V2ltTWdleFVkRWx5azVqZU84Y3JYaldQYUorMHY3UzZKUzZKWDUxU2w3elgxUjFsTUU5czJ6R0RrQUtESmd2T3E3c2wyNTJRUnFoUVhrK1JHWHlsaStjZU00ekZKaFV0YnVjMEVlVEhOVGFZZ2swcmVRdHo3RFlpQndYM1NKd2x0cWt5YXF3MUpZY1BTNmVudVZqditOWXpTdzJ1UVRJV3V5eGJTWmszM2g4dElYMmJmZWV0ampxclNRbmdMbUNzSjl6ZVpQVzRpZGVNT2l5WFZEbU1XN0JEejQ4T1hHSUNSTTQ4ZGVML0FPbkpGRlVkcEhEd3Z4S3ZpRnJsa3dyeDluaFJVRTI3ZG01ZERPWllGalJ5ZVFSVXZCTWFON1ZMNGdCQ2NSRklFRmNVcWFLbFA0S0tKVndsNmFXbkRYazczcFVWWkJqVE5zY0VSUXhqU2pSb0hITGFaeEFicFlrdkR3Q2R1Y1hjS1AyNHYxRVliVjVmcWR5OG51bm5XNnQxSVZmTlgveFdGMTNWdVVxRk5NMW12T3NZb0U4ZExMNm0zM3BqSlNJcHRDZHRjSng0a0tOS0JIUWFHQjh3azFDbE1jcFVTQytpQ1ZOMjNsTnRZaE5TWTdhTkgzTDY1ekp5MG5scVNZMHpXNnQxWnBQK2RCMFhWTllQMlRYZWV0ampxclNRbmdMbUNzSjl6ZVpQVzRpZGVNQmpTRGNCWEkxdDJxblNJOE9YR0lDUk00OGRlSWp3KzJsY3c2R1M0S1VLN2l5b0N5OEZIRlpTaHQ0RlF3QkZNMDl0TWxJUGxYTk1PZ3dHVTZibWprZzRtQ2JHTVhqVHB1dEQ0R1NLYXJTbjQwbnRFck5ack5ack5ack5aclA3U0xXYXpTVXRacEZyTlpyTkl2ZmErcU90d2RjWWhHNDJzNlVneEs2eXVDQTQ5VEUrUzdMZEZRdWMwNHJRb3MyY3kyKzJhenBTREVwYmk2bDQ1Rk9YR2EwTHJWWE4rWEZoN21pbnpYakJwc0o4K1d5MGpQVzh0SXFwVUNUSldXNUZmcTYrbk9hcFdOTXJXZjJ4K1hTSDltMzNKcjZ4WXB1cEhuVFFmWjV5WE9iMWFUdEhjSmFTSFFSeWRLU3pESVNFa3JrNzNSdXM0RWZWMW00U21IVkNSRGszUndtM1NXNTNBUTZTV3ZGTGZONGZralNVeWk3VlZMSzJ5SXV5VGRtaEtoZzFVeENmdlRMUU5zdHBjWHB4M0Y5SjlrVjl1eWczQ3RoelNreG85MGpOeVNtUUhvTHZMZFJLUVVJa1JUUVd5VVJYVlZUb3BJdkRyZkx0WTZjTmVUdmNrbVRjWXpGeWJjRXR3U2tuUzVrT0UzVXljK1BSaWFrU253dXpUQXRYRjQ3d1RDM21WTGl0SVRMMCthYnJpTXJjWlV0eGxwanJlU1VFVlMzeXBCeVhZejJ0MVZlbk82WlN2Q2s4ZkpCckdLd2xiRXBBU2t5bmhRZUMrT2E4TmY3cUhTeStwTjk1dTR6RnQ3N3FsY0o3cmd0Tnpac3lQYmdJb3o1dndoZFJMdE5DTzhadDNDVkdjZGFmaXo1aU9zcTlJdWIvQUZxTERmY3ZZS0U0c290YnRGWHcwelhoWGhXRVhSRTdpcFNKV05ZUDJUV3Qxa3lXSEdRWmtPM0ZtVTNHcHU2eUZ0cmpoRmNaUFUvUFFibzRjaHNrRzVUd2JDU2NPYytYU1Zkc3N4NlcwZk9rVFpqVjBGcFF1azVCR1NUMXduS2J6alVpNVNqZFZHb0w1U1lndWxYRXYzQVZ1ck9hak9vMGZpQU5QRDRsYjR1S2FhRmx2WWlIemxYRWcyaEJRU2sxUlZUeUtRUkRoUUZNK0xrWCs2a1lwZlAyVTE1eHBVMmRMa1YwdVJUYzkwVitJREZ3ZHlTM0NhYXlQUzVGZExrVkNmY2NjVkRkVlJhSlU2WElxRTg2NlM3OUg1eW91MXZwTDYwRXg4S1lmRjhNcE5lY2EyN09seUtpdUU2eGxlbHlLaFB1dXVLaFM1RHpidUI2WEpycGNpb2toNXg3QlB2aXdHVk9ZK2RKSmZTbzAzZXUxenZOZlZIVzZDcFc5eEVFd2Q2RUFjc1UzUHFyamJOemZJMjBWcGlLNmU5eHhaTFFDWU85Q0FGY2RYTXRIMmdPL05LbDQ5TmNwM291RzBjaHZpeENiWWYrSklmaEFKSGJ1KzRGVFcrZEVjRHU0U3R0YlYxejM4YXcvczIrNWRSVXJjNGlSTGdhZEhqc295MHR1SjZuUHUzcWNkYVd3aTJsc0dJRVpCWS9UNTB6bUEwRGtsZVJEUnNYSXlzayt6Y2JqdWMxdUxDU1lEcktxT0N4VFNFb0xpM3lSWWZ3YnJEYVM0clFUbmVpUnllYWZnR2R1Nk1MZHZjajJoMk9jb2lpV0ZwQmpYTjI1VFdtbG5oSGpjMTJYV0FWVVFpUUVKZG1pclE0Nk9xVkFaNlBEQnZUaHJ5ZDdrejdOeW5QUUFxY3B2eW0yZzV5RkhpNWxQTkxlR1hCYWNkQlc1Slgvd0N3cWIwVGU1bEJqQzNIR1FJRUZ2YmNXMjRjdWNod2RiMkNoY1QxODY4cUd2eldhUmF5aVV2blM1UmF5dFpwQ3BmL0FJVDRrUk5iTDZrMzNrTUdvRWxrNWZJSnNHWEhINUV6bzRWWVhOMExZbzhwR3BYTmpBMTAxMVFaQm81TWZvenNTWkRmWkVremp4MTRrREVnQzF6WG10SWxiVlRYYXRZcE80dmxTSjNJUDJUV3Q4RVRlamlWeml0OU1aamh6ZDl2YWpnUmtNSjlrMm94c3p5YVNIUE9OQ2JiWlYzbHNTNnRTbXpjVmFPZDZ5eFRneG5BRkdMaDBSU2Z3NjIzemlDVGFWSmJjM3VyaVpwZjAzSzJGaXNhUVgxeGhZamltS3RsSVZ4VjVUYnpvc05vS0tSS3VWcFVyeFN2R3NycEM1YS9DZlJWeGhIY2dHMWZaWEg1aDBPR29zOHpTM0ZsdFJxNEwra2lhS2lpdUZncmgrbi9BS0JhVzc1eTBsSHNZVmRHbUhYdmw4cWdudGZ4Vng4eDB0NWZDUTZXL3dDcXRUL3I2ZEhlcUd5NkQrU25IdWZ4UW9wTGhIV0hHZm5wZytZMGhkNXI2aWR3STdEWmJnNk5HMnFORkdqdUlpRVRUWmhzSUdHVzF5QXhvNEtxajBhUHkrWFhKWjNvZEdBT0R0TW83Qmlna1RUVGdiQ1JscEcrWFRiVGJTWWIwbk05SGxtM3FpLzgrR25qcmhPK21zUDdOdnV0c01OTGtPaXh0bXl1ang4NXJvVU9tMkdXYzh0R1dSVlNSdGxsbjZZc01BZThlZ3d1N3hMQkdEZjNtVUFkeTRSS3RNNEFrQWtocFZlZ2dwWFVveE9DMi9iVkRrR0lYRnRoNUdHWFlFQklWMk1VUzlweXpDVFRmTFF2alhHaTFtclhGNlhMYmFYVGhyeWQ3aWloSmhlalIxYjVkSXl5SjcwNkhFeGlraVJVcm8wZFcrWFJ0Tk9qdE0yR0hNYjNHV25VdzV5MjFEWXJiYmJRN1ExNGxadzhEdWk3YThLeFE2K1ZLV2lxdWlZckkwbmo0cGpHdGw5U2I3eXgyRFBlVGpMTDMxRVpaUTk5TnROTloyQ3d5T2NOc3RNcGhzR0dHeTNBVFRScWlsM09JbU9aRFJ4TlBHczBuajNmQ2hYRmJscmN0WnJ6cE81Qit5YTFOcHB4VVV5YWFJME1raVJSTGNoUll4S3FseW05eUhTUjJCUG1Jc1NLdWM4cHBYT1pTdE5FYUdxTU1JNXpFSmhnejNrNHd3OTlSUER5cTZNODZBNE5OcWV6d2ZiY0w0OUdUNVpvdENtSEJlUjQ4TjRwNXptdXFYY1JGWHdRNHp6VGU0NlNtVnhUYnk4cFNWNDkyZjNrOHFYdVhINWgwYyt5MHQza1ZYRmZsVFNVbTE5VXFJdUpBMC85RXRMZDg1YVQvb2FXL3dDaFQzMWlxTDljYXVQbU9rQXNQWTB0MzFWcWY5ZlFQa1RTV21KQlUyZkxOQ3A5dnBiYUszMWUvVWRzbW1rQmU2QzdUUmE3U1JhN1NSYTdTUmE3U1JhN1NSYTdTUmE3U1JhN1NSYTdTUmE3U1JhN1NSYTdTUmE3U1JhN1NSYTdTUmE3U1JhN1NSYTdTUmF1Y3hpYTZqcmRJdEtXYXhXS3pXZS9tczl4aS94bW1CYlh0SkZydEhGcnRKRnJ0SkZydEhGcnRIRnJ0SkZydEpGcnRIRnJ0SkZydEpGcnRKRnJ0SEZydEhGcnRKRnJ0SkZydEhGcmpkV0xrSVRXVThGb3NJWHcrTk16WkxBY3Naazk2ZGptTTNWV0xlc2NFdmpmTEZIRHU4MVNJazNLcTVXdDVnQ2hxUzAyUHhaWGg2RXJiUlNUMHROeWF0Nkh2N1NSYTdTUmE3U1JhN1J4YTdSeGE3UnhhN1J4YTdTUmE3UnhhN1NSYTdTUmE3U1JhN1J4YTdSeGE3U1JhN1J4YTdTUmF1ZDJZblJlVU5lTkxvUG5TVjVVcTZKV0syb3RiYTJVQ1k3a0NRTVNXTHhkbzR0ZG80dGRwSXRkcEl0ZHBJdGRvNHRkbzR0ZG80dGRvNHRkbzR0ZHBJdGRwSXRkcEl0ZHBJdGRwSXRkcEl0ZHBJdFAzMkhJWkpvdkROYmRRTFZhVmNkeE5CN3NmaUNNeXdEYTlwSXRkcEl0ZHBJdGRwSXRkcEl0ZHBJdGRwSXRkcEl0ZHBJdGRwSXRkcEl0ZHBJdGRwSXRkcEl0ZHBJdGRwSXRMeEhFVk1LdkxWNVZiZHlnK0cwazg2YWVSWTYwNi96SSs3VVJVbHdpUVhoVVZkZmlOUmdRMjV6YUhGWEZCVEFxUzBSYkdkbEV1Vi9lR2w3bHgrWWREbE9HMXk2RVNOY0RGWjVMV0Z1Qy9xb2xBbVNSS25KL3FLWlhEdzAvOUV0TGQ4NWFUdm9hVy82RlAvV0tvMzNBMWNmTWRHQzJ1b3VsdStxdFQvcjZEY0ZSTVZHbHErNXRxZXdxcHpFcVBJSmdxYmNGd2R3KzZ4M0VXc3BTS2xMdC9IZHhRKzJNQmNCUktiREMzeU5oSTh3cXBsb295RXFrRGNZaHlveDl5WlRZZWNkd0d5Y3lxUEh6Q3pvcTBpS1M0U3oyc3BycUtTSWlKaFBhcW1LelM2SXRDYVZsTWFvbmpXS1JFUk5QTmZjWTBMeTBTazBKZTVpc2FKN2RGeFFPWkg0amRVa3d0Q0RoZktvTy9uU1B5Y1pKTnFqUkc2NENnU1B2STFzci9taHBvMEFhY05WWDk5TkZUVzQvTU9oUm5SYjM2UTNsZGI4WnkvNmhhWVRMdzFjRS9WUmFSY0xtbnZvbHBidm5MU2Y5RFNCOUNuL3JGVWI3Z2F1UG1PaXBqUzNmVldwLzE5WUgxOUpjVFo4WVZHZlZnNlJjL3dBUDUrNHVFQnVleHNWaU9ESkxIbGRYdUduNlp0UE5KOGFFU2VReURGS0YxbzhvZklhSU1oeUREQ3V1S0NLcU5xVkt0Q0JHdmhiYlU5S2V4VExMYkRhTnQrM3hpbHJiU0RYTFd2Rk5QR2hSZTRQaDdueXJPcWVXbjU3cVZqM1M2UUc5N2VGUnBFRlFwd09XZUZ4U2FiaXJtbFhuNThza3BmRDJLYVlyOFZjZm1IVC9BUFYwdHkvR1NWS1hNZ3FqWTU0NW5rSmJWR2pYTVZWMHQzemxwTytocEEraFQzMWlxTjl3TlhIekhTUU9OcTZXNzZxMVArdm9BanNTa1JFOG5aeXR1S05OejFjTkJxWXdqUlpHb1pibzZmd21QZVRJYlV4dmFTaEpnSXJUalRqem9vTER6VEgrOGtGcDc2SzI2Vi9hclQ3WGlvUG1DYlRSb0gvazVUbS9iUXROajlTRlpucFNDcnpZQzBDQVB1Y1VncHJpbFNoOStxZjhhWVdzTG9sWTk5Lzl0TW80dEJ2YVZBYWNhNWcrQnhqZEh4Sm93WHhwRnJDMExhclNOaTBtU2NkVXZaSnF2bFZ4K1lkTW9NWEsxYmsrSWxwMWN1a3ZjUmN3ZExkODVhVHZvYVc5ZjBhZFhMcExVWDdnYXVYbU9rb2Y5TTJXbHUrcXRUL3I2QW83RXJjbFN2dUNwaGNQRFZ3eHlkSUgyLzhBQ2VQdlNFVFRCTzJodk81bFVuUVUrTHBjWlUrTHBrZG90emF6emJZNVFQdnZTRDN1TnRPR3Z3czJpNHl2cXc3UkVocnVUM3VhU3NkM1B2Y0pXRTB4V1A0RkZ4VFV4MXRNVXM0enBKcDBjb1RTbkZRaThBQU1lSzhsSzU2SjVFYW41K3pUUmZLcmo4dzZLWkttRnFDR3huY3ErTlFtZ2RjVkNseDJtMnR3VXl1WUM2QTRiZnk5SWZwcENmaDRKVVZGd29rUStWVzl0VmMzMWN2N2RIUjNRVTB0L3dCWmFuL1gxamZYR3A3YW81djBVaUx6ODZZRGx0SVAvUkNqc09mTXNLS3RkV3dWcElFSkVvR20ya3dIOEJqK0l4L0M1cksrNVh5cVZHSjlVeDFjNVhWemxOMjhSWEpxbnc0VHE1eW9zWW1DVlZmYlYxcFJUcTV5bW1DQ09yYTlYT1YxYzVYVnpsUjJsWmEycS9FQjVjb3NCNm03Y1g5NENMWTdSbFJpZnhqcTV5a2IvUjVhOVhPVkZpa3dha3NtSWJ6bTVPcm5LNnVjcHFDYmJpRlJnTGc3U08zbC9aMWUvVEVJV2wzRi9rOVBDbDhxU3NKV1BHc2FKUzBpVmlzVmhORXJGSldLeFdLU3NVaVZoS3g0MHRZMHhTVmlzVmovQUtVbitDQnI4MSthWFFhV2twSy9PcWVlaVV2bFg0cFBLazh0RXI4MSthWHowV2xwS1drL3ltTmZtdnpTcm9OTFErVkpYNTBXa3I4MStLL0ZmaXZ4U2FKWDVyODErZEZwYVNsV3ZQUmY4b2pwK2F4U3BRMWpOSldLVHowV2s4Ni9OTDVWK0svRmZpazhxVHlwTlB6WDVyTkxyaXZMUmY4QUtuanJsZE02WlgyR2RNL3dLa0krZlNXYzRycGJLb3EwTTFrMXdneVdTcENFdkwvdDNoV1UvZy9Hc1Y0LzlTeG9icmJmekhOK0hjampxNHpSR28vQlJyNUFCR2lKdFJ4Y0RzcE1OaGtHWlppUDZqYm9PcDhQdmNKWGhXNUt6cmorQVUyeFhDN3ZIdlk5OHFvS2VLRnUrWGxQclJNdEluNnl0MlR4eTFBdFR2MGpnbTJLOUhzMTdadXl1TlZqM3FKbXNJbXVFckdtS3gvMDlhZGxiVjJncWxoVk5SUE8yaDVUcnkwUE1GZWFyYUNha3FOa1pFcHVORWZ6bXlpa1h4ZUtsaFFmSlMrQmlTSi9DWHZNMThWZkdsSVNMUkh5bmtUWEh2VlZFVHhWdzNDMmpjTFkrdHVKOXUzU2h1RU1YaEhPUEhUeXBYY3I4TGs2T3g5UnFVdzZtUVFrWDNUamdOQXBtQ09QRGxHMlFIenlpSjRQUzNYeTJSMHR1L3hlbFc5bHByY0ZzMzlZK0Yxa25EZ0c0M3diYVpNUng2Uzg0WU5BcG5EdjhDYXZ3KzZSTVZ2cmRXZkRUdy9DSldCckdOTUl0ZVgvQUUyWElJa1VRZEVrRkNwOGdQOEFVRnRWRk9aV2NzN0MyR0E0YWQzcTBna1NBMkN0a2l4Mi9ncHBvemQyR3BpUTdReURhSW9OR3JmeExFbG82bTFmYmY4QTNncThxelNMdXBLeHAvdVZjRnlyWUpTYUtsYjBTczU5MHFJU1lWc1dRK1VsYTJaTGhUYjFiOE9zeVd6RVpWMTNkUHZDSzQ2TExBSmdEOC9GcDBtandrZVNqdmg3aEVWZkltRVA0VHhXMWFudkV1R1cyR1JZYlFFcTV1N1drQ3JMR0lVVjg1em5UWmZKRnBzV2dRQjRoejFJL2podHNVc2pZazIzdEg0ZmNlQ0pXYVRSTUltbmxRK2ZkeG1sVEgvUk05MU5KTDIxTUprOXlwUUMyZTVwV20zSk1SUnBwN2xseTBTYkY1bnh0WFNINGhUeFJubkZWRU1GWjNKeUdqMkVieXl1WnZiVVdJNy9BTUlJNW5EaEtDaU8wVEpYVTJObWhqbjJxWXJGZUNWK2FNcUJNRHFxNFNrSkFGWENhYkpUVjQ2eHFRb3RKdWFYM2Jha0tiaDRvdTNWMXZWdHV4d09nV3RwaGRpVnNyQlZMY0c1emxFZWsrQ09WaDNkc3BpM0FHVk5JN1NlWElCRnlLZVh0NDd5eHkzSnlXTHBENWdlVkdXMGMxRHk0NmJwVXFvaVpwZDl3bTRxYkk2SEZYYmFJKzBGZVdyeW02Mk9qVmtIbFJXNm5XaGsvallrQWNkM0JlMi8rS3lsWlNrMFhDVjRVbUtSVXBWcE80dmo3VzFNTlNad3R1OVIydXVwTFhYVWxycnFTMTExSmE2Nmt0bGRTV3l1cExYWFVscnJxUzExMUphNjZrdGxkU1d5dXBMWlhVbHNycVMyVjFKYks2a3RsZFNXeXIxRllpU2tCbjk1QUpmTFlkYkRyWWRjczY1WjFzT3RoMXl6cllkYkhLNVoxeXpybG5YTGNybHVWeXpybHVVNnF0RGxTM0VDclRyZ0NTSFI3d2QydHZLNlQ2cFROdjhBaHk2bHBoajV1MnRwMU1qeVdJcXJ6V0RSbGdVUmdCbC9FcnNNdG1BZEVCUkZlSW5pYytFdVcySmkyM3RhWlE2Z0h0VGF2c3Z4M1VwVnlKVVB5cHA1ZU5idWFxMFA2NjdsMVhUTmVHUGNKb0NHQ2N4SDVReFdTZWN0YlIzNjZyZG4wMS9OV1pBM1BBZzU4U1czTUszbmNpWTl5bW5ENnJzT3A3UUJNTGJPSkJqbFZ0WGRHenBMUHc1YVFZeU1ONXE0dW5MdUNNZ0FvQW9LVmVEL0FFRWFxMmp5STRWS2xxVnNWNEhYZW5NS0pzT2MxdlB0UnBScmxMU2dTVWhxbElhVml2Q3Z4U0pTZHpHaEo3U3grcGg3VGlUNzRmMzdKNlczN0xpbVdyODdsSVNKdndTR3BBV3hSTllxaVVKc0lqSFBQcHo2NXdyanhKdUtKSk45eXJ1KzA2U05vMGJUSUViY09TcERsUmNFa3pWdzVaSVNtNjhZQ1BJVFlEdSttQ0g0bEtLU3E0anRKNDZ4clJiampnUmRTMnl1cGJaWFV0c3JxVzJWMUxiSzZsdGxkUzJ5dXBiWlhVMXRycWEyVjFOYks2bHRsZFMyeXVwYlpYVXRzcnFXMlYxTmJLbnZOcGNOckhsU2VkZjJPVTJ1VzAwZEpTWFlLaG45SkVUQ1lUUWwyMDlMWGR5Mm0ycFBtZmlpVWk5MjNNdHZ6UWJjNmx0dGRTMjJ1cGJaWFV0c3JxYTIxMU5iYTZtdHRkVFcydXByWlhVMXNycVcyVjFMYmE2bXR0ZFRXMnVwcmJYVXR0cnFXMjFjSUZzaHhTYzBUYnU4VkZFVkVDOVNEdjF5UzF4NGpRTXRveXpyL2RVQmdSdWtwbFk3UXFtVkVCQmZEdUxyTnZkMGFtT3RoWjd4Y1pWMmpzTzlTMnl1cGJaWFV0c3JxVzJWMUxiSzZsdGxkUzJ5dXBiWlhVdHNycVcyVjFMYks2bHRsZFMyeXVwYlpYVXRzb3JQYXhGVlVZamNyUEpTMHpGcTJST2l0b0ZYb1VZbEp0dkQzTGpWQ2I1VVVCb2lRUjNMRHpMZlU2ZmU1REpHdG5aM3lpZVdpTVFIY1E3cm5NVmFhOEUyMHdXKzN2TTBpN1Z6VGlvemNNYThRM0NYQlZ2a2RmM2F1R1lNVzRXSmlUSTZsdGxkUzJ5dXBiWlhVdHNycVcyVjFMYks2bHRsZFMyeXVwYlpYVXRzcnFXMlYxTGJLNmx0bGRTMnlsczFyUk1xOHJmTVZRcGFMUDQvdHJZRklKSjVaVlBOQ3JQaFErNnNYcVllMDRqKytIOSt5ZW1OOTdwYWRPNkt2V2FiekZKRXprT0tGTnpSZDVTaTFjSENiQjAxdUdJcHYxMDFGNU9PNFJJQXFTenBKU3BEamxFWWlPOUZSN21EVFRLeVp1eFo3cUc1dFNPQ3Z5QkNyamdSRVJhRG9jSWpVWElaN1VQeGk4eDBZNzZ5QVZwVm1rMHp2RHBCVG1TNWl1TEdaUkc4STRRT20yYXZTZmliSlhmRkk1b2JLS21rUDdSdnZOdnRPa1FnMU1qUGJkaFM0N2FxaE9TV0djN3htUnpWVXBaa1lXeGNYbWh6ZVYzYm85eUlKa2tqNjdPaUxUZmlqbE1GK25SSHRGVnB2NEFWeFdsd0hqbXM2VFpCQ213WWNVWXpkT09ybmFPd3F3UXJRcm51V2oxRnZ2R1l0Z3BrVXVPRWZua0x6WmtRbzFLanZLaUFzMk9tS0dYSElVSkVrTXErckZOT3R2SXFoM09JSDFKOFdxVmFaSW1COGVKTHYxZkY1YmRudHF3WXZMcEV3bmNjejRLa3ZMUEZTQlNHOE80NllkUG00THZ1L3dEajY5ekhTa3Qydi94OWU0VnpZa3Vkd0gybkhDYkZ1WkdkSkVBNVREZTdjNUlaYVZVTnVaSGNMYWl6WXdzSTh2TmJSM2xkMjhTUml3U0pZODBOMldvMTNERzE4TGxCQWFuU2ltU0ZjVzgvcW1ERkltRXhWMmZWdGpscGEyZVJGU3VLSnd3b0tKWER6NE9Ra2RvbkdnSGNzbHh5NXVveTNFanBHYjJxbm5WdU5Fa2JGZEJXblNCYml1d1czTlozREZ4NGgybEYvd0R4cmY2NGZnUFd1ek13M3RYSDJtaUVUY2xNTkhzTlgyaEVTVkpUQ3RjMmlueFFWVVZIbWxOUVFaa1ltT2VuY3U3eXN3Q3hXVW8vTHdIS1YrYVVzRFh4TGhWYUw0bEd2QmEyNDhFVHk3bWRWOC9aMkwxTVBhY1IvZWorL1pQVEcrOU1OR2JuejZiRlJCZDAvd0M1S282S3pOYVpyenRETkFTN0JCSTYrTWNGN2x4TFpCZEtuVkxtZkVDZ2hiQlFDSm9tMWdEeW1UZFZ4VnpVQTBDU2kwamFQU2xjSzRML0FLUXFhU0Nxa1NBL25lcndCMGhnbW1tMmpodGs0YWY2bU9vVjlGbkE3RmtLamhZSnh6SUl1LzVZYUlqQ0lta1A3UnZ2QzZzWjZTdFFBNWJqSVZMYjV6enpkUE9rNjA3dm1mV1pwNVFPS3lCTW56YmdoOTNpSnpFWUJxUjl5MGxaMGF4OFMwejhsUFpJa0NwSy9DZ0pzcFVWS3pXNWFCZWZkOXRPTHRITk5KL2N0TFNmQXZjdEhxTGZlbWZadVU4YXJiRWoxRys0azAxdUJHWGhqTGw1bGFQN3dxQjF2ckxtMWJQb24zYms2cmt4d3FaRGVXVm16V2JiSEtRZHJZa1hLV3QybEFPeE82NktHMnFMeEwraTdGdUFOZnFpSzBQd3Jpa0pNNXJPcUo0THJBK3lhNzNPNkxjWDNGdDRLMjYwS3pCUWlrb3BtU2dZRzc5V05SSzJjRmhvMkhPZE1aUHU4U09ibEJxbm94Q3U5b0xtalNmckJMWWRUSU95bVdBM25EM3pwcXlUcTU3bnBpTm9Bb0FJTmNaTW1ac2xVT1pOaC9CRnRkc3VNcFZjbk1zTk1EdGI4ZEJOUUpDcTZnbk9SMUxtaUxibktaTGN5SmFjTmZTYzcxNVF2MGxHU2ZPbG02anYyOFdnVldZNUNvL1JtVWp2TGJlT3N0aEJmWkR1Y1F2ZkFEV2hKalRkNFVsRXZ3clNJS0txMHlPeEtTazhTck9tMUZwUlhIY0wyZGo5U0QybkVmM3cvdjJUMHh2dk9SSTcyN2VzV09TRWlqRGpqdXJrTmJoS2lpeFlxSVl0eEdBSkRRb01ZbDNVQUkyTzFOYnQ2YTdUeUlSNFVsWFlxQXJKdk90NW1PZzAyakNTQTNGOERZK1BqQ2tqdDVhdWdqemFndndSQUkwWU1IbVZGMVViNUg2Q0p5bTE1aEFoeHYwOXBzaHROUmRjVlZUbE1nYUtMWHgvVGpKaHJHc1A3UnZ2SGJCTXNxa0JRd1FKQlZWVWpldG91bTZTZERjTTl6c1dDa2RmaWFnUE1LS2dtY2VPdkVmazNSSmw3Y3ZoUkdpSlFydGo1cG9GUnVrKzVTbnZ1bTByTmJsck5lRld6QzNOOWFmWDRhQk1EcmpOSnJhUFVXKzg4M3pXU2JycTlsOVhGQW9qcU9HYlRNSUdTVERkdEpnVzBiU0I1RVNRTVJSWnFQR2ZqcXFKcThxaXlTb1I4eGNxaG8yTzJwUmRvcm1vVTBHRTNVaTUweldkRThhdmNWWlZxZGJxenlCbFd0bGFCVlJONnMrRFEwaTFuUWR1MWNwcEEreWE3ejFzRjhpVmVnS2hieFdDcGdlOSszaTg2YmlERGMzaVRrV0QwWWhXbTdlNnlRazJPN2I4V3Q5WE05VXBha3hHWktmRXRuUFB3TjJjYzVkYmJCc05vVTU2d09VOEtjYWJlSGE0MURqc3JsdEJyQ0pTbHFTZEl0ZWE1YVBObTJzY2RqQURwdzE5Snp2UFJrZmNBbGF0WXR0aUNoRGQvVFJ3N2FKeFJaVW9MdjZvaWR0UXpWVWt3T2VScWphUEo5VFhpSkd2Z1dsV2lKUHlwS3RMNVkwZmNFUndUT0RjM0pwaE5Fck5aMHhRMHZzN0Y2bUhkdVY2V003eW1PME0ycmZJT1hFRjQ5RlZCVEt6Yit1ZGtWMlpLZVg0NmFteTJGL1RnWDFIRjVjbnVjUi9mRCsvWlBURzlMbzQ3eldXUUpiZ0hLalBGTGY1WWdmUzMxYmE1cjhvMmJnMEFHUkhORnRFbHlPcUJ4Tm1HU01sU3Z6WHQrOHJrK0pxcFJpY0tBQklqMDZJOG9xa3VYR0dtVG43ellhdFRqeXlIVzZ1ZnA3dEdPWC9BQlUxMmJ4aE5lYnF5WE44bFZwdzN3ZFhsanlpRGNuTlUvaEdMSlZSUUhKYlIrTGpab2tpUDhSTDBadkRTT3R1TW9zbHp4TERicmlxNk5LRHhPNU1RRVBPT2k3bEJHa3dDYXcvdEc5Skx2SmptNVVPWElLMnZvVHo3NldJSEVsRWJVRURaa3puek5qWkxtdXQzZ1JSK2M0eGRuRzFaa3lWNkxsNmE2TjZRVXVpeStRZ3hpblNZdlNHZ2JreVliKzJvNzhwc283eWpJbHlYRGNCTTQ4ZUlWVDlOS3psYzZPNXhoSGZFMGIwYzhEUXFtTGg5bys2ei9wN3l0UEorbXROcWlocUtkeTBlb3Q2cGZSenVwTHBubjExeWE4dEFidWdPd1RmcUxNWmkybm50dVhkOW1PanpuWEcwWEVNcnF2Nll0TjNSdHlDVXBJTXRKc2RIVWR2U051SHRmdTZOdUtMUzNwbFhXMndPOUNKa3FPcWhSeVZESlFlcmlHNVBFbzIySkFnTXc0Nk1CdXJDRlhsV2F5bEt2OEF3TzZuUUZIdkd5Q3NLVkpnRVFJZndVdzRtOVNKS1JhR2lRd2o2d1BzbXU1TWZkU2MrbFBQdm0rd0x6YzZSMU1abXMyVWxsM2lwVEFoT3VoRmZmSzRNQ3QwV1gwYkVaWmNtSVVob1dUbXRTVzJnaFRubW9EenJ0aGRmY0Z4SGRPSUM1ZHhWVjVnVnVCZkxYTlhDSWJwbzgyemQzRy9oZTY2WW9icnZYNE9sU25QTE10YTN5Z29aeWlXSEFjQnp4RzNMbmUxVFNvRzVWMDRhK2s1M0hzb3lTb3pNa0FEYmd0eUgrVE1XbGxTRDVUYmluUGFsUjIzaW11OWQ3VXVpeStRZ3hpblNZdlNHZ1pPYTFLUmhzWmt2cTlGV3p2T3VFOEM2Y1NKK29DMHE0V3MwbEt0SWRHaUY0MDBPRnpyblRIaG90RDQrRkxvdnM3SDZtR3JyelRBN25MaGZWTkZiamFXWDAwTmI3UFVqNktIZHNNOVhCNk01cnhIOThQNzlrOU1iMG54SHBCTnVOSmFKRGJZRUEyZDdBYmt0azhCYTJ1MmVaSVUzVEJtU0F1R2dXVi9ZMjJVTzF5bUhtak9aYnBMajV1TWxaaUxjTk10dU5SQmJTUGJwd0lZT2hacEJwaDRMYlBGRE9yYkdsUkcrVTVLYjVzWXdvMlZKN2JRUkZWZmpYd1NuR0hVSmNwU01JS2JrckZSNU8zNFhKY1ArOEhGNUtjcEpBOUpFWENrYm1sSGJsNXhGVWhiSW10dENEYUo0RGtuUlR1US90RzlMNDd5NENwUm85RmNkYWRjbE1PV1ZHUmRkaHV4MkFZQnBVRlZKN25QZy9JRjV2cDhwNGtZOG9kT2M5MXB5VWx3bjlIZ282QU54eXRadHNBaXpwR1dZNWM5WXJBT3RJQ09SeWJRa2JSQ3Y3ZTZHaDBpWTA4M3FhVFB4cmluRXlGU1I1MEpjTkh6RzBMdVRXVlZFZEdPOEVsbmNueE1MU1BCU09idkw0KzVhUFVXOVFNYmM4anJBK2M2by8xNGRJNXNndWhTT0F0dGtOQlBCNExXMXYyS3NlV2JzTDFKaXBUOExxNGhqV0p3RjVyWVhBQWRrZEJpN0Via1N3UlBvd2EvL2ozNlkrM0d1SnBDV2czTjlrdHJrZHZwTDNrbU5kNmVWWlJmUDRjWnJkL3hsYWRSVmI4TDJodzViTjJiM29UYU9Ca1FVanBvOXcrS1VDSXBZcDFWOEJYU0I5azEzSmhSeHVFam1xeTQ4OHcwN3p6ZmhNUmhqdlB4UWtOVi90U09RMisxSG14M0hMaE9TTkI1d01oSE8ydXR0UWo2VmNHU2JnUWltc21LV0lYRWVlVmRMODJpeS9GeTJ0a3ZnZGtBdkZFY21XODBSNUZSVXltcGdCL01rYU9ua3B0dHI0ODlxaGRiUHk1cmZoVHpJT2d1WWpwTlRFRmJldjhBcWtwVjhDMTRhK2s1M0gvb0hVUEVma3lxY0pJdlNtSEgvd0JHSzNIbE1LNmpzWG1yenlaV1pWeW45R2g4d0FiamxhemJZZ2wwcTR0dU50aXZRUkpiTWlMSWZjYTB2N1NGQzMwZm5vbEFLS09WSm44b3JSRFM1b1NwS3hTL0NsZU5JdEl1ZFB6N1d4ZXBocEpJbTR4a0xyenJ4Ym5OYkw2YUdqaG8yMnBxWms0YW1WV3UxTE4vVWM2anQyM0ZYTzJsQVBLVkVlV1BKRjN1Y1IvZkQrL1pQVEcvWlh5SU1HN2VCdlNPWnRFamtDQ3FZeThLdTRISTVZeWd4elZhNUgvSElYOEw0SlRNb21Wd3NpTUJqem16YlJ3dDFGdjUyMVBpMzFqNHR5aGhDOElJWnlhNncvdEcvWTNXT2NpRXFDdm5vaWZBUlVJN1J4b3ROK0RpaXNmSVphN21Fb29wdG52WlI5N0dITWt2a2lPTDVnaG9YY3RIcUxldlUwUG1icWZ0TVo5MVhLZXRVZDFRVkVzOFJFQkVkdEVaMDNDViszTXlHQVpKMjFSM1RjS25MVkhjRUVycWlJZ2dLTlFtbVpKeUI2bmFSMG5CZXRNZDh0eXVXK080clZIWjRqanFucHhSYTJIcnFNaDNHTlppUGt6c1loejUwQk9WTWltK2FxcHVncXhnYzFGZnhUOGR0d1NqdVdwOG9icDJ0NHdESlVtNEhOeUxMTGI4TnRSdzB5NlM1WFdCOWsxN0cvdFphRjFMdGVXTFUwaW5acit6ZDFKdXBqU1BSaUZiY2UrR09qMDJPeDRGMTFGWHlHNnhDb0pESi9LYlF1TGxlak4xMFZwVXhTTWhuTkVRajV0Z0wxeHlEQksxdU9sMTRhK2s1N0dTeWtpT1RTdWdvR3FLcVVsRGhFeFg0b2ZLaUVjMGdKNTBuZ25qV002ZVZMV2FUMnRqOVREU1VpbEZjUk9oVEtLSktBZHhhV1gwME5MbXUyM3VhMnBFUzN0NlgxRVczcnJGTGRHQXRlSlB2aC9mWnVVNk8yamJmWEZ5cnJpNVYxeGM2NjR1ZGRjWEt1dUxuWFhGeXJyaTVWMXhjcTY0dVZkY1hLdXVMbFhYRnlycmk1VjF4Y3E2NHVWZGNYS3JoSWt6Z1JYTW0xZzZla3ZPcGhhYmJWYWRKdktiRUl2d2hQWjhGNXlKNDU4YWlQcXk1aXBzVk9laW92Tk02OFZIQ0lpS09hQk9hVzJoRkFIQ2FzOFJjcGtXNjdUVjJtcnROWGFhdTAxZHBxN1RWMm1ydE5YYWF1MDFkcHE3VFYybXJ0TlhhYXUwVkdxRWFxaStWS253RFNMWG5TMDU4Skl0RjhNdk9tTmNacmJwanV4SkhSWkF2VjJscnROWGFXdTB0ZHBhN1MxMm1ydExYYVd1MHRkcGE3UzEybHJ0TFhhV3UwdGRwYXVOMEc0Tm9QY1VoRlBpNUVjRDU3TUdOL3JGY0NXS3R4MmcxVHdwMEZNUGh2bHJXZTJrcU5hTGsxY1kxWXBSL05SeElBOGRXT0llU3dMZGRwcTdUVjJtcnROWGFhdTAxZHBxN1RWMm1ydE5YYWF1MDFkcHE3VFYybXJ0TlQvRUF5R1NiSitBek1MOVptM2RWY1JNOHA1RTVSVmFmc3FtdkV6RklodHR1YU1PYzcwVmlsdE1WeXVxZ2JUNGVoUEQ0b2pNMUsvMWFVcVN5U2tpT2w4OGFLSS9BMitZaW5MSFcyWFhxNFNTdTAxZHBxN1RWMm1ydE5YYWF1MDFkcHE3VFYybXJ0TlhhYXUwMWRwcTdUVjJtcnROVStTM01lVndhL05KUTFsS1B5MFVpb1hGL3UzaGl2RFRkcXZ0TEg2bUhjdWZwN210bDlORFM2K251YTJ2MDl2UytlbkZyQyt5YTE0aysrSCtDZDJ0SXVjTU9VZ1J2T2haWmNERmREYS9MY1pqKzFXaFVhNlNiSjdIWkhSM0IzRENiM3UxTWZFMVJ0c2M3VmNJVFJQQ2dmVFp0cU0xeXdUUHVNYmd4UXFpcHE3NHFpVVk1ZUgzMk5GMHhUWU5tdURHMHRPcjhNQzBSb0FvMmwxY1J4MU1hb3RLbXhjMWM3TSszSjZkYm9zbVpJYlRMRVl4TGU5N2VjSCtwWWNwOU1zbFZ2YjVjYmJWeUZTaUxpMkZ2aUpWalliY2ZOVEl4YThFWGtxdmk1MWVIejdiU3RERnQ1K1hRb0ZjeXpSMXlVNjVpK25MWVZmYmtsWThhelNVdWkrR2pud0psQVR3eld6UktSUGJXTDFNTzVjL1QzTmJMNmFHbDE5UGMxdGZwN2VsODlPTFdGOWsxcnhKOThQOEVZSVk0VjVreExDaXkyU0xubHRvQ0pSRVNFbUViYzVuZ010NEN3Z3lXWlA2YnFRZHE1VjdZejhMWU5vS2JrMjRUdzJsVWVJZ3J2UDNLLzhBd283dkw5Ukt5NnZrRFcxZHkvbk5KM2R5ZTYvRk4zZG9KSFJwbWM2Wm9YWEErVWlJdlB1SWxLbEltRTl5OEhNYVZLMzh5Tm1vdjBxSVVNVkZiY3ZSM0NaSzN5bGh5RU9uVENXMHF0dUM0QjRQVDgwaUt2a2tNMEhjNFNwbjRmY1kwOHRTeHFtcUptdmxyT2ZhMlAxTU81Yy9UM05iTDZhR2wxOVBjMXRmcDdlbDg5T0xXRjlrMXJ4Sjk4UHVrMVR2RzJKcGhYSTVqNWZpbFRjbWFKQjNWNUhXRXdxMThSRDhYaUk0VEJMNFUyd1RpK0RiQXQrN1ZLd2kxOFNWdlA4QUNJWDV4cTQ4MDE4M1NuRCtra2VTNzlVSWpUYTU5M0toeHByWExmV0hkYlg5azN4RTBDN0pqRXFOSlRMUGozVTk2Q28ydUZFZVNham8rTzBrZFJ0VUlNMHhKZGpsa0hIWUV4UDFDZ3hsWDRPaHNKNTh1M3MrSmRQRUEvUmNkTjFjbDd2R2lVZm5walJLUWMwcW9OZWZ0ckg2bUhjdWZwN210bDlORFM2K251YTJ2MDl2UytlbkZyQyt5YTE0aysrSCtBem9tcHNOblJ3eXg4SnhudnlUUjF5MVZhNVpKNFVMRHArTk5SQUZQaVR3OTZvMWhhemlzb3RLUWpYTlZma1Z0NTM1bTR6SWVOSjc5MkswOG1GZnNVUXlVcVcyejJ2dHVaeEdJYmFSM2lCRXBaZkUrY0lqbkZDcFFSTCs2U0s0MktnR0Y5NHFJcVlYeFNubFVnVVVqYmdid3FMWG5TN1I4eWNSUGxNRmQrZEVSRTkraTBTWjFSSytGSzNlNHNYcVlkeTUrbnVhMlgwME5McjZlNXJhL1QyOUw1NmNXc0w3SnJYaVQ3NGZjSjNNZnNKL0U0cmFpMWorRXdsYkJyWU5iUnJIc01lenl2OEFENTkzWS9VdzdsejlQYzFzdnBvYVhYMDl6VzErbnQ2WHowNHRZWDJUV3ZFbjN3LzVjc2ZxWWR5NStudWEyWDAwTkxyNmU1cmEvVDI5TDU2Y1dzTDdKclhpVDc0Zjh1V1AxTU81Yy9UM05iTDZhR2wxOVBjMXRmcDdlbDg5T0xXRjlrMXJ4Sjk4UCtYTEg2bUhjdWZwN210bDlORFM2Sm0zdWEydjA5dlMrZW5GckRURVJ0TmVKUHZoL3dBdVdMMU1PNWMvVDNOYkw2YUdraHZteHpEV3d5d2NqY2hhNGdsRHkwanBRQ3BtZ29LSUlvaWFjU2ZmRC9seXgrcGgzTG42ZTVyWmZUUTF1c1hvczBrMEF5YkxjUFcxeDI0cFNJbHlWV09Lcjh2bUxyeEo5OFArWExINm1IY3VmcDdtdGw5TkRXNHdBbk03YWZZZGp1S0Rtc1dJOU1jMk5Rb2pjSmpsQnJ4Sjk4UDhQSnVNQ0g5Y3VMK0hBOEZEaTdoMXp3U05QaFRFL1EveGpZdlV3N2pyWVBOcTJmVXR0cnFXMjB3dzNHYlJ0dlYrTXhKSGE2N3c5Rkw1T3pkTThQeEE4VGFhYVpEWTMzT0kvdmgvaGJ6eEZiN0tINnR6NHh1OXdWUkFpSTF5V2dHYmE3Z3RmR2QyZ0tndTJlL1crOU41WTlpbmRUL0ROajlURDJuRWYzdy93bkZQRkEyZ09qeDNYblpEaXVPOUNsOUU2WHBLaFM0SkNNaVBIZWxQSXl6TGh5b0Q2c1NhNWR5dExqY2l1R09KVzcwMXluZmJaLzdFbFJySkpkVGM1SURoeUNXeVhIRGh5YXUyTEtzanJBS1ljOW1nSVRUS2Z4OXBKUW1vU2RmVDY2K24xMTlQcnI2ZlhYMCt1dnA5ZGZUNjYrbjExOVBycjZmWFgwK3V2cDlkZlQ2NituMTE5UHJyNmZYWDArdXZwOWRmVDZ1cnBQbTA0WDhGZmJzM1pyY1VoWDMzWlR4UE8xRy9WNEFlb2ZFa3JqL3d1akxkY0dnRU5pWGR6dng5ZWNOUjd1dGNhZmJXOUtpU240VWdYMmJQYzJydmJ3bEIrOW51Wi9sYmlSSnR4dk9raVRGbythMFcwdDUxdk90NTF2T3Q1MXZPdDUxdk90NTF2T3Q1MXZPbXdrTy9JZk9hWEI3enJlZGJ6cmVkQnpuRndMZ1NHdm4zblc4NjZQSjVYTXJlZGJ6cmVkYnpyZWRDWjU5aFlvZ2txeUR2TjhsY1JQdU5NTlFMYXdtR25yZGJYL0IyUGRyaFltbFpKcGN0b3RIZG9Gdk5HSE92b2FVMGNDZlpXcmpGN3Q2blcyelRRaDBWL2hnS2t1K0hMdGpFNk4vQzJ2N3Yyay81V2ZaVyt4TEphNXIxeXM3TVNQejJyWmFqdUNxU3VjT1J5QmVTTVkrbHBIT1ZZZWpSeWRTTXowaDhXa20yTG9jVW5xdGxyNnhRbG8rR2p4OEQ4ZDJNNnJiamZEbk1iUTZsV0NRd0NtM0JpOU5rb3pYWm1yakE2dmRRTk9PYmtzdTZkR0dyYkVpekhTR1JZLzErRWJnelZyWjZSY21XcTQzZTV2RWJxVS8vQU92NEViYnJoYi9YV1NmYmxyamI1WUthY0EzSldKNVFpb0FKd2tFVytIV1JETDl6dDQyOXhFRnV6YjRIU3FnUk9teUVacTR3ZXIzMGIwdDlqV1MxelhyamFHWWtmbk4yMjFuUFZTVnpoMk9RL29reVlQY283bForcjJFZDBaNGM1clFuVXl3OUVqRTlWdmdPM0IzYUs4T1JzYlVDT2JzamtOaHc3SEVQMWJoRFNGSjVLUmVIeFZyZkp1TmtXSzF6bXJiYitzSENDcDhOWU1oV2xLMWJiYjB6U0hFZG12STBIWnlMamFzNkM1QWU1WlUzWmQ4RHBWUUluVFpDTTFQdC9RcElzMVBzcFFZL05TMjIvckJ3Z29ZbTZkMFdybmJPcnRsUTdGMHVNTDFQOE92dGh1YXdxZWR0dEszQUNPcGtaWWNrbVZ0bHI2eFFsbytHVFJQZ2ZZZGpPcTI1N2k1ZjI2RDhxVk4rNUtoWWVKTW9UVG9mTnFJR1hrb2tQbWlLcTRUbzBpbFJSWEM0Vk5HNUJJMG0yUXI3cnZ4OUdrZHlHOG9NNFNZNis1ODFNcHkxM2s3TmVkVEZBMmJueXF3OEtaWFVmbTloTGtyQjRPa1NBaU5JeEFZWkdVdzNOdWNXRzlHaXN3TGxLaU1QdEkrd2JTMmFVNC9iVzMzYnZHT1BjNG0rdUcrSm1HdUc0OFJxTnhCWlpEd3g1OTF1Rm1za3B1RzRYRWxsRWR4SHhMdzRuSzVaOFRXUm9GTTcvTWF1TjZqU21uZm9sVmo0bGk5bjRzWm1QZjdPKzZMRTg3U3JDa2I2OFEyaGZzQjRpWVQ3aUdscnZUQ3ZXcGNvdUY5L2EvdS9hVC9sWjlqSGI1ejR0MXhFNnJVY0dSeXVNVW1ZWEQrUnNyeE5YQUt1YlNCZW1EUjhlYWpyTldKdmZjVVdyb1c2ME9MWERQeU8wM0llYnZhb1BFcmFaYmNxZVJCWmNqdzlJZWRCd0RndG8xZmxFZUlIWFc1Z29KR2JpL0c0YU50cWF5bmlreVRlS3VDWXNaK2ErVWpnaFVmV1pBcmd5R3IzRVRlNjd5T20zUjk1T012OVBIZ3dhNEVmNWQvUnFwckhScHpqTmNjL1BEVFMyU1ZoM0JwOUVWRlRLV2RFSzVONTRqSXVsZ05aVmFZOUFXckQ2aWxjUi9mRFREZk9mRnV1SVhWYWpneUdWeGlrekNzR1JzenhOWEFLdmpTQmNRTk9KUHNSMG1rUVdMSXErK1NZS3pwMGEwRS9TdUdSNzE0YmEzUG02dDJmTjZlNW0yQXNpNE5pWEVqcGM0R3FzSjgrQ2JKOFBEc2x1Q3Q5YjU4VnFVam45TmFjTk5ZWk4ybkpMcHlWZnEvQ2owQUh0SS9vQzFZZlVVcS9lcHQxSUJKSXVSbDRjUlVsT0lyWHIxY1RmN1ZSRlZMQmxMRk5mNlh5VHZqS016MVZMVi9wN1lDMXhFM3Ntb2RjTS9JN1J6cEVhNW1TY1NNcHNCNzNOeS90MEg1VXBCQmJpVzZlNFF1cHRaUG1zb1N5MjBhZlZFcUZGUjM0emx5eWJQbHRSWCtrb3Jicmtma1NoUktlbGNwNVVialNFa0JVNktLRHpBai9BRUJxUjkrR25Nak5HdE1LdzgzdUdkSGFGdmVOdStoVnkrbWxOTU54R2VZZlQ1Ry9ORzAzTVozamJ2QjBrcVFncXlXNXVSRkJhNWJKSlU1Z0dUVGFQemV3djM5QlNhL3NHazlmZzBmcnN6VC9BTWV3WTcvRDBlVTd4bC9VTVdrODZ0ODJWSzJJN01iUjZHNjBUa2x5WTVBZWNlK2tWUXZPSlV6N04ybmZxMitsMjQrTzN5WkxxQURzOFVjdDd3RmM3ZzVkWXR2Z3ZTNUt0UnpmS0U3TElqYmt1UzNMWEtidXpWNUVFbGJ4OS9hL3V2YVhENVdmWTJ6NzlxdUp2OW5TNCtGaXEyZW9OVmQwVHA4VmEzWXVLalZsWTVNeVFxeWx6dzltdUdma2RwdGx4eStMdDRsY1Q5TnVwVERrbTBjcHUwUTNMY3k0Y2kydTgrOWMycDlvQ2U4aml6b3lSSlJNcGRGMjJ4OWRlRHZnZ1hGK3JMY2p0RnlibUROZXROamd2WGFGQmE1OHhwcXVMT0g3NWRyeXJzYXpjSzhSd0xxekpQaTVqby9FVDZWeHY0OUNMUlBCYXQ1S2NCa3FqUExIa0M2anJFRzhNSVZUNERrQjNhVWYwQmFzUHFLVnhIOThOVzM3OXF1SnY5clM0K0ZqcTJlb05WeENuNnpDMXhKOWlPblJrbVdzV1Z1ZG5DQXdqaVIvNmZYVGhuNmJ0VC92bmFzUHFRMXhIOThOY05mU2NxMEp0dXNoRVliNlpiWFkxT2YwMXB3OTlocGNrUmJIcEg5QVdyRDZpbFg3MU51blhPVmMyOHhXT1JlWGFiOWRyaVgvQUdxaS93QlByVms5VGJyaVQ3a0tua2tLQXdGY1NONVpiY3JobjVIYW5mZXUxeEI5aDdtNWYyNkQ4cVVUVGF5SEhIRW10NThRUVVIQTNEN2pTQXFMR3FRaW8rV2JlaXJJcVlxYzFwTkpQM0JWYkVYbUZVbFVTT1dZL3dCQWFrZmZob1h6TFZ0K2l0WEQ3ZXJkOUNwcW9teFZuSXZSbDB0NkwwZW91T21PWWwvYkZvejlFYXVmbU5ENSt3di9BUFFNbXY3UnBQWDROSDY3TTAvOGNmMGt4WEdYOVF4ZExmOEFUZ1U1OU1xamZKYjZlK2tWUXZPSlV6N04ybmZxMituZnBGVVB6aDFNK3pkcGhjdnQxYy9USDZIMUtSVjU5S2VxNmViWDhCYS91L2FYRDVXZlkyOHRrNXBWNG1Ud2FYU2F1K3daUzFwbTROVmR5LzhBYVJScDg5bDRaby85TTFNY3FaL1R5Vnd6OGp0U3VJVFpkTm9aRWgyVTZyamt4MXhpejh4dHdldExNamhXTDFJSzRqKytIUzROODJDOEZlV25EbndjTTNJNi9GY1FmMHJia3JocHZtMytNTmNTWHE2SmU1QU5EZUxxaEl0Y2VEdm5zeWs0cmZZazJ5M0dGQW00MFNvamZKaXR0NlJwTHNSMURiNGlCRmhpVk1lZ0xWaDlSU3VJL3ZocUFXeWEydGNTcDROYVRWMzJES1d0TTNCdXIrWCtyWkd1SlBzUjBuK2dhUTEzOFByaXVHUzhIUnFlbUp6dFdNdHR5Q3VJL3ZScmhyNkxpMVl5MzNCNHF0a2psM2g5bFp3Y3F6dk42Y09sbUNxYVhaZGxtUWRJL29GV0gxRkt2M3FiZGNRT0V5NHc0S2JYSkRVZ1cvWGE0bS8ycWkvMCt0V05QL1poVjJSSDd1MDFWOGh6Smlnak4wYU55MGZId3o4anRUVVZaN3FWeEVTSkNRZmMzTCszUkxnd2lVc3NlY1MwblEwWE5EY1djZU10MFhuZHcxSGtGSEx3ZVdKSytLbTNvc1VQaFIwbnBJa1ZQaXliNVpaZGlSMjhKS21jL3dDRVc3ZzJEYURUa29Ua0M3WFdUZEt1VnFMTEdPM3RXVE1COXJha1dZRERlMVpVc1pBb2lNVFFWdmx2ZEdqN3FjbXR0dDdHWXNoR0RVaWVuZzYwb0pUZHdiQUVHcGNnWkNwZ2ZQMkY5VFBBVXFrWExZTFNldndxUDEyWnAvNDQvcE5pdU12NmhpNlcvd0NuQXB6NlpWRytTMzA3OUlxaGVjU3BuMmJ0Ty9WdDlPL1JLb2ZuRHFaOW03VWY2NFZjL1RINkgxS1JWNTlLZXE2ZWJYOEJhL3UvYVhENVdmWW9xb3VVTUdiN0JUYkxzYXc0aFBGYUhtcHR2S0VkdXN5d1grZTY5TFNaZWdNYnc1eWJoSE9yNStqQk9wbjlQSlhEWHlPMU8rK2QwdVhvYTF3Mjl1YU5sYmN6MGUrY3FyaGFBbnZJNHQwdDQyOHhGRjhhdlVOWUYwZVlXckYvU053cjhWeEQvUzF1V3VDaFF1SldNM1p6bTNXUWVuRWYrcTRadDB1cFZ0bHdtR24zcTRiaGRQdlRMV2tKaEpNa1dpRGh3a2QrTGlLVUNpTWNiTzRFcTJyR1dGYk9ySlF1dmNSL2ZEU0txTGxEQm0rUVUyeTdJc09JVHhXbDVxYmJ5aEhiN01zRi9udXo1YVRManZHNFFSbnNvMnR6czRRR0VjVG95VExXTEt5ckEzSGptN1hEOHhyWVVSenMxK3JWdWZHMjNJaE9kWSttUDg5cVhINnBtaHRuUWd2TFFQc2ZCWkxhbzF3MTl3ZFBPcXhkRGRTOEtKV3B3aHF3VEFqdmswWjhQS1V0VHJpQ1lMaEpIQ3JNNDNMdHF4bGhXenF5VUxyMSs5VGJyaWIvQUdxc0w2UFF0aXRldlZ4Ti90VmJXK2RaeGJxUERnMmZMcmx1Y1dmZWxmVzZYT1czT01HcmU0YysxS2g4TmZLN1MyaUkzS1dVN2VwNFRIa0Z2M0Z5L3QvYlorc09rbjdndlpqNSt3V0owL2hkMktsdGU2UmJXVHAvbk16bzh4dGpuUHpKTTF5ZEpDSkVOMHVESVRrRGh1T3k1eGwvVU1YUzMvVGdVNTlNcWFIWXhhalZVM0ppcmV6TERiMG1aOW03VHYxYmZXRUpNTEFZbUFnTEl1TGlOVzk0bG14SExjL0JKeVV5c2lLNHlrVUpXOXgrVE5CWmhOMjl1ODRGOFEvZ0xYOTM3UzRmS3o3SUROdGNnNDY2NnVUUlZSY29jaVE2bUQvZDQvdEtrSTNGdXJCOFhDZHhIUW5uamJGc2tWUlhLYUs0NG9JQ3FSS21GcmdHMHF4SEtlNW9rcVVnN1U4NkVpQmNpNDg2OHVYTkJNMjF5QnV1dXJseEZWRnloeUpEbzRQdkxJa0VPMWFDUSsyTzBNcXROdk9zL1RNemNYSjkxSk1sQTJhaVJBdVJjZWRlOFhQNFc1ZjJmdHMvV0hTVDl3WHN4K2IyRmlsRHNXT1YrNFBtdFREbjJaWk1waVEyeE5kNWl0bHk3VnltSHdrM2F3M2VMZkxZRXlOeE53MU92TTFtVkU3RDhRVXZBZHlCbU1NZGVCcitxWW8rRTR4OE94N1pJTGcvaXNTMkNQOEE0OHU3VWhaRGJuQWwrZGJVRm04RjNGNUl2UjNPQkwrNDJvS2ZBZDFnTm9OdGdjQ3pYM3hkdTkwYXNsNFlXM1NuT0M3Nno5bVBDSEZUbmc1YWJQYWVHMUo5WDNqa09xNFh2N1g5M1hJZXJrUFZ5SHE1RDFjaDZ1UTlYSWZya1BWeUhxNUQxY2grdVE5WEllcmtQVnlIcTVEMWNoNnVROVhJZXE0b3FJeWkvd0FFK3cxS1pKbDIvd0JrZnNrMVd5NGFuUkdMVmNJOGp2OEFEZGhkdmN6Q3ROdHN0bzJIL1I1ckxqMjNaMEtUWFFwTmRDazEwS1RYUXBOZENrMTBLVFhRcE5kQ2sxMEtUU1E1S1Z5SjFkRGxMNTlDazEwS1RYUXBOZENrMTBLVFhRcE5kRGsxME9SWFFwTmREa1YwT1JYUTVGZERrMTBPUlhRNU5kQ2sxME9UWFFwTkpEa1o5Z2lxaTVSbTl5Mmt3Vit0WGFlMEJ5UzRlNHpCZkhxTGpLdURMWExzMWdDSEtXc3JXVnJLMXVvWjhzUjJvUm1hN2l6V2F5dE52dk5mSTVNbE9wZzZSVlR5VndsL2dnY2NhTGNIVDUxZFBuVjArZFhUNTFkUG5WMCtkWFQ1MWRQblYwK2RYVDUxZFBuVjArZFhUNTFkUG5WMCtkWFQ1MWRQblYwK2JYVHB0T091dkx1Yzk2dEozYmpiWXQxaXJIa1h6aHFkWlhGSmU5WWVGcHQ1TkRLREJqVzJNa2VQL3dCNmpUWk1UNmZYVTZ1dXAxZGRUdThuc3Z4LzFJaEV4VVN1bkExc21LcHhwZkJGOGpyK21WZ3ZZTDRody9lelhDUStCcjFJWDlXMThFV3VDcUcraUlLWVRUdy93R24vQUZqUCtGMXBQOEIvai90cWU4Ly94QUJORVFBQkF3QUZDQVlIQlFZRUJnRUZBUUFCQUFJUkF5RXhRVkVRRWlCaGthR3gwU0pTY1lIQjRRUXlRRUpRb3ZBVE1HQ1Nzak5UVkdMQzhTTndnck1GUTJOeTB1S1RKSkNnc05QeS85b0FDQUVDQVFrL0FmOEE5RU4wQW5TUDg3ckFSeFRxMGZ3dTZBcGRHQ285cFRXcHJkNm85aFJ6ZTFHUitMeDhDdVhxajhLbUFoSng1QlB6blgxMmFzZzBYNXYxaFl1aWNidkw4VDI2QlFsTkVJU3JmZ1ZvL0NocTRxcG1IUElEQlFrcDVwQ2FvYnpWRThEdDhsV1I3cnJlNDJKdGFxUnlHYVBncXdmeFhXalZjdTM0RjMvaE0xQmR3d1FydnlRNXV0VVVmYWlUQ3BEUlVacm0zZXZUaDJGT0RIejdsUWQ1aE1tbXNkR0Z4VkVWY2hYajJaRDBUWnFQdFJSL0NOM3dJZmhUMUcyREhYa3N5Q1czcTI3V0VjMXJhZ0xsUnMvS2ptaXlMQURpRTh3MjEwM3FrS3RXRm1YMTJWSG4rSzhUNWZIcDJxZHFuYXAycWRxbmFwMnFkcW5hcDJxZHFuYXAycWRxbmFwMnFkcW5hcHpqcnkrNkVaZFhFOFUvL0RiZHdUSmJNRTZ6OTZHdzBrV0c0OXFBelh2YUQzbnRVN1ZPMVR0VTdWTzFUdFU3Vk8xVHRVN1ZPMVR0VTdWTzFUdFU3VlAybEx3dnltdHRRUXlOemhqZUJxVDJVaDFpdUp4dHFYMlcwbzU3V3lJRlExS3dYWlFqT1F3MTFSOE1zZEtiZFVJTjJIbXZXZk14WlU0andVN1ZPMVR0VTdWTzFUdFU3Vk8xVHRVN1ZPMVR0VTdWTzFUdFV3TmFzOWl0RWNVRzdEelh1WnNSVmJuZHVDbmFwMnFkcW5hcDJxZHFuYXAycWRxbmFwMnFkcW5hcDJxZHFtQnJWbnNZYkRTUlliajJvTnpYdmEwOWhJR0tuYXAycWRxbmFwMnFkcW5hcDJxZHFuYXAycWRxbmFwMnFkcW5hdlZDdys1dnM1cnVWdGg3UjhjeHltQnJUeEdNaFBFRFdFYXduaUJWYmZncVJ1MEkxWXB3emNia1pUZ1pUd0xyYjA4UjJvMTRYb3pHV3dWREtZbGVzTFk3VlZKbllxODJYY2xkeFZLUzBWQVhUZW15Y1FqMHNQdWFDV3VKSTZUTERXUGVWQkRXUGFUMG1XQTl1aVpoT0I3MDRWZU5pSUY2ZURHdE9FRkd2U010WjBSM1c3OGdxRnFDRXhlRkRtNmtOS29sZXJrRUsxWGpKUjUrWk0xZ1d4RnBHQzlIK2RuL0FKSnVhOXN5TGZlSnUwRFdiRTRBMm8yMkp3akZQRTlvUnJDY00zRzdTRWwxWHNiYzU3ckJaZk42OUgrZG4va3FQTXo4eUt3Yk02YkNjZEF3RVFBalphaktlQk9zSndyc3J0UnJDTWpSdGQ3SlFTMTVKSFNaWVRJdlZCRFdQWVQwbVdCd0p2MFRNSndQZW5DcnhzUkF2VHdld3B3ZzN5alhvbUtsY3JZKzRzNDlpOWJnTUZhdmU0aFgvRzhjdlhhbW5ObGdzaVRPdU94RE5nQnV1Wm01V0VjR2c4MEpQMm9QeXBoOVExVlRiMnh2WHY1enV3RlcrRVo2d28rQzl6UFBkblY3bCs5UEJkYWlWemd6YUQ0bGRjK0dTNGFWamtMYjBiRFBhaDBtQW52VzN0cktxYUR1Yjl6MVJ3MHJLOXJZNXEwT2Z3VjVvMTZ3b3lEMmcxcnF1L1FybUYyd1ZLK2o4Um8rNjBsV25KZmxNRlE3dTVKa0MrdFVaSGVFdzk1VkdCMjFvZ2RsV2hZckZjU04rVFY0Nlh1a25aQ3NESERZUE5kWm5CV09PY1B6d2ZCWW45S3R6R2ZwWHVsdS9OMHJocEQ3M1h3T2xncldtdjhBMG5OOFYxbmNGWm1NQjdETmUyRmcvaXJxWThGL3pDNGZsaU9CV3ZpZEc0ZXlkVnZEU3NyMnRqbXJRNS9CWG1qWHJDaklQYURXc0hmcFZ6WE8yV0srajhSbzRwMWFmbndoR24wbmJnclRhVmFGV3IvajN1dUIySzRnN0VSRHdObzhrWXppTmtRVkg3VE83b2pCUUlCRnMzOWdSeGpzTmlJL1o1ditxSTJRb01nQXpJckhjVVpBRGdlOHlvT2EvTzd0aFVTWE5QYzFBZmFGMHozNDJvQXRjNmJUT3pOOGNtSDNYUkRzTmFyTHZ1ZXFPR2tmZm4vVEFrZHRTaVE1eDFRN3hVUzR0Mk5QWWo2N1k3MUF6QVFJSk1raU1BZ0hCclEzSHR0Q2d3M050SXZuQXEzUXcwQm10R0twcXpaVW5SclZKNnVoWWpHamF1c2ZESnE4ZEt3WjI4UWpjNEh0Y29obGRVMXhaZFZ2UkdjMHp2bFJGSWJaTlYxa2VLSXpYWm14dHFob2NHMVdWZ3poZ2dCMkdmQWFOM3NldmdkSzBvK3RFYlpLaUhtYTVxbTI2dmN2VkxBM1pLZ2xnSXRJdDdpaU03UEx6aFlnTTlwa25IRkFRSnJrNHpabStPamRWN0oxVzhOSSsvUCttQkk3YWxFaHpqcWgzaW9seGJzYWV4SDEyeDNxQUdBMlZ6SWpBSUJ3YTJNYjlhZ3czTnRJdm5BcTNRd1J5MWFpdUtCMm9EaWdha1VabkZGVjl5R3hkTmgrUEdDRTc5b2E3SzZ3cVNwcm9pQnJScURKRm1BVHVuU09pWTdPYU1sbGpvMTdFNzlvYTdLNndqMExPK09hZDB3NEFWQ3l2a3U4cDJhY3pPSmkweEtFRStzNkpoSHBaMFNuWnhiZlprdzlrNm80YUZ5ZG5DbDFXSi9TRG9zRmtkaWRVR1NMTFlDZDB6ZlZpVlNaOGdYQVFyV3hBd01vNThzemhkZEs2VEh6TlZsYVBSem96WStqb2RYS0pMQlVuNXo2UWlkVmE5eXRlcXlydnZWUWtjVUsvQUp1WTl4aGYzeW1yUXhXdkpxOGRDMEFxbDFXREUxcWtsN3I0RmtZSXdLUzNjajBTT2FQUXJIZUZVTHluWm9vMnpaYWptRjRrMzQ4bFU4dXpaUnppeSt6UXg5ajE4RHBPNlRTSXFHS2Ztbk1Cc0hTTVN1alNrcXR4Ry8rNjlZRUFhcmVTT2NXdHpnWWhPem0wdXF5dEhvU0FmSFJ2OWs2bzRaWFp1Y1lzQndWTjYxK2FFZW0wd0NuZE9ZS1BSTENTTllua25TMXhqTmp4UmtVZG05R1NQRlZVZkZIb0YwWnNlS2REYUlnUkZ0Y0oyWUF6TzdhcFZweVllT2dFTWxUQmZpcWdkdW5ZdHZzaFRrNVY1WEp5S3dUa2N1MU9SbklVNVdweU55S2NuSTVEQ2Q5M2dqSkJyMVZoQ2MxKzZ0R0E1bFd3S3B1ZWVJNUZVaGUwTnFremVFWkxUWHRISk5xejVud1h2QU8yVHlXcmlGTFhmWmlzR0pxczhFM29VcE5jd3ZVYTlWdGkzWmt3OWs2bzRhSDFXb01pdlVoMHM2TnkvZC8wdFRobkM2KzBvakUxelhDYm5EelJMaDltYmEvZE5YZ2oweWVsMlR5VHdLS2pzazIvWERROTVweStvNm85NnVsTjZicXU5T2dtSktyTUZmeTgwMkFLOWlHY2FVOUhVQnJ5V0t6UXZLd3lhdkhRNnA0THJjMDNPaGxuYUY3cmp4Q01qTnUvd0JTYlZuek95cFloUzEyYUw2bldmWGNwWWMwOUlHTWF2ckZXWi9Ma3EyNDZGOWZzZXZnZEl3N09GWGVobXZhd0VPN0JZaG5PZ25DYmVTOTBsTmtaMTNhYTFOSXdNOExFU2I0Sm1LL29yTkxpNlJiYlZibzNqMlRxdDRaYkNlU0ZVUnhRcno3TWZxVUlJY0RDdmE2TzlxZ3ZMckZlNERlVTNOem1pcnNBV0hOU0NYZXJOaWxyNUZVMU9ydGplcXMyakVkdWFQR1Y5VjVPeERRdVY2N3VmM0o5bU9uaHBESmZvNExESTBvSzc3NWdCMUJNRUhVRXdHTlNiSVRRTzVNQW5VbUROd2lwTkVpK0VKQ1lDQlpVbWdoTkdiaGNtZ0RWbHg5ajZvNGFMQURxQ1lJN0FtQ1RWWXFKdXdKb2IyQ0UwVjI2KzFOQTdLazBBOWlvbTdCb2lHek8zS2FtaUIzcnIrS2NSZ25aelFuWnJUOUJHUUc4VXpQTTFaUG82TjFaeTZ2SFFzVEJtNFJVbWljVlJ0MkJVWTJCTUdiaEFoTmtKZ01hazBIdENGV0Z5RURWb1greDYrQjBtQW5HRTBIdEVwb25HSzAwQ2NFMFYyMVdwb0hZbWdIc1RRU0xOSDNUN0oxVzhNclFZc1RRU0ZSaWV3SmdNNmdtaVFtQ2NZVkdLOVFUUm5ZM3Bva1hwb3pzWXJUUVRqQ1lEMmpMaHdSUWpMMkZYNlFqMnJEVHcwOFRvWDVNRmhvM0lvajdoaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNJRUhYN0d3MUFCTU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TU81TkljeW85bmxrc3lPNk9DdVRZZGo5WHFoem5Oc1JqTytveWkzUnRmWjJlZVVFNTBKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNKaDNJRWV4MWdja3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3c3a3cxOW5zakRVQUV3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2t3N2w2cW5RcU1hRlFLdU9qYjdOWmt0V0dYRllhZUowc01yVU10bjRBc0tFaTVNc1RVU2lFTkM3UjlRVzY5WDRpT1VJWmJVNnBHcFJIdFZtUzBaTVZoa3cwOFRwWUxETGhrc3lXZmdDMjRwbGFNMjFKc1pXcDllQlFJYVZab0NHM25raEFINGx2bFhjTkVvKzFZZUdpY21IaHA0blF2QXlZWlJrRmliYXJEK0FyYmltOUhGUHpydWtxSE1tOVVnUGJWV2hLQkNyR0JSZ201Q3RXNEJkQmd1dlZnL0VwVnZndldGaUZZOXZ3eTQ2R0duanBZYVdLeC9BZGlPYVZXRlJ5VXkzZ2hmTmFyUVhRYWhMc1QrS2FrZEVlMUhKZmxHVEE1RENjVmJrT1M3TGdNbUdqZmtQNEdhQ21CTUNvd2hIK1JKUlJSbklVY2hSdFJSUnlWRlFqa05pSVdFSW9vb29vMlpDb1ZaLzhBdzBEbEtQOEFuU1VWZXJjaGpISmFMZndNZmd3bFZLazNvY1VFOHpnYXh2UWlrbzdSNGo4YlZvZXRpaDZxc1RyRTJzS3czbzFXSXlEVWhaa3QrQStxNzRFUDhWdFk1SHRYdkNkSjZkUHRaZ0JWREwzbE9rcTVXSVM2eHZhajYxWE5HQUZJQnNKRlczOFptQXFzU2pWWU8xVjNaSzVSZ2k1VmxHYzVDRVNhNVFtZnJkOEN0SitBMWRxRldJUnF6bngyWjJnWUFSK3lvRFlQZWQybTVOajYxcU5rYjFWN2JhY3Q2dlZnK2lybDFVTFZaK012b3F2RW9RMXRpQmhBcVFub0EzYXdpWlZZVXlCdlVpUHJmOEN0TzRhVm50YjVCdWhmdEtXcHNjVmFCWDI2RmJLRzdGM2tqVWJ4NGhldGhjNEsrNjVNQ0VlMENWVTd4MHJGYllGZmsrcTBKaTVDQ3ZvL0doSU04RlI3enpWSHZQTlVlODgxUjd6elZIdlBOVWU4ODFSN3p6Vkh2UE5VZTg4MVI3enpWSHZQTlVlODgxUjd6elZIdlBOVWU4ODFSN3p6Vkh2UE5VZTg4MVI3enpRZ1I0bjc4SUlJSUlJSUlJSUlJSUlJSUlaTFZXVU0yYlVaSHV3aldjaFRTWFllS3Z5WElIT0trZ28ycXNxLzJuSFFzQzlXNzRDWVZnUTZEYW1EeDBUMHc0bWUreEMyMEt1TFBiTVJseE9TL2dyU3F3M2pmbDk0OEZhalhDOWZISDQxcjRIMlRxamlmdjhBWHhQc1ZsSHhWVXB2cTJKM1NteFgyWkNoVUZhRGFoVTdjakFHUTFYSW1BblYrS3RDczBHVmtDODgxUjd6elZIdlBOVWU4ODFSN3p6Vkh2UE5VZTg4MVI3enpWSHZQTlVlODgxUjd6elZIdlBOVWU4ODFSN3p6Vkh2UE5VZTg4MVI3enpWSHZQTkNHWmNkQ3kvUjZUazdURWdxajNubXFQZWVhbzk1NXFqM25tcVBlZWFvOTU1cWozbm1xUGVlYW85NTVxajNubXFQZWVhbzk1NXFqM25tcVBlZWFvOTU1cWozbm1xUGVlYW82N3F6YnR5R0ZYNCtTUCtHMzF6OWJFSVkyclJxbHhqN3FrcURpTEJqMko4dGU5Z05Rc0xnRGNxUGVlYW85NTVxajNubXFQZWVhbzk1NXFqM25tcVBlZWFvOTU1cWozbm1xUGVlYW85NTVxajNubXFQZWVhbzk1NXFqM25tcVBlZWFxUVhhVmVNbUdXNUN2SVlDRU5GblpqMzVMcThucTBuSEs2Sm5EVmlxWGMza201ejNDczk1d1ZIdlBOVWU4ODFSN3p6Vkh2UE5VZTg4MVI3enpWSHZQTlVlODgxUjd6elZIdlBOVWU4ODFSN3p6Vkh2UE5VZTg4MVI3enpRZ1hmQk5mQSt5ZFh4UDMrdmlkSVhUS2I2cmcyM0ZObm9sMnhEOXB1cWxNaHJ6RnRtNEp2cW1JeHJoRDlwdXFuUnVYdkswTG90VmE5VnFzeVdwdmVoMGJBb2JGYU02a1lEYkNuU0NuUVhaQkFHaDFSdzBqVzJvcDA1MHgzV3Axa0RiWWpZSjdrYTRtc0VWZDRUcW4yTDFvblI3RnIwNzlDMHIxamFjaDB2cXJTc0NkMGNVZlZ0VHJSUGNqYklzSnN0dVJ0TWQrR3BIcFd3alpWbzNaQ0IzU1ZKcHFXejZ1bEgvRWRXOCtHbFVLU05xeGhHb2ZjT1ptdk9jS3pZYStxblVlYXg3WEdzMkF6MWRFMXR0VHJTUnN0UjlXSjc3RWJCUGNqWGJXQ0t1OU82SnZSNlJFNk45U05hSGVuTHV5MnVWcnExV1huZ3J5VWFrT2lEWHpWdkhKWTVYTDNUbExSbVc1eE4vY1UrajJ1LzhBRlJuTUZjV1duUVByVkJHdUo3Z2o2MW5lbmRHemZDUHEyMUdCM3hDTllyVHVqanUwYjZ2Z3V2Z2ZaT3FPSisvMThUcGU2RzdEbkJXbDFHZHNsZnVucXoxaDN0TTcrSzZ3L1VoTTByanNydlFqTmU0Y2RIQXF4VnAxWnNWb3kyTnlBa2dXSVMwM0pzRVY5b1FCenFsQXphMFp6azZFUUVJME9xT0dsNzB4MmovL0FFcmpTSzkxSHdYckNqZzlvY1YxWC9wVG9pam52cWhYMFk0Nk41V3ZTdjBmZCs1K3FqcGRVOEY3cE93VmppRmlQMHIzR1QzVFh1WFdwUEZmdldmcFRxeTh0aStJamlGMTNjZEhIaGtxaTdIVkpWcDlRZjFLM1M5MHd2ZU1ycmZjZFVjTks4SGFBQ1BGWE9mK2tML3A4VjZ6S056VDNFZUN3ZCtsR0JtdU80Z2NWZlI4dEh0eXVsT1ZneTNLeXNLKzVHQWJBaGx1WHZpVUppdFhnWk1ScFdnazdCUGdyTTF3SGMyZkZkWm5CV1Voa2RvZkIzUXNYZnBYN3RtOEl5R2x0bXVOSHQrQzYrQjlrNnZpZnY4QVh4T2tKenFqM0p2clJQZFloNndneVNhdTlEMWJPQ1lYUllKSjNFd213YTk5cUZjemFSWHRXOHp4ME1NZ3JDT2hVcjE2M3E5bXRYV0ZFNjAyYzZ6bWhFV29YeW1yM2JWVURvZFVjTkozdjUzbHVUK2tDNDJkYTYzeFR1a1hCMW1GeWRIMmdqelQ1Z0VDQkZ0OXBSenVpRzdPYXBCVTNOckd2L3VHanJXR1cvTHIrKytxanBYaUZTVExRM3NzMTZrL056N2FwN3hXRllHNXFmNmhkYU1lOEowdXpnNDFZWEoxWU16Rjh5bmpOSkpzcnIxNTNob1lLOURrai84QVRVTzhvUmhxMHhXMnNkeTdObHF3SjIvY2RVY05KMXJnN2RFZDZkMHM0dXN4dVQraytMc05VK0tNWjdjM3pUNXpSQWdSYlZOcFRwaHViWnJsUDlVRVZqRXoxZ3JkQzRESmFucDhvUU1tSXlDUW1BZDJsYlJuY3J3VmNCa3hHa2ZWbmVJVHBqT25Ybko4dFpaVkhaTmFQcW1aNzVWSkRhUzJxdmJQZ25WZEdxT3FuUm5BQ3pBektJUFlJOFRvZXQ0ZkJkZkE2TUVpMU5idjVxMDg5RGJ5VHljanlGVnI1NlBWOFQ5L3I0bkk0dER6WEZ0eWNSbk9OYzF4VmVxUWdCOEV6WENwSEJrdXJybUt0cWVjeHViTmRzM2xHcG9rOEI0cDV6M090a3lxUXRCWmNUYi9BSFR5MHNZRFZWaGFuVk9vOWhpbzdWVzdORzJGU0Z6czF4ZGVCYkhncVFuT1pOZHhtNVBMaVdBMW15eWVLZVh0YkZacnJ2V0J5QzlXdXlXSXBzYTBlOWQ2Nk1JK3RhakJ1N0VPaWJFRG5DN1dxZ3E1MGVxT0dTNEo1emhYTTExcHh6c1pydEtwM09MaUo2V3F4UE5qWnJ2VHVpSUJ3clR1aVJIWVlUeldUTmR2U1R1Z0lHcXRUSk4yQ2VYQnRoTnRxZVhBMGVkWFhYQktwQ2Z0VEJCc3RoVXVhNE9xYk1DT3kvSnJ5M3E3N2l4NCs1K3FqbG8vOE9ZenZKTS9aYTdkeW9wTDlldU1FSUxiazIrc1RmT01lQ29ZQmlPbGJQY3FPSHN1blhGdmVxUE9lOFRFK0tIcTNJUXFPV01NRXltWjRhSkptRTJjK082VlJ5eHBndW53V0N1VmRKU1c2Z3JHMzRuN2ozcWtheDZ2ZXJ5QnN0WHZtcnUwTEhaZXFPR2hTbHVhSkFtK3FwVWhZQzJ1dU1VNHpNQW85SUdDZnJ1VktYVWNDRFBTbVI1cHhnc3gxRmVzVGRncVF1RFFLempJSGlxUW43Ums5SzR3ZVNkSkJxN1U0a2dpM0xaQVJSMGJVSjNGQW9JSUlJWlBlQldHWEVhR0NwU1hGMFJNMWRpZWVpYXE3S3pZcVF0QmJiTnBydEtmYmdiYTcwVG1UbXhkWnpVeVRkZ25sd2JZVGJhcVNjOWs5S3VDbm10OEU5d1RpOXJUVVQzNWNQZ3V2Z2NwZ0tvWThzdXZpY3BxRnVsYUxPekRRNm80bjcvWHhPUWpPWWI3RTRmYUIyZHFyL3NpQ2MvT2Q1SXQvd0FNbUptK05TZU04eFpNY05pajdSMnlwUHFiTXhiWGhVaUlaTytkV3RPRVBFR2ZCRVJtZ0R0QzlZTkExVENMWWZNbXZPNUp3cWJtaVBGUGJubG9hTGJPYXpjM1ZNOThxOEsxV1pCYmtOUnkyS3hHYjA2TGxXQllxemlpcnRIcWpoazk2QjRxMXpMdFVja2VrMkoycTV6WnFpdGU2OXJmMUwxYzRkdDhjVmJtTmNOZ1hXUDZsR2JuenIvdFdyWDJkNmRuVWxUalVjZkJDUUtPTy9OSVE2VkdUT3F1VTMvRkxxcXJxMWF2ZFBITDd0YXZ5MnRyVitoYTNKWmtIM0J6NkVuWVY5VmxmWFNLOTU0NW8xQndJN0NmSlB6cGlLb2pvMkl6U0NCdkhKZFFjQ21sb2M2RE8zRW8xQXlPdy8yUXJkVzVYTTVMcmYxQmRjTEFMMXBxR0tNMHRKdUdrTkFXZXNxeEUvbVh1Q0IycTIvS2N2VkhEUXZGWGJWQ3RMRC9BRlI0SzNPamx4VEE0Z3lSZHI4Rit5SUcyUjVvd0F3Y0N2ZXM3MDdPcFRXYWpjUXJLTmtIdGdwK2JENXNsT3FuQy9ITGVFVTZ0ZEptaUpUQnN5T1JSdHlZclhvWWpRd0s2eEJYclBOV3VzcGtOemJid1Zkd2xXWi9mUEpXdXNUczZrcWNhamo0S3hqQUQyd2gwQlNWN0F2MlpOV1c0L0JkZkE1TFFDblNkRFh4T1M2dFduSVlaeFRkNVJscHlYSFE2dmlmdjlmRSt4V09yR1cvS2N0WVhTR0NNU3JsVU5QcWpoN0RkWGx2MEwxN3VqVW1LalZXajlWWlppWmlha1NNNjJEYWlXNWdnUVZQUk05dmJzUlBUdCtvUk1OK3NFU00rMzZqVWlRV0NBUWExTU1NOXZhcGwyeFVqd1hZSHlSZE1RYTdlMVZmWjJmWGNwZzFrVFVjalpnVmFCaHhSSDJqakFGcDc0dXdWbDNpRjJhRlllcldtVzZ3dmVoVytDRmF1ME9xT0hzTnlCSk5nQ2JtUEYyclZrdXlHdEFxUWpwV0RSMWV3M3EzNEpyNEhKZ2VDb25iQ3FNZ2RoeTYrSnlZWmNNbUl5M2djTXZWOFQ5KytBT3hVbkJVbkJVbTRLazNCVW5Ea3FUY0ZTY0ZTY0ZTY0ZTY0ZTY0ZTY0ZTY0ZTY0ZTYmdxVGdxVGduU1cyYVJWNmJrc0tzZGtPU3ZSb3JBQmI1S2krYnlWRjgza3FMNXZKVVh6ZVNvdm04bFJmTjVLaStieVZGODNrcUg1dkpVUHplU29mbThsUS9ONUtoK2J5VkY4M2txTDV2SlVYemVTb3Qva2hBMDd4OTZKaFVYemVTb3ZtOGxSZk41S2grYnlWRDgza3FMNXZKVVh6ZVNvZm04bFEvTjVLaCtieVZGODNrcUg1dkpVWHplU292bThsUS9ONUtoK2J5VkQ4M2txUE5Jdm55MGFJT2ViNysxVW1lMXRVbkhSdFZWS3pmcVZUMjJqVG9welFCYjVLaStieVZGODNrcUw1dkpVWHplU292bThsUmZONUtpK2J5VkY4M2txTDV2SlVYemVTb3ZtOGxSZk41S2krYnlWRjgza3FINXZKVVB6ZVNvYmY1dkpBRmVvN2NzQ3NTclYwa3dLajJLY295R01sMmd6T25YSGdxSDV2SlVQemVTb2ZtOGxRL041S2grYnlWRDgza3FINXZKVVB6ZVNvZm04bFEvTjVLaCtieVZEODNrcUg1dkpVUHplU29mbThsUS9ONUtoK2J5VE0yZGZ3VFh3T2hobDE4VG80Wk5YSEwxUnd5OVh4UHdLOVZKNmVpcTh0dVN2TlY2Ymt0OXV1K0JtRTl2QkNRM0JYYU5oVlZKZUxuS2dJZHVSazdoN1Ixc21PUzVWeFlnb1RtcHdSRzFadTFRN3NyVE14dS80M3I0SFF3eTYrSjBjTW1yamw2bzRaZXI0bjROWWlpaEJSUlZ2dHhyUVErQi93Q0cvd0NVNndkQS9CTDhsbDZLdDBUbWhXZkc5ZkE2R0dYWHhPamhrMWNjdlZIREwxZkUvQkxORUlxOVhJSzM0R1V5VStPejJ4c2hPejZQcXU4Q3FKMUVkeWVIZGgrQjJGV0hScUtwZ3FZSjJkdVFBK082K0IwTU11dmlkSERKcTQ1ZXFPR1hxK0orREZCQkJCQlYvQXduUjJJVi9BV1FjUlV2U250N2EwNW5iaW4wZXhCdXhQWnNYcElhTUExR2ZieG9oR3JENDlyNEhRd3k2K0owY01tcmpsNm80WmVyNG4vTnpYd09oaGwxOFRvNFpOWEhMMVJ3eTlYeFArYm12Z2RERExyNG5Sd3lhdU9YcWpobDZ2aWY4M05mQTZHR1hYeE9qaGsxY2N2VkhETDFmRS81dWErQjBNTXV2aWNtR1hESnE0NWVxT0dYcStKL3pjMThEb1laZGZFNUx3Y3ZyTjRaTGJUa3YwT3FPSi96YzE4RG9ZWmRmRTViRFdNaGdxazRLM0pZempkb2RYeFArYm12Z2RERExyNG5MNndzUWc2QVg5OURxK0orRDByVzlwWHBHNTNKZWtEWTRlQ3BBN3NQK1dXdmdkQ3dwbTg4MHplZWFFQWFEWlRpTjZwZDNtaVhJUU5IcWppZmdwbDl6UmI1SjMyYk1HODBaeW1DajlxelhidFR1bGUwMmovTERYd1BzblY4VDhFcnBqOHZtakxqZVV3L1p6RTNUa1ptbHdrZGlibk9kWUUzTmVMc2dOR1NNNXB4Q3FwbTI2OVkvSFJ6UnZYcGpXSFc5Z093cjB4cnpxZXc4RTRFRHVSK0kzQjM2U29VS0ZDaFFvVUtGQ2hRb1VLRkNoUW9WcFlPSitCK3RZMFlsR1hPdHllNVNjc251MGJmRmY4QUtiRGUwcjlvdzVqL0FLK3Jjbjdya2pEbXErMFlHLzhBQkd0RmNVVVVVVVVVVVVVVVVVVktxUlJSUlVuSVVVVVVVVVVVZllMcWdxUTBmb1RDVzlHcDFNUmJYY3pqdzlIWVA5T2NkcnBLOUhaM056VHRiQlZJYVgwUi9SSWRXNmp6cWdRNjlzN01sQStsZTh2OVNMQm00a2RaZjhPcDlyUC9BRFRTMFB1UFlkTDBla3BYdmJuZEhOc0JpOGhmOFBwNEd1ai9BUEpBaHRLSnJ0K0RZTy9TZlpPb09MdllqbWdwOGhHR2hVbGV0VkdZM3Frbk4xZWFxemlxU1kxYSsxUHpjM1ZQaXFXZTcrNkVFS2x0R0htblowZHhSaVZUZkw1cDJkSW15TWg2TkZ4TnVTbUZFQTBtVGVjRmRCK3RpOTV6ZUs5MkJ1VnZwRDU3aC9aZFhPSGFQb1pQM1E4TWg2TkpaMmp5eVdsVWxlcE9tVSs0bUl3NzBZVHM2cWVPUTVvS2ZJUmhvdlZJWjFxb3pDZm5WeFpHT3ZKUzJnR3p6VkpNYXZOVkFXbFVoenU3Z3F6TUtrclJsT2pVblp6VTdOalZLTXAvZEd1TFp5MGh6dTdndTQ1S1M0bUl3NzBZVHBtTHRaQ2ZuZDNtblpzYXBSOTZKVDg3T202TEkxcWtpZFhtbloyN0kvTmpWUGlqTUorYm02cDhWU3lleVBFb1FSN1RyMEdvYUF5dDBLTW9WcHVnd2xOZ1pHRXFvSVNtK3lXaWpwRDMxd3ZkWTNlSk84cXVqZVhraXljMXRWbXRWVWJSUnVBcnFuT21KeFZqZ1J0VlFMUVVJTHFPbWR2Wkc3SjZJK25MQldhbU1uL3VjUko3bDZNNzBWenFnNGtGaE9HZTBrVDJoZWowbE5TT2JuZEN1b0dLNWUxZjhPOUlxMUQvQVBxdlJLWjVwV0NrR2JGVFNZci9BTVFML2gzcEFBMUQvd0RxZ2MxL294SW0zOW8xWUwwUi9wRHFOb0JNaGpBY001eEVuc1hvei9SUytvT2tPWk9HY0NRRDJoUERhSnRlY2JJWG90TDZTT3RVeGg3QzR0bll2K0YwZ0g4ajJ2T3dPbFV1ZG0ydE5UaHFJTlk3OXZ3SEIzNlQ3SjFCeGQ3RGVRRlVENFpMWS9WL2RlOVV2ZUxlS3ZieGtlQ3VrckgrdGF2Rk90Zkh6TFdFWXFieENNeEcrVmk3eFRpT2o0bEdWY3JYRW5Jd09hMmpOcS81dEdmcmVoK3prbnU4MTd6anhxWHVVYzdmN0t5a2FXK0s5MXhHOWZ1eGs5MXd5ZlZTc2p4T1RxTzhWZ1YxUnhLdklDcUI4TWxzZnEvdXZlcVh2UnVLNnc0SElZT2Ezd1R5ZTlXbVRzL3NqV3JoeC9zallZMkt2eXJWa1NyQlYzRlhEeFgxS3dINnNsNWpaL2RHdVpXSTM1T283eFdCV0E0bFh0NThsaDRycm5pVi9ONExxdThVNlE1ZTlXdmZkeE1jRmVGcThVNHdIR3JWSzdQcmY3VHIwSEsvTFlxb1Zhc2taR2hXNU1BdFhqa1puSnFFWmJVVmJrc1ZHZ0ZmN0QxSGNWZzNnRi8xZjBoZFdpL3F5Q1hDb1lDTlMvZFV2Rm1ScldzZXpQWUczTkRzMk40c1ZqZ2ZydVJseDlFL3JZc0N2NFJuKzR1cTdndjRUK3Rxc1RHdGFhTnRJd05zRENTMk8wS3d0UENyWWEwWllLRVV6eDF6NnJBZFV5U0wxWG1BbllKUUFlM01OVmtQYm5DM0JWUG95QTcrZWpKQUlPTVdqQmU4QWZnR0R2MG4yVHFEaTcySEVMK2J3eVlONGhZcnJlTFZlemdUelh1MWIvSlhnZnFDMWVLSHZ6c2N0WlZwRGZCVlQ0Sy9POFUrSUVJekhKZFIzQTVmZG8rYXJ6YmV5OVRuK2xqb2FwdFh2T0EzcWh6bUJvQU1oVU5UWENheFpmZXJDUWRvVjlFTXZWYndWeXIxM2hWZzJGZFIzaXNDdXFPSldJWDgzaGt3YnhDeFd2d1hXSEE1REV0YjRKOHlZNHJxTzhjbXBkWjNFcld1cU9KV0lXdjlTdGFYRGZJV3I5V1RFNU1HK0dUcU84VmdWZ1AxRmUrMGpaV3ZlRTcrYS9lSGl2NXZCZFYzaXRmQXJEeFZ4YnVWeGpiL0FHV3J4WFdkeEt4SHRPdkxZM2txTVFyTkRISmpvWUxBTFY0NWNjdU9uZ1BZdW83aXNHOEF2K3Ira0xxMFg5V1RXdjNWTHhaay9obmY3amNuOEovV3hZRmZ3alA5eGRWM0Jmd245YlZndjRSdis0dXE3Z1ZkNk5RY1hMcU8vU1YxUFIvOXR5d1hVYjQvQU1IZnBQc25VSEYzc1BXSEZmemVHVHF0NGhZckVmcUhKWGdoWS8wam11cXp3V3J4Vkg2cEl0d1JrbEdDQTN3WHJBYnh6V3ZndXFPSnlYdGR3T1hBREpyWFhHNVU3bXRCZ0FFZ0wwaC81aXYrWlJncHdKeklPN0xjQU5neUZYSG11bzd4V0JYVkhFckVMWDRaT3EzaUZpdnF0ZGJ3T1RxczRqSjFYZU9UVjRyckhpcjU0THErSldJVi9OZThYYlFTcm5jWHo0NUxuY3NuOHVUcU84VmdWZ1AxRldpZkJXT2FSdGdqZ3V1ZUpYODNndXE3eFd2Z1ZxNHBzZ2F3dldBQjVyVjRyckhpcnp6OXAxNVJMWEtkQ3hPelNqbkZZakljMU9WaUZpRmlia0NDQ0dTa0VaSzBNZ1FzOWgvZHU0bGRWdkFML3EvcEM2dEYvVmsxcjkxUzhXWlA0WjMrNDNKL0NmMXNXQlg4SXovY1hWZHdYOEovVzFZTCtFYi9BTGk2cnVCWDhOUWYxTHFPL1NWMVBSLzl0eXdYVWI0L0FNSGZwUHNuVUhGM3NSaHczRlBraEd2dzhrOFZLd09hQnRWM05lKzRjUEpkVm45SzFlSzZ6dUp5WU40aFhWcTZlQ2RGVUowemt1TlhaZGsxWk5hdW5ncjN1NDVMZ1cvV3hDRzBvbHVTeVpQWUs4aGdGUDZQWWpYYVVheEk3aW5pdW9kNjZvNG5JWWNOeFQ1SVJyOFBKUEZYMVdyQkFDTVFaVHByamlqRXRiNEo4d01GZlo0aFVuUjdLMGVqV0o4VStNNzZsSE9pQ25KM1RQSHlXSGlybm5pcjQ0aklZRHVLZDBKNzBiTGUzSWF4STdpbml1b2Q2d0hFcitid1ZyQ3V1ZUpYODNndmVCSEZQcityQXRaOEFud0FxeVpDMWVLZmZPQVhxdDlwMS9kNGo0TDc3SHQyeXJRME5QOEEzTjZKNEtqTklLSXVrTjlhSE5pb1hxak5HS1RNRFE2cDNSbVRGeXVHKzRJUVlyWDdxbDRzeWZ3enY5eHVUMy9Sbk5IYUMxM0RJME4rem9XMFE2UU9kRGljNnF3ZHE2cnVDL2hQNjI1QUI5blJOb2hEZzdPaHhkblZXQ3kxZFYzQkNCUytqaG4rdGh6bzd3U3ZlYVJ0RUpvWTUvMllpUTc5bTJKcXhsVnZwbk5IY0NDNDdCdlh1dEE0L0FNSGZwUHNuVUhGM3NSaE9KN2NqeVIyL2ZDeXAzZ2Ntckk0bHJiQmgyYUJxRnlObVFWdnFiMmVlVjVqdE9Rd1U0bnR5bUU0bkk4bnYwM21PM0k4Z2R1UnhIWWpPazh4Mm5LWVRpZTJ2NE5yKzd4SHdXMjVSMDYzMFpzSjZ6Y0hMMFo5RTU1elJNRnMvd0RkUGd2V2d4MjNMMFgwaW5wRzNCcmN3SCtXSEFkNmFXc05nTnRYWktweFJtamE1dGJjNmM2Tll3WHByUDhBNC84QTJYcFRXbWlZV2VyTWdtY2FsNmF6L3dDUC93QmxTUlNVVVpqeGM0Yzd3cVdpY090bW1kbWRDOU5HZTVzT3ptemZOVllnYWw2YXlEVit6LzhBWmVrdFlhR2krek10bWE1eEM5TlpYLzAvL1pVN1MzcXZCTWRoQkJqVVZTZ3NiWG1NRUNSak1rcjFiamdSZ2JvWHBUYVZ0MmUydmEwaVZTMFRCaUdrOFhKLzIzcEI5NDhNQUZhZmdHRHYwbE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeE5PeGRRY1hmQXhMWFZGVnNQcW5FYzAvTnoyZEhXYS91S3FOdnJIdzdTaEFINElDYW04RUUxTjRJY0VPQ2J3VGVDYWdwMithQ0hCRGdnZ2h3UTRKcUhCTjRKcUhCRGdnaHdRUVFRUTloNlNmbVVqSEI3RGJEbXFpb25kam5Ed0s5SG8vek8vOEFGQ0h0blNlVVowSEVKNU9VL0FqQlZLNzh4Vks3OHhWSzc4eFZLNzh4Vks3OHhWSzc4eFZLNzh4Vks3OHhWSzc4eFZLNzh4Vks3OHhWSzc4eFZLNzh4Vks3OHhWSzc4eFZLNzh4Vks3OHhWSzc4eFZLNzh4VGk0Ni9nZ2tIZHJDR2RSM081NGFmUW91dGoySnNOSDFYK095anVSM0k3dnhVSkJSK3lkdTJKb3BCcVBOZWpQOEF5bGVqUC9LUWdLTWF6eVgrSzdYWnM1Ly9BR2cvLzhRQVBoRUFBQVVDQkFRRUJBVURBd01GQVFBQUFBRUNBd1FGRVFZUUVoWVRGQ0UxRlNBeFFDSXlORUVqTURNMlVBZGdjRUpFVVNSRFlTVkZVbkdBRi8vYUFBZ0JBd0VCQ0FIOHo3L2tkQVhRZmY4QXorUi80akwrZEw4K3cwLzRBNmYyZmUyZnBrUktNOHZRWElmYTR2bmNYRi9QZklzcmkvVWRmN0E2L3dCeVdCQTBqN0Q3WEhUN1pmRVAvQUwweUpSQy93REI5YmVRN2o3NS9lNCs5d1F1ZjMvTnYrUjl2NzkrL3dEQ1h5OWMvd0Q2NkdkeDBGaXNPdHJaZmUvK1p5L243ZjhBNmp2L0FEWmYyamIvQUFxWDVTU3VIK1FUQTF4b3N0VDYrR3YvQUFSNkYvY3FrcVdoU1UwTGh3dmpsMDJvMHdxbWt6UDEva1M2alNZSkEwRU9Ha0cyWDJOSmw3OUNGck95VTBxU2ZxbWtmL0x3cG9lRk1CZEtML1N1bnlFZWhwTkoyUDMvQUZ6NitZK2cvd0RyM054MThsL2YzQnJJZ1NqVUxXR2swcDFIY1hHc2V2OEFBRWRqRlVoSW4wa25XV29UY1AwL2tFb3VPaWZMY0dOSkdEYnQ3c2lNenNVV2xHZlY2T3cya3Z3aWFVWlhIRFdOQTBneUZpQ29qVDNSeVRTVm9NemFzWkgxOTBhdW9JdjRXMlZpenNMQ3hqcjd4U3lTQ00xaXdzV1JrUmhUWC94Y1pjMFhRMXFVNTFJei93Qk4vd0NBdzhkNGlpVldHbVNkUzh4K2FYOENSR1lJaVQ1U0gyeUxLOWd0TitwZTRZWWNrTDBJaHdXMkM2VzZXQmFTQzNFTXB1YUpqaTNOS1V1UGVoTG1td3JTNlNrTExVTktBa2l2ME1yaW9VOG52amJNakk3SDdpOXdSV0YvT1dWdmRsbmYzbHZMY3o2RnBQN2w1bGxjZzRoVGpkeWFLeWJaRWR2ZjAySzA0MmgwNnVodEVRaUwrTjlRbjBCbWVYWEs0dm42QWhiSlpGNmw3WmxwYjdtaEVXS2hodlFuU1JaT1JXMXF1RXNTRFdacFFhaldvMXJjL3dDVUtaTjA5Y1o5aHN6UVhOTUFqSXk2Rllpc0ZGY1ZPRnJJM2tlM003OUFrWElmQ0R0NXlQSS9VRjdnc3IyeXNMWmxtZnJrUiszUC9nZWc2Rm5jWDhqWnFhTzZTSzJSZ2pzZnRiL2trb3k5TG1mOGNoTmlCbmwxTHFOUkFqSFFhUnBNaGZ5a0ZGWS9iVStJVVZtNmovOEFJc0hVcU5zOUtaTXBsS2pEVERTMnlXWnhpTUlkWWlPS2FYSDRicnFqVVRMUXNSQlBROGxGY2hVSTNMdjlQYW1ZSWZZR1B2NUw1bFlXejlQY1hTTEVOSTZXSHJsZk1nV1JlM003QTNEUjZBdlFYeXNMQWs1R2RpRERqUjYwdU5PYXl6TUpQODh2NGx4Um9iVW90MlZVYnNxbzNaVlJ1eXFqZGxWRzdLcU4yVlVic3FvM1pWUnV5cWpkbFZHN0txTjJWVWJzcW8zWlZSdXVxamRsVkc3S3FNTzFPb1ZSMVp2Wk5OY1p3a0ZMS3l5akluTU5SNDFnM1RqY1kxRjFMb2R4Y2RMQTBmOEFGOHVvTDBDeTZaczB0aHhsS3pxc0Z1RlRINURlN0txTjJWVWJzcW8zWlZSdXlxamRsVkc3S3FOMlZVYnNxbzNaVlJ1eXFqZGxWRzdLcU4yVlVic3FvM1hWUmdxVlByRWxiMGdoWUVWckVkaklmWVNJeWxwL0RRMjhoVmlONlFaV0ptRWFrbXBURWREQldMTDA2ZzdLNmtLbXp4WXBtV1VDRzNMMWEvQjR3eERXNTFMckRzUmpkZFZHNjZxTjExVWJzcW8zWlZSdXlxamRsVkc2NnFOMlZVYnNxbzNaVlJ1eXFqZGxWRzdLcU4yVlVNWW1yRWg1TFNHeVhwK01peVBKUXVMZzhpLzV6c0xaRmxGYVMrK1RhdkI0NHhqSmVvSk1jcnV5cWpkbFZHN0txTjJWVWJzcW8zWFZSdXlxamRsVkc3S3FOMlZVYnNxbzNaVlJ1eXFqZGxWRzdLcUdjVDFoNTBtMElKV2t0V2R6dGxZV01XSFVFVnhZeUhVV3pMTm1sc09NcFdkVGdOUTZhL0liM1pWUnV5cWpkbFZHN0txTjJWVWJzcW8zWlZSdXlxamRsVkc3S3FOMlZVYnNxbzNaVlJ1eXFqZGxWRzdLcUtlN0tkaHBja3RIcnVveTlCOWhiek9Lc0M5ZUlFRncxR1E5TXk2SC9NUC9BS0tzMm1IbjFhV3VSbThUaGhVS1loWklVYlRpVUV0U1ljdGFpU253Nm9HZGdwcDFEbkRWeTcvRzRJV3k2MlYxcWp5RzdtcEVTVzRka0hFbEpYd3pKbDAyamRKYmJqZHRXVkFoSmhVMUJaR0lieUl6NU9oaDFtWFZTV21xL2pTMHNOMUUrVmhhU2lOS2RmSklxQ0cyMitHUnhGY0hXTkN0T29HZGgwTUdSa1BYTStoNUl4aGg2TWdtWEt2aS9EMHFsUHNOZVJiVHJhU1V0Y1dTMlJtdE1lUXNpTktHSG5DdWh5Rk1adHhDalNGT0cyWERYdytKNXNId09Sb0xTUVJEL3dBaTEvWDRpQkxTWml4NTJGZ2FiQWxKTXJGWWZib1hYb2YyRDdmQ2RVakptdVV5akdmTzczd3lNU3pZMVFyajBtUG1ocDFhVFVsRWQ5eE9wQk11bWFpTGwzK0p3d1VHYXB2aUViYmlVRXMrV2trN3dUOHVIb0twazRsZ3N6QkMxd1pDMlJEL0FNWkY1Qzlja1RZMU9Wek1uZStHUmppdVV5c2xINUxOdHRicTlDRU1QdUxOQ0RaZEkwa2EyWG15dXRFR2FzelNrNDhnalVrelpkUzJUaHJiY2FWb1g1TUt3MVAxRGplWHJZRmxjWHk5Q3lzT3ZtUmpERDBaSk11MVhHR0hwTkxrTXRlUmJUcmFTVXRjV1MyUm10TWVRc2lOS0dIbkN1aDJITFlLN3BScEp1RzJYRFh3K0o1YVhIVkpudG9KOXdrSXNFTFVraVNFSGRJTG9McEYwajRSOE5nWU03QXVHZnhMNDVMTlZrS0xsMHFNdXBBc3kvbDMvd0JGV2RGU2ExdnBLbUdoRVVvcTZja29xb3NZemo4MWgxaENacElYTmNTVVdPbDJrT01sUFdSMWRwb0d5M3VMbXhXZnBHUTRodDV5VXdzMG1obHhLb0JtcUN5WnRKTHdQbFRxL3BHeXA3UE1UVzJnUldLM2tLNUYwWmVjWmRKeE15ZEltbVJ1MHQ5bU8rWnZPR1UycEVsTlcvQ1NUSk9ORkdoV016Ty9Vc2l6UDF5cVBjSHZOSWlsTnAwTnNxdTRsMW1TdE5MWHdtWWl3ekdUR2NiU2lFWm1Vc2hHVVVhcFNuMVB0Y0NrT05lV2t4T2VxVE1jTkpKQ2RKRUN2bFlHZ2xEaHJJSlM4UkFpa2ZmUytZSnR4WHpFd2tqQkpKT1ZoNmRRZnlpcUZhWWVXTS9tWTgySEVKZFlrdEtndDhHbE10bkgrc25CNXREdFFhZlFhbElrMDQwdk1FN0lpTkZ4Q2xWZU5MVDVjSU1XaXJlQlpXeXVWaDFHc1hJZkNPaGVoZ2krK1Z1b01nWFVGbGlQc3J2bW9YZDJSQlpiYnFjaVFVajZ5Q0pEU0pNRjZPS2o5UE1Dak5VZFNqbnBMd2ZseFh1NnVlWEJ6V21FdGZrc0M4bGdYUVc4aEY1YWwzSi96U0lwVGFkRGJLcnVKZFprclRTMThKbUlzTXhreG5HMG9ZTXpabWtHMUZHcXNsOVQ3WEFwRGpYbHdnMGFuM1ZncjhTNWtUWnFzWnRwYVdhVStRdlVMVlpOd2QxZk00cldDaXVtaldXanBZTXEreGxtbjAvbDMvMFZad0pUY1hpNjZiTGJodXJVdURWWTdDR09MVDZ6SGlJYVN0TlVqS1A4UTVVVnVuS2l0UzV6TWllaVVYanpHblNIWnNLWTBTSDVWV1JJUzlwZHJVV1M2NHB4cXF4R0VvYVFpdEpibE4ybHlJVXBwdktoZDNaekt3NmkrWjlRUm1uMEtXdmlrNHVaVVhKeEZjci9BSExLNTVuNjVWSHVEM21qVnhtT1JBNm5GY2FObGFLbkVaSnR0RWFzdG9qeDIzU3FFSmduT0ZMckpHaFhLUzZqQW1vY1FhdE9vOU9lRHYzRXdFaElTRlRZNU84SXZHTDNOS3Bsb2ZNRkZxNVB2RTJMa1hyZkxxREJrWGsrd3JIMVdXTS9tWTgwQ2NpRzA0UnlLNnl0YTFJVk9nTm0rNnl6V21tcWc0OEUxQ25tY1p4YmRaWlRvY1ZFclNDSm81VHlZNWZvK1REcU9IU0c4dXVWN0dDNjlSNlpXeVQvQU9lbmxMUEVmWlhmTlRaS0ljNUQ2MmE0eWhxT2hTSjBGeFREcjZxdDBRdEVpcVFaWE1KVjRyRHV0QWRyWEdla2FxbkloVEgxU0cvSmhoa21hV1IrV3cwalNMQzM1QjUxUHVML0FKbzFjWmprUU9weFhHalpXaXB4R1NiYlJHckxhSThkdDFVNkcyMDZsbWRXeVdsWEtTNmpBbW9jUWF0T285T2VEMC85TTZvYVNHZ2cyMmJpK0dTelcwczBtVHF6OU9QWWN4YzdFNHp3VUpDVHNkeEtkVktWMTRSQktUUWZ3bnhBeWhsMC9pU1hUTlBwN2UzdExlUzM1RC82S3M2UEhhbFZKdGwwcVhBMXp5SGd0SU4xdU9KVkpoTVFXRkU1UmFZM05mVWFhWFM1RGtWNXNxWEExenlDS1BIUERweWd4UnFhK3BoOHFKRnAwNm9HaDl1azAxaHR4OTV5azBtbnZ2cWtiZXA1emtxRlZnd2lwN002TUtGM1puTXpzQ1VSaXcwa0xEcm5ZdktYb0R6cVBjSHZKVElwVHB6YkNwZEtwcmtXVHk1MFNtZUxvWURkSXB4eFdsbXpTNENzUnVSRHFTb1BNOEpnNkJUSFRqRXhKcEVDVXdUa1dvd3FHMGg1aEJVU2tyZDVKT2VGWFRheEJITUVFaXBLY05UYkNXNGh4NUtuQkdzM1RuSEZMV3M0VGNaTUZrNGxWNFM2bXRjbWNtTVVkOTZueUZzRkVsdFRHOWJZVjBJWDZDK1ovY1ZOV3FXZVdNdm1ZOGtGdEQwMXB0YlZNcEIxZHlDZE1wMU9xRlJlSVU2bFJWbk5ROURneFhhQy9KVy9SNHplSGt5aXc1QXA4OTVTWk1la1V4cGxzNUJVZUJBWmtQeWl3OUNUVkZrcXJ3SWpjSm1iR3pveFdwVEk2WitvMWRQSjBIM0hUTHJsOWhicUNMcmxpUHNydm1lbzlPUlZZekJOMGlsTXNyZmVwdE1wMHVydW9STWl0UmFtdGhTcUJURnkyRzIzYVBCbXNzdlJKdEpwcW84Z284U2lSUEFseVh2Smhwd25LVW0xaGJQMUZoMUhVWFA4dXBkeWZ6b0VLRktha09TSVVla1NvRDB3UFVHSW1zc3RJUlI0VzREaktWUTJXNGp5VkxvbEtjZGRoTjFHbHhVSENRemlTbXhxZTgyY2VGUzZkSW9pMzB1VU9sbXRjSkVha1V0TGNabCtIUllEY2U3OVVpdHdxZzR3Mk1IL0FFamcwaXdjU1prRktjUVlSSmZTWVdvM1ZhanRwQ0NPL1gwRnNyQ3cwLzhBQkVzeTZKZEl6QkdFK25zc0gwbW5WSmg1VXJhMUFHMXFBSjJDYVcrZytXbHhYb01sVWQ3QzBDUFVhcnduOXJVQWJXb0F4ZFJhZFRvS0hvdExhYmZxVExUbTFxQU1YMGluVTFocFVYS2lZTWJXMFQ5UlJRS0tnckZMd25SWlNlbFpvOGlqU2VFNWc2bFUrcEpmNXJhMUFHSktlelQ2d2JUTzFxQU1YVWFtVTZBaHlMaFNpVXVvVXczWk8xcUNOclVFWW1vVkpnMGhiMGVqVWQrc3l1RTNFd3JSWXFMQnpEMUVkS3gxN0I2WXJLcE1IelBmb0t6b1Mwb3F6SnFXMDR4NGs2NXhWSHBpa1RUOGlqUlVvZU1uNU01bHNtMldTaHZyVzA2ejRrNDRscU9uVFR6aVB1TllXZlNlSGU4dENQenY0eHRWQ0t1VFVYWlVXN2ZpSFdySlV4aCtNeTRLYTl5ODlwenlGcEh4RU5ZMUY1UHQrVFVlNFBlU2dMU2lyc21xb1VsdFp6SmtnNUR4VmRFY00vUXNCbGg5T0tYSFRyYXB6azFTcFNlTWNXbmt5Njh0cUVYTlZBM2xzVFV5VVJwRkdwR2huT21QbkZxTFR4SjZoUG9KYlJ1dDNRMjg0cU5JV3FHZzVEeVczR3BpRXplTWJrMXQ2cG9lVEZJcEZZY00zcWMxQWl1T2xCY2VmME5ScmhSOUI5OHpNTE95RE1TRjhSOVNzc1ovTXg1S2IzRmtNL3V0d1V4TGNhRzgrNXk1b21UdE5QalBwdzlJWlcrMHk2VHNKT0V1NkdLZHozRGFNbExtcmRscmlHdEM2czgwVmF1MVJJcks4OFBPazdTVzh1aGd2T1l2MEJubGN5RjhpeXhIMlYzekxiY2Zxc09RM1QrWlE2NUlhWml3NmJ6Ym94VXpvcUpPa3ZqbkloRXpMZGZLbk1wY2ZXODNDbDg0eFVLZlVZc2xhVmFkUjZjOEhPYW9UamY1UlhQOHFwZHlmend1dFRjZVd0TkRuTytIU0pidkE0VldmbHVJYlF1b1I1TGI4eHQrbHBmT29VbHFiVW5YcEJNY2FYQU1WNUtKTklKNXVrL3QyU0dGUzJYRm5LcFBQazNGdXc4OFVaSzRkZkpCVmg3U01IUEovRlpIUUZrODJSaVFSRXJXVEpJMDYxb1NhekZpeUkrZytFZEJZaDhvY1c2a3J0OFlyM05GbEhmMmVBZnAzOG9tSzJwTldPbnFHUEdFb25OUEZnTnU5UWRYa3k2aDlzbkVZMFJyb1ptS0wzZVBsajM2VmpMRE1STXl0TklXS2pXNmRTbHBSSlNwSzA2azR4aUprVVZUZ3dCOGtuTEhURnBFZC9MSGZhMnhnanN4NUhXNlFrelNlS2FyVFpWR1cyeGd5S2xpakU2SG5tNDdTblhLYldJRldKWExDc1JDZzFSNWhQbGYvUVY1SEpjdDVHaHpucHVvbEJFeVkwWm1oRDc3Ym5FUTVLa3ZwMHVybXpIQ0pLK2RtY1hpam1aSEROc051T01yMXR0eTVUU3pXaHVRKzA0YmlEa3lEZDRwdXZ2eUZhblFYUVV1VnprQnQzSXpJdlUwL3dESHhDLy9BRDBHa2RiZEN2NTFXenFQY0h2SVFkbHluMDZYZWVtOFRpRG5KWkVSRHhLb2g2VEprMjR4eVpLa3BTYjBtUkkvV1hMbE9vNGEvRTZsNUM2RERjdzU5RlllVW5Lb3hGS2pxNExoY09VWkZTMHZFMnBiVlJTb25rS1ZCVzYwcDUxdVpNVkxwaVRQd240MHJZTDBDcm42ZW1keFVIK0RIUFBHZnpNZVJLbElVU2tsTW1FN3hRcVRKVzN3MWVJMUM5eHo4OHh6c3duZUtHbjMyVjYyMjVjcGtqSnRxUklZUFUwVDd4TzhVblhubjFhbmM4SVNDT090aks1RDcva0VTUllhVEdoUXRib09oQXNzUjlsZDh5Smt0dHZob1psU1k5K0NjbVNiWnRtN0lrUDI0cXBVbGVrMVBTSDVCM2VjbFNua2FIRzMzbWtxUzM1TUl5ZUZVRGFQSy9uNjU5TXIrV3BkeGV6YmtQc2taTm9rUHR0bTJnNTg1U05Da1RwcUVrbFBIZjRadGc1Y3RUWENVVStjVnJGSWZKbmdrbDk5RFp0cE9YS05yaEdpWEthYjRhR1pVcU9WbVRNMUhjeFJYK1hxYlNnb2ttWVFvdlRKWlhTRkhkSm9EWlhVRUowcDhxVnBVZGlDaDZoVFpheUNFL25sNU1BL1R2NVUvd0RkK1dQei9FamtNQUk2U0Y1WWFlNDlGYVdNVHQ4U2d2a0tMM2VQbGozNlZqTEJYZThzYm4vNnlRbzUzcE1jWWg3SklHQVBrazVZelk0dEpKekxIZmEyeGdqc3g1VFBxM01zTExTdWdzV254U25Rbkk1MFNlbkM4NTVxZHZ1a0N1ejJLblZGeW1mSzRuVzJhUnM2YU5uVFJzNmFOblRSczZjTm5UUnM2YU5uVFJzNmFOblRSczZhTm5UUnM2YU5uVFJzNmFOblRoczZhTm5UUlFhZktwakNtSGg2alRZeHFGeU1hUll3bS9sSWdRUHlTc0tUSDVLM1MyZE5HenBvMmROR3pwbzJkTkd6cG8yZE5HenBvMmZOR3o1dzJkTkd6cG8yZE5HejV3MmROR3o1dzJmTkdDbzB1a2t1SStRTEp5SXc2dldjU0czRXZ3M2FieHB2SFVxanJKeFJvUlRvNlNTazhqOWJpK1I1VlNUeFhkQlpWNmpQMVkyK0hzNmFOblRScytjTm5UUnM2YU5uemhzK2FOblRSczZhTm56aHM2YU5uVFJzNmFOblRScytjTm5UUnM2YUtOaCtWVEpuR1gwenQrVGV4aEtoZTRMMXpxc05jK0F1T2paMDBiUG5EWjAwYlBuRFowMGJPbWpaMDBiT21qWjAwYk9talowMGJPbWpaMDBiT21qWjA0Yk9talowNFJNTDFDSkpRK2dyMjY1Mjg5dnlKZUZKa2lVNDZXenBvMmROR3pwbzJkTkd6cHcyZE9HenBvMmRPR3padzJkTkd6cG8yZE9Help3MmRPR3pwbzJkTkNjSVQwbmNtU2VTeWtuazJ1TGk0TnY4VWdiS1czelNuTTNrbmNrdHZHNFprYkM3TzJ5V0wySWVxN2hKV0w4OHZKZ0w2Wi9LTGh1blJLaWM1TWlReEZhTjE3RVZXS3IxRTNVWURidFRYRmlVdmh4WEZqQmE5ZERJaFYwY1dsUG9GRjd2SHl4NzlLeGxnbnZXV051OUNqZG9qREVQWkpBd0I4a25Lc1IrWnBiemVXTysxdGpBL1pUeWR3S3c2NnBZcjJGMjZOQ0tRbkJOWFF5czZlNkszUTQxWllzcWJDa1UrUWJFajNSSG5ZaHBCSk1XVUU2L3ZrWGtQODNwK1NsU2tLMUppUHBsc2F5MEdEUXN5Nkh4UHRyTWhxTE1nYWlMb0RLeFd5TVhNVkNZVWR2UW4xOXdXWFVYRnk4aWdWaUlhVEh5cEJkQVhUM0JmbC9iSXZiR1Z3WkJQUTh2aHVQaHpjMWZheGdrcEk3bHdrYTlRSUs5UllqQ0UrMHdEOU0va3hpS2x5Snh3eU1pVVZqeFpTV3FaVUNObkJqZWloSk1WbGVpa3lGREFhNzAxMUFkUnhHbElGRzd4SHl4NzlLeGxnbnZXV051OUNqZG9qREVQWkpBd0I4a25KdHhMeURNaGp2dGJZd1AyWTg4Y2RtSUZjanVXR01URk5Jb2N3VitpdFZpSWFRcEtrS05LdmNrZWZYemVua00vY1FwYTRqdW9sT0tkU1R6QlRFcCtkTHpTL2xHa2dhZitOVGhIMUpaS0k5Slh0MU13ZVU2YTNGUllsclU0bzFLOXgwSWFnUmk0dVE2WkdOUU15R3E1ZytwZ2k5d1F1Qy9MTDNGczNYalpYckkzRFd2V0VxMUZrZVZpR2ovQUp2YjB0MHVDVGYydUF2cG44ak0wNGt1UXg2Z3VWWVdNTk44T2hNRU1RazRxaXZwYndNeEtqb2ZROEliZkN4SWhHV1BmcFdNc0U5Nnl4dDNvVWJ0RVlZaDdKSUdBUGtrNVVLUnhlWmJ5eDMydHNZSDdNZVV1Ukk1dHdLZWRXVmxVdkJ6VlFnTnlUbTRMYWhRM0pLY0tWdGRVakd5K01WeDB4NjQ3cDkwUjJCZmtYc05RTlh1b2t0eUk1cVMydVBOK05EamJiWm54R25GL3dEYjV4YVAxQ21NZmNsdHFPeFdRZlV0V2t1dXBJVmNTNnFsbzlMYTFxY1dhMWU2dGw2Z3dYUUdOUmpVRElnbS93QmlLM3VpRnhmSzVlY2k5MVlLVVpBOUMrcmlIU1I2OFZDRDZFb2pCR0xDNHVZdVpuMFNuMjJBdnBuOGt0TGZ4Tm9RTWVydEdZUUtVM3dxWXdqeU90OFBHTnNzZS9Tc1pZTFVSVnNpeXh3aFNhdWxRcGFEYXBqQ0ZZalVTYUhJTVlBK1NUbGh1UmF2ejJNc2Q5cmJHQ096SGxMWWU1dHdHeThSWFBEQjZxQ3dLdWhUbEtrSlRnYlY0c3V3eG1vbFZ4UmU4TG9OUUx6WDk2bFNrSGRMTlhjSXRMeVZ3cGZ5OHU3Zm9jVjFaRVN5aHBOM2lLWmFTeW5TbFMwTmxkVDFXak5mSkpxTW1UMFAzOXJneU1zL2lCSS81L2hMZStXd2xmVTB4MElLdzRDQWhwS0ZYeSsxd1dyN2NNd1JFWHQ4QmZUUDVOeFl6S3pXMk1aVFNtVlVtRzBKSkNDU1dMYWxMcHRQUXVOaGV2VlNkVmVCSkZVUm94c2pLVkJpVFNJcEhnRkZGU2NZb21LeWNaUXREaUNXaDJOSGtXNG94eFVFTlFVd3l3QjhrbkttU09CalJ6TEhmYTJ4Z2pzeDU0ZzdKSUdCNXlYWUNvaGhtTEdqbVpzbW9rcE5TcXZNOFFxVHNndmZYTWFqRnpGei9na3Z2SStVcHNvaDRoTkhQU3d0eGJoM1YvZGRocElhU0ZpOTFodkVNZWl0T0lkMzVUeHZ5QUtoam1RODJhSWpMcEprcGRjMzVUeGlURWNldE1OdHRVU29JcGRTUktYdnluaW8xdU5NcmpWUVJ2eW5qZmxQRy9JQXJsUmJxdFJWS2JvbUtaZEpSd1ZveHpSMUY4VTNIakJJTW9jcVZJbXZxZmZ3MVg0OUVKMG5kKzA4T1Q3MWc1eU4rUUJpTEVrYXN3MHN0WWZ4UEZwRURsM04rMDhiOXA0cWVNWVU2bnV4MFE1c21CSUorUEV4NHdhYlMxWTRvNUYwcmVMWkZUYU9PeC9tZ3Z6L0FGUC9BQ2FXWlovYjg0dktYNVhyMS9za3Y4RGtEOWlYbkwvS2YyL0pMTXZZbG5iL0FQQlpFWmpoT0RnckJzTElHMHNnWkdYci9taEtGSzlFeC9pMGhDT3RnVnZtQ2Z1b3lLNTNOUFU5UStkVmxMWlNaL0NwQ2srdjVWL1pYRnpHbFEwQzJkLzREcU9GcWIxSi9nN2tRNG4vQUFlc054WlVnL3d2QjZ3UkJ4dVV3clM0bHovNUxRYVBmWEY4aUxQcGxmOEF0QnRpL1ZXa2o2SkpTYlhCNmtJSFEvZ0l6TWlLNWtraXNsUkorVks3RVhUb1Nia2JaVytKeG8wOVM5MTZnaXVQVExwbHAxSXZuZjNwbVJCVGgydUlzd3VOb1VnK1dmc3BkdFIyeVNrMUhZbFIwTWZyZkFyNURPeDllbnV6V2YyNlh1Q081aUhSNGNLTVV1cUx4UTYzOE1PaTRobnk1NU1QNHFhYThLNGlrYVNPNnprb2ZUOEEwbVh2TEN3SWgxRnhjV0gyeXY4QTJkSGJTUjNVZ3k2a0c3bGRCcU1qK0VYSWxYSWxwdmRTTkpLTXlTWnFQVVI4VS9pQzNFcEw0VWtSSGNGYy9tVlpYUW5tZEIzOXQ5aDlnUStZeFlIMHlMTC9BRWhucHFNRm1RdGYzWmxjR2cvUTJ5YzFkSm42dmtiSlpxc2xUcmJIUktuVnJDcjNDVktJd2xWL2NYc0ZMKzVBeGg2R3kzcXFNbW9UbmFoS1UrNE1IdytOTVUrZUxxcW1XNm1HMUxVYnJwTUpRa2tKMGszMFVMbW96c2svK2ZkbDVDSFVHZVpmd1hyMS9pbVc3OVQrSG9ZVXBSZkdTalN5K1JoMXBUaGF4eWI5Z3FHK2tJUTZnckhvUFhwVWJwcHVra2FMV1A0bEk2M1QvcFNTcm1MZkQ4U2s2VHQ3Ym9Edjl5OUFraDB2MXVXWHFOSitnV3JwcElYekpSa09pdmRlaEJTQ1VmV0JINGp1b1NITmJ4bUxpK1RpK0F4WXVKMEl3WEZNN0JMUkVOSkRTUVNmMjl1NDN4U3NaTFZGZE5DdWhodE90WkpGZU5NU0sxQmJDVXFXb2twVVNNT1VFdys1cEkzRlFtejZ2S0NsYVVHWVFvMXhSVEpyNW9OTDZGcE12Y0VYa0xyNVB0NWZUMnRjbFB3Nll0NW5jdGFHNUswTnkxb2JsclEzTFdodVd0RGN0YUc1SzBOeTFvYmtyUTNKV2h1U3REY2xhRzVLME55Vm9ia3JRM0pXaHVTdERjbGFHRzUwcWZCVTVJL09OeHNqc2ZGYUhGYUhFYUhGYUhGYUhGYUhGYUhGYUhGYUhGYUhGYUhGYUhGYUhGYUhGYUhGYUhGYURXbDFWaVRZanNFb00vZ0NkSm9NMWFtMHRFb0c4cS93b2NtdmZMeG40NjdCdVc0NzhJZjFLVWFncTZRU3dnelBvUmFTSUZkUmthanVwd3lFZ2lQcVh0bFpFWG9EOWN5VHBDejA5UElXVmg2QXZjdUtTczlBUXlicXRDSFRURllKaEIrU28yVXROeVAxTU1sWlB2S2pZbEVJanlYR0xpaE1jZXB0cEdKckZWVkp5b1VZeU5VMVZlcWE2aE1zVXRWOUxRU1drclpTVDBzS3NoQkV4cE5wai9xdENqYTRCL0N5c25FWDl0MEZ5QmFEQm9GakZ3ZHpGeDZnL01rL2FZbTdNNTdUQi9iRi9uNGs3MDc3TEI4TGxxYnhqTDB1azA2VkZlOW5icFlpeUtwTzVkcGVINld5bFBFUkdwcmF1V1pyOUxpMDJLR1VQR3E3YmhPTEt5bkVXeVkxWDZJUVIzMTlWSXNGcE81V2RTV25SNUpsZnE3VXR4Q054MW9ianJRM0hXaHVPdERjZGFHNDYwTngxb2JqclEzSFdodU9zamNkWkc0NjBOeDFvYmpyUTNIV2h1T3REY1ZhRk9iZktua2NuTC9nTEw0c215KzU2dEphZ2ZYTXVvUXowdW96YSt3VUM4bFlmZGpVMXgxcmNkYUc0NjBOeDFvYmpyUTNIV2h1T3REY2RhRzQ2ME54MW9ianJRM0hXaHVPc2pjZGFHNDYwTngxb2JqclEzSFdoU2FyV3FoT1N6a1pxdDBRWm1SbXFLMlVSZzMxdnBKdEYzTTdIcHVKOW5HR3dqcVZ6U1Z2S1diRlBpTFpTbzZ0RWp4cVZJZWEzSFdodU90RGNkYUc0NjBOeDFvYmpySTNIV2h1T3REY2RhRzQ2ME54MW9ianJRM0hXaHVPdERjZGFDTVFWdGFpU1NIWFdFcEo3bkdSTmROWktVS1VrellOSjROamNhcG1vVlo0NUZTZVdHbWx2T0UyaXVFM1JxVzFFUWdyZFRTb25wbXJOOCtNNlNFcUNrMmtvY0JsY2d6K0crYWM2Ykhaa2ErSjRiQ0dJNnhVb0ZiZmp4OXlWb2JrclEzSFdodU90RGNsYUc1SzBOeVZvYmpyUTNIV2h1T3REY2RhRzVLME54MW9ia3JRVGlLdHFPeFJpZFF3a25jN25ZYWpJWEl4MCt4a05OaTgvd0IvYVltN0s1N1RCL2JGL240azcwNzV2RGxlRjg4U2FHWnROck9KVGVhWUowTzB4YlBNRXQ2a05JZGRZYktqM250eFI0WVpjemZ5SVFiaXlTVlBpb2h4VzJSWlNqMG5kR2t3NHZoc0NrbXhRS1J6c2dxcktxRWxVcC9CNXVQdnZQTzRrcVJWR2ZadGxwOXByNFQvQUJiSU54clQxQk0zT3hwYjRSbFlrY1JYeEZja3FTU3lOTGRrcStBT0ZaWjUxRDY5N3pQUlg0NkVMY2VwczJPUytLM1RwanlVcVF4QmxTU1NiUzZiTGJTU2dpblRWdk9OSjREdkw4ZnkwT01VcXB0b05INmE4ei8waHd2akNVM01INjZTVjY5TFpzSXY4UnV1R3N3bEplcDZ4Y2xBK25rci9aM3ZNMjJ0MXdtME53SmJzdmxVcml2dG9RcFQwQ1hIU3BUaFV5WWR3cW5URUxVZ3ppU1NpbEtOK085R1VTWGZKaEtNVGNWVWd5RHFTZFVLYkU0emwxRzRrdjhBcVhscU5hcm5iT0xwTkswS0tQek5PTXlUUTR5WktBN0FReENLM24zNVJvaDh1dXBZOG8weW12eDBlUnlLK3kwaDFidE5tc0pOVGpVQ1c5bzBNdzVNaEpHMjdUWmpTTmFrVXlhdVVxTWtvN3h4emZMeVliZ3JuMVpDRXlxZklaUitNOUJXUm1iU29zczFDTEg1ZHJTTUhGeXNLWE9VWm1vN25ndW5jM1VUZVBFODBxaldIRkZ3VGN1UkdSUTVPa2NkR201cWtyZk0wTk1OY0pGak11Z2tKczNja0hxUVJoOHRMcVY1cXhKQW9LN1N2LzZMUWhYcHpOVHE3MHRuTm1LL0lRdGJiTUNYSWE0cmFZa2hTMW9JNmZNS1FVYzBVcWM0bEpwVkZmUzBsMDFVMmFpWHlxdkpoNk9VaXFvSS9LU2JuWUZvSzVKZVNXa2xDNWtOUm42K2N2WjRtN001N1RCL2JGL240azcwNzVxYTF6VkU1VU9yU3R3dEZJK2dTSmlreUtaSWtBdW1JWkpoMUtTY2NkVktJdE10MHZKU0VjU3BzcENMYWVoM3RxTTNDSXlVVGFFelo3VFpZb2xjV2Z3aXB5U2Raa01rdWVkUG9TSWJRVnpHa2lCdEdlblFzamFXU2xxME9xMHBOUENjdUNJbHJGeVJkSldTbFB4VzArcnZWZWRRK3ZlOHlveVprYUVrVlp6aXNTbkJUWHVYaXNPaU5IUkhlWjRkTi9Ra2lLVGpVNlE2bVExd0tPcHJ5NFFhSTViaXdqOU5XVmdmcVFYOHdiTHBxRGZxWmk1RG9MQ3crV0tDNm1IRmZZZEFrSDhSQXM2LzJkN3pVM3VMSWpza1ZiWExLWjlMQkQvRGRPUkdYTkl5alNpTnZ0eVREakR2Z3ZMaXUvVU4rV2tNOEdtdElEcTlDYkphWVZKY0pCRWhwdFBBRWg3akw2RjVJTHkySktGb2pObTIrOUZYT1dtTzY1b2RScmE0aXVwSGJ5R2ZVczZwM0ovemNyejFIak1sV0hDZGp5RmxUVkdoTUZSTnRvU3R0MXVQK2xPQ0V2TjFPVklibHM4dFRaTFhsd1doVFJPeUNwMWFiVTN5MDJSaGQxOHpYQmZnU29qbWg2TERrVEhpYVlyWnRVT2h0MGhzWVgwMDdEVDAwMXFNMVhOb3pzWWZqSmZQNDNZVGZUU2hCTkZZdFJDNlZlaWs2a21rUkZYYjBoOGlNZ24weXhuK3N6NXNOR2dpZkpjSnJsYWVpT3FQOVpPQzBwa1RrdUpYOVRUZ2JQR2Rqb0g0cmxWaXlYUEpnK1A4Ymova1Q2Z3cwUm00VmxMY1VraUR6bXMvTDZaZEIweVQ3UEUzWm5QYVlQN1l2OC9FbmVuZk14VUprWWtrMG1mTVFhREpWU21MMGptbjlEaVFpZE9uS1UydDZvUzNVRzBwRlVtb1JvSjExVHk5U3M2RjNkZ05uWk53WHIxVzRsQ0ZKS2hrMGlXbHhkYU5YaUs5VVo1Yk1oTGlKcWlxYWxUR3ZRTU9ya2xvQ3lkYlhja3JQWDhabnJVV2tqMHVmRVo2K3FTVWxJMUxNdXErbnpPSGRXZFErdmU4emRjVzAyYVVxcTZYTlNIUEZVa2ttMjQxYld3MHcyb3FrMDAyYUdKMVdWTElpUklxc2VVaGFIVHRjN1o0UDlYZ2Z5V0ZqQ1NIK3NLUDRnbjlNSi9UVm4xSFVQOEEwNlFrSzljaUJkUEpYK3p2ZWFNOXk4aER3T3J5WXBORTYzVUdUWmJia1AxUjJRaFYzcTBpVXA0M2pxL1EwSU9yWG5Ma0hNblJwaEVwV2NkSkxrSVNaTUcwV2t0T3RXb1JtemhzbGFTdExaY0JBNmk1alVMaEptWHB4RzI1YlQ1V2NKNTF3U1VKV3ZnbFVOSnpYRFRtZDlSQXVtVlQ3bS81bzFkWEZRbEtmRlVxYjRTMDFWTGJqWERpMWRjZGh0azExSmttM0VzejZvVTF0U1EvV0dKS0hFT3IwR285R2VGazZhU1I1VXl0VDZXdTdKWTVaZFJhUzlqUTBKTk1KOTkyUzZicm9hMTdDVm9VVnhjMGpXYWdwVnZRdFN3VFkwV1BwY05ud3BWZzk4Z1Q4dVdNdjFtZk5GbXFpc3VJUy9YbkhuWEhDWFVtUHhsTXQxcGJVNWNrazFXT1hCVXRxdHFiYXNjR3JjbzIybFR5bzUvbzU0T04vd0RFSVdNRVdTZlcrVVZwYTFHYVpHdHRyUVkrL25zbjduWUY2ZXp4TjJaenkwYkRaVFdPTksyaFRSVm9iY0NldU8za2xLbHEwcHBtRkNOSk9UV0tkQmpGK0ZZZy9UWUVvck8xVEN5bVVtN0Q4bUQrMkwvUHhKM3AzS2h0TWNDVEpjYlRSM1RmbVJrMDZMeFZ1TmNoRUo2UndJc0J1UlNYMXVOSVEzVEhIbGVIdy9IbFhwdE9aUWNoQmxFcGtmUndrMFdJcG9pUkxReWlxdUlVY2FtVDQ1TFQ0ZlQ1aXpJNURkS0p0RXArdk14a3hHWFNvM2RXUWs3TjlMRVhRMXJOUVprY3JPYU1WcTVWTndhaklNdnVzT2s2MnJoVkJQRmpvVm9jMUUwc2tydW0zTUsrUFFwQzdNa1JFbTYwcFBTWXUyU2ZoTlZ3cytsd3IxenFIMTcyVUZubVpqYlFuMCtJaXN4VFJHaXhWWW5kWk9BaHArcHV0U1lOS2pOb2xjV25VeGgzRHkxSERwYkVxZ3RPbEloUXlLZGFMVEdGNGJVdFZCVFQrYVV1WWltUXB2S3ZyZWhRcDhYV0pjYUM4aVpISlVPQkNaYlpjVllsSHB3Z1IzZU1lZ3VFZW9MNWRXVGZvWkJ2cWhSZVZYeHhTQ2ZVS0t5dlBYK3p2WkVWeHRaZWswandIcEdNRmh0c3VNYmp0Q2RZcWJjUTUxUGt6Njl5enpPSDRzbVVxTzBXSENXdGsya1VBdnhsdk8wSjVtcUloSFU0Q3FiTE5nNCtHamRhUnJpNGROMW9sdjdha0pZZWVkYXd5dGJhU1V3azI1YVVxaklTN0RVUWd4aVNhblhWUHJhdTlsY1h2a1JaRUd6VzlURFFVWjBuVU5CdHhUWDRxNnJDWHdFb2F6TFF1UjB5cW5jbi9KVG9zYzZiR01SNGtSdUxLVkhlcGNQY1RhR3lwa0U4U0doUklwemxTWmp1VDRrVkZKbExUUWlnSE52TVRBaHowUkgxeUdxYTlEZWZjcVZManZWV013emlsaUt5cGsyTXNIc0hLbzJsQnNQa2RqTnR4SlhWNU1MVjZMRWJWQW5TTUZSWlg0bE9QQWxVSXc1aERsVTNrSFRLRkgrZTFCU09EUkh1aEt3NlRyZXVNOUdkakwwT3l5Tkdsd09GcXNXZU12MW1mSkZJbFNVRWI5UGhPT090TGRoeENsVThpS0JDYjQ3clJOVXFSQW1QUjBVeGpiT3M2Q21uODBwY3hGTWhUZVZmWElhcGIwRlVwNVZPcDNpeGtXSVl6RFRjZHdzc0dxL0JjU0NJRURCSjZBMlZFR1ZjTG9KRHVvdE9TYzdDd3RtWVQ2ZXp4TjJaek5pTy9KWG9acE9GMHRHVDAzTEVuZVhjOExVcEtHK2RkOHVLYVVUSytjYXp3ZjJ4ZjUrSk85TzVVbW9SNGFIbVpDc1F4SFhYRU9MeEhIdTZTRlZ5bE9yZk5iR0lxZEVTMncwNUtndUxaYU56RTBYVzg2M1VhNUJsUlgyMnFkV1lURVJwbVFqRXFFNkZCOTVsK2V0NDVkWnByaW0zR1Y0a2lOS3ZHZHJWS1diYUJXWnNHZTd4bVlUdkFsdHVEaW1UV3BKdUxXRWxkUkVIdFJ1bVlkZFU1OHhpSXhHZU96elZETmFpY2hQME9iSVlONDJYVGpyTWpiTW4vd0FRTm53cnBKczlTRE1Ib1NmUXorSVhNSDBTZmtxSDE3MldGMk9MVlNVR2pZbXRNdnNNUXBUV0pGeVZSMktneE1sT1NWdmtwd2lUSDVlS3VORFhIZThLaFIwS2svOEF1QVo1Vmg5bUNkSXBQTlZRMlhGdXpHNjIyN0pkTk5NaWFaRXhIS3BuU1hHWCtLcHFXaDlTRnZyVWpDcnhvbm0yRDljaStRd3YvZ1dDZWhoQjZIUXBObEdXZjJFZFpmSWEwRzJvR1hFSERVQ2JIUXZKWCt6dlpGZS9SYmE2dkdPUEpQNUtZSlgwdFFCczhTcHN1QTJYUEdJcjY2VTdIWFc1SEM0aEZLZ3RzVlRzc29RWXRTOFdTdWJpbGx3dUErNVNYbldZaDFPZnhGUFJZTGhxL1hxZy93RGRvNG1kSnJndzdMUS9UMm5rUHVwZWRNemRjTnhacXlJWDh0UGNTaVFSTGpGb1c1Qk9PbER5OUJxYmNsSWFqbE5qa3krcmhoYXRLRFVHU0xxck9xZHlmOGxPUktWU29mQVJKWmpzU24yU2pOeEtqS21ybFJvMDl5SStQKzlGNW1SR2VsMHlVeXpTS1dxWlUrWGRrdVRFVnBsMStwTm5CcEVwRHRWcWFLWklRbzhVcmFPUEhJc3NJUHFhaEdhSTJKNWJhYkxSakovMGNWRG8rSTJEWEJNalNacFBOdDUxbjlNNmhQVVZqSkR6dzREb1UwNG4xNExuVVFKOGlDOFNrVmVPek9wSnZwbTlXREJGMUxQR1g2elBraC9WdGlmZVp6RUlOSVZPNUdVMUVKTWlhOU1neVVzS2p6U1lTY1ZFaE5QRkZwUnpLa2JUcTNaamRiYmRrMVJISTBaNWw1eFplSnVJVGlOUmxEak5QNVlUZk51cGNNSjlNakJyTXVnU3UzcnhDTUVSR1FOcFgyTG9RdVBYSy9rTUY3UEUzWm5Nb1NFT3pHMEtZanNSa2FHYzhTZDVkeVpiTjUxTFpOTm9aYVMyZ1Z1dkZUUHdXaXhQV0NWY1VXc29xclprWW54aW1RM0dEendmMnhmNStKTzlPK3l3NU5WVWFSMWlVeWpjZ1R6NjBVWGpsd0ZtazFuYTZmditHb2NNdnNTVkk2cHBsVnFNR0pyV3FKVE1TUnplanFRL0FlTnBhSFNOdm9qU1RWeDlzdnNIbGZZczZoOWU5N0dneW00bFJTcGVYcFlnZlhNK3FiaHo0cks4bm9FdkVwT2xlbEgyUFNRMXBGeXQ1Sy8yZDdQY2xSNFdnUmEvTmlzSmFFZXZ6R0V1Sk04UjFBemNNMk1ReldHbW15aVZpVERsT1NVTVY2WXcwMDJUTmVtTkxjTWJobm10MVp2MU9SSWhOeEY3aWtLWlN5dU5pQ1pGUm9TMVY1YlJQaHJFVlFhWUpzdlVZUm1LT2xjRkMzT21oT1NFa3BSRXFIRXBUaWxKY25zcGp2OEFEQkg4WmxtUVd0VWlNbVVpSklKdytJR25ueWJhczZUY3FLbENtcU9YRy9FcnBSbW5US01rckZuVk81UCt4d25KMHlGc0d5bmlxTWlVMGFDRklsS2kxSnB3c1RSa3hxeTZTUkJvdFJxQmFtbThGMUZ4Tnlld1pXV3krRitsMUdOK29oNTFralNSU25oelR0ek1HNnN5TWd5eTQ4cXlaVHZLVU0yMVNTMTZXd1dlTXYxbWZZd3BLb2NwRDZXbHBXMlMwZ3ZVSDY1NjFEV1kxWEJDNFB5WEJlMHhOMlZ6S0Fva3ptbEs4U3B3UlBndUswb3l4SjNsM0tpSjExVmtzNjZacXE3MXhoWlJsVml6bXA0Y3gxSlpZUDdZdjgrUlJxWkxlTjE3YjFHRzNxTU52VVliZW93MjlSaHQ2akRiMUhHM3FNTnZVY2Jlb3cyOVJ4dDZqRGIxR0czcU1OdlVZYmVvNDI5UnhUb1VTbm1aUjRhMmFwRE9HcVl6S2hYYlgxRUtsT1NVOFIyVHdTZXMwWHIwYXBOUlVqakU3NGliWnBGRGtMaFZSQm5YNlVtb1J0YUdYT0dlazdKUTMwKzQrNFA0Q3VETzUzOGtqQ1BIZlc2TmxqWlkyV05salpZMldObGpaWTJXTmxqWlkyV05salpZMldObGphQWFTcERaSlVMK3ZrUjZHUTlXczdpK1hUTXZKUGljOURYSEd6QnN3Yk1HeXhzc2JNR3pCc3NiTEd5eHN3Yk1HekJzd2JMR3pCc3dVaWhMcExpbEZrUVlqdlNWNkdWSmxObnczcDVwT0hHdTJlcGFzdlFYTVEzME5PZmlzT3JwMG5odU9FZW8xa2t5Nm1FclNuMG12RSs5Y3M1T0V1WmtyZUd5eHNzYkxHeXhzc2JMR3pCc3diTUd6QnNzYkxHeXhzc2JMR3l4RndvdUxJUzhoTFRxVnFNa09tdG95Y2gvVnRqRjUzclJpalEwenFraGxWZnJrcE1nNGtibnBpVDFCbkVsWWovS25GRTEwOVQvQUl2Q2U2T0tjb1RoRGcwVStvU1ZFUVlPcXhHZWtlYk5lZlZ4SDJrbXBYRVZuV2FINHV0Q2hzc2JMR3l4c3NiTEd5eHNzYkxHeXhzc2JMR3l4c3NiTEd5eHNzYkxGS2h1d0l4TUw4bGdXVGFTTUxiTHJwNGJsN0E3aEpkUWVaRjdURTNablBKUk82czU0azd5N2xRZTdzNTF2dXIyV0dPN3B6cVhjWHM4SDlzWC9CTXJjSlJLYlRYcFhEMHlFMW1JejFibjFWRTQ3S05VSDdKbkthL1JhblB0TzZ3ZEdqVk9QelZPaTB1WWNsS0plSTVhbzhTN2FXMXVIeFYydjhJTkFOcnFIRlhQM0JDL1VXelIwSUYwUWZsdmxjSjl5UUlhMUk2cFhXWnhNOE5VaWM5SUlyeEVtU091WkhZd24vcUd0SWlUZEpjTnhVaGhzUHkxUEZwTDJ4a0hPaWlNUjFhWktER0puZUxWMUtHR0hTYnJMZDYreXFQVm5TVlZGclMya2laWjRwYWxHNFNRVDdwL0x6TW9oeml5OWVjVWZvb3A3eWZ3NGxQTm85YnhlM0l4OXZLa3JpNWtkeVkvR1BTcHd5SlJrT0ptUTZIN1hFM1puUEpSTzZzNTRrN3k3bFFlN3M1MXZ1cjJXR083cHpxWGNYczhIOXNYL0JKVWFUdVRhMHFJWDZsYzJHbkZkRlFUU1h4Y0hTUU9MMHVJc3FiVEhPSXl2Rld0cXlabFNrMUt5WEwyTFRsMERqdHkwbDdyN0N5UlpQM05XUjUyRmlGakJGN3JsVktiNGpZKzJXaEpnaUpKZFBJbFJrTGd2Y3JUMERLejRpVEZhK3VEVGltWFNjVGlTMDFocWVpV3h6RE9ra051TXEwbW0xcnB6dVJlcXBTTldsQ2IyNis1dG4xQ1RNZFQ4eFg5QjZlMXhOMlp6eVVUdXJPZUpPOHU1VUh1N09kYjdxOWxoanU2YzZsM0Y3UEIvYkYvd2FWR2s3a2gxQ3ZWS2tsMENFa2t6SWkxNkF2aUtMNGxwLzBud1VYQkpJZWdVb2srcWxtcjNmcU9xUjBId2tETWFzckJLRks5T0NSZk5yYlQ4cHVLTXJlN2FkY1pWcVFnNGMxUHh1VXB6L3RPUjNtdm1ML3o1aUwzZWhTVmRKSytjakllSVVkNG4yVndISG1qWWROczNHME9GMVR4MlBRcEs3ZkZ6SmczWDEvSW1PdHhYeG9iUzJWaysrVGxmeWVvOVBiWW03TTU1S0ozVm5QRW5lWGNxRDNkbk90OTFleXd4M2RPZFM3aTluZy90aS80VkR5MEJFNy9BSktVZy9RbkwrdW9haUJ1SVNGdktNK25uSWk5dGZwbFl4WXdTVE1FaTN6RXR0QVUrby9UNHo5OTZCaW9QczlBM1VtVjJ2OEE5RzZYVk1DRXBaM2Nod2tYMWNTbEExMDM3YTR2K2s3WDk2aGFrS3VSa2hYcFRHaWJrRTZxcUxROU5VdHUyUktCSVdvSlJwOS8wRmhZN2VXM3VNVGRsYzhsRTdxem5pVHZMdVZCN3V6blcrNnZaWVk3dW5PcGR4ZXp3ZjJ4ZjluYWp5dC9Ca1prT0s0RFdvL1d4ZndtbEkwcEJFUmZ3ZHo5N2lic3Jua29uZFdjOFNkNWR5b1BkMmM2MzNWN0xESGQwNTFMdUwyZUQrMkwvdmI3ZjNOaWJzcm5rb25kV2M4U2Q1ZHlvUGQyYzYzM1Y3TERIZDA1MUx1TDJlRCsyTC95NWlic3Jua29uZFdjOFNkNWR5b1BkMmM2MzNWN0xESGQwNTFMdUwyZUQrMkwvd0F1WW03SzU1S0ozVm5QRW5lWGNxR2Rxc3puWE83UFpZWDd1bk9vSHFudkhuZy90aS83THY4QTRSeE4yVnp5VVR1ck9lSk84dTVRM3VYbHR1NTRwZ09NemVaSVlSZ3JOMVV0UWNXbHBzMXFXbzFyTlI1WVA3WXYvTG1KdXpPZVNpZDFaenhKM2wzT2hUU20wNUo1TGJRNmcwTDhBbytyVUVvU2hPbEl4Tk9LTFR6YUxQQi9iRi93MXhmKzFpNit3THIwL3MvRTNablBKUk82czU0azd5N25TS281UzVPc1JwVEV4b25XYzUwK05UMmVJOVVaNzFSa204NW5nL3RpL3dDSFMydGZ5bEVrRGxaQVVoYVBYM2hmeXRyZ2lNdjdmeE4yWnp5TVBPUjNTZGIzTFdSdVdzaVRKZW1QRzg5bkZtU29TOWJER0xwcUNzN3ZJdy9pMm9PRlpwK1E5SmM0ajNrd2YyeGZ1dnQrV3pIY2U5RzRqVGZybllqRGtScGZvNnd0ayt2K0M3ZndtSnV6T2Uwd2YyeGY4SkdqY1U5U2lJa2xZdGFkZW5KQzByOUZLSkJYTkMwdUp1a1hiZHVrU1k1c25jdjdHdjhBa2ZjVy9pYmlSV1k3UjJiUk9xenhYYVZOcTdYVnlKVmt5WFNhQ2FKVmxGY1NZcjBONDJudjQrdW9KeW5HZzlyVXNiV3BZMnRTeHRhbGphMUxHMXFXTnJVc2JXcFkydFN4dGFsamExTEcxcVdOclVzYldwWTJ0U3h0YWxqYTFMRzFxV05yVXNVSmhFVkQ3S1A0SmhvM2w2UWtpU1ZpQ3VrMGdyMEVINURFczlha3RCajhGODI4b2Z6ckNra3ROamRiTnBacFArdy9zQ0ZyajFHQTJtWHVaNG5KeEFyRW1GMHFOSnd2REo4Wk1oams0ZzVPSU9UaURrNGc1T0lPVGlEazRnNU9JT1RpRGs0ZzVPSU9UaUNiS29WT08wbUdkSnFEUEZqY25FSEp4QnljUWNuRUVvNlRCYjRraURMb1ZTTTB4ZVRpRGs0Z091WWZLcGxBTGs0ZzVPSU9UaURrNGc1T0lINGtUZ3E5aFdwU2trVENjTFlVY2xPRUdjSlV0cEg0NjhLVWgxSDROUndzZEtxakUwVkJDbXB6cmFxdXpPa0tZV3p5VldETGt0dWVxTS81WUIxS2UycHhQSlZVUjF5U2xPTVAvd0FMV3ZvZmFVdjU1UHNxcmlkTUo4Mkk5SHI4aWZMNVo2czF0cWtrU1ExaTZVaFpjd3VXMlVCVXR1QmlqblppR0RseUNpUlZ2blRjVCtJVFV4aFdhMzRRYUNEV01talA4U05LWW1Nazh5OWkvZ3ZLYkVIRlVTVTRUYnRUbmVIUTFTQnZRVWVxZUxSMU81UW05TFdySnhha2w4TDNTU2d3NnJTMlppRVZtQ0Nmam1HSlB3UElXUHNJZnF2S2EzZEd2SmEwTklOYTNjWFNYSGRNU2lWWlZXWlV0VDJJdUZWZVJGVW4rR3d6a0NqMVB4V01iMlZWeE9tRytiRWVqMStSUGxjczlXSzIxU2tra05ZdWxJV1hNSWZiZGo4ZHVqNGc4V2ttemxJeGR3SDF0Q25ZbzUrYWlPS3JWR0tVeHJXV0w1aEhyVTVLYVlpOHc2dkY4cGF6NEZLbm5Vb1JTRG00cldUNXRRcVJpUXA3L0x2MWlxK0VzSmNGTHFDYW5ESjhrMXZWV2ZEc3A4OWluUmpmZDNkT005WlV5cE0xU054bXc5aUxoVlhrUlZKM2hzTTVBcFZWOFRocWtDazRqVFU1WEFPc1ZYd2xsTGdWUDAwdm5SUmExNHZ4QlVjVWNoTVhIRVRGMFY1elMrVmpLNVZpdWxTWEVvRlBtSm53MFNFMW10K0VHZ2czak5vMWZpUnBMTXhrbm1mY1lBLzNPVC82NnhoUDl2c0I2czBtT3ZRNUdxVlBsblpqTjZWR2ovck5QTXZwMU5MV2hwQnJYNC9SUTA2MjgwVGphWFcxSFpJbTBPTTVVWERlb3JkSXB0TVBsZkg2S0NNbEZjc3NVVXRFcXFhM01MVStrUXRYTENxdTg2M3lzZW1ZVXBWT1dsNHBVMkpDU1NwRE5acFVoMG1tczMvMEZld2NSeHErbEI0U1lTM1NlS01jU0hHMm0wSndkSmQ4UlNrVlpsTDlNZVNkYllSTG1OcFlwRXRpVFgyMm1KZjBqZ2xVbVpJcVNuV3BNQ3R3cnFURThWcUtGT3Rjald3bUhXejFBb0ZiR0FtRnhxbWxwZFQ3YStIYVhQZXFEcTJwRUd0UXJxSXF1MnRzdUcxQnJNZytydElyTEpYQnpKY0p3bTV4R1JsY3ZmMXI2SDJsTCtlVDdHUzl5OFpib3dpeWwrVzdJYzBsZTRQVFVjVjZWNGlqb2ZwTGdvcjV1WWFrdG5GWHdEanZuaWQ3aFVoWkNqSTRlSUdVakdmenNCMkxIZXcwV3JCcnFqUzgwS1dsSzhUYVZZdWlzTU9OTGJxYnFuc0trNHJDVExMbE9XYTBOdHRsWkJkVHNFbHBTUlpURktKSldsOUNTc1MxMllNTkowTkVRaWZFcGF4TlRkbTRRclUzY1F2OVdUaWRhRExMRUNsSW83eHB3Y2xQSU9LQkpJajZUUDNXUXhQMmRZd2YyeFlrdkZIakxkR0VXVXZ5M1pEbWtyM0I2YWppdlN2RU1kRDlKY0dGM2pjcERqWjRQN2t2S25KU3ZGQnBVbVBIUWQwMTlmT1Y5RVkwdE5wYjRaWXdrYUlyYkJVS08zSHBiV21zUGNwU25scHdjd2dvcmo0eFMzeXRUYmt0NHRYcnA3U2l3eTd5MDUrQ2JYN3l5eGkvZDlwZ05SR1c0WlJoaFpTbzFWZGpaUy8zVVF4UjJkWXdwMmQwUW5EaEtabWxpOHlWQmFNblAyd01GLzdnVHlKV0tpSThUMDZMNGVjaEdHWkp5S1NranJmL0FGbGFkU01JdmNTbW1nOFovT3dHYVpFbTBWdENzR3lUMXV4ajl4Z0QvYzVQL3JyQzNwYk9CV3VYd1hDWmtVeGZNVlNONGRWSFdXOE16M2FoUjBPUERGbUlYYWFSUkl1RzhOeDVzYm42amlLa0t3KzZpZlRZVlo4Wnc3SVdzVXZEbmlkS2FYTnIxRWRvVW9pTENPSXBEai9JUzYxM2VTS0wrekplU1lOZnFNTktqcTZLeFNwcHNQNE9yVlFmbW5FZnh2M29ZQ08wMTR6cU5YbllscVpRWXljRzBRbzNDT0xVcCtGYXFxRzdqcGFYS1l5dE5FVyszVldUWW5VWEVFdHMxQTUxVGp1bVF3aFY1VlVpTFRKZi9RVjdCcjl5SkdHZXhzakhmeXRqQjNkR2hNK2pjR0pzUlZBbDhrMS9UNzYxSWZKS21Ga3JETlhhYm1GQlJXNHJNbW11Y1RDVGFXcTlwVFV1M1BqQ2ZmaFZ1MlBqQ0hmekZTNjA1OFlTcWpaUDhpVmVqTlNLVzRhOE9VVkV1dE9KSmFZdEVweWxSOFA0Z2NyTGkybmNaWWNocWlHNjFTRkxPS2FGZS9yWDBQdEtYODhuMk5ZNlVwOFlMLzNHVko2NG9GWjdVK0tBby9DcHlRYUNPakVzWWpsY3hUNHFVdyttTGJER2Z6c0IxOXByREphc0dOSzB2T2lGSlpoNGdONTZ2MUJtc1NHbW9sWlk1WERmQkZKcjY2VkhOa3FYTU9vUVVTRGIvVUxPWDFjUVFkYjRyV2tJSjExWk5xWDhMWmlLKzAwMzhUc3BoeHMwaUtlcU9RaGY2czEvT1ltUnlseFZzR3hLcWVIcEp0aWxWUm1xeCtJaVorNnlHS096ckdEKzJMRlk2VXA4WUwvM0dWSjY0b0ZZN1UrTUlxUGw1S1JnN3VTOHVjT24xeGNrcUxYMTFXVWJKelAzV1dXTS93QlJrVXZ0akF4UDJkWXdmMnhZeGwrcXlLK28xMEtLbzVUdklWcG1hVFg3eXl4YjNUS2pxTXNUR1dVejkxa01VZG5XTUs5bmRFZHJqMEo2MDZWemVIR0REbjdZR0RQOXdKMzdzSVlrN0k2TUhmUXVDbElPbzFXV3NZTmVzKzZ5TVovT3dLWDJ4Z1lTN29mNWx2emNBZjduSi84QVhXR0tsT2Fvc0tCQ2N3bk40V3B1UTQrODhwVCtDZXlaWXpiV2l1S1VxaE9JY28wYzBZMGNRaWhtbFdGVUw4UHFDOHFCMldPTWZLYjVKbElvQ0ZyclVjazFydThrVVg5bVM4bzMweUJqenV6WXdUM3NoamZ2UXdpaGJuT0lSZzFhRTExR29ZMlVoVmJzbkVCTExDMEVsNFo3NnhsVmU2U0JnRDlHUUgvMEZld2EvY2lSaG5zYkl4MzhyWXdkM1JvUy9wSEJpWHVZL3A5OWFrUy9wSEJodjl3RUtsMjU0WVkvY0FxWGJueGhQdndxM2JIeGhEdjVpcDl0ZkdFdS9DcjlyZkdEQ0x4Z3hYKzBPakFuMXFoaVV2OEEwWndVejBkL2dLMTlEN1NsL1BKOWpWRUc1VFhrbGd2MWZMS25KNGVLOUoxb3lLbFBpZ290UTVxeEViNHVIWkFiUG5INmMwS2YrN1ZER2Z6c0NEaE50OWhEN2tXS3pEWUpsbW5zTlNjUmNKMWxaMFRFUnNweE4yWndZUDdZdkpzN0xJODVIMUNDSDJESDFLeEpPektoSFliTmtybXczWVF2a1VrUlVxUzR1K1NqdW96eW1RMkp6QnRQWVBjVVU5YUJML2RaREZIWjFqQi9iVmlxSU55bXZKTEJaL3JsbFRrOFBGZWs2eVpGU254aE5Gb0Q2eGcvdWE4cVgrNnNxZ25oNHJJekdNMEgrQXNVbzcweGdZa1FhNk03YkIvYlZqR1Ivak1rTVRvNGRJam9GWmljWEQwZDhxYTV4c1FSM3NzWElNcWtsUUxxS0Vrbk1STFZsTC9kWkRGSFoxakN2WjNSaEpwRDdNcHBkbE5RbjRpM1Ayd01GLzdnVHYzWVF4S2RxSzZNUHFWRm9ENzR3elVLZFRrT0trVU45dHZFUDRlTS9uWUZNTWlwYkpqQ0RablVWcnp2N2Irbi93RHVzbmNGVmxiaWxFM2hoNVZKanRtdmRLMnVFVCtCcXFUcDhQRGROa1VxbTh1K0s1UTQ5YlkwcnBiT0pNUEVjY1Q2VmlIRWtsSnlWVTJOU3FBOUhZRkllcXNhaXNtaXAwN0U5Y204VjNEZUdDcEI4dy9Qd1RNbHpuWDB3TVBQeEtFOVQxYkNuQnBIRGFTZzhSNFprMXFhbDl1Z1lWbFVpb2N5NVg4TFNheFA1aHZEZUc1RkVrTGNjckdGSlRjem5xVVZmckpNYVRwK0ZKOCthY3lyWWlvcnRaaW9aYXBPRHBkUHFMY2xZbVlJbXlaamp4WWFvVDlFUTZsMS93RFFWN0J2cGlSSXd6Mk5rWTcrVnNZTzdvMEpuU0c0TVM5eU1mMCsrdFNKZjBqZ3czKzRDRlM3YzhNTWZ1RVZMdHo0d24zNFZidGo0d2gzOHhVKzJ2akNYZmhWKzF2akJuZDFDdjhBYUhSZ1Q2MVF4TDJad1UzMGR6dDcydGZRKzBwZnp5ZlltUkdWamJja1lYcWFpVkF4S21vVDB4MFY1aCttMVZOU2FxMklrMU9MeXNkaUFkUHc0NjByRHJQSHBFdHNZWkxtS2syS2QrN1ZER2Z6TUNsOXRZeXBIN29HTUkrbDVxU21yeU9id3p4aFNhK3VsUmpaS2lWWlZXYVdzd3l2VzBSNVBmVklIMkRIMUxnbS9vR0dTczJXVWM5TWhhUWh4QzFHUkNRdlF5WjVWQ1VxRkRXK2x6R0xac2ZCaENDNGsxeTE0aFpkZzFoTTRxaldTclVGYkViQi9iRmd5SXlzYmJrakRGVFVTb0dKRTFDZW1PaXZNUDAycXBxVFZXeEVpcHhlVmowbUFkUHBQQ1ZTYW1xbFNEZUtpMTlkVmxHeWZPblQ2NHVTVUhGVGt5WWhnWXFnUDYwVDJkNUo0QXE4UmRZbzZWTjB6RTNJUmVXa1FKWlY2bXVhNlhVWE1Pdk9ScFpjVEV0Wkp3c1kvUk5pS3dtVFJHMlZVQWxvcnJUYXhpbW5PUzRxWG1tOFdwUkJKQjRUcHkyVzFTM0JpRmwyRFdFemlxTlpLdFFWc1JzSzluZEdDLzhBY0RGTVk0OVI0aVhQMndNRi93QzRGWWU1YkVTbmhMcUZUeENTWTdOWFpUU3NOOHFtaDBhQTdURzNINnF5MVNxNmxUZU0vbVlDY1FUbm9CUW8rSEtVdW5SalU3N2orbi8rNi9McXZhcEdWQTdMSDltLytncjJFaDNnVnduRHdrK2x5bUd5TWJzTFcwMnNZTmpMT29rdE5ZZmJqMDEwMTExMG5xa3N5L3A5OWFrUy9wSEJodjhBY0JDcGR1ZUdHblVweENkNWJTbjRqalNjTlUrVXhYYnJxM2JIeGhEdjVpZWpYQmRTTUowK1I0cHpJcmF5UlNualBCOVFaYnJTdFZYWWNrMDExdHZCMU5sUlpUamptTXA3TVduY0k2UmRUQ2wvd0ZhK2g5cFMvbmsreVcyMjRWbHRNc3NwczBaRW9yRzFGaXNxMU4vbXdYZlZzdy85VWdFQ1NSSGZ5V0s5eGJLYzdkV2dzamhRMUwxcUxvRklRNFdsYkxEREJXYXlXMjI0Vmx0TXNzRlpveUpSV05xSkZZVnFiOHhSWXFWNnlDNDBaMVdwd2lJaTZPeDJKQldkYmJiYVRwUjVlVGlHNXhEeVVoRGlkSzJXR0dDczEvQzRBLzNYNWRWN1ZJeW9IWlkvczMvMEZld3JVVldzbjA0Y3hhN1RWRVM0Mk9ZenpkMVRlT2lFNGNhclRLcFBNeU9vdzNZVWsyM2FCV3lvMTFCZjlTWnEwR2xVUEZUY09VY2h0eitvOHg1czIxdDFkNU5UWEtZWi9xWThsblNhTWNyVEw1c08vd0JScGI3U20zS2RpWkZPbExrSWQvcVBMZWJOdGRLeDg5QXVrcTNqeVRVbStHbUszVTRaODIzQi9xTE1pb0p0eDcrcHI2ay9CT20xU3Z1Zkd5MGhob20wKy9yZlNBT1pqRG1ZdzVtTU9aakRtWXc1cU1PWmpEbVl3NW1NT1pqRG1ZdzVtTU9aakRtWXc1bU1PWmpEbVl3NW1NT1pqQ2ttU2xTVEwrQ0l6U2R5WWVKNUZ4SVFzM1VLSXZUenlIaVpRRE16TzUvMlBoQ3IwK2xjZm05M1lmRzdzUGpkMkh4dTdENDNkaDhidXcrTjNZZkc3c1BqZDJIeHU3RDRQRm1IVmthVmVONE5DTVY0Y2JUcFJ1N0Q0M2RoOGJ1dytOM1lmRzdzUGpkMkh4dTJnRGQxQUc3cUFOMjBBYnV3K04zVUFidXcrTjNZZkc3cUFOM1VBYnVvQTNkUUE3aXlncWFVUmZubVJHVmpkbzBSdzdwaFNQQjU2aWNZL3FUcGJKSWMvcU1sMXMwSFhKTE11ZHhHdko5Z3FGRVVxNXBRbEJXVG00eXk3ODdjU00wZDBDeEdDU2t2VCtCY2FhZVJvYzhMcGc4THBnOExwZzhMcGc4THBnOExwZzhMcGc4THBnOExwZzhMcGc4THBnOExwZzhMcGc4THBnOExwZzhMcGc4THBnOExwZzhMcGdaWVlqcDBzL3diYmltMWFrc3lFUEY1MzVLR2VnV3RUaXRTdjc2a1E0OHI5VHdlRVBCNFE4SGhmM1czTmNSOHlKckt2VW4yUngyU0NwcktmUnlZNHZvV2ZULzl3V00xZjRmL0FQL0VBRXNSQUFFQ0FnUUpDQWNHQmdJQkF3VUFBQUVBQWdNUkVpRXhRUkJSVW1HUm9iSEIwU0FpTW5HQm9yTGhCQk5BUW1MQzRqQlFVMkNTOENNemNIS0M4YlBTUXhTUWs2Q2pzTVB5LzlvQUNBRURBUWsvQWY4QThFTWFiNzhYWisreE5rZjYzV2tKazJWMWRsVmZYV29jeFA4QWZYTDhyaWFxVGxORXB5ci9BS0pBVGtLUUhWWDI0MWIrVnhnSEpDTXgrYkNuRkZXZmNMcE9tS05kVjg5UXJ6TG9QRXhteGpzL0t0Wng4aXJyVGdyOEp3ZExiK2JSWGY4QWNSNkk3QjE0K3F6R1pMSFZqbE0rWDVYcVR1ampRbTRLRXF4bnVSNXFkeUxmYWgrVXIveW9QdUxwRlY0YmNGWk42SlZ1bWFIWWh5YkQrYStrSlMrL2JncU9qelZIUjVxam84MVIwZWFvNlBOVWRIbXFPanpWSFI1cWpvODFSMGVhbzZQTlVkSG1xT2p6VkhSNXFqbzgxUjBlYW82UE5VZEhtcFVHNXI4TjZ2dFFyVnYycE5ZR0xnaWFUR3VJc3VIVXFPanpWSFI1cWpvODFSMGVhbzZQTlVkSG1xT2p6VkhSNXFqbzgxUjBlYW82UE5VZEhtcU9qelZIUjVxam84MVIwZWFsNnVIbXRkZHkya0tsb1ZST25sMmpDVFZLenRUanE0S1ZGc3JSWFlDcU9qelZIUjVxam84MVIwZWFvNlBOVWRIbXFPanpWSFI1cWpvODFSMGVhbzZQTlVkSG1xT2p6VkhSNXFqbzgxUm1jM21qTSt4WHB4MWNFWjA2VTU1cVBWalZIUjVxam84MVIwZWFvNlBOVWRIbXFPanpWSFI1cWpvODFSMGVhbzZQTlVkSG1xT2p6VkhSNXFqbzgxUjBlYW96T2J6VnZzWk5ZR0xnaWFUR09jTExnVGlWSFI1cWpvODFSMGVhbzZQTlVkSG1xT2p6VkhSNXFqbzgxUjBlYW82UE5VZEhtcU9qelZIUjVxam84MVIwZWFvNlBOZEkxL2tqRWNMUzQ1aE5RblVzVWpOUW5BbXdTTmFGUnNPT1NodUpJblliTWZWblVGMzZTbWtPeFhwaHA0cFY2RTBpZTYzUW1FU3Rxc25Zb2JpWlRzTm1QcVVNMHJaU001WTAwMGNkMmxDVTZ4MVk4TnJxejI0Uk9Tc3dWRTFZTGNGbjJNYVRtMUhtdXRIWW8wM09ZNERtdXRJNnVTMGdHek9tRVN0cU45bWxNSm5PVldLM1JlbWt6TXJMOFhXb2JoUEdDbUdrTFJLc0ljMnlkMCtVSkYzT1BiNWZiMjRMc0Q2Tk95b215MndIR28vZGZ3UnBNZEtSL3dBUUwrUTBrTnR6ZGFZU0p5c3Z4ZGFhZWJibTYwdzBzVXE4YWhPbzQ2SmtoVWJEalREU3hTcjBjb3lESy9ZelJZMjA2cmxIN3IrQ2ZTb1VwMUVXMFpXak55Qk1tNU5KSXVrbW5uV1orcE5JdXN2eEtFNGtXMUdwTU0yMjFXZGVKTk5FMzNJU09mazJNMzJleVJwT2JVZWE2MGRpalRjNWpnT2E2MGdnWGNscEFObWRNSWxiVWI3TktZVE9jcXNWdWk5TkptWldYNHV0UTNObmpCQ1lhUXRFak1JYzJ5ZDArU0oxMTlXQ3o3SG9xcFhWZmZtSTRiNGIwNEY4b2hxSU5FU3hpZlhVblVpNXhlQ0p5bFJJdmt1a0hlSnhidGtqSWY4QXB5SjlUeUxsRUg4eHRmT2xaMVQwaFZtSFFhVGpJdEs2TXU5UzlXc3FMNGwvNUREYjIwS3RjbGFQUnh0WDRjWWFKSzF6SFJORGhMVUYrRTNmZ3ZJNVZvVnlzSzZKcVZwK3l5bmJUeXJSUm4xUG4vMVZoWkM4U3VFWXJvR01DM3FMWmhXQjdELzl4WHZhejlUcTlTOTJOTFEwOG4zbkJXRGxGSEFVZVhmZytMZHl2ZUFHbWF0TVNHN1M2clVGa1JQRXJXQXRkMnd5NXAyaFltK0pXZXNpNkE5V1BhL3UwdkxsWG5aN0htOFE1V05XUEhOL3pGTTdGa1EvRVYwakVpbHZXMjd0RTFsUTlpdFBvemRxdGdpRzd0ZE9lMEw0ZkNPVGVmWk10MjA4cTBVWjlUNS85VllXUXZFcmhHSzZCakF0NmkyWVZnYzA5OVh2WXo5VnVwZTdHbG9hZVRjRUtrSkl6R1BsMUJXS3o3OXhIRDd6SE43U3IydUZXZEF6aEYxbVNSMTQwMG1pMXc3UzZrMis1VXE0WHF5WkExem5PMFZJdUpMZzZaQUYzOXhRUHUwdXNXeVRUL05wZjRVcVVyYlpxazJpNXhFZ0RVNHpyckVqcFFJTG5OSS94RXRLQkZPR0cxQUd1Y3plS2tIRnJXUEU2cGt2elRzN1VYZXBhMmlXNDZwVGxPVnFMZzVqQTNvaVJJbmZTM1lNZjJWWkNFZ1BzY3AyMDhwcHFoaHYrUUprYmJLMERSTU5qWjFUbXp0ckdoQnhheHJ4TXltUy9OT3p0UU00VDUvNHFrVEVjQ1pnQ1FEcVZWWm1kQ0xtRnp5NDNWWENvcWsyazhQNklQdXl5aGVyT1JqM2NnemNvZFFRVExmczhXRDR0M0tGWkxDUDhYVFRUMG9aYjFNeHFrWFJRUklnU0V6TTF6cnpWQkEwSHRBenpEWlRWS2NFQ3FRcklydHBia0RUYjYwLzVQc3ZWSnptRjFkdk5jMlY1eDZrNG5yRXZtZHliL1k4M2lIS3NhbW4rSE9sK2t0Ykt2UFdxUWRDQUVnQkl5TXhYTVN6MUZDVHhFYy9OWEtwVW1pSVdrVkEyRCs0SU9vZXJFTVdUcU5wUmQ2dDdTR3R4V1NxbklXWEl1cEdWUmFKVkFDMmx1NVB2Vit5WmJ0cDVUVFZERGY4Z1RJMjJWb0dpWWJHenFuTm5iV05DRGkxalhpWmxNbCthZG5hZ1p3bnoveFZJbUs0RXpBRWdEUEdab3VZWFBwRzY2UUZSVkp0SjRmMFFmZGxsQzlXY2pIaE1wOGw0ZFBGZ2FHak5ncXdHaWZ2dkVjSW0wOENtZnloemF6VlU3UHRVS3Q3U1owalZLWEZONXhpVVNabXNUY055Wi9EaE1EcU16WDBzK1pOazJKYTJaTnhOdHR5Wi9LSE5yTlZUcysxTi9pMnp6VDBXSmtvWllTNnMyMVo4K3BWQTlGdGRlYWVZWjB5a1BXRmdFeUpDbFJScEJvbTFsS1JPL01oS0hScFVaL3NwdEFQcWxPZVBoZ3greVpUdHA1QnFkL3RNb09nM3pKblZOUStZV0UybTJmV21WdWlVVFdiS1RoanpKbjhNQ3laeERQTlF2VmhwSVBPSm5YbnNYUmRXVFhNaVg3dUNiUWxFb0d1ZnZVWjFybVJZY3BFbnBWVFRUU29VcWM3NXk2dVJsWVRLbWEwMlRXalN2ZVZyc0JxUnB0QW45bjhXN2tXRndHdFFMQlNuU2RtcXRVS1VObFVxUnRuYk8yNnhObVlWbHZ4Y0UzbnROUnIrSHN2VGY0bFJKcnNKeEtzaXdWN3VLWlNNVnhBck5Wc3RpYVlnaHVrQk9XTEYxcXVHMXRLWFhPL3NUYUFmN3M1NitSa2oyUE40aHltYzE0ZE9zNHV0UTZROVlXMm5tdHBFVDdMMXo0TFJuOHM2cVlIYXY4QVM2QmFYR3M4NlZHWFZiZEpOb0J6NkpFNTFUTmRmVW1VWFFMNWt6cW1temlVUzRWbXFxcmp5YnF2Wk10MjA0V1VxQUJGWkdQRjFMMGJvWFUzWXNhSDhONEpJeFN6MnB2OE10bUJNOFpvYzhSQTBHdXcwWlZXWHBoRDJ0QnBUT3l4TmtZdHR2dzhVSk5jT3VzZGE1MFh0cVA3NjAwaUkxbEtsUGRZbUV2akFtYzdLcHBoaU9NUXN0SWxXUk9ycW1yQmd5dDMyOTNzc09sSWlWdTVRTmJ1S2dhM2NWT0c3U05mRkNUbXB0Sm9CS2dhM2NWQTF1NHFIUk5LVitJNCtwQ2JYUGFEcFVEVzdpb2RFa25IdnczKzdacFhvN2RFOXFoMERqYndzVllOaHhwbEtqUmxibnhLQnJkeFRaTU1pQis4NEtnYTNjVkRva3VsZmlPTXFIU2RTSXRPYk9vR3QzRlFOYnVLaFVYQWk4NCt0VkFXbkVvZE00M1YrV3BlanQ3S3RpbklXdE83bDRqaHg3a0pOY0tqajVwNG95TDRaa2NSRXVLYVNXUkJTelNMcHpWYmpEQWwyUDRoUW13M3VkWElVYld1cVFrSENyUHpUeENkWDZ1VkhOWk9hRmJDVzZTSitKWi9DVlJlMzF4NXBFeU9mYmIycUovRWdnYzJVNTIvdXhmekhRNngyK1pWVHAyYWVPQzRqMlRLZHRQSXg3aXB0b25tNGpWMVkwZVlXVDdacjhZK055YWFKRnNxdWlMMERlR3pFcWdkZHFmUmRMNWJFQXcrdGJZSlRrOEdmYklsRCtHR2loMXk0cUdYUm90c2hPWCt0dkk5MXcyNGVrMnNLOUhtaXRDZUpWV0xQd1JtVFVqUkRMYy8yWHhidVJsdDJySS82cDlDbEZ0dHNkdnJDOTlqVHFjTnliUmNYWDFXMFUrdjFZRkhGYldzazdRcUwyVXpkV3l0MTgvM05VWWdwRG1FVHJrMFR0L2NrZWQ2b2JYY1FxbllyN09SZFY3SG04UTVRbXdOZFhkV0U2bkRmRWNDMlU1VGNSUGVjeWRRWk1ESEtvWGRibFk4RGh3VHcxMUEyMzFOcVVvVVIwU3FRcUZacmxyN1VBQlpOb2xTbU01cnhLbUdoZ0JGVmtuZEhQYmJtVm5JdVBzbVc3YWNOb2FQbVJtYVV6b0NkelJERWppRmM5aysxR1lMQ0o2SmIxVko3YVgrTHgvdFRheHJBWmp6QzkxaE9wbzNwMU9pODEyV2sxZGxRV1BncUphR2RNQ1U3YjU5dmFxTDRjalhLdHRWazU5bGx5RTZVWjFMKzB2ZHVrczJ3VDE0TGJlVGV2OEFmMkpROWt4akJDbFdXZ3puWlBOZzk1dXovYXVidEk0WUxDcm5BN3Q2eTJiY0dNN01GZ3IwVjdjRDVGM2IycXdxMkdRUnNPMWZEODJDK1kwVjd6Z3kvbGNzbzdCZzlJYnBVWnJuVEZRT2RXeENUb3FHeEdUVzFsT25SdHV3V0ExZFZvMWNyRWVSRWNSbkpVVjB4WldhbEVjSjJ5SnJUeUhZd2EwOHVHY2txSzRnWnlvcnFXT1pucFR6UmRXUk15Snpva0hHRkVJTHJaRTE5YWVRN0dEV25tbGpuWHBUaTQ1elBEZVBZOHAyMDhtSVhET1NWRmRTc25TTTFFZElHZHB0eHFNLzlSNHA1ZExHU1U4eWJaWFoxWWs4dTZ6TlJDVzRwbVNqdi9VZVBKTXpLdnNxd2lzbVpXVHVUWnB0RnhUWnVDRWlTbjBSS3ZsMjRmaTNjZ3lJVVIxTEhNejBwNUxjVTZsR2Qrb3FLNzlSVVIxTEhNejBweGFjWU1sRWNKMnlKclR5MDVqSk9OTEhPdlNuRnh6bWZJTllNOVBzZWJ4RGxSSEJ1S1prbmx2VVNFODBUZE15VHk2Vmt6TlJDYU5sWnE2c1NlWGRabW9oY0JqSlRpQTYyUnQ2K1Q3NDFqMlRMZHRPRjVFN1pHMVBJYWJST3BSWEVmM0ZSWEFDem5GT05FMmlkUlVSeGJpbVphRkZkVlYwallubWhpblZvVHlHbTBUcVVRMGNVekxRb2hEY1V6SlJDM3FKR0hITFRnUDNGakdEOFIyMDRQaTNMNFJ0d1ovRVZpQjBFRlpiTnVER2RtREpPRElHMHJJWjRRc2xmRDgyRDNIQTd0K0RMK1Z5eXpzR0RLTzNCbjJsVlV3UW1PblVLcGJ5S2t4K2h2OEEyUUlEcFcyMUFEUHlyMUVicjRLSTNYd1VSdXZnb2pkZkJSRzYrQ2lOMThGRWJyNEtJM1h3VVJ1dmdvamRmQlJHNitDaU4xOEZFYnI0S0kzWHdVUnV2Z29qZGZCUkc2K0NpTjE4RTRFV2lYc2IyODRrMzNsUkc2K0NpTjE4RkVicjRLSTNYd1VSdXZnb2pkZkJSRzYrQ2lOMThGRWJyNEtJM1h3VVJ1dmdvamRmQlJHNitDaU4xOEZFYnI0S0kzWHdVUnV2Z25ndGRXTXh2MDhnVm8ycDFXSlJKQnlFNWZZWFlYQVVaMjU1S0kzWHdVUnV2Z29qZGZCUkc2K0NpTjE4RkVicjRLSTNYd1VSdXZnb2pkZkJSRzYrQ2lOMThGRWJyNEtJM1h3VVJ1dmdvamRmQlJHNitDaU4xOEU1cEVzL3Naa1hTMmdxSTNYd1VSdXZnb2pkZkJSRzYrQ2lOMThGRWJyNEtJM1h3VVJ1dmdvamRmQlJHNitDaU4xOEZFYnI0S0kzWHdVUnV2Z29qZGZCUkc2K0NpTjE4RkViTnBuZnc5a2UzbkVtKzg5U2lOMThGRWJyNEtJM1h3VVJ1dmdvamRmQlJHNitDaU4xOEZFYnI0S0kzWHdVUnV2Z29qZGZCUkc2K0NpTjE4RkVicjRLSTNYd1VSdXZnb2pkZkJkSytYSnJIdDJNWUpsNUpOZGduMkoxRm92SzZEYW04ZTFYdjJBSzRIWXJuSGp2V1E3WXN0bTNCak96QmtuZGd5UnZXUXp3aFpLK0Q1c0dUckZZd1pmeXVXV2QyQ09hek96elVXbFhLenJSNlZiZXZGMjNZS25peDM3dVFrNGZmOXl0djYwNUhBUHN1bCthZ2g3VGpHQjBueklyRjRWaUVtUksrbzNoWGx4MXkzTElkc0t1ZnVIQlhpU3kyK0lZTVoyWU1rNE1rYjFrTThJV1N2aCtiQmpJMEVqZGd5L2xjc3M3Qmh5eHNkZ1A4UzQ1WG50d1ZSRzlFN3VvcW9qNy9zdlRxc0J3bEJXcTNrZEpXL21XNVgrM1l4Zy9HK2ZCY1RzOGxpbnBKS0V5UmQxcGhiMGJRUmp3WFJRTy9neG5aZ3lUZ3lSdldRendoWksrSDVzSHVSWDZ6UGpneS9sY3NzN0JnZWVrYjg2Y1NveEZMTjVxT1pzQk5tTHRYOHlIckdQamdzZEk2UlhyL0lGbDRScnhJUzZsRXBiVXhWSThtczZsYWZ6TlloVWpWN2JqR0FWK3QrYkJlVHEvMnJtTjJjajhZSFM2ZURHZG1DOXB3V0ZnMmxXaGpkaXhMNGZtd1h1SjBPSTM0TXZjNVpaMkRBMDlJM1owMHJFZHBWcFk3WVZaUU8wWUxnMzhoQ2tqSXA4Z24ySTNTVmlxWE9Sa1B6U0VPU2ZhTVl3TUFKdElBd2YrTVM3VGJ1VnlkUmNYU3Vza2NmWW9sSnBCdUc0WUwzd3o0Y0RBNldOZWp0MEp0RmpLTlF4RVZvekJUQTZWa3hQQWVjK3M5UTg5aStINXNGam52R2tuZkxCbC9LNVpaMkREa3JwTU9vK2M4REEyZHNoSldCV09OWFZZTlg1RWNRbmxQVHlqUCtoTEM2a1JZb1R0WEZRbmF1S2gwTTVyUForeXE2d1RwVUoycmltRnRFenJRbUJPek9DRkNkcTRwcERXVVppL21sUW5hdUtoTzFjVkNkcTRvU0JsYm1DRk9IaXZIVVUxNDdCeFVJazQzY0I1SjFKeFRDNm5Lek5OUW5hdUtIdjArOU5RbmF1S1lXa09uWExFVXdrekpxbG1VSjJyaW9UdFhGUTNBdUVyazZUZ29SQitHdlVaYjBIbnNIRk5vUXpialA4QTlHZ1A2MzNLekJYZ3MvSTUrNXc1M1VvVGtKZm5tNUczQUVjTnVHejdodSs0anpTckxEMWNrMTRnbUllM3VsUG90eHFFMWpWWTVkS1lsdlZpcy9PdHVDM2xYS3RWSS9rTVRXZ3JOeUxWVzVGSDI3b3c3TS83dVY5MklZc0h1YlN1aXkwNS93QTgxazhocXFVcFliL3VLemxXKzF0bDJxd2NucEhZckNyZHZ0bG1HeTNCYVVmNGp0dmtqV3JYWVRLZDZ1disrekp3bHRDaTkxdkJSZTYzZ292ZGJ3VVh1dDRLTDNXOEZGN3JlQ2k5MXZCUmU2M2dvdmRid1VYdXQ0S0wzVzhGRjdyZUNpOTF2QlJkVGVDaTZtOEZGMU40S0xxYndVWFUzZ291cHZCT3BFT2xkaUdMN2Nwd1RnbkJPQ2NuQk9DY0U0SndUZ25CT0NjRTRKd1RnamdxVmF0d2xHWDVKdDVOdHlIV1BiY1J3ZGF1QTJZQlV6bzUzR3pRanpXVkRmclZwNU9OV0g3NitIeEQyVExPeHYyL3crRWV4V3hOZ1Z5TnFGUy8wRlUxdFF4bE1rNGkxR2IzWUx1VFp5b3RRY2JtNCtwUmRUZUNpNm04RkYxTjRLTnFid1ViVTNnb3VwdkJSdFRlQ2k2bThGRjFONEtMcWJ3VVhVM2dvdXB2QlJkVGVDaTZtOEZGMU40S0xxYndVWFUzZ25VbjMvYVZCRGxtVGh4VVhVM2dvdXB2QlJkVGVDaTZtOEZGMU40S0xxYndVWFUzZ291cHZCUmRUZUNpNm04RkYxTjRLTHFid1VYVTNnb3VwdkJSZFRlQ2k2bThGRjFONEtMVmZVMnpSZ0UxYXJUWXY1anRRejlmMjdiUUx5aEp6V09JdHREVEpSZFRlQ2k2bThGRjFONEtMcWJ3VVhVM2dvdXB2QlJkVGVDaTZtOEZGMU40S0xxYndVWFUzZ291cHZCUmRUZUNpNm04RkYxTjRLTGJtYndSblZXY0Y5UXdlNkZsSFZVclN1a2YyVHA1TjF2SXZ3aWNwYjAzV2VLaVNZMDFDUXhER0ZHMU40S0xxYndVWFUzZ291cHZCUnRUZUNqYW04RkYxTjRLTHFid1VYVTNnb3VwdkJSZFRlQ2phbThGRjFONEtMcWJ3VVhVM2dqTjBxejl5WnZFUFpNczdHL2IvRDRSeWo3MHBiMUU2YkhQc3hTcXR2bW55bTlyTE1kNk5jR1hiTXk4MUZuRWhpY3FNZ2I2alNPeFA2VFE2Y3JLcDQwNytUbXRybDJjbTlXTkNzVlpSWDh5SllNMTNGSG13eE1EUGNqT1c5ZEJsUTNsRkd2RFdnaFVPVmxPMm5sQ1FlSmpxVEpVSlRySHZXSmt3NEVpeXh0cWJPa2FJc3RsTkFFRXlxTFRYaXFKa21jNWx0bFVrT1pPWGJieWJCWG8rMHMreHhieHlyVFVFMytJTHVyVWhVK3pPbXlEVFJObHRxYktpQVROelJVNnkwM3B0WWJTdEhSeDUreE41aE1wNTBKVEFQWWVUYTQ2aGduTFF1ZzFObTMzUmpPZmszalhjalcxT3FjMmtoTnhyN1BzR3Ztem1tb1hWWlNhK2IyT2FLaGVDTXJram12czdFeVVnQ2F4WTZvSnMvV1RvMlYwYlUyY3pSdXRUYXB5cUxUWG5rVEx0VE9lMjBUQ0hNQmxQUHlicTlDYlVVVTNCWTBZTEdiU2p6VzgwZG5MdXdZOEljYWRrZ0x1MEprVFFQOEFzcDBYbSsyemtDWVlKbnFUWmlZYmRhYkVLMlRKelN0VGVlUk82eVU5aWFPY0pqbk5tZW9UbW0xT3FIV05hWno4VldLZlZ5YnE5SEx1OXUrSHhEMlRMT3h2Mi93K0VjcjN5NlhXS0ozS3dNak4vVElibCtQRFhTRW1IL0Y5UjBiRmtId2hPb2dRR2lkZnZWWFRLTXhFaHczZnZSeWNvWUtrRllTQXVpd1ZMcEZzeDJHYTZjWG5ITTAzZHVBcTFHcFhLdWF1UVZmSnluYlR5dmNvei90SW44cXZiQk8xZTdEakhRNWRCMFdrM3FMUDJGbHcvR21sMUtLR21Wd3JtVG1yWHV4aU5EZVRjT1hkeWIvc2NXL2xaYmRxOTROMGt5UGhLeEh4TC95eEtJL3VvQXQxaFpFSGN2d0luaUNhYUlodGZPVlU2VXpYMUZmaHMyY25GdHJ3Vi92RWpKZzZSM2RaVmwyWVl1VGJQc3dlNHhyZjFLb2VxcUdhY2hwK3d5M2JUeXJpM1FYT0IzS3dzaCtNcTcxMnhkR0pHWTRkclR2bXNwbi9BQ0pzelNZS3E2cGd1MUJDVW92R1hKekJDWU42cnpjRXd0T2ROSmNVWnZkVzc5NThGODlWU3Y4QXNMdVJpUEtzY0d0L1VhTzlkS25EY2UySkllRlpFVHhMcFFoSTlUb2N3ZE13c1RQRXZ4b21velRTMHVhOFNPYWx1UEo2dVhaN2Q4UGlIc21XZGpmdC9oOEk1VHBVVE1XV21wUHJaT1hiYnB6cDBxSm1KQm9FOGNnSkkxUk9sbnJtb3JXMGhXU0d0bkxHUUpucVQ1dE1oWVBkc3VtblZTbzF0YWFoWEtzS1hZQU5Ra09SbGNpc21wb3o0OEJrUXJmZWJpempOc3dYWUFqWWpiZ0t0S3I1R1U3YnltZitNTXR4VDUxbWV6V29jMk9hMXBycjV0aG5MY29jbUJqbUN2S3RNNUprL1ZHZHVwUTVVbkJ4bTZjNVZ5NklrbTBlY1gyenJQWmNvUms1OU9wMHJwWko2MVp5TTNzdUxmeWhPaVFkQlVBZ0J4ZlhWT2M2ckxxU2gwdlYyU2RMUEkxSGNoemkrblBzbEpRNm9nYlk2WFIveE5xaHlaUUxBSjJUcm5PVmVwTXFjMmpSbmRLVnN0eWhrT0RRM3BDVldhanY1RjVHMUN3YXNBL2lQUm1CYWNaejlYTGRPa0s2NXlLTTVDZmE3bXRSOTlrTWRUUk55c21lWGx1Mm5sTTZMQzIzUE1HeTVRNXNvTllhOGt6Qm5LcldvY21RdzZRblh6aFdaeTNKc3hEZlRGZXF4UTVlc0lMcHVuWVp5RlFsV21VYVQ2ZHM3cFNzVUk4OGcxT3ZBbGttMVZEOTlYSXZKd09xeEd4ZWpUL2VjTDBjUTg2ZFNjYjhGZjhBdjdIM3VSaVBLRmI2TmVLaVpwa3FWQ1ZkbEN2dG1WQ291aTFFMHBnVHRrSkMzcktiVTl0RWllWURjb1UzUWhJYzZydEZIZW1UY0tkYzczM3lsY21VcURuRzJYU2JLVm5hbWtkWm44cmVSME4vS3U5ditIeERra3RCc2x0dlQzNlIvd0JWV0JLM3FCdzFrby80amVlR2xRZ096QkNCMjZiVldNbS9zeDhuTE94djIvdytFWUdCNWh0cW5XTCtDWTExQmdNaU9hSFYzSHFDZ3RMblF3UTBnU3BWN1ZCWTZJR3Q1cEFrSGM3UmRpVU5vaU9MaUpDeWpjTzFDWmNRMFpwVms3QW9iZlZ0Wk9VaEtaT0pRbXZMWWw0SFJxK1ZRbXVFU0lSV0p5dHMwSmdteUxwYlNyQnhpU3FZSG16RlNVSU5aVGFHRUNSY0twNzFDYTMxY1NqVUpURXAxcUdHdGJFYzNtaTBDbEtZN0FvWWh2ZE9vQ1hOdW1OQ3loeVBka3JNQmtRaEovdk0rWnViTmdybXFwV0lURjZ1Vm5MeW5iVGd2SVVNVVhUQkVoS3JNb1lveXNrSldDNWVqTWFHQXk1a3BpZHRmVmFvYlR6blVaZ1dTdTBwZ01SMUlneXJxejlpWUtZZE95MFVqTUhzVUp2TmFKVkNybW14TUhyQ0M2Y3E2ampSRW1pb0c4cUVHRjFaYUtnYXA4RkNEQzJMUTV0VlZJTjNxQzF2cVdnZ2dWOUdhZ1VtRm5PZFJKTTZyeFplckZaVjlwZDlqaTNqREdIclFKMFpiL0pSUDUrYXlxZU90UjVOaEcyam1CeDUwNllmWWMxOVhtbnlxcUlGVXBZcDcxNlRNdG5QbUdxUmxqVWFsRGlYeXpFMlR6S05RaHd6Um5LM3NtbmRPdzV2MkVaNTFHRFh2RXcyVy95VVgxWmNhSUVweklud1R3UFZ6enpsc1VVQ0s0VWcyVy95VnpodFZwQ0VtdHhycE9FdW9lZjJBbjZzMHJxc2Vjb2MwbWs0NW0xcTVyb25hOHlhaC9JYUM3cmR5RFpoeTNiVHlJRFgwekp4bzNjNnVlaFFXeFMxL05tS1dUVnRUUlJvMG5OdXZ1VFJRTGFRRjJqU1ZBRFlzM1RGSG1rU2RMcnVJVU1BaUpVWkNybkJTb2dYMlRVRU1MeVpnV0VTY1JzR2xRUTBRWWxIbTFURXdNMk5NRFdrVE1oY01leE1EUVFiQkxGaDZRSlREb1RlVC9LZm9FN1o1aW93bzU2OWljMVJRTzFSQVQxcmVuUzFKNEtFaXNmSXhIa1l4dFVCcllZYk9rR3lycnZ6S0czbkF6cUZkUXR4cUMxN2c0VlNzRlU1RHFyVU9vV1RGaGxkaVRSNnlWS2NxNVRuYjFJaVRSVURlVkNEQzZzdEZRTlUrQ2dob2h2STVsVXhPV1pRMjFRd1EyVlZycTVYM0pnaHZlT2NCVml1dzQvdVhONGhoYVhGVm5KdTdjZUg0ZkNNSXJQUjZzZktGVHVsMTQrM2taWjJOKzMrSHdqQUNXUkJLcTNYMXBqdlZPWUcxU3BWVDdMMDF3RkNpMnkydXMxOFUxLzhaclFaQVdpZWZxVU0rcmFET1lGTHNybDFvTzlTeWM3S1ZabWIrcFF5WE9vZ1Rza01kZWNwcmdZbEhGZExQbVRYVGhPbUpTcnR0bjFwcG5USlA5cG5VcDBIT0p6eUoyb1BCaFNvdDV0RzJ2UFltR3Q5SjA1WXBWVnFHNzFZZVhtY3JhODlreXFkTTVVcFN6U1Z4SEl4NFlsRHNtdlNBN1VVeVVVV3lzZG5HZGR1QUtyN0RLZHRPRDNBVHUzb2toa1EyNTU4YXN5YnpIV0dyRUZPdGo2TmM2Z2V1cTFlL0RjN3dvbW5RSXpYVG5vcTdWWjZ4ekQxVGQ1TEpIZ0tKcGVybG1sVmJucTJyb3d6WDJHenRUYUVHdHJheGFlMitTTWk2TlNIVlRCbm9DSW94V2dOejgwaFAvZ2hoblhWT3ExV1RLc2NObkx2NU4vMk9MZmhiNnYwZ05uMWpoTzVadkNGKytZMWU0dzZUSWNVSk9MQ0QxZ2VhaDBaVXAxem1hVnVaTmxCTXlQMG5pdnhQbUNjSGxyQ1JLNmRXSVowSk9MWkhySCswNllhSk1IN3gySytKUGFzZ2VBcjhNN2xsSGFySkJkRnVzL1ltVFhWR1htblR1bm1YdlBBL3dBSVlWdnBEaTkzOW91WFFtYUo2c0l3NWJ0cDVCbEozTy90NTAxMFJFRm4rRkxldWpRQjJ6bCtsUExBUlViNTFFYjEvT0RuWXBrU2RYMjFIclFtNHhEdEM5eWRMc3FscFRhRUJwTFJXTFMwNTBST0xFbTNxbUR1VU9uU1pLMlc1TXJJcXJzR0xaWG13bXNPVFFWQmE1cUhxbzRybzQvM2pWM0ljUjFLTTc5UlZhYWdoWWpWZUxpdmRFeHljUjVHVU5xdG9Balh3Q2xSaGcwcTdLaHdVU2I2VWkycVJiVlhvbklxdVlybGxTVTUrcjdKV2FWWkQ2WFliRTJoQnJhMnNXbnR2a2p6b2tRa2RVNW95aUdFS09sL2tqT01CWGo3Y1B2RGxCSDI3NGZFTUZoY05xYUdqTnlQaDhJd1drZ0t3Q1dBVGlIUUU4YUFoSjdiUnZHRDNocnUxOGpMT3h2Mi93QVBoSHNYU1pVVU8yYUx1U1Z6bVhMbVJyL05DaVJkOWxsTzJuMkd4MVhWOXM1SGxZdDR3MFp5bFNsenYzMkpyWFViSmlaSFZXbXRmNnd6TklUMzJLWFBFdW9WMlY1NzVwclQ2dXkzT01hQXBQbk8yOHp4cHJUNnF5Yzg0eDUwMXJoRU15Q0ppZWxTbkVFdW9WMlY1ODZBb3NzeDdWQmh1YTJ5Ylo3MDFzcGtpcm96eFZxUjlkMHA5dG1sVVpnU0RwYzREcndYRldZYkUwaHA5N0o3TDg2SU1zVmh6OG0yRlU3Y1pZcmxlMHQ2cG95ZERKSFlxbXRIYVhHeFBCYUNKOXZCQ1FOUTZoeU10MjArdys4SjZGZGd4NmxZWkhUZ1p6Y1pxQ2UzWHdVbmRxaG5raGU5VUZmdTVHSSt3KzZWWWZ1VE40aGdzRG03VkdaK29jVkZhU2ZpR0g0ZkNNR1BEandYZzRibkhiaHl6c2I5dkRtNDlmRlFkWjRxRHJQRlFkWjRxRHJQRlF0WjRxRHJQRlFkWjRxRHJQRlFkWjRxRHJQRlFkWjRxRHJQRlFkWjRxRHJQRlFkWjRxRHJQRlFkWjRwdEdsYmF1azJ6T21VY0JvTXg4RjBSZ1pKdWVwQnBFcFZTVlZ4N1YvTWJabnpmWlI1VWlUMGNmOEFrdlNPNzlTOUk3djFMMGp1L1V2U083OVM5STd2MUwwanUvVXZTTzc5UzlJN3YxTDBqdWZVdlNPNzlTOUk3djFMMGp1ZlV2U083OVM5STd2MUwwanUvVXZTTzc5U2o5MzZrWmtYK3lHVks5Uis3OVNqOTM2bDZSM2ZxVWZ1L1VvL2QrcFIrNzlTajkzNmxIN3YxS1AzZnFVZnUvVXZTTzc5UzlJN3YxTDBqdS9VdlNPNzlTajkzNmw2UjNmcVVmdS9Vb3RJRzZVdDU1RGFUbE52WW15Y0tXaWRYSi9sbnBCV2Z1U3NOZXBWWjhGM0lqeXBFbm80ei9jdlNPNzlTOUk3djFMMGp1L1V2U083OVM5STd2MUwwanUvVXZTTzc5UzlJN3YxTDBqdS9VdlNPNzlTOUk3djFMMGp1L1V2U083OVM5STd2MUwwanUvVXZTTzc5UzlJcmI4UDFKMGxhRmxEYXNscXN2NmduVUdNcXFVVjJrcjBnOXRha2VxcFEwMlNjcGxRMGYzbTVNU2pSelQzaGVrZDM2bDZSM2ZxWHBIZCtwZWtkMzZsNlIzZnFYcEhkK3Bla2QzNmw2UjNmcVhwSGQrcGVrZDM2bDZSM2ZxWHBIZCtwZWtkMzZsNlIzZnFYcEhkK3Bla2QzNmw2UjNmcVVTbkt5cVc4L1lYKzJadkVPUmxZZmg4SXdZOTJISGd4SFpoeTNiVGh5enNiOXhWRUtFSGhlaXlLYVdqRUNvV3Nwb1oxQ3ZTblRuYk91WXhGR1J4RzVDeXdvODVYb28va08xT2NXNHJWZHl1azJ1ZU1ZdXhXSXFvZTA0d3NRMksrWVY1bXIwYXNEWGFFeHltT3hUMEtZVHFUdnZ2NGZFT1JsWWZoOEl3WTkySEhneEhaaHkzYlRoeXpzYjl5bEJOd0h6VEpPd1dmY0IrNDZ4OXpZd3NRVm9yVmh0VnFzNVFwSDc4K0h4RGtaV0g0ZkNNR1BkaHg0TVIyWWN0MjA0Y3M3Ry9jNU0wUHVvb2UyRlZQUm1oOXlXdHFPQ3gxaXV3VnBxYmdNL3YzTjRoeU1yRDhQaEdESHV3NDhHSTdNT1c3YWNPV2RqZnVZWURoUDNLUHVHdFZJQW5BMG9GTktacDl2cVRnSkt6OGg1dkVPUmxZZmg4SXdZOTJISGd4SFpoeTNiVGh5enNiK2RDaitaL2g4UTVHVmgrSHdqQmozWWNlREVkbUhMZHRPSExPeHY5WE0zaUhJeXNQdytFWU1lN0Rqd1lqc3c1YnRwdzVaMk4vcTVtOFE1R1ZoK0h3akJqM1ljZURFZG1ITGR0T0hMT3h2OEFWek40aHlNckQ4UGhHREhoeDRNUjJZY3AyM0RsblkzK3JtYnhEa1pXSDRmQ01IdWtIWGhITmZ0d0Nxd1lMQldyOE9XZGpmNnVadkVPUmxZZmg4SXc5SnRSN09PQVRCVUVhOWswSkRCMG9sWFpmdzVHV2RqZjZ1WnZFT1JsWWZoOEl3MXROby9kNmRNSGtIc3ZQVXV3WWh5TXM3Ry9jNFRVMUQrbVh3K0ljZ3ljRkYxTjRLTHFid1JtNDhoOUVwZ2RxVUR2ZlNtaG1zL3ZzVHFSNU9XZGpmdVd4VjhtcittT2J4RDJUTE94djNKWmd0NVZhcy9QUXBiRkFtT29xQnFLWWFSc2xYNXFDUjE4M2JKQ1RoTEViUk82cjd3dkxmRUZQVDVLZW55VTlQa3A2ZkpUMCtTbnA4bFBUNUtlbnlVOVBrcDZmSlQwK1NucDhsUFQ1S2VueVU5UGtwNmZKVDArU25wOGxQVDVLeHNRK0Z2M05pd1kxZXJNR1A4QUpUUVpVUG1VTnVnSVdmQjVKZ0xYZkRua29iZEFVTnVnS0czUUZEYm9DaHQwQlEyNkFvYmRBVU51Z0tHM1FGRGJvQ2h0MEJRMjZBcURUaWxYb0FtZzF6ZXBRMjZBb2JkQVVOdWdLRzNRRUdOR2NCVVhFZkR4Q2h0MEJRMjZBbUF1SmxNTkZHZUpRMjZBb2JkQVVOdWdLRzNRRkRib0NodHNOdzlndnRUZjRscEpzWVAreWM1L2JJYXBJdWIxT250bXZkZTBod3FuSXprNEwzWEVhQ25nRDFUTFJpTG0vS29yZEI0SWd5RTZ1VTlvQU1xd1ZFWm9QQkVHakt6N215bWVNZXlmaUh3dDlpYlNjTGNVOTZoU01wL3NGQ2s4M2NWQkZFNHBneTdiVnpnR2wzWFZOUWFOSytsNUlUb2lhZzBhVTY2VTdBVGlVT25TbmZLenNLZ2tETVo3Z2pOcFVDZEVrZEw2VTJnVDJoTnBTbFZPVjZnZDc2VXlqSXl0bnVHQy9BSjhpN0Rqd1hZRElCUXFzOHlkU1pSbzYxQzk0Tm5QSEs2VzlOcFNsVlltVVpHVnM3aG1HUEEyazRXbTd6VUtSbFA5Z29Vbm03aW9YTk9LWXE3YlZXQ0pxRlJrSjJ6dkdZWThFQ2RFa2RMRWY3VkJsU3ZwWnVwVmsyREdvSW85dTN5VlFsTlFlYU91Y3V5eE5vcGxMUGo2Z0UyaSs3RjVKbEtabGJMY1VKWmxEN1o1cDJTMzRQOEFhZ2loMjdmSlZZeGl3UXZlRFp6eHl1bHZUYVVwVldKbEdpU0pUbllBY1F4cUhRcXh6M0JNcFRNclpiaW0rN1NsUE5PVTFEb1VKWHp0bm1HSlFaMGI2V2JxVEtHZWN4dXdNcHp6eTNGQ1ZML1NoMDZVNzVXZGhVR1F6R2U0SXphZmFmZytiQmpLK0x4T1Vkb1BXb3JYSE1SeUhodldRRTRPR1l6UmtCYXZTRzZVWnRONk9EMDVuU001OUxSNXFJSE1IU2RuWHBEZFBJOUxZeW9jMTEzVjEycU1Jc1Vpc2k0ZFdEMHBrT2ZTTXhTNmdKb0Y3eGVkd3NUd3dIR296WE9OZ255TVI5Z3h0M0sxN25IWExjampPeEhwQjAreXhaSlBhS3hyVVA4QWp4T2M2Um4wcFVlSnhUVHFUSUpaRG5qbFNMaU0xSW1XWllqc1Q2TThRbWRDZlRsY1JJNkNvaldnR1ZmL0FQSlVkbjcvQU1GR2J6VEw5ODFSMmZ2L0FBVm9pSHdGWkR0aFQ2TkxOU05XWk9weXVJa2RDYVM4M0p3Wm1BcEhlbzM2bUZ1NU1sTzhXZmNPVXp4ajJUOFErRnZzUHVnblFxeTJXdWZCV3FzQjNnSGtyVzFqczhsN29mb0xaOFZjL1VLSjNsZTlJYS9KWXY4QTlhK0xjbWlxRUQyaHMxWlVmM3FRbUtUOWprMlJkT2NzMHVLdEladENhRHp6ZG1haExrRzlYRlg0TWVISHlNVzhLMmx1R0Q4Um01WXh0V1dkalY3b0owS3N0bHJud3dWZ084QThsYTJzZG5rdmRKMWlmRlpCMnR3Q1lwUCtaTUE3RllLTGRQOEF0Q3BlOGRuKzBPa0FUMjFxcXJiVnZWcE10QTgxVVRYMnRQOEFwWG5jdXNkbFd5U3hud1lMaFBUL0FLUTVzcExFZExUL0FMd2ZpTTNMR05xeWo0V3E1eEdpWEVySzNGZmhEd3I0Zm1XV3o1VTBCelpXZGNrYTJjM2hxVmtOaDFOSjJsZTY3elh4Ymt3VExHMXlyblJ0UitMY2QzdFB3Zk5neGxUckpEcFpOSjNrRkJhUlNxSkZxcW9PcTNJemNKZzlubGdNb2pxeWNRNGxjOXo3SmsyWXpqbW5GalNaZFI0SE9xbnRZNE8vU2ErM0JIY1FSeld0TWdCb3JLZE5qdWlmM2VFNmxQb2syOVN5M2VJckc3d3R3ZWsrb21CSnJXejB1bURQcVVaeE5vTkkxaFBMMnluWGFKWjFramVzbmVuVVlSTWhuK0oyMlNZWjVVelBocVRxVUlHek5qR0pWZ3UzRk5wUG5WT3p0WHAwblpJRkZ1a0dlbFJYQncrSW96Y3cyNHdWaVBzR01lRlovRVZpM2hZbnJKT3hTWTJpQVNCem5ERVhXeXpDV2RmaU4zcXlSVU1BRXluNzA1VHJOK3BDdG9KR1lnTDhYNUNzaDJ3ckxkNEZrbll2eEQveHJJZHNLWUw2N3lSWFgySVZ0RXgyS3FrK1hVSlVuUzJKZ0FhTmVkTkZsMll5T05Oa0RhTVJ1Y01XSXIzU1I5d1pUUEdQWlB4RDRXK3c1Slh3L05neW43SExKS3lmbGNyb2gxdEhCZS96dFhtcmlmQVY4VzVHMkVCcGJKV1ZEOTZrWk5Ebjd3cHVsUFNaY0Y3b1lOWVVPbE16dDZodVFsU25xSkN4NGNlRDNjQlJ3WStSN3draExHRFllcmlxaUxSaVg0ak55eGphc3M3R3JKSytINXNHVS9ZNVpKV2I1bGtIYTNBSjBYUDF6Q2gwWkNkdWNjVitJemRnejdsa04yQll4dFdXZGpWaU81WDBmQ3VpOE5kMkVTS3orREJramZndkw5K0Q4Um01WXh0V1VmQzFXdzNOZHBxVnJIVVQyQXkxTDhJZUZmRDh5eTJmS3ZoOFFXVnVDc2MxL2VxR3BYZ0hSL3RmRnVXUTNZRmtuZDdUOEh6NE1aUm92alVxOFhQSzlOZjZ6ck10czBadXZtc283c0ZqZzJXaVcwTElicUVqclZwY0piZGk2UHE5Y25ZTWtMcFV0VXE5eXlocXJPcFpidkVWamQ0VzRNUTJMSUhpY3NrckpHOVdtRVpLOE9sb3dYTkU5ZTVXMWVGWTl4d1pidkVWamJ2V0krd1l4NFZuOFJXTGVGaWVzUjJMRnhYNGpkNnlUc1dYOGhXUTdZVitKOGhXUTdZVmx1OEN5VHNYNGgvNDFrTzJGWmJ2K05aSjJMRy9jczNpQ3lYK01MNGZFRmxuN2d5bWVNZXlmaUh3dDloeVRzWHcvTmd5bjdITEpLdkIxTlBGZTY1cDNLNGJISC9xc3VKOHkrTGNvdFRnRElESG5tZGlFZ0VKdExuMWZxUTVqaU5CczBUV2J4QlpaMk4reENDdUt4OGtUVmhic0lYNGpOeXhqYXNzN0dySk94ZkQ4MkRLZnNjc2txL2NQTlpCMnR3WlVUWTdCbHNPekI4VzVaRGRpdWx0Q3l6c2FzUlYwdkNyV05ib0lHK1M5NXVzTUxUc3dYdEcwNExxWi9lbkIrSXpjc1kycktQaGFySEJvOFN0WTRIUk5wMmhmaER3cjRmbVdXejVWOFBpQytJanNIRlBrNTByaWFoMUJkQnhjQjFWeTNMNHR5eUcrRldCdThlMC9CODJDaldjZmtuMEk4R1pCRlk2VTE2cHB5cHUxQ1NjMXd4emtwVXBrMVlPYTl0aC9keWdldWhYU2RaMVg2azBRWVRiQk9leTA2RmtQN1RSTmVDRUl3b2lValJQVVoxZG9QWW9FcmdLcEFhVWFVVTZCNXFLMEI3aWI3eW5ndWlUcnVyQUc1Um02MWNFOE5BYkt2ckozcUlIQ1JGVTFFRFJJQ3VhZUhVaEtwV3puUnNrYzEzWXZRSCt0N3Y3L2MxVk16SXZQQUp3YlJNNitwUldrTk9mQkZiem5FMzNsUERxY3JNMDFpUHNHTWVGWi9FVmkzaFluckpPeFl1Sy9FYnZXSTdGbC9JVmtPMkZmaWZJc2gyd3JMZDRGa25ZdnhEL0FNYXlIYkNzdDMvR3NrN0Y4ZTVadG9XUy93QVlYdytJTExkdSs0TXBuakhzbjRoOExmWW16WTdXTWZXRkRrRGVoTnRVK3V6V0ZEUE9sK3hKZElzZVQxa2ZzSy9naC9LWWRwLzdMTGlmTXZpM0xJYnNHREtmc2NyNnRGaTk0TjJoUTZVek8zcUc1TW8wVDluZHlCU0xWQ05QcnFRcUlrTjZGUklQYTI3VW9ScTV4SnVBV1dkamNEWnNkckdQckNoeUJ2UW0ycWZYWnJDaG5uUy9Za3VrUVNlcy91U2JTbUpheHdVT2pJVHR6Z2IwSjBYUDF6Q2hTcEhHdmR0elNzS2hjL3JxUTU5VGdOeWhrbHRuQTlTYlJuTnFZWlp2M1dDbXlodGxvR1BPVmxiaXZlaGdkMVd0cERVN0FKbG13cGg5WUJMTjFvU3BWRHE4OEFtQ1FlMXQycFFqVnpqTzRCWlI4TFY4UHpLeUlObjdDL0NIaFh3L01xNkxtblFBb1VtNXQ1UnhEck01bFF3WEd2WFZxVlRSUmR4Mkw0dHloVjBRMlltVFpKZE4rb1hlMC9CODMyZVE3d25Ca2oyUEVmWUxpM2NyV09PZzg0YlZaV0o0ckZXMWdkTTNWM0kyZ2dkWlZ5L0VidldJN0ZsL0lWa08yRmZpRFcyU3RjMGpTRXdqcE9NeEwzYVBiMkxKT3hmaUgvalY3WGJFMDBLM1RJa0t4UmxuV0tXbXBIM3lQMUNXMUNaSTJWcGhhSkVWZ2l0enAzNHBJMW12c0htcjNFL2NHVXp4ajJUOFErRnZzUW1FME42cXNFTU5PWUQyeUUyZU9RbmdFd21Cb3pDV0VUQ2FHOVZXQ0dHbk1CeTJDZU9Rd01CT2NEQXdPNnhOQ1F6Y3FHMmxqa0o0Uk1KZ2IxQ1gzTjhIei9aNUR2Q2NHU1BZOFI5Z3N2VHBFVlR1SXhPVU9mOEFhZHg0cnBnVktNSi9GT3JzdVJtYlVEU21DSlp1dEYwam1ad1RTRE9Zc3hTUmRJMVdNNEpwb20wZnZFalhuRmFwZXN4MWRWNkxpRFVhbWNFMDBpNmtMTVVrWEVHbzFNNEtZR2tlWFl1QVFtVGFQSlRFcmpYNW82RzhWTnJEYVRhVllQdURLWjR3bmpTRThhUW5qU0U4YVFualNFOGFRbmpTRThhUW5qU0U4YVFualNFOGFRbmpTRThhUW5qU0U4YVFualNFOGFRbmpTRitJZkMzN2t0V1A3QzM4a3ZvMHFNcWliS1dJWjFHN3J1Q2pkMTNCUnU2N2dvM2Rkd1VidXU0S04zWGNGRzdydUNqZDEzQlJ1NjdnbzNkZHdVV1lQd3U0S2ovQVBHZitxaXlBK0YzQlJ1NjdnbzNkZHdVYnV1NEtOM1hjRkc3cnVDamQxM0JSdTY3Z28zZGR3VWJ1dTRLTjNYY0ZHN3J1Q2pkMTNCUnU2N2dvM2Rkd1VidXU0S04zWGNGRzdydUNqZDEzQlJyc2wzRDJIbW9UYlllckduTlBXMHoyallpeXZNZit5TXhManltRFFoTGtObW1DZjNLME9HSTFxQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5STRLQXo5TGVDZ00vUzNnb0RQMHQ0S0F6OUxlQ2dNL1NPQ2dNL1NPQ2dNL1NPQ2dNL1NPQ2FHak1KZmN0dkxyUDU4Q0d0RFdoci9OZGFxVGduS3RWZjhBdEIvL3hBQXBFQUVBQWdJQ0FnSUNBZ0lEQVFFQUFBQUJBQkVoTVVGUkVHRnhnWkdoSUxIQjhOSGg4VEJBLzlvQUNBRUJBQUUvRUJWYk5EaVhsZ3JDTGpMVEE5bHlRdFlCbkxiTGs4OEVzeFIxRXQ3OG5FYzJxMHErdW5jVUhEaEJPa1BNeGxHMVZ1cUlObG8zN2wrRXBBVnc1ZEptZlorQ1VPMlNMQkt5a2luZDNCV2cxeHpNdkpQVExMVDUrR1dCT2t1QVR1eWw4TVROS2piaE5uSkR5bVhjd2xVYUpsY1d0c3JzY2tSMCthbG9zQWJqYnBURldhZktHY3d4ZnRpQUtYanRocnYyK01ucVo3Qnk4WkZhOGhQbzNWUkZUY0RLMXZjeFRQZk9wV3NhYlNyVlhVYXFDNHlNNnN3NDNxNVlhb21RY2hMQ0pIUVp1VkhpNWkyaU9JOEpham9UYmdtYXF0cU5Ua0lyUnB2eVV6WTRnYmw2dGFpN2ZJTURWYVpjQXloTUF6bktFanVGcEhMS3d6bjJTeUpDMGN6RlFqVmozQUlxMm9XZzF4TndvSUhjZzVEYS9Vc0FDRVlRYlN1QmZzajR5TXlLK1pZKzh3Z3hQSXE0aXY4QUVoUkZ3R0l2RTByTU9rd3k1cUVFdHplb0Jnd1dIbWlHbG1Kam5NMEl2aitBU21YL0FBdUpUbEFCVjQwaExDN3FwZk1udnhzM1hQYVZvUnU1bDZqdWQrQ3BFUmNRY2dSNnNIb3dPQm5jREVnZFRFRjl2aGFGREE4eDRveXBUek1maWdVTW9FWTlycnFXU2xOd0w1aXBzUjhaNytFRG5PbUViKzVpZ3NhcU9rY2F4RUk4YUNiVTl3VGlwV2lvNkJoUlVnNXpEblBwSlVxNGNKRGhSQUdVU0JqbHVDOWdNMU1aNmphZ2VvbnlseTZDTEo4WVNLc1NSV21Kd0V0NVVjbTBURUszeTMrV0c1ZlNTay92TXpKYm1vZSthSGdGb1JGcDBuY3kwZ2kyUFVDV3IyU2tpQTlRdTdFekpRNHpUQmhpazc4Nmp0NG9PMGN6TUM1ZVR2MHhCaEhmTVdYTEdnd0dFWXJUbTh3ejlWNHEvc2VDNzJEaDgzRDBKM3ozQjVoQ1NESmhtenhiL3J3My9DVk0zVFFrYXNjclVPNE5saXB1VzVsZURMSFZaVVpYRjVaY0FHMUN0VmFBazhaSURKalR5Qm1HMHhlNHZ1SzdBY2dweU9ZZUxxWStJeHNyaGhvK2VZSnRRbHdORlVyU0FCdUh4Wk5HdHNOUHJjeEJXYXpaaUxPUU5YRUFyYXRZdGdYT01NZWtQNVdHTkhxeW9LSFpCRXc0aUVJYm03Ti9VeGZIVTVadFlqUHpMdWx1bHhFUkJvSXJWbzJEQnRSdXI1bFBFZmVjSm1Nekw5RHdzZWtodGxaaHk1Z2wycUNESGphazJHSmd1V3FYNzhNU0piWDNpVXVNN2xkQXE2WVhJMWpEYkpIU3VLSlRnd1pUcmNSQ2dGZU41SHVLNisyWW16Y056TmJpRXhvbDIzclVFd0ZzTWVDSzJmSG02ZUViZjFMYjhzb1M0RUM5M2xQd1N1blRMWUdCanZkaXpGZkI0YmlHYmdqUEkwdzRFUDRFeUV3Vk9HY2pUWWtZM3BHNGhhRmFWS2ptRFVHMFdEbUEwUjhZNUFXcndFam5CTTExZU9wZFJ4N1p5dzBKSXZrQnA4SlZGc28rRDRJZkhjeW5aQzhCSzhsTjBvZ0VVWXFwdFE1WFVUU3JuY041elV2SmN2TVNQSWFsUGZpcHF5Q2ZsOE81dGVBalpvSkNoSTN4NDdsY2x1SWhhVkMyRDRsNlJwM1JMeHBkYnFFdHRWYytMbzNESTI4WDhZOXlyTXlzS2x5c1BaZ2J6RFJXM0RnbUFUUWwraHlZcmtXMWhOZFF6VjQxQnNybmlVMmx5K3BadU55d084L3VKWVFoeS9IQmR3YnpFaExLVDU4ODRqSzl5b3JrbExVWjN0VXIzTE5RSXZlU1ZQOEEzR2JDek1ER0JSTUFCNllod1N1SzVqWWozRElUU1hOT2VwWFBYNWxUamNCNWw1VUhkd2RyTk1zZFcyOURMZ2lIbmZ6NXZVSlFCNEl3NTFCelpGYjd2eC9xN3dYRUJKVVRZSkZXRXVSdGFaYzJrR0tyeExKY0gxRW9jR04xVEJIWnBlTVJKWlIxSHM0ZjBUaDczNmpzTUplNFlDWkVYdW4zRERoK0llNXM4Q0NzL2hqalFjdVdZbmNxWW9zbEllellIWkRXYzdTM3kzOUk1V2hhSmFyUGd6V0VsNmhYMUxVRjRFRktlc1NNdFBydUZOQllVemI4RnpNeUdwWWF6Y0lPNFNZSUM4dDlrRnc1VmxsZGtsME05UUhLclFhSnRwUkhORkx5OEV6NHZBdXlWZmRCcFBaNDJ0L3BHVWNvOEV3MitHV3hCTEVHbG9lb1dUdDBURGl2anhpV3ZrbmdHVS9TVkRtR0I0Q0VFUnFXVWFVSmhSVzRMY2g2WlJWZXB4TjF0dUdpeEF1VlJ3Sm5pWkhNUWZtNGx5QzVRM1Y4VExYWE1VelBTU3BqTC9oS25sVVc5NFlUWVVlNG1WRjBOTG1ISS9jVVByWXlyNWFoUmxabUR6R2dhZTVhc3Q0UEY0bEQ3bGhUTlZESUxQR0VQTkk3VVpXTlNxSlVCVkFXSWw0WVVaVXBGVG8xT1ZOTE1NV0RtQmNwWXN5UVFoU3lXeDRVcnkvd3dIcVZ1eUR4WGNEY1RRQVFvQW9sMGVvVW5KQXJ3Q0RDRkdiUWVRdkhrVUUxTVNaK2ZHWU5rUFRQaFRjeEhNWXVVT0ZnQkE1UHBHZW5MTE96TDM0UUc0dUl0WUFBUlBGSjZFZTlyeFNGK29td0NwWTlxNWdWNHRUMFlkZUJacHhBTHlWUUJGYjF5eTc1dzVNeGNSaWVjeGdod21VcFZHb1htd2R2TEtqK1U2b0hXTTZBaGZPeGxyWkw5dklnQm9xQTIvUUUzL2lZL0xrb3ZCRE1JTzJjMU01UTVYY3Y3Q0dHNVZMNm1NNVBGSTh0eWlQRG40bUNmYzdLQzRIUUdabmtLeXdzSkhRSG1wTUJlQkU0bW1rSnJhbmNKOVhBRlZTbmZPSnZuTTlXZXZmOGJZVTlkeEltelpQc3dHSTBFWFY5dy9yUW4xTUxlQ0pGYVFTa3VCZ0RCaWNDUURFdElaanZ4WHdNSHhVdUxpQ1gzSmFyWmV5RnJDamJKUm1GV3VhRW8xSUl4SUZqRXVpSjZLZXRyTVF1cUdua25aTEdqVVpnaEtLSk9TS2dZWURROHRxNjhBbldBV2UyNzAwVUcyOFBnbitTSGY3WFY4cWg5WUkvQWpZbnViNVd4V2hOcXFnNGgwdWo4TUZiVkNuMlVhWUhaL2FYeGY4QXNoN2wvQk8xYStmZWxmdUtEWHBCWTcyWDZoaFRwYkNYSjA1Y0NPZXlVZlREazVITE1qYTRGelU2cURxZ2RPNGxUcU5OdTIwOEwyRkZIcUYwMlpac3J3UWpQcEVmZnEwSFhRbGJid2VGaGtCalMrUmwrY2NlTVpqWjBVRnF5VVpkK1NJdXNHbGpwVkVhNTlwNUpmRUxzTkVRSU54N3FINVMxSVBEdU9yd0xMTnhMVktNbGlKSElJWEY4a0JtUkZGVmthSVV4b3ZVcHJ4SUFKQnFVVGlDWnlyUkJiY0NWdnFabTExTS9abFYyVzVzNCtwMTlCdXR0bysxZUlMZzRKazIxdGlPb0lHU2xpYk14MVhnUXhEZVpTbzF0TlRtWkhLeFhobjBhbTRWUXRTdjUvNm5yU3NrVk40UkdxaVZJQklRaEN1V0U0M0tKUXVVWVlmT2ZDQU9HNmlldnpDYW56NGxOc1ptV256K3N4eTdZbVBGQ3NTcFB1Q1hraFhtcG01a3dSV0dDclc0VlNaektqT20yTytjRUE4ZjdSamFSTlJvemZ6RlZyN2U1UVczS3kxWVVlTFB6djRNejFLWnJuTXZFN3J5N0hIRXBxSlRIWnBBODRSRzBJQ3FoZ3R3Rk0yUW8xS1ZxbXFsQkZaM00vYmhFTXRDTHh3WmhXWUFmSERRMWhzOGpFN2l2Y0RaaElsYSttVEswdmhKVFZvQ2ZzdTQxZzE3aUdYNmorZkZZYXNYR3hnMXVPYzFPUTNhK1NWYTJIbDh3VXd5aUlLT3lXRFU2ek1VTUdqY2ZTQ0V5eGJYaTl5M2FzYWlsL01jTXBjcjJpdlBIS0hRekRoYlpqcUdzU3A2Z3FDcUhnc2hvL2NxVFBpdzlJVmZqajF1QzJCTHFJQnpuQUNEd2hOajZtSzRkdEY4ZUxlUWVQbVh5cUR0aWdwTGxmSyttSjd0NkpkblpQWGpFZlo4eFp0YjFMQ1ZuS1FjdUVsbVdURnd6bWk0OVN3NGVRNllsR0RkenNFMnhSQVdBKzVWZzJLZUVQUmZsRTZyWWZ1VEkzb1B3MUMvenp1WDVTdXlCcTNGTEpRdDkwbG5zdy8vQUMvQm1iZ3ZHdlVNYmFNK29WVjdWNWwwYjJCWE84aHI3MlduN1k1WmJETGg4Sm14VFY4d3ZTVmNBbGhKVDZTendKd0xIdEkxcWZEQ3ROMWFEZWdNOEp3K1pWbXYxa0lLMmdtSVlVc25FYmdLR0lvNjU3bTRFNWhobkNNdHJWRGE2ZStJWTVIZkVWTERpRVIxanRnREJqd3FzbWMxRDJoS0VIRExibVFIYVdacnVRRFpXTGNnNEpTSGRJS0NNTHBoQXB3a3p6bFd4c3NaVmlDdk41WEV5S0I5c2RxNVhMV3Nlbnl3Q2doVURodVo0M3hoYkdlTkVkakRQV0tWZmpDSWxrY0Nya1poa3NXVE1PQVJGdWxZWWZEVk15L0JUcXVYKzJFRml3bUl2elNwWkxKNmoxWHpBM0RNbUk5d3krQWx5eWN6Ym9pMjMxUkNEbFlWanBuNW8zclF5VHBnbHp1ZnB5Nys1V2RwYVVLeHhGZTJLZ2s4TUlHM3h4N2o4ZnlxTnUxRE4zRGJyRk1Za2FNZG1EY0tvUkZuZ1FnS05IUktZNzhCRlJzOGI1RGJ4Sy82a3J0K01ydCtNVHYrTXIxSStYNHc5bjZuditDSE5meDhKWkJnaUdzTkVWVVRCS3lDTWdVbFpPVkh2TzJ4aDBhcjl3L2ZNdDNnUXNxazFNS1drNVNTNEQzaFVZbkJGWTA0QkFlcE82cGlWTVNoQnVLUnVTcUYyTGN1VkhlR1pMOXg1UUdxSXRjUENZSFNZWVExWUFseG9lb0JPMkppYzUzZ3lnU0NzYVE1TW5xcFlCOFJGUVJQbUFReXg2QjdNb0p2TExZNzhvMEVvKzJqSGJDRnF4dVpiZ2dqeXdxdkxqbTI1SUtzV01va3ZYdUsvZ2lnZHNvTkVpMEplb0MxUEVMNytDUjBDSkg5Ui9Ib0s1WW84NXd3dUswRlh5eHFwa2ZxSWNBNVNFWjZ5MTRHcy9WRWNRRUpET1pjSi9xNFNaS3pkRkEybXNHcVp2SXZoNnpJUFNaMFhieFN6THRTOFFXRGI3M2VpZ2V3UHE0YnJFS291Znk1V1ptWEs5ZEplcEJKYjNtdGZUeitnK2VXWjFkT1dKVnRQRHE0Zi9nLzB4Rkx0YVQ1clVicy93RFZjZzlJZmVhRUMwVGQwTlVlR3BOTXhuTjkvY0hzTTlZQTFuVVFZRHNiRTJPR1BaZ0JFRy9ZWEtUdkZGaVVqVVZiVkVCMlNBZnBNVTFLVUo4UXJlT1NKVldDdmNDUWxDRlNpb0JlVlEydkhFTkx4cER6YVlGemFIVStWdVVmYmhqRDhuOGFnUWxicnZPTkhoYVZTYmdxN1lPVlNHTEpZMTN3TmMxUVJhRGdZaWJaeVN2b1hPQkJ2NG5FeTdUY29VKzBlNURubUNvMDdoK0ZTaWpib3hYSDRJNW9YeWxOOE5lQWVOWkptMUFvOXNGUVBnSUorUWxvdE8yQnJhbFFPcGZWeENQRmZNVVVJZTFpak9pdkRIZEJqdUdrZUlscTROd2VuS0xaTnRVWlFGSEhrb3F6QzJWUlpsNkdiTVhSMXhMVUtsRGFoNWlDSzZoNHNpZ1FtUGw4UmZWMUlGMWwrSkd0RjdPSWRlSkFyWnVyWTJLL2tnNmNPQ3VLbkVaK0dZL0Q0WGk4dGVLenlrejFGeWN5MEdVekQyUWk0WC9BZ3FRTWk5OGZWaW82VktrcXRnaFFxbVpwOVhGV0pmek9EdkFiRVkvSjRXaVVseGxaS3BoWFY4T0ZKanc3QjFIeUFHL2ZnVjIxekRacWg3WmxCaDNVTlNYN2w2T1ZIeEpNOXBicU1TdjVRcXFoV05TYi9Fei9BRDA4UllQZUc0QVFhaUJaZ3cyTTVFaEtrb0hETzFrcTh4ZVNOS0xuNnhLZmlRV25oYWNzd29ucGdzMWJoSUpTczJGZTV4ZjQ1L01QTzAwT1lydjRjVCsrUENRbStmQ1lZOTFZRkdjSngvQ3Bqbk9FUG9BOE5ud1NvaUxIdXl0TTF6Q1VlaDRpc0tIZ3dNRExlSVN5cFFmVEtqMHpQaHVDZTczeG5KR1dzcjlJeTBjREV5T0YrRHFzcWdJaHRsRWVDQ0F5RlRnaGRQNElvUmRDT1R2Qmd6bXFRbXRFRUVUc1M2SmJTM01BVTE3cTJZVDdpYU43SVgxOHlaRUV6a054WFFZVy9MZk5QTGZrcnFMTUhkUWdkZlVaL1lycU5kR3FDdExjbmwxY3N0Q1M2dU0wbHNIcnhsNkFoVDBhTk90OW9hZE5rWEd0aUVxWUtLYUF0am14Kys5MjZXMG9rejhsdUFlM1psREh2KytGNSthOC93REJsOXQzRnVRYUExb3dMZjV0ajhJZkt1VkxjbWZlZEF1WDh1WndvcmlPQ3c0K2I5T2drTmZjL3dCaDZQOEFhRUVFbElhZVI2OWZjRERSNk55RFQ1eXBvdjVCREhIWkt0OWtwQlhiMmo3UlplUzhUT1J1aW1NWjVENzJ4RTRBcmZpVlcvSktBVVZlUFJHNUZZSE14TUVWckR3c2IzVjJRS1lCeE1xR3NjR3dSRmxIRkV0bWVQNEJjQXFadndFS29vRUVyQVVjRDZqTzBGMUJ3QWxjT2ludVd0TGR4R1FEbEtzMU9rb29Gd053b0VDQzI3WUl0SnVnNW1WcjVpU2xWZm1WWStBd3JacDFQbEhnaWxhSHBoa3N6V2FsdFd6bkU1UUgxRTB4RGlZZUE4aExtRUdGeExlUHpHR0lWaG9ETUM1RGFiaDg0SmFEN3lXZU5sRkk1ak40OVloUWxoSFlSdG9mQmJFK0pVTHVvS1E1OVhDbGFUVmtmemhYa1FDaXhaQnF6eTJ4ZGhOT0ZPYWpXMkJraU9KV1dVUjJXd09XTHdZdGI2NHhZSHc4UzAvSnpNUGRtRjl2UkNlSFV4MUJESTRtYytIVXd6OXpUOEliUEVLMmdjVFBVenZENHZ4a1NFU0RoM09QVWRpaEVJTWxSNUZ2cFNNTVRZOXE2S2ZMdGJENkp6TGxhOHZINzc0cFZkTXhrMGE4WklHMjdpbkl1b1A4REY1NElxcTFpaEIvVDFMVktDN0lMeDFEU3ZNR0lBVjQwZlViMlpuREJmbkZwc24xNE1wU0tPWGhuMHdFMTlJdTBEcVpsSFBneXU5ekFHcHZzaDZsaExFS28xN2dLNWhLekw4RWE0UVBjR2JNYVMwVXZvbFg3TzQ3cHp5ZndkeUZOckxhSWV5WU5NaFBVeDV3M0RMQXBSNEpSZlJDL2ZHb3U2K1R6V0dyUHM4c0tPU0NieVhQbldmQnJIbk1aZFY1bEdKUTRpQ2FrNnVOUTFZT29WLytCakY1WG84VHVWNC9oQVljMWlKVTVkelBFL2lCcVhJOEFtNE54K0FNS3VLcjF6TDh4RjdWZWpjVWROYzFodEJBb0RVSWI3R2JaWWVyN3BPa0l3T2tBWUFGQVVMZ1NxK2pDZHdjRDUxSDd4cnd5Y3M5YTZDRlN6NlFJS2FMMndSQ05yVE5JV2FoSnhuR3IzN0dPQkRRcnVXcjlSRkFCVWdXaWpRVEtSM3F2VUdLMWxmMm1mRlJCV3B6N3RWNWZuak1qZmdjVmJEUzBLYWZoQkR1MDBhVEwrUTFWN0FEQ0Fxb01KTTNWbW5QUzEzNDhWT0pNeGRvU2lWV3RGcEVzb0NBdmV1VTB1LzhOY3hSWG5ENWR5ejhTSmlMYW1FTGtnM1ZvQ2JpRmE1YTlWS1lSVFdPb081Q2NzQjg0MGxLVS9BNkpkaUN4a29PS2dkd1dQckVTMjJlQ1o2VlBuRXZJdFVJMjBZYmdockxMemhVTm9YekN2clFwYmFZVUtlaytCY3YwWWpFZWJ4STBIcUNFUncrTGphSmZKRlVhYVhDd0RLMEd5aUFDVVVZaktiazFFdWNLcXZJd1JSRGtrckROMEhZbGorcFM3MU04V3F1VWQwSmVDQU9rWUJtYVN6bm1HMnVaZ2paTkxNRDl4YnUwekFEYmlMb0ZSZ2lOMVVtWlNnMDZtQmhnR1RtQnpUQXJLQWxMcEM3VDh6amllMEM0VnpVVnYzbW9yMjk5eEVOZ251ZHdqMC96QU9oTHdpTUF0emlJNUw0U3dnL2RpdEJVVVNqQlZ5SzlSNnVLemt3UEtyZmlpUGpEd0Zjd0NneWdzeGV6Q0drejA0ekRJbnVYQjdmRXBHSWtHL2Z4THZoeXVDbW1YOU9XcFNIYm1WaElGdVpHVTVVc0c2RUs0MGZIZEVyc3Z3TFBlUXg5OEtoNEZsM1NIWUFodVo0WXZPVkdFS29Bd1d4NUl0akw3anNCdUNxY1JtSmo4ZVlhaW9jRVVOQ21MZTQ3RFJCQzZaWTF6R09Wd0paTUNVOEZFYXZvbS9wQ2MzQzQzckw0ZUZXSVBXR2FPM3lSS0Y1SnRjN2lGR0xHS20wWll6T253RXlaSFJNOHR4OFVaT1laQXZRbVhxWlhqTHl4R2lXY1dUS1RMQmlnQllpVDAyVGR2aEdPekVQd1hnaDFjc3NRaXRCR2FZbmFKVEo1V0pWdzlTOHFtRCthOStPNDYwWjVQT1ZqS21wN0hqRDRJaXM3Y1VJY1J3bkUvZzVnWFFYNkllcmVtV1o4emlPOWE0SUN3VzlFb2Fzd1VrQVIrZzZDZXhHL3dDRjhIZ3FwQWhlQWhxaUdJMDhYd3RMaDd2c3dBeWZrcUhLTzM4bDMrQVBnWEFnbzlkaDh2S0gwcmdUV0NLV281VmxpblEwZW1MZHk0QUJjSXRWRkE2ZUgzSFBqbDNwRDdWK0lWbjZucmpuc2o0a1VXbnpjczhlam53TnJiTXc1TnNkbS9SeXZRS2ZLUHhIbmJRekViK3VWVll0bCtFb0toUWlOekZNVGczVHdFbkFpWkpCUkdsekRTSlpRRUQ4cE9vWjhwYjFwdzJBZzRHRDJ6aSs5dmdqNks3K0VaaXFDeGlwVHl4TE5Rcm1WZ2Rzd0JmRVhFRTRocEJxOHI3ajh6MUI4akZjL0dzU05ZVEU3cS9oUFFmcURkaVM1TitobW90K0hxTFRWVG1DQ1FMaVViRnBrd01ZODhjV0NLRzcxektKY2RjdmJCWENKQ3hZU0tZUFJqanBSZExMcXRyQkFUSjVZWmp6aUt0cHMvemlLVDJHSUdPNmxCOXM3akg0Q3lvRG1RNEJTTm9NemdiTzhFQUIyRTJVeGQzUVQ0WTRhb2FIRDR6TEgwZjNEeUNlVmVSNWlYbGlVR0JYSk1NSzVibURtc3NoRnNkTEZPOU1YVVRjTSs0Z0M0VXNzbFFZWmptS0lhdm1EWWkyVGxpeUhRTm1FTkQzTHp1SlI3akFQVXQ4SlZRelRBbHdTdEFpditNdmJNSGtJaG81SllVSWg1bjl4dWVNMHl6RlcxWFZSRTJRTzRJTGN6WlZRNTQxSGYzL0FKVEh5T1AwUERwbjY4eStTSkJRdlRVdStCbVUybk1XWnBtSmZkQ1d4T0tqYzJlSlFweVZFUllTdnVkazIvVU5xOFJiRm56aUZ1QmlqWjhrcE1YNUViR0pUNDVISmhsVEFraGVEZUZZRi9OWUlxMVZVTnNWSGhidUNIQk1tbjlzcXhMN1krRXMxY1VyeXZFenFtSWhnMmRDTEduUmlZVDY0WWl1SENScWFjSkE0SjN3RVFmY1JRMXd4aFBHWXJCZ01yZjdmQ2xxejhTbU9pOVIxdnZHVXFIMUJaNU1EOStFRUZxejBRUzV0STFydVY1WWZDeFRUMjh4TlhpeEg5Z3hHZDZscitaSVNqOUxIcjA2Sm0wbjFNY05Nc0FabnNJdTFDcGJGWCtJTUFEUFVucFQxWjZVdVJTcExpOGJvWU83ckQ4dEFwaG1la3JOZDBiOXFyS1d3K29OWndYOVgxQmlFUGlOditNLzFqSDdrOHN4VmxWeTJuZitzOXorSWlUTVZ3QVIzNXgvRitkcjdXTk9wY0RGWG9tc3E0allHQWVDTkZhRGtrd3h6MnZXQUtkSUNzb1R2b00vUGlxRkE1bzk3OHVjamU0OW04OThVMStuakU5V05HWlhPVkJmYTBvY0lOcUZOSUlna2F4d1N1eW5YZGt6aitueU0zRkpnKzNZY2J1NWpVbm4yYmc3WFk4STVHeG1CN0hGTVF3b0ladDJTZ3MweENsU1hkR0ZYcW8ycFpiV1k4Y24zbVhrRjNOMUlyclNadWxsVnZndUcwV0ZseTN5NXVINkpVdmFDNjJlQ002MTNFVk13S1RtQzlkbzNRNzR0S0ZjZW9yQ1k1U3hqNmZETllWNm1JKy9ZZzc0ZUxMcG10V21MMEV2aTFlVEU0T0RRSHBRSTRwY1JMVVFkSlJMU0Vjd1FtZk1LajBsaHhOd2VQaXB3dHdyWTZOelA0RTJ6NmhDV08xRWV1dWlLNVFDWFVBaFdrczBXUVR0NmdRV1V4REN3b1ZSalBnanJUck1Pck1Xa0lmUmoxNTY4TGF6NEZSVnZVTVppVnZwcDdnVjVRT21YSXFmVWRnWGtoTGpOSUtCNkpiU1Q2RDdqcWVKbEp4eEhhNFp0elpHRGR4ZTN1WEo0RVNQT1hPWWkxOW9Da1Z5djhORDFNQWFmdUZ0TmxvZ21jbTVsMXVHcnVFc20vSFlaZ25DZURRTjl6QkdSekRwTW5TQURlNjhlMy9UL0hmNlhuOWVmdUk3MnhNZWFjcmtOTzRjZkdwd1Rrd2dQdGJFTnl0NW5pRGVSSmM1ekFyVlJRZVN6aWo0aWpLRGk0bHJEaVVaZHB6R0F0aTRaUW9WKzZWRGNVQnhFVUpKNzhjSzZKYzhJWk8wMWNGc3JjVkZzbFVabjBFOUhpKzh4MnJPU3Y0VzB3NmR4dGRudll3WFM0bVJpUFlEc0ltM3JIR3dZbFFHb1FjNU1SYWIwUldubGhGZW9SMmV6QW14VGhyZ3lub0VTWjJRaUhNeGU0K1NJSTBtaVc2MDhjb0lvTDdZcVhSTkNqaUQ1UVZCOG1wWVZQYTVWYWcwUkxCNjNGVzcreGpsbVBCQURyL1BFTGF5Q3RaeTFCRVJBNWFuN3N0ODRsUytmV2VOZnZaZlhWaU9rQWQweTlCZHJ3Q3pTdUVVNFh5RTNLdklYY3QvQjhDOW1YOHhqbTNjL1RpMWZxREwzK0V5OXRDQ084MFUzaTEyNFJMQzRYeVFqV2xkS2E5Z1dxSGx2dEN0OFhXaUtrRVdmRnZKb2haclVwWjJFdDE0cXY0QjBvbkNMRlJXelRXQTFaVTFiR3RqaDlNci9WVUJzUThwY2F0Y3F2TUhKWk1QTEh0Y2RnR1hmQU1SZWRLemZ3N2YxOGEwMDExcXRyQitzTWlqcjNDZzJFRWJtRlM2MU9FNWw3dksxejEyWDZaZUdqby93OFJMcTh6UjNPV05oY1ZBYVBzUk54cEx6aUNXS2xURXgzNFZFcmw4UzhLcWJKZWVaK2VJQkpiYzdXUnVGRVVHb0hMSGtSZmNHUXFMbEhhSUorbURnQTNTVHVNMFB0NHYzRWF6MHhWeXFabThHVE5uc09ZVko1N3dyc2dJYVRDeHFXNWZGb290OUU0N0RuQlJxVXZrVU80RTc5NnRRUVYzRERUUTgvdFdPTCtqUHhDRDhvUW5SMS9iS3h6WFIwL0ZlaDh3cnd5TUhzRFRNejBnNlNBZWovaFVGY1dMamJGWUc0TUxWOUloVlF0WDM0NFBRSjNEL2RZNWIwd1g3aHBkS2hnbG5sbCswQ0ZhWVRjZE11MFB0NG1mekZmbnlaSUI0cUJnNnhpZDBJVE9XR1l6ektESDVaVDNXcTJmcG8xN3FHd3h5aS9BRXZWM1Qvc2krV3MxQVdjRnl4K200aWt1TmY0V2ZtRGRNQUo5azVlQ0c0QzQyNEo4WXpPWnFMYVlqSkhidE8rQnhDSVd4N254S256TFJoWmZNVFBwbTZ0SmlmMmMrQ0VpdzlabWl3YmZHUkxIRXJ4clVRTkpVOFBGUWtlWUw4clppY2F3bEVLbGJZTTB6cmhZNTJtVWxRZldQM0s5WERsSFBuSXR6S1NndlY3aXJZNXduQkNodDlrdEsvSmw1ai9vOXh0VDB3ZkZmNDcvQU54TlhBQUJsMnpUb1JSdlJGQktDUHhvOXhkNGRtSWhJU0toWVBNVGJzKzRvMC92bVlxdGpBQWNtSTlIVVlseVhCb2JlVVhLcFpocTIyUkNGRUVsQzh1NkZocGF0aldJb2tjZStoUUw5OC9pb1V6S1hOZkFNUzQwV2dYeG00Ri9sdmpocFVsNmpjS2xPbisxd3dhSmhGcjdnMTF0Qm15MkNzK0xCYUFIbW1jc1lsb3dlMDMrSGZtNUgzUUh5QXhGWWRtbU5yaThPeDB5aGJka1VlUXdFbVI4S3l1WGVCanN0MW1XRzVlZWNxS3RWd0djM0t2Q0xPb3FEdzJNS0c0QzZkLzhTQmt2dnF4RGFVdkNlKzFTSHA2Q1c0RXBZY09Fc2J1SW9TR2lKN1pITHZxOW5zMG1nb3VmQ0VxdWRVWHJMRXVTTXdUSnFmZHNPVDlTaXBDR09WZEJMT3lEVCtvU2tVSGhoUU9aZ0pkMWNiT0NVSUU0WVA4QWEya1hDK2ZEeEYzR0oyNjh5V082dml6Rm9qQTdYY1ZNNGF2aUtrUWVCbERFaUF3dkxIN2lqTkJYalpnV3UzaERUdVRFZUJFcnZSNnVPZXl2aWI3amhicVAzL2QyVlF4cmhVTE9TNWs5MHlQdGpTY2pLRndsbEhubjdEY1JCVndJRTA1RU5waGFVMFRqZ1d3Z1B2RDJBSld3MlFZUDJnNU0xTm9HeXllTFBCZjlJcmRoWGpFVk9aSXlMcE9pTnBHd3hZK2M5Q2grSWc4UzdveTdDQ2lNekhhNlI1dE1IUENpMjBLUW9Db1NxczliL1EzN0loZDdoekpYUmlJWlNTaU9HaGVqSGZ5L2kyYzRYeVlWRmg0dTlDandZQksvUWxHWVgzZ3hUTEJKM3hEVlBYbStjQkVjNWxuTWNNcWhTRms1TU1ER1FsMlk2bll6aUJzYXFEbE5vTlpGWGdEaUV0ZHl4L0M3bDhXa0MwQkJFc1I4R1BHaWMxTXpNQkNZUGNXSWtZaGRQYTYzSDRCWGdqemZiNWh6ZVBhT2h4Y0VPMWtmUTRlZ0JHalRXS1VSOTlRSXgrcHFZVENIamdJR1NtTGdQZC9jcmF0MmgrZmNvaWF4UmVtUlZVYnd3WkpDWUE1RWVwYUJQbTRwVTlxb0NoSXE5UkdFdkVjUFJFQ2tzbHl3OWVBMXJhUmJUWTlFcjFLZU5YSFh4U2lTNitnWUdsTk92SDlMKy9CbHhCYmtWTmtWcFp3bVdHd09ZT2xzS0E1Vmxkd3ZFQndYSHY4QUNLeklQd08zcDBGamxLWE9GdTI4TUJ0bHhYZm5Xb2kxS3l6azdsa0YwdDNHb3BrMHBibGllNFczZHQ2SFZtMDdtclhadjJnV21nTEFkSXk2RkRwbDFtUkJSS2FzeEttTmFTNWJMWUZzS1U0Smg4NlFhanBtSHd6d3diZzJhUFU5ZjlUMXdSVXJBWUFVTmVDeDVoWG1SQzJtV3JtdUNiQU9CZEh5WlFaRG1zdFVWWURvM0taZWtBUTBvSmVCWW1sb3lmUGFtckwzRXh4UEdWTHRlb1FsanJjL3l5THNpeG9vNlhWOWlLai9BRDVQdDlmc1dKanZXcElMaitiREFreUNnOWdTZzdxQTVUM2NzZ0hLNXlFL1RmR3JqYVJYOEV1WDQvN2lKL1hobjdSaHIzdEhVSENIdHVVNkhJaVY5ZGRNVmR0dEFER3c1aE4ySHVpVU1LbHBjc2Z5a1VvYlF6VHhFeGgydkVGcnhQSCtZK0lDV1JpTWtFZk5tSE9wZ2p5WG01WmN5a2NwZlJVZHN0RlZib002R0VkYUNxVlFiVzFjSXhNYVZCeXBkVVp0eGlFRm02c0VFREZtYUZnNWZmNUN4UWlIYXFQcXc1SHNpTDNDL3dCaGxEb0FkdGdpOWgwN1VPRkJLVlF5K1ZDWDJHWVFWVEkxd3VjVVp6aEdxWDVRcEFlazNoWWNtb05SWGN2N2ZNZklPY1A4d0llVk5QMGtnRzN6TEFtRHV6NW1kb2NRbE80bzM2WWpIVGo2ekVMSXJNT3JRM3VOdVlvUUFmQ0dhN1hSR0tqRjFVYXZ0U2d6UmJSbWNSUm5rMnREOXFjeDg4MkVvVmFicXdzRkxPMDBuRDdYbURkMFZHWlZXem82dUdWZENCSFBJTm5rYUs1VHlsQ1JscWREd0tMQm5ZaEFRVWIwSG4vNDJBNEpSQWhua0haVWdjS3IwV2RnaE5EZUIybzh0NVExUDNsU21DMzBUV29qTWdNNkVMYjNCcTY1ZUJzUStXT0FOYytBQnNJdTVFY3Bjd2wraUhBZW9UWkVoMitWMVZ4cWp6NHloR2FoaGZ0aGJFdU5RVE1oeU5lNWZUZDFQMGdjb0JZTzRRdmtNWFVIVG5nT0l0V2tZUUxVdUFBV1BXZWdwdllLSkx1Z0N4OVJWcHMrRkZVcTJ1MWxWMlhsU2o1K29zMXdsbkJzeDFxL0NXenU2U3FEdWREYmp6aWdYMk12UTYwZ1VRN1ZWcmhZMDkxaTBuWkY4b3NTMGY4QU9tRFMxdHE3bkpxSDA2cXF0TzYwalhCcENRcU1pQVNWWTEvZHVTU0F0UVlpOWpKRmNLakpSYXRsc1pPMmU4NTJaeVBJb3ZJY1BLZnYySmQzZStFZ1R1K0Rpc25VSFRFd2J1ODgrSDcrTTJkTWVDbnBDT29QN2hwbWp0ZFF5ZU9oamIzQ0JMa1dUZHkva1FqRFBmV2lHZlUzRXg5MUdISkJWd3oxSUFZa0xBRHhSQUVTMnNxcEljWExNeTZFd0JaMG5jeFk0SnZPZFp0c2pQWG9XbndjRGE0aFExdW9SZUcyK1ZsRldudDhNczFvY0ZtRzVuQXlGM3dINVJxMnJXT29kTzZxRlZzd3hjQzU2Z09RMWVYSDNCZUdVVXJRUEN6dnB6Ti92TzJ4QlYvUExGZ1RDSXdXRHRtY2NqTWN5M2JLbkZ1NGNIQk9CY3hxM2VDY044UlRnRWVncVY2c0wxQVBDNUE5eENZaXBhMWJIdTl5NG44SDl4Q09RZ0FPK0lZVm5FRTBOckE2T1dWZnRjenFDRjJOTndLNVF6SzZCSFBnbWw2YTJSTkNYMHBWOGh4cUVDUEhac0RMZkFSWkRSVjJrTlhPMm1CR0NycGhSUXpXT29yTkZKNXdJTUkyVW5DNDBockZpaU83allUa2RUeUw3SmwvdTB1eEJtcnJNb1dZcHp1SFNJM0xGck10dnNldXlFR0JXNEhramJZZXJqRTBzTEMzU2pFZDhlV01veW9aUEEvUEx5eldkLzRTMkRWK0xHbktVeFZiVzJWZGtwYVVId1dsaUpjK0xkUUMyZlVVUDZUdUdyT2MzWFZ4Q3hRelNzdG56T1BXeWdYTkxXQkx2UW5PQlEvZnRDVWlzUHNNdDd0Z3RTaHU5T1k3TThCUlRkU21hTjhGMWJDaHJqUVdiSGE5aU1hMnVtWHhVNEdUUWh6L0FDRXlvRU5vcFkyUlZxV0p1Rml4d2sxVTdMQXhwSytteEJ6VG1tV2VNejZZL3FaeDVmOEFjVGhmVXVXeHl3RGtFbnhWc21RTDRKa0Y3bHArMEphZk5SOHpMbEsvaGxjY0xNOTVuZGpYOWN3Rkljb2dTc2dmQjh0MUVsSkpUTjMwVXhpa1BZclptQk5aUnRWYlV2OEFlazlHVEU1SjVLbFl0QUZVYWh3SUV1TGUxOXlhaTZ5c1JxOGVGRlpvcGYyQmxOaDVWZTBud1VKZzE4MWxMZ1hWbTNDa2dTUmZRQ3BaVVFKN2lMcWpIK3ZxNmFVQ0FKUlh1d3ZPeDhpdEtDQ05TRlVkRXlNUmEyUzlBOU05a2ZxQVAwa01WRjdQRkZwWmRtV0tYMVNOOXFIcmx3WWlxOWJaS0ljQ3BqWm10UnJyQzFOTXhlTUt4TE5rWGh1bVI0anM4U3o1dFg3aHduR3BUOXNNcVJ4NlEwSEhOTXZKOERCTENBMTlvNjNybm9oMUgvdUdjNkIzWXpLOWdwZDJHVzE5c0dqWExsQUpFdXdRdlV4ZW9LWkxyWkhmUFE1SFpYWHdUZGY1V3krR0kvRDJyL1hqMkRLWEZyZkkrb1duVEpsZTh1SjY5SFViUWxWTUF5MEVNNTF3by92NWltc09HS1F6VXhyaWRWR0Q0bWhSK1VBSlF4N1BKbkNPWUtncnVWYTdnOE5KTVkyY29TeXJCYUFZYmF0a1FpOTgrd2NPYWI5T0srZGFMVllKL3dDaUlwd280UUNnZ1FTV3VqU1A3WmNMaWhES09SNi9rMU9MZWlMc0ZjdVhoV25RTGZDaUZqY0tGVnI3UkJBOXMxNnVRSnlYRXo4V3p6RFNxanR2OExKOWR6L2k3aElkMEhiSjVPYWE4K1J5Z1B2YkI2NnFPQnVsQm9SVVJvQVZMMWxDbG1nSXBadHd4d2tRRU5NWldpNkNnRXdxRDJWYW9Mc3BIOGhmWlpYUGxFRlI1amRRRFgrRmdvTWphNWU5MHRwMVpwUmJGY0FlMklackI2Y3hkdkc1TGI2TVFYZGdxYlZYYXY4QUgxUkxxRitLSWhOTE95UWI5amIyTUViWDhKRzQybkFiWmZ6aTZQQktXb09WTENsck14VE5HSlFISmcxOE8yV2JRR2FtSkZ2VTN0K2lJVVVQVUZWVys0VlBmOFZwS1BaQTdCbWsyZ20wSjRNVk00NllnWlVidUVXZHNxNVNCdlRNVWUxbFlXMXJWdWdGZ3hlQjRGZUMvTXRyYXdWU0hES1RKVG00b0gwRE10Y3A4UjZyUkNGOUk0aTFYT3dENEJnSWZjNjg5eWlDOFJ6WE5GV0h0MTl3S3NNQVo5UXJOTlBJWExjTTErb0FVTHJKQU5SR3k1aXI4Qm1IZFhSZnZ6ZnJmMHdoNmJZcVZaTHhMNWREQ3BGU2VYbGhxTktpaU1YTDJYRTNJSjZwVEJjMXBna0ZXeXJCRHJBNG1nK3Y3ait3bUh6ZVhwTzROblM1VmpaWlF3Q3RGWFYrOXlzNk5CWXF0bnU2VUJBVnFOcWNTNTF5UGF0b0hPVzFLZ084NkltRWJ2TnhqTmN3enVGck5iVFFoZ3BiYmorSHE3ZFdnUVBva2NDcUIxNURUV3NBSnREMk1CbmxRcVZETFFxUzl6RXJwRG0xcTl3T29aOUJMRWlIV3lzeW9laXR4RjJPVm1yc0lkN3A5bjhNMml4ekt6bWJwWmhGL21YbUJSUkFRY1JIRThCOXNZTEw3UDVOaiswb0FpRzBpcGJqVmN4alpueFV1RW5YODFBZ3lpRjc3SGxyWW5HLzNCa0RITytvUXUrb1hJdHZQZmNyVUFIcWRhcDA1ak1jaFJzeGcycWpCTGJuZC9tdTFndHphd0gxZXhORlRPRUdFMzlRRzFPU3lONmNEdFZ3R1BWeC93RE9GMTFwMm9kMVM5R0hPcVZBU0Z6QXhNeTYwRmJ4dHRWbGRkczFrcDdWa3lWa3BackQ0eGgvV3pqeTZxVGl2VXZwcGNJQUlBVk4rWG1LdVlYbVhCUzRRSnJsM0sxQUEwUVBkOHhGUmozekM4NXdRcXpjTERSS0xMVy9KRXFDRW5nMnZmeEg4SkcySVJjSUJxTDM4TDRHT2dzcDV6VWJZRXV0eEhIS3NlMWIxdCtGcGZOSU52YXRjckNwR2g4dFZkZkw4RW9yckJXampIQ0ExMnoyMExUQXZjTXNuZzFZbjlWRkVMbEpSRjhncHRrVGt5WjM4WUYwMlBac2YwY3VaaFlWbGxvV1I5Z3Z0cW4xRnJLcDRRRGYvUHFYemNTdG52M0UybWM4UVRXSHFPeHQ2aGRjZzVZMEpaMU5JbDZDYnhIcVdEZVhwTFV6anBoMnJPNWNvRnQvc25YNkZ6TTFtQkxZNGpLOCs0NmZ1aUxnZkhvbzM0SkV6REt2Z3p6U3F3VVErdGdyYTFXZEtVdHVCMUJNdExKR0hOZU53NlZrRlNXbnlISURzSVJENDZtS3N0cXEyckdXTkR6aGM0MXVhdkltOU1RTVR0U3lxVXhFMmNRdm1lWnBycElSNUJkWnFwenFZUWNUZ0dJcUd5QkxRckJ1alhjTS9pakhaME5aQTR6RFpPRzhEZ0M1Qzl5b3M1c0M3V1RneG1ERUt3dVZ6YktOYWhhWGJITkZ2Yk9KR05hTGxBU0xVekcyR0x6OFJ3dk5JYkJsc1g1emd1WEUrWGpjVU40aGR6aWp1ZHgxUmxxYmpULzZWRDlhenR3dFgzVDZXazVnNitUTE50MjNNUmxCd0NwNmFUQTJDa2NqSEhjMUo5ZUg2dWZPWXgrdnowUm9DYkhDUEpHcy9vWUdGaDdvN0dMV09KUHdta1BOZkZQNTd2bXM5MUtodWdSMkFNa0NFZStFUVZPQllqcEFZWmdBZTZKZEdNOFQ0bHJxbHo4bkhsVzN0bEpjRU9TaHpOVFFmZDMvQUJiUEdpN0RSZVJkTS9FTVBUZzVNNWhGbmJHNGF3MUJ3Ry9GbUtzNDBvai9BS2lPSE9Td2luRnhhVlgydUVaQ2NzQVM4OS90d3hyMGFRSG9UZzFETkM2ajJNTFZzb3R3ZGd3bWRZVTYyM3NJY3ZpQTZ5eXpUbENZZStNRmR5UllrT2JnVmFKejU3ZVlDMHZzSTdHSDVodDNBTG9NUXRXcG5VbjVpMlkzZWp1SEx2UzNHRUtTeHgzS2FRU0dNR0lWaWdhbHVxSGNSb2Iyd0FjczV5NXpGY1hhZmlaUUtCdzZLNVdJNU9MczZsUWlJbDJKRWJRTENTeXdnWlEyaFNUa0lacjRXNkRhUkZLdENPTmlGUWFpS1ZRVlMwbFRueXRqRnd6VE1USzR1d0o2alp6S0h0MThwUnFqQUhEa1V5bk5WU2x1U3kvMldTM1VZb2U3NWpkbzJabUcxQ0tuWURjZTFYYy9ibEdYTi9CMHFyb0x2VmtGRkxJK0cwY1ZDVkE4VGNHVlppbVhPR0NheENQYjZyRTlzQ0tzaFBieEFHNVB1WnhaVklqdkdtdjc4WlZQMzRBZ0RLdWlHN3N4dTY4ZThEZ2h5c0lHVmp0dGEyZkx1SGY0Q2JBTHJTQVFERFdRMlM5SmEwZ3lXNHZVVjlZbHE3M01qWnMzRmR3RkhMb1Uxd2VvTDRsQWdWVGFId3dVMVp0WFBWWE9BNFNtWDNoQXlBQmdiZXBNUitLZHM1WlI3TFZydGd6Rmt3UFFHQ05PeFRGZElhTHBYVGlHZ2F3TG1JSExzeS9WQkwxcjlwK3hoRWxXcmxnMmdremlnaXV3cXlZN21BZmNxRlowWDV4VE56UWdLQlJPWEo0TlZON2dZc0Q0bnVpVUZlN1laMjQ3V1UrVlBvdDFBV2E4Y3RtZWNQeXdHdUJvQ1ZOQW9YRDFGQnRSb0JXcVNtaG1jd3B1TkFJbVg5WW8rSldVWjdNMEdLNzRIUG9wZ1N6R21IU05IVFVrcTJ4ZERGdXFhb2RPQjhRcG1NeXhKQTM2bE5NWlZDa3VsdFRpN1FvM3BHSWF4OG0vdks0R0cxby9WcWExL0xjTnEvR29qQzU3U2p4NmpsN1BkakJ0Y1I3Vk1jYzhlVnovQU1pR2djSk0xNldmOFJGeWdSZktQam1EdDQ2SWtXd3hTTDVlTFZFbGE1VVROVkFEREFsb3pLRmJlT1RGWmNrMXhJakVZVHhwWDNLWEVOQVhEVFo3eDYzQTJXOUkyRzdVMzJOTUVHZ2FqV0JpVkVxb0JZbEdQR1VHTWRCQ3R1and6RlBRTjduQlRmMFIyMG9MNGl1MEV6ZGVXVXR5QXg4RDFjUkFFK1pSWkZ6WHFVVnBmT2p0emk1SkkybjFXTmpoUVVGMXV4aW45bzBDRjNRRFI5a3lvQ2xxV2Fxb1dFdk5lMlhpTnI0ZXBVMXZxWmRrckVOWWsxNElQVHVDM2dOK0VDRUQyLzB6ZGNJWm14dlF4cWVtT1h1Y1hFUFl3bzlvRFFGekJMWDlaVmFIdjFBSnlicTgvSHJMRkc5TFFwZmRCNmxJZ0F4QW96dEhwR0hvbWlPWW5EV0ZncnZyMTVDcnc5UVV4THBPMWZnaGV2UldrWXpHSzJsYUZCZzd5NWN3clRLb3JLd3JsVjFvS1dSVzlEaEVqQzg5V3lWTlEwWXJSZzBHZ0VIeDg1bWg3YUI3WWQ0ZDFTN2xOU2F1Q0tOZHJJQmM1UElEUVpWNENtOU5FVmoxRDZYRFYxdVpJMmxSV3lHbTJNTk1qRW9EYXRnUzFUZ1Y5ei9TQXBuZ3NHaGlpbnhEYlRaRU9kYmZYcVdPWEZrN0lETjZWMUY5VGtVNTk2Wi9JK3lOZDNPSjZ4UjYzT040VUdqbXNkSzdWZkZCY3MxcnpBT1oyNThDVXlXUnovOEFGbjNXS25meGJYalZOQWoySGlWMXRMcEdSbjdFTEczb0lvZS9CbVkwUitKcUEzSDY3SStBWmNuN0Z2aFN2K3k2ekQweXRXL3o5TkkzQitzOHVmdzNPS3dzNlA4QVpxbjhJejhRQnFoYytOSU14MzJ5akJucVZpVnoxR01LaVhEaVNIbG5mVk5vY3dlMkNwekZOU0JPbVRjNjMxSnZVVTY1TzRuUFhOeHYwc3ZxbWVxU3JVaXZ3Vzl5Ry9ydGJ4bG4vS1lsUXVXdWlIL0RIemFtRXo0ekdMS09McUxGTmxlR3FocTBraUkwaFY3QWhmOEErdWpXeHJXOVp1UWx0MncyQ1BWckRTSXN6a3NYdXBMckF6VmNUR3U3VUxnazJCS1VxTHBjRDRTVmxaZHdLQTJReHpJSnl2eTRSZ0FqUnhvNXR4RWVaaDZuYTlXY044d0taanRwRm4zMmJHRGpkVUFOdWYxeE5sY2NtTXV5dUlLeXNybHlrMG82dmdtN3V6Y2R4d2l5THIzeTBrQzBqSXZlVWhRYXBxQk14VDBTUFJCVzJ5ZlRNQjFOT21SZHg0aWcwS0I2SkFDM29HNGtETG1EakJBOVVDMUtJOFZuTTg2ZTRSQkJvTkJDSEsybFU2TGg0N0NhY2kwVW9XOXg4L0FFa1Y3d3ZIQWhZby9oUW15Vm5KVVdUTWU2ckVSQ05VS2F3VEU5NGFFMktTWXVrVTZ4SjFpYTg5Z29Od2svVnd0dGQ0R0p2YkdNTG1Kc3FHMVFLaUpPYmFQMnBnM0NlYUdYdHVGTnBhbHg2MldIRVNLclhVRmo1UUI4elJjeDBKZTJLQlNCdjVZcmNRMGg5bjJITkVucWtLbE1oNklnZkVoUnVFOVVIMFFQVkJEbVBSRTlNRGg1QVdtY0hwZ0s2a0w3WFYxS3JWd0NCeU1IZWJ5OEpiWEVORDdHZDVhR1daMEdYZUdIR2FsNXJwZ21TY1VBRFhqR1VCd0JVZEdVbVpDd3RuZSs4UWhuWDNZSnJhVFBDd2lCc3o5K3hVYW5CV3hZTjhPTlk1SUxXZ2huek9QZmttQUE0U2lHWmR1UVBneXVnaE5PdzlrQWlDTWRqYWh5cEFWSG9OWTdSeStrQktEM1htd3VqS3pjcll5YVExTVZady9KQ0tCbUNJYnl0OE9OS2QvK3Q2Z0Q0ejdYUmJ0UFRJOUVnNnBHcHhMbWNIVEk5WGlIWTlVVUxqeG5qMXlDNlp1a2hRaWhGTXFNa3RLbkpzVnF3VUlPQ1V2czAxeS9ZTm82cHpMTWF1UkFLalE1V3pBaWszTjhjY0tJTGdLaWFCUlhkQTBidERVUTEwTVFBWjIyUlZGc2RyNXc0TWcwM0tuTFJBaXRtQTBhRnRoQ1VRc1AwTlFUcnRWRmxVYnFXeTU4YWhFU3lIRlVWdC9WeVlmM1hSMjBjVktOSXBFYXVvemJyWUxGTUdHSzBsV29pRzNMaUNsYXNWbkFOMnlpb05yYWlhV0FYa2RuNW1IWVhFdmYxQTZuSldqQmt6Z2xuZFdVb2cxV0pXNUJ4clgxQXV4SnAyUjl5MTltblJNVnNnSElZZ2RTajB5YjZhZXVRb0l4SHFtbmFTSzlNbExHL0ZBMFlWb3JSYUVsNVZCM2pmU2k0K0xoZG1VUFJWRE4xSnlXTWU3REVNdWlCWkZ3Q2dMTWJTWlVjSEdkeS9jTTJkRmt1SlpVVUZaK2loMFJVd0hKMUNFVStlWmYzaU9CZTdocXhrS204OXI0SmFCdnVVMjRWVHFkQmhWQlFvMWtja0c1MHZyRWZySVJ1Vnpjd1lHbmoxNWxFcHJlektKZEYyRzVkY0YyUUxjRUhlU0F1SzhyTHRDOXdqaWRzV2wyMkpkSGd2b1Q5UTFiKzRWZDlwaWk4bDlwZVJIQ2FyQ21raWtpL2JDM0ZmcHYva01PSk9vNGFnY3hyRzVHZHhHZm5LL3lobnJzMDhvL3oyUi8ydC96Z2NnN3p2V1h1L3BGVUpjeGxmbHNxL3gxSGxUdlB4eitWOG5ON2xtR2cwOUhnNzI5V2M3Q2N0SCsvZzhTK3JFVVNmbCtQK2tLMGJnd0pBaWk5UTJiVlo1bk5uc0FXNkswV1pqQUhEWnRuS0hkUVZEb0c4ck9EelF4YjhDcFFzU3JrS0xTMHhUVEZDcUNTcmdPWGN6VkZIclhSbll5WEI2dmVSMDBVV3lpcm4rRW5POWVyTlZjdnhzcnZJQVZnQnB3d2JxcEN5eE1pb2FzeVJMU0ZSS0JDcHdhc0w0NGhwVmFDQ3FLQWdTSW9MU3loUkdiTnhVSGRtTVNpTGNBdzArVlZyU2psWkh2OWNFZS9pQUxjc1h6SWxWUnpiVEZ5a0ZOckpPSXUzZFdURzFtMlVxc0ZhUXZ2UlMvS0FHSWJGRTJHTXNjMDBVMExJdnQ0R0lKWFhDT05OS28xbXNFbnB3K3hESzlLV1lNZS8zRk5paTBIZG9oWjlWcEtxQ05uOXgrSFpxTlpRQUE5QmlOR1M3WTZrNlJncVhLQXVzb0IvWkZJcVVlVWUzdnFNN0E1dmtnaG5TVkRNSHNRUmozWXA4b0g1WlVoU3VZcXEyMG9LV1FzMXdBdElDMytKS2Z4MUdsZ0YyTExJUFdlMCszQ3poT0ZxSDlKUXJhUW9ETFBsVUhUeFVZc1FOb3pYTlRYWXNuK3E3NERNWnQxbWlrRkhrb1Z6Q29LUzhLa2NPazVMb3YrV0hSTWhWWUIrMzlFekpDVGdwdWhjdkI3Z3kzb0JiUVhWb0xSY3B2YzhGeWVZN0VTK3BwOW5CODBjSDBwRjErczlXZUU3amFjcUZxakZsNGpsQ0FBUWJlaUxOUnM5SFpNUnJVT0lGYVdKdnJZRFhZSzFodWhxTEdMR2JYT3I5TmlFSzdpaUdtUkJxekpUY2RmRVFUeWtQWURUY3dhS0JhZHZoQmh1VExBNnAvbGNvR3lMSlB2aUdoclpQZm10ZHUrclVSdzUyUDhHYkFKZ29Bb3JnYVd6UjhuZURBbVFxOXZCRm1WKzF4NnRpQzBCUVltb25VN25WdlkxVzJvdVZnZW15UHVYRjVXVXlRRlNyRUdscXk1ZkY0Tkp1dmh6MTdmeURxVFpYYUc5cEJOMWNVZGl5Z015YXhHaHQ2YVdWamtnQUZtQXpTRHFvbFJNb2JKcFl6TXZaeWFNbEpKbHJ5dWdOcGVLWWVnZ3NMZWtBYXhpRk1jS0lBdGJZbEpJS3krVmFnb281dXUzREZZZlFtWjhaUXk3ZFNvY1JoSXdPTDFlYW9nT1FFNS9vaWFrQ3BSWkgwR0pvUG40aTdHYVNtQUVLdC9ncUNINllSaDE2R3oyMGM3OU5rd3NKd2htQkR6dDdTMHNkR1o3OHhnYTdpdDRhSFQvRDFvUzdjSlY2Q0M1cE5PMFNoeVV4ekRpZGV2QjZ0Z2cyRkVJYzhBODJDQXpuS1hraUhlTHZuS0xWa3VySlFvL1pmQzVZV0YwTWtSNUF5R2tpd2NJT0lZbUVPNElnSmFFN0VmNHF0MG8vMEFDMGNtc0dVcloveVdPZjM3VXJrZzA4L0hKdjhBaXNaMU1zc2U4d3paN1pLRzFjVFBVMVlncnovQUhHalF2eHFrcnZpRG0rMkNVN1c3UFNjYmdHWmx4ZDFpVDFiM1lXME5ueHR0K3kxUmJCSXNnTGJDcDRUUUFCYXRLSEpkSEhJWERkQnJSREtOQURjaXF3WWhEOFFDekZ4alYrYmxoZldSV0lzd0RaalZRU3BKVUR1RGdPYU5Oa3JYZFMxcWpPK1NiSmdTNTlORWVUZlZVR2xrSXJySUxUQXQvaVNuOGRScFlCZGl5eUQxbnRQdHdzNFRoYWgvU1VLMmtLQXl6NVZCMDhWR0xFRGFNMXpVb1o4YWQ0VnZvaUpiNjYvVUVzdFFDNFZCU1hoVWpoMG5KZEYvd0FST0IvaXBkOEFNcjMvQUozRnR3WGJOUkdRM1BRUk9FU0htWnNnZTVUdXZWVDJMSEprOE1ISmpRZzRZTHRkQVk1TlpmYk1QbFp4WmdZaEFnTUZqS29haXhNUXREOFI3WGlVSjF3SEhvaXJoVlY2dWNlWGpBVGV4OTlxTVY3d2ptRkwxNExBMG9TZ1VGeFUzWUpBQ1R5bUs5R1VWMW5TVDdWSjk1WTFtdDBhRlBWMUc0SkZDTDdHTkFtV21OSGFMRDFPMjVEeXBERnFFdndqMGdoWmhaZks1bExaUzhidytna2QvVWNhbWM3TWYzQkppeDZvVVY2b0pWc3ZUL3Y0bU9aZTNDQ2pmY1l2cGNKeFA0di9BT1Vidml4VThmQW1XR0hPNStJbmpvbnZ4LzhBdGRuT0o5Tkp3R3QvNTJyOVpxKzcrU1BCdFJEQTM4RkN1QlhxcjYrWDZPTCtIRXViM2U1ektrNjcxOGt1MzcvaHBNd1dtRWZndEQ2bUZWS1ZYS3gxdlBqdnF0NDVVOFhMTHRmb1REUU95S1hOREpqL0FPTUR6SDIwajFBV0I5b0J5eEcxRlQ1ZkhLNVhGd2g2S0RvT0hMTVBlcTNTN09QVlJRZXc0TUJYMFdrWWV5K1o0RmpNd2t3MmtIVFArU25NcWNCY29ERmxGajl3eitKVHdnYXpUZmZhVDhlNXNrdUNSUmhQb0pLSGg5WVJLZllRMllYcDgvQUVyU0oxUDZsRXFyRjJvcXZ0V0t6VjB5WEtlQnpMT1U3RXIwSXpHQVE1Y3FJYmFESkpUSG5RWHlobHB4R0ZPMkVFWmpTZFNsaEFBVzVjQjVJdVQwZVJ1M0c0b2poVHVOSEtXYktvdHdMQkpwV3FITWNndEFwRy9iaUtSVTVlSXl2RTg3OGxWcG5HSXF4SlcrRmliUkdkMFVWTUtyZU9yVmdXR2FFU3NIQzFIQjJtRHlid2RYS0k1WWxabXloK2FsNzd1T0JUNkJEZERvaC9QUnNPZlNKOVFaVXAzY1JjL3dEV0VrSU5aQzc1cWRSVFhkWStpWHRSQ09TZDVwT0ZZV0I5QmEyQXorYUxPcVYydHY4QWlaNVNDWHAzMkNSck5EcWx5b2xaM0U0bW10eTg4MXVwZHNGVFJET1dKcEYwZWNGWWhRVzc3V1FyMEtZamVlb2srTGRydHN2aUllNmhVVGtEZm9NUU5DcEVNVjJKVk1hS2d5L1drVndMRjU4eFkzWHNlYzRPaWhCZWF0MVlmVU9wZWVZdW94Wmxkb0tFdmhweFl0dUx1R1pydFZXcSsrMlZXd2M5WC95aUUwWGN3LzBzL3dBaFNLM0cxdlBkcERWM2dDOCsvcFBDWFh1WmpwUTlJNTdFYlAybHI2L0lFNUdZOHNhVW8xNldMMnVTVTJuK1dseHRjRTJjbUlpcllsS1pDcGhWSzFyQzczblZHaHc3S3FZTGx4NnFYWXlvanZ0MUNuNEZDc0VxTWF1Y2o5QzhBc2x3L3dEY0EyaFVzRmRBME9XcWphSUlQVUpCcjBzSTdjbHNjV0kxVEc1dGYvZW1Cdkk0MGdGVkVXWDlVMGxPRUFsb3ppaHRZdkJXSkp0WnptTitSREJjNHpYUEZNamE0c1Q4WGplbXVzczJXUUlUeG5Ka2dHRXB5TnlZZndpRmRlU21HdGt1ZmRRMGpUWk5jZjVyL3dEcSswcDMybHpLTzlMNjhDaDlQS2RSdmYzbzhZV3FkN2oxSTVXbEh0Ni95c2UzOG5IZjdlRzdCZy9jVmdOcUswbnBEYmx5aEVYRjZ6R1J3QlUyNW1oVmwzanRheno2R1YzdnVjcHY2S0dXRzB1Nk9CbXFvdmlWS1hGb2FTUHE0emc4UGRLZTRQYlVka3Q0SHEwcVFNOGU0b2wyVUM0UFJRZTJLNjNYT3c3ZkV1Vjg0QnZaUkhYSUtYT1R3ODUyWXhYR2pQMU9NT2NrRFphM0dyVzMwbHZUQjJRNjI2RHErZm1HeHlOKzVuY3dLT0tTNjkveTdZYytrVDZneXBUdTRpNS82d2toQnJJWGZOVHFLYTdySDBTOXFJU1FUdldrNFZrd3R0Y1d3VFA1b3M2cFhhMi80aW9abVRvalJoaGJVSE42Q0ZXZExXRkJZMjdaYjdpYjZSWUlsamtLZ0FERGR1c3JzRG1BWnZCZUtwVldxOXFaWHBvT2pDWkF3WXFGYTUwVnNVOE9Hc1pLOU5aWlowdml2SE5XYVpSQ1lhRU0rTVpjOEpVcnNHS2tXbDRFWTJuVGFwMWpFeWNOV1VNQUxCQWtsRzlqWkF4b3dITXJ0M3ZSdC9kY0xzWEVXVnV5Qk1MSFlxc2ljWklreThFa1dwT0JSN1JNQTVHMytDRExZWXZVVFpNMkVLMmNSTHV5TVM3UlRVUlJlSENNeUQxVEp0dkx6dWsvRXRQMWYyQ2lBQVdGL1dYeW9Dc0k3dHNsaDFHNCs4ZUg0YjVlL3dDdi93QXVOdW9mMVRmdHVmdVBoNjRSbGlqaEtFNGp4TFBKS0RrT0NXNDJzUW5WMFpmb2dvTzlPRm1JaDVIbmQ5cXVROFFzSWRocWQrNTA4NC9TOHgrZlA1Y3pPNUdINW41cjFlM0R3L3ZSaFo2US9TbUNxWmRYdmhsdzZNZmN1THNHNDMvcWw4alByL2hkSVVVeWx2cGhmUTFoaXRDaTVjdnBqNm12RjdYWWloVldjM2hVdUdjS05SWmVMU1pvWlcvSjB1d3Z1RVBFSi95bUhVcU9GUzNIU0t5TE9WM1JSc1ZiQ0h2cmI2c3M2TjFKbmtYSzlkUXdJMDVVVVBkZ0tIYUloekJjUEI4UWtURWlJd3kxS01YSURTcEVPSzBHYUtJRjFRdkVLdDRKWDNyRmdPV0tsM1FMcDhiWVAwVXYwek1Ec3ZRREx5blpjamQ3aTdpUkhIZUhwNWo3MHNIMUoxQXE2RHNIU1RJdGFsSWtnamdXYy9URExlY3BXcFpCUW9DM0czN3VtSFhGc0xtVERxT1Y4UWRQbkJVancwbEgxQzBpQzRRTUVxdzFrYWoxVnUvVW92cDJxVUxkWmJqcVd5RjJDVlVWRWFRcTJKbXFvQmZnNWlGczRYaEp3OHlEVWNuK1ZGWjk2a1Yra1Z2MWhXR1Mvd0FXRWhFWER4QzVjR3A5YUluQXRpQ2xEZW1LcElockJtWmdOejdvMVNGaHFVVS9ZM0l3YUFoZ1hDeGRON25haXF5RVhGUUZuUlYyMElJVW9BY1c3L2d5d1VMSU1UZ2xPNHpvK2pUYmlPaHJ3YmUxWGx1N2lwM0JtZ2txMUFNNVVsUmMrRzZtRmkwb1pwMS90UU9tN1AzQzlEWkVOTnFxRmFjUzN1c2t6YXl4ZlNzV0NtL1k4ek96MHROa3Bsa3RLNTVUTU9OK3hnZHh5MlplQlhMcDVzamFUbVdCK0JJc096V1dJR3M1UWQ2SEUvMTNmOGd2THhvQ3loc0ZDRG1YK2kxT2FxRzNqazVsbjZXRDdYQXgrOWNGTHp0V2s0UStWMFlWc0xxTDFTSEpRdytTMXhRWE5tMVZHcWcrQ2RsY1RBZ0ZGRHRDNStybWZGS1I5dFA0NzFUQUpyaUdObThKbTMycGJ2T0c2Q1VmZnJQN29UQ3F4NjI5RkZkYVlYSXhnRkdHMjV0OUJ4QVNvNGJ3UGkwanVxaTJWQzJmYzlxTDd3Z1pvZ21xVmFBOGFpUVhnMUdxL3dBUk00Y1ppUnR3akNZczEvWEFoWE5CRnNEYUM1YjBza3dIRGczRU1ITFVkVWdUaGhBeWNOd2lZaXdYSXJFcW9zZlVKaHIwRnJCd1dRTDI4aEVzOXdyaDBCb0ZPRHJ3NEwveVFTbERKQktBRitVZ3FiNnRpYkM3eGdyaTVlSFBYRzl5cjltS2dHVWZHQ0kydG0wQmFCRlgrd1Z5TFhGbUlTMmNXcUlGSGdnTUpYMzUrVXF3RTJ1bUs0QjdiWGI5b2lIMS9qVUNrSTZyY0dsQUZVNklRRjdOYmQ1K0N0VTBSSHI1SFlualNLaDBDd3Y3aXRPMGhXTVNtVmNIbWUwcmw5OWk3Z1RHVVVaQ0poNFVhMmpJelJRRjNnemlaMlVVSDhTbjVqWlpKOHJPUmdnV2dBQWc0OS9vQkZyUXJMRERmMk92M3N6cUt4RnlBakx4c1Z5UXZWaVFNaU9LUWhneDJRUkVSMHViWlV0UzRicEdOVWtUUktwb3dMWCs0czhsYWN1WmJWcWlMZDlQNXRpcys5U0svU0szNndyREpmNHNKQ0l1SGlGeTROVDYwUk9CYkVGS0c5TVZTUkRXRE1ia3VMQ1hKYWlrVWFoVnllb1hRdExRNHQ1aTZiM08xRlZrSXVLZ0xPaXJ0b1FRcFFBNHQzL0Nwc2NJSURVUkxzSXBoaDFHeDdTUktPVk16Y1lPbXQyNkMwcWZZa0xHdjN4MnZvSVQ0bU51Zk1yekhKYlVDcEZoT2lzQmU1L0lJakJ3enpTWlljNWpad0svaTBWYkhRa0MzWGVGa05oa1NZdm15dVg4T0NIaEluZld5eUxaYU9Ra3RJQ2JRcnVubHNudU81aXB5K0FybnpCYVJoRTFkOVE3VkZacWoxWW5PeGJkUXRSS2xlUnVXZHRnUk5JSnFJT2N6bHJqUkJQV2pDb043MUVhVm1LbGNMdzQrTng2aW1yZ0xuVVluOFRtemlXTnV1Q1d2WUs4TENabGd0NDVqdUMwOFpXM2g4bFAwNDJEUUhsbWhwZ1ZLYjN4VTlCbFBsZXl0SXVvVG1QakxsSnJmODRubVJ0L0hQZW5GSXJwc1FCOHIrN3VCelZEZHV0Umc3b0E4WUVvV2hnWmhBSG5GczNlMkpUeFR6Y08yMmNSdnNZUG0xVDBYR1VqZFpmUnNaSkduZlJtcE5xd0haRzJnNmx0ZEJEbXl5YjJ3clZzQkRGQjNGYzJhUlJkT1hNM2JIK2l0eXduTmZYRWFqdUxPRVZvZzNZV0t1azFMU1hxdDJhTDRoWjl3TEs3MFpaenVEVUdoaEF1NnRFYnlnODFZL1BtMFI5RlJpMEdRMHl3QlhlL3Z5T29WYWNGTHZuTnRuQjFMeHlHeW9IUG1jRE10T1M3cTJrMEFaU1hMTVltSkZSOWd2R0NXQUs3MzkrUjFCWHpvcjZwY2ZPMldTVzl1Sk1pTHdzQUJrZEc3SVJlT3lKYldhZzV5cVZvV3FvMkxBTUt3STlxOSt1UW9LdDhaUmlPdmtvNXJHakh6bHZNSHk4YTNzRi9nZTFmQ3BiL0FGR0V6anJiVlFWVzhBS3FDLzMvQUlwRGVwOFFxNFZjNFJSS2JEUkdDcU1EU0JlUTJyR29lRFFVd2REL0FER1VyS3dMWitoWTd1V2lOaVROcUc2UFVkeTRCai8waEtVMWkwczVYRC9VZEhwSExLdHFEQUJMampjaU51bVJRTk5DMWJaaDFWaWVyZGVBSG9nK1czM0NxL2ROUk9NcXU3NGwyYlQyL3dBOUt4YXNCUHlxc3hYZjhhSEJlbTh4dHBLQzNTek5SM2VGN2t2UWRxZTRvdGF6TXpyOGNEVXZYeFMrR3ltSG9NTnpWdHgyN1VzeXN3aFVuYVFhcm9haGJtdHR0NHZSb2dZWUdBazAxQlYwdGxBYXBTS0ZDZmlCYXJYQmdRVGluZm1FT0UxcitDeWtVN0RMSUZXeFFaNWxsem1IQUZMOVgxbVlYd2ZVUlJ3c1ZybWJrRThqaXFvcFZSRW90cktzQWZEWkYrRjNXNzJYcHBYb1I1b1NNNEN5R0NQWHl5MHlScGlWTUUyYTNFNFdrMDZKUk44MXJMZU4zc2FZK1F6alBVSTJBdEVGRWNseEloQU1hTUhBbDJseUQzSzJzaFNESmNJVnAvdmxmRWNUWHlmVC9IaXdPdjdmNGVaYVpWZVFscExFWjNRZlJGVmUxLzUxVXZmNlpGZUVMYnFHZTlhUzFxSzltQ1Rka2xRNlVQY3BLZ1Urb29ycEIxZ1pFTHZOemxVUzdVemRvbjR2ampSbHFkeno2WmEveU50eHdYNG0zREhOMmNKRFZDbGlaWnhkTFFXS0hQYURmcEEvZ2ZWd2hSZnNuUDVtVXF5VSt3cHVpbHdlSXdRRzNuUm5XZkJnaHlGbkRBZVpnS3pZQzhOZlp4R1pUbTlBeWgwWElSdklhSDRnV1YwSHBMYzcxcWpmUlRRSnlDVE1rbDJzVnRQVDcza3VITDFCeWxRc2FMa2NLRUVJVmxtVmhLTEZwd3RSck54dXRTMlJ3OHk5eWtwQmFhQzVJaTRqZDh0Y1ZrVXV3Y25KYUlCRWw1YWhjc3RBRklsMGpUc3p0VnRtNEl4WjhuRHptdEhTS0lrUXZkNThmcS95bVdOekdTN2hBMGdqS0NpNU82c3NOd0pudGt6V283bkFEQXZFc05ZTGNjcWdubFlGTTg4Zk1TTkZUbmxFYTREbkhYMkRjcXNrekFESjRIcGlWeHlEQ0lFQllONm5ZckEzZjhTdVZDbks2THpwRndITWtjM0Fnb1FSUFhDQndSNnNBM3RTMUdYQ1hNeS95dnU0dEdsNWF3eFJNMy9UbGRRMHBNdGhDTDlWdGZRVFRGS2QzalZaeFQ3ZHlpRmhzQWNPQ0MxSUVaUjZzZW16TUxIbGF2UDlRUXBMbCs1a0l6V0xBWTFDT3dsdGR5a2NIa0dBTE02RzRLTTloZFV6alNzREd2V1hFZ2RSTHlaWXU5UXBJUGRBUllLV3dxR2tiRGwwSjBDbmJXRk02MWRoZHZSS0dvdGZmR1BqRU4wTXg2anlnOXNZc2FmTlVQWEQycXk0Vm8xRUFrK3hCeFJIWXk1Wi9XZFBwSmMxMkN1WnJFdEdrZ2d2QVV1RXQ3eldHQXV2TGExTGhNODRidEQ0RjUwRmkxQ0RrQnBCaUNxK0FSRkZIUHNpTlVOTGxEaDVqajFOY1huRjlTMWI2MW9rdFFOS3FxME52a3kyQzFIQTVJbk8yNXpaU3d1N2FFQ1BVY0p4amJrUHJ3SXFHZjJMS3M3T0Fvd3NxZDNUQy8wMUUxZEFBcGlqR1N4cFNIWlJnQWNMSE42V1d6U3JwRm5vbDE5d2R6Y0ZFVjJDTEtzWVYzWUFNaW1HM0dVTHhLN3B0cllpYlRVcmlCS0l6Q3dvUkxBcCtaZnhjMjQ1RzhLamNrMHpKNWVGWHhPV21HS2l4c1d4b3hxTnBXNFZpZ3EvRU1SakxnanVZZXBicXdGQXV6L0FYRTJXRVBHMUJRMDJ0aUFnckR1aVV1QTFvQjVCWnl4RmpHSUJvZFduS1puM3hFZGhFQlZwdEhJNjBuTXFuQjhGdE81U2dMcmdTOXAyOFFqb1dtbU1RODAzSzlPanRwLzNMUTJoMm16SDlSbVlrTGhFc2Z4Q0lEYzBES0p5RHVVL2ZtSUY0VEVoQkhVb0ZLN2p0OUxLcTZHVm5RWEFFT0VZdytOK0ZOUlRLUy95UkZZSWx6ZHZ2MFZhbGZCTENwT0NOSU9SOFJSZmd4OG9LUksvUkdtM2lGZnVFVmNOMnQ0eHdJcFVHNm1RcHhDVllQUm9zdkJaR0xsbWNiVFNYVGdSQU5ROFd0ZGFxWEdSQ01WS1d1NklFQmdtWWtoSmJIWm5zclVsRlJUU0RZaklJVElEcVlOQjZlYkZzd3g1ZDJ1VVcyNXFacGE5cUNzNDJIUDF0OTBqZVAzNWVSYXpHdVdORWxncUxvZjR2SGNkNGxKNHdzcTBiL3pmTy9mWG9vbS9ZRVBtZGlZZG5USUhOSU43NFlPKzRJZXFVamwrZUdyZEJjckFCWUYzc0tkQjlpRDdNR1dkZk16Y3kyUlRFMDlmS083OFE1cEhBalhUNjdGcE82RDFFemNraitmQlFUMWVieGxnaERZRVF4VFQ1L2E4MzNRYTRQbDR1OFVBTGl2bGlZeDBEQTdkWGtyeE95bXNaM2xuNmc4ZXNjcStJUWJ5WUxleEN4RWdCTWpkTm1ZQUVKWVNEUnFNVGxJYVJ2azA2WFVkUlIrQWpkbytMY0tRdkRYYndJckJXR0tJTWZzM0hVZENuWVB2RVd1Z0NzZ1M2VUo2Ykk5bjIzU3p0YllJQm5QU21wY1ZVVjR1cGEvTXNob2k0Um0zTjRLcGdPYUxNWDdoZU52TW96clJlSGlKbVNRRkJGZnMzbnhCUDJVODBXL1VRZ0xob0RqK0ZLUXQrb3FIN0JCZVRNZERQTW9YRnlUay9NTUoxdUZVVThlSFdWTkxzV1djWThNSkUxbk4xQkF6M2NiWWJXdFoxVk9saEg1c3VuN3RlZmdYdGJLWVIwcW14V215cXR5TFJMU0t6UjZYb0ZnSEtNaC9BSXNuTzFxL0N3MUxMSnd5TXZZSndpbkY5RUYwVzhWeTk4SXVEOHlDbzFJcktFTmcyK3EwSnhWdDJxV1FZckw3RFI2SWJ6dnBtMndGS01aWmV0WXJWQ25oQzZsM3I5QWxlZFJraUMvTHZtWm82Z21oektYME5sb0pCMnFLTUU1K0pVVGl5cFBXdmlheUt2OEFYVTVpNFRKMnVFbDhXMjFXZldDT2NwQitjbjdab2JjQkVxNy9BTGY1VEVnWEhTWG0zbEE3ZEJLSzVSUmZVQXRhQUlldlUrakNSQnNZN3JvSFVsenFTV1Z2Zmo0MXBsRXRGVGdMaVNoZE1RaTB3SXRPS2Jyc2dkUE1DaXNId3Z4S3M1V25aMzVva3AvZ2k2anFYV3VCY0NseG5Cc01jd3NXcllDY01SbjltMFdNSXJTY01va0NtMEFIdEpMZi9RQUthWW9xazZGaHFOM21yR3d4TnhTV3B2V1d3OG5WVmVtRXZ2MVVqMGNXc29JVGRGV1JVUWx0anN3QnppQTRTSmplZ0x1MjBKcEQrc2xDVmpUdkZiZzdmVU5VbnZjZGNhMEFYOFM1bW1PcVoyaGNWOG9pMFlFK0pXaExJNHBER3ZzY2VsOXRZcXFNUUhNTXdVSkhWYlQrWFlFSVZnMGNDaENPcDhQM0xEUU1BVm02WFBicHhqNUtLdFFRN3FQR3I5cVhzdXJpRTFGaHdSSlR5T2hCeG9iTmhjd3h1QlNSTzFLcXQ0VVJXN2hDcEFQQnVxckkvQVFkL0JpNjNYOEtLMitkaHJYekNhaUVPWUFyYUJmVkhjVFNDbmVhZFFDdmNWNG42QmJPd1NXQy9SZXlKaHFvWE5RQWlGWFhjc0Fybko2bEJqL1hKbnRKOVI5d1JzalFwS1B3bXlQc1IrNkJVQ0hVcXRoZFVrNVlXMFZEbzlybmU2NHVOUmtqZUJSTkdtWDBHRjhJT0VBc1dHZU1TUDV3NWFpbTZDS1Z6bVdQYTAwcWxnWXRsRElXcmpsQUlDMW92bzVWcnZpZGhic094ZGtVZVlVWW9ReGxGR01CQWdQV0Vmd3BLSjJlV3hUdGZhL1RZMGtkdGlkMGVPRmxNRURnNWdMYURZOTgrVUNOTVRoZk1qc1d5VWpLb0tkRk5UNytCU01EeDVkMENEVUtURXBlUCs1bmlZYWFrNjdubjNuUUxqTXJXYk1jeUcrQW1xMFlnS2NGaHJNcDExM1J4bzFrd3NpR0U3SUIxNXhZbnBFbGJ6TDluNUl2NHJiRVlydEZ1OWdma21OZFk2K3h1OGdTNUprTDFjSXkyMUtuRjRRbnFYM05KaEpTc1h6OTNiRk52eTlWZFJiZlVIWGFVRW44OWx4YThUQmg2dGhFNnZSVXpJY0ZVZFF1QUpqQk14NUxDOEVGWGJSeW1Ub01RTVd5bnF0cEFOUzJFVTRZdTRGc1cyRG5aeEdxQ1FDcTBSb0dMcjNPU3FWajFobGYwMkRITk1sRkFncGE4Z21XTGs3SnJ3WUppbkt4T0poSm9Fb2xzSWFTM1VHTWd4U2QreU5LSW5QekRaTWF6dEtxNFRKNlpZZHRmTEh2cmZRWDZod2k3VC9nNE1vVjlrcFRkcTFsb0RONUxzMzcxZnJnSDNsZ2ZEbXZ2bkk5V01kNXYzenhnQktSZGxvSlQ4SkMwbjZzUlcvTDQyWElLQVF2ZFJ2WjA0VVRqd2lEd0xQaVFzbzdNTlBxeTB1Q2s2eWtrUTRSS2xkWjhPU0tYZFk5T2QvZjcvRnBmZmkvZUVENVVMdjhVZFdXSTFrU09hMHI0Z281WTUzMVpKODFXZkdWZDNkNVVNRnJ0d2N4Q3JhbTF2VzBOREhiT0ZGSXo3ZFRiZmNWNXMrSmN5ZXU1OEV3UUczdWo4LzRWV0N3eVlMWUtKYTExTlRGWmF3QWlDbzhnU2loVmhXY3EyeC96UXlWYVVMUE9jeFdxdkxjVTNSY2E1Vk5yd2kyaGtSUlNSc1lEUFdmNDY2aTd1NU5xUnZHOUMzQi93Q0szQ2lyUUxGR25URk9qWktTVEZxVzA1WnMxUDQxMlFWc3Vjd1NUVnFEUzc1ZnVEek1rakdySzE2OE1tcUVUaG5kU2gyVUh0WHNPU1JWYS9waDBrWFVwVXJiRnp6ZVhlQ2dzYlRhbXFOMnFuWkJNUWtiNXNVaHFvQ0xnQ0tUWWR0NFlqQ3VKMS9IYjdoY0hoQXQrTXp6R1p1QUFwR1BtVHkvcExCWU5IaHFvQXRTTUNwb0J4TDhPUTZDWUROUE1Tc2FwK29HSGJ1cktjVFRMZktZUTFTTnlDNkI5Si9Ka2tWSWpZa1VtWXFzRkZrWVl4RkFLWElwdE9GZk9WWEtlMk91RVV3QnphWTdaQ1VwRksxYVVpU1VJZW5OaGxTNjZJd1Z4VjAwcFRRNGFKYXl3dG5xMVI4U3RQMkgvVmdLOUg4VlN4aUVISWs2UlR5bFI4WUpRa2F6bHNVL1Jnb2hXbmF4cmZGVUxBZGJXa0lBMERCbHdOamxac2loQml4QTZXa1dzUzE5UVFnaFFMYmhpeWl6WUxpaHJ4OHRhVExTTkRDYzNzN0c3V1RBNWxaSUpkQVFHbXhtMnVTQmJsOExOdEdNdkxHNWJsWE52a3VBeHd5b3BKem1vd1VVdUlVVFZidVBocFk5Nnp1Vm5WOVdVZzc2akFKVjZTZmpmMy93dXBxczJzVElFRVRJa0g4UUp4RGRhWUZyQkRCT3dic0xNaFJhdTFESkt0c3A4cUZ3NHRCQ1hlZCtGRUN5WXRFckhlbndPYjhCYXdSRjRVVWxoY1VVTExqYnBKUWNLQXUrN2xTL1RCNlJLUUpTN0M4NjM3THVNMzB0ZEdpOWFMYUwvZ014MzdFdHM3TEdKOFJ1MkdvU2lWczVFWWdhaXBvNmx3cnlTa3J2TlBJdFJFM1RWeG9GVlZRTStqSEVPOW00aWhTd1JkWVRoWmRTRGNBMjBMWVp6SWl6QkdWQVN0QkxhWm9vbGpNMzJTS0xJNU5Da055K0ZjcUcyVkk1dlBpQ1BHY0U5QUJING12QWJZQlVMVjA5eGRQaGttMHRSOElZUEd3dTNlSEFmeUN6ck9KVmpQbWhHYTRTbU1EYTBJUk1aRzNCQzFwRndHQllneERMYkRRYTJ3bWh0L252N05pS05ZQ3ZuRWNhaEIxNDFoWEY5OFhYMlpBaGRpN2xXNGNCaDIxTUdDaUR0YXpnb0MyRGdwb2xHdlNuNkZrSldWMTQ3czhZZEVEVzhxVUE0RkIxWXkvaWQ1SFh0UDhBcFg2Z3ZzamsyQVcvTldSWjMrcTV2aGpZbmdjY0NHV0M2Z1NPeGw0N3RwU3dTeVhEZDZBcU4xMHNzMjRseHlXMHpYeXI4aEJWYjZ6UVY4cTRKanBmL0g0R29VYUp0eDlGb1Ura2VsaEp3V05BOERlSmRsSk1Gcjc5eUl6Q3VhMUZOTHV0UFJGNmxadmV3ZkNseWNzWFFZV1BRZTZSQThTeVBvV2h3YmJsdVZiVktPMFFGTk9zV29hWTB4ZmcxRVVBQ29KYzVsQWxFOC93NUExWFVIaXBoVUZXTXU0NHdyWUhCWU9rTmpNZEQvVTFaM1V4WXFINVZFMGlJQWhSVEVEVUFFb3VyV2daRnc0VkFJcG9IVFh4R1pRZHg4cTgzU3g4UkNValBMNDV0MjB0THdkUW5IRnpsWkJ0d2JIUkRkNEFsR3FkTmNZbGh3ODhtNkJYN0k2cGJmWFdCWEZ6Z1JJTnFybFY4T3VuSzFLRkg5a09OQmxZa29GRnkyV21LbnYyWHFvNXR1V0JBWnBoekp3a3VGb1JocXYweDJ2NmJaS2pZRUZCUGM1cTAvS25Jb3NQTXBZSThyUGlvT1RPYWdaUUNrWU9EZzlSUVl0M1AyaXRkU3FGdHlnT1dPVFBUOEhFZ0ZGcEtIWFNLZ1ZCd2dPcHgzS3pDRXQ0YXFMMmJKTVZsOXhRQ0RFdEswbG1jckNpRUoyNi9sVjdQQUZVdkRuandrL1NXQzJ1b0tUdktNWXd4MTRNZ0krcTh2OEFNaDZsZnVUN0I3d1RmRm1rc3BqTGxnV2xCcWZpSy94NGRpMy9BTi9HQm8xdDlvZjZTN2l3dmwvcVNnWkUwQkNEQUpkTWsxeUgraS9NMWhvZU14bGl6UDNDdm4vcThDcjk5a2E0S3RPSFFSVDhiL0l6L1RkK0ExZVk3MEQ4bmdJM24vRjc5M2g3b3EzazFVSEM4clZPMzhaQzQvYlhudzBoQUNrQ3ZBRzdEdmZ0aHJ1WGtZSCt2aGg5YTVBb1poeis3NHJ1eWNjSDVaRTJ0ZjVVbmhUN2wvN3NxLzhBeXljdHc5eUk5UjM1NUtLeCs1RDYvTkk0UHp5Wm5EN2tnZjVKVVgrZVcrYTBWN2FzSUZUN1VsZFNzM29lSVhJNXJER3daU2xPNXhLR1lLQndVSXNkeFd5bmhRaFNCYWpyYTdmazRGR0ZRZERLZW95V3FPNndXanpqcGc4MXVDNTNaRmpCY0RFR0Y0RXFQZWpNT3VVOXJtbm9EaVVDbktYaUJWaEZCUXJ3U2h3U2t1dVZ2WDIxVDIwbHlyME5nWlo5QVJQR0VaNXBhTmJnK052L0FFL0ZkMWZsa2hDVTVXWFN2d3l2L1Zza2R3di9BRVpJM3pxbS9OTEZmblNKaU1oZk9MeitmeE5IUitTVmkrcVhxcmFUVCtjYWFoa0I2R25kU3pXcTVXQ2wrckthNHVheUlyaUlMQUxIRWxSUkZLdEt0V053N29GQVVOZHBIeVo4V0NqMEM2YnViYnNKVUpCQUM0V0lVbzR2Z0NsdkxaUUVEQUNFb0JvRGdnVTdPSUNtY0MwN1BQRUxBZnBIb1pDVnQ4cGVvRzlnRldOSDRCVmxkTnFxdTZuM1IwWEJVN3ZVNzRzUXVsV2F2UDhBMlpaeitXQTJvUi8zbmlHLzlPUnl6aWVmK3BMZWZuOHd3d2xZMjEvSkkvNzJTcEg4OG1QNVdTZWxCMUZncElFd2xYdEZ2SFRLczdMSWJiTk5RSUdvb3dBak82bDNkRUNiaW5IUzh1WU5xWFdXbllmM0Zyay9sUXJqbUpQY0xQYTlMTlZMMGNrTGtGV1dRcXd2cXg3YVNGbWNmZWczN0FVY2FzeFdhMTFvZHF5cnhha3ZPUDhBaE10cWpRY081bDFsTlNaZlFEMnNBQjJwdEJpalZWbUdwOXJ1aXF3VElZVk1Hd1ZVYzFLVjU1VGNUZ0ZmTG9Eeml5TVdZWVFka0ZmeDNpTjBYVEk4ZjVKZGtySy9sU1JiT283OHNsYWxJMy9sazVZY3YvUWwvd0MzSnRYOHNuL3NwR1UvUEs4L3l5U2ZCN2tLMGZua3UvelNLMVBOaTVQa1NrdkxlUUlod0p1UURnMm82cFBqRURNUyt3a2pzVEZ5cE1yZHhjc09JNGtUWE9QN1F5aTRtcnREQWxJU3hXMlhjZ3BETk5sQ0NPUWw0aUJaSTNLOXdSYTVoVlQvQVBVUFpRMzVnRFl0UGF6SUJvdFlZb01BRVVHRm94RHBXTlZqY3YyM2xERHUzaXVZZWhTbU9ldE9ZaTQzbExVVzRjYjZzaGduVjRvLzRBYlB2TXZPY3EvUlhBWEdLU0p5Q0Z3REJVTXhHOFBFRHQ5TVhLS2xacFN0MUgvb3l6V2ZUS3V3K1dUNFgvVEs3cHZiTEhydnBsbUFEdGt6VEIxNHZpNnB5T1VUdFBGYzcvMVpYUitXUm94di9ka09KcjF3YkVnZ1Zlem9GaFdqR0hFcTExY1NMRURnVWxOa2hqeFVVT3lWZW1VTzNMRzlDY1FYREF1eDRNSmQwUlpWb2RYc0grVElaM2ptQVQ4NkUvTVJqNTBMcHpNanJwMmR1VlhiaE8rZ0pYaXkrMHl5dDBNVXArQ0sySXhEM0x5NzFNamhLQVJ1UFlhaXl0UWQyOUZ5M25weXA1UmJBamhLcktBRVJLQlhvUFJPTnkvSDRFV3RTRnpQMUhoalIrcVRGOUg5eFplb3N6ZkVIbm5NZHU1VXo4L0JQci9keS91bFhEeHZMdFQ1YXlJYzVjenR5T0liTGRQSitDYkJhMUJtM2FXbGlOais4K2cycWdOeFBteFFDT1FCanBTSjF3aDZSLzBKakc4TjMvekV3Ny9nWExLOXBYdWY2TEJuZlBoQlJQQ3ZQMU1SaG1mMGVKb3R6a1BHWTduN0o5WGY3L0g0eUR0clA0dzMzSGx6WkpPMVFXck11WE1oM0RHcXg3UlZEcGg2bzY4V3lZMjQ5ZEJtdVdtWW4yblFmYWM0Zm5JaStmMW9IN0NaemNYdEVKU2F3L0pBY2szTTljcFUzMy9KR2x3eEt3RTlUK283NmtIMkJDVzg4YkkwM01BR2doaHZSTXZoWS9wcVZWOG9LMVNlR2o4UEk4TVZrMkVveVBuRytna3JBQ0N1WXV2b3dkanVXNmh5c093MnFMQkdJU3IyVDRFN1VKRk4rY2RHSFp2U3hMS0YydzJMYlNDeEZEMm54ZVV4NURLTXcxQytxTnczWkdUeW4wNEM5c2ViTFhsaTI1WjBqZkt4QlJRN1kyZzdubTV2Sk1icmJZUDlSdnNkNXQ1UjczcE40REVtc29NVU9PS25SeE5rZDZtSlpCT1N1ZXlJbHpkS2hDWmZnaktXQnBtNXFrYytwUkVQR2dHSmU2bjlrVFdka1FRMlZmZ0FTTk5UclRJa29iYXhwb3BOZyt3OXdQSEZkQ2dwa3FYRm1NQVhEWlNQTEx5R0N4QjMwNGgwM3d2MjBwOFpsTXRTZ08zaEhURU40bUs1NHl3eVZEeTZKbHFpVjZZS3dSV1dWbGN2M0F0ekN0RFVCU3FxQWNmK1FVZFJmbDJaOWF2Qk1JQ2hGQUdnbjRPb2N6MlErNkNWM0hydGkzcElxTDNsRVhRTVNvUGhYY3A0Y2ZXZkpSQWluR1kwRHpJcWxqRUpEVjRjWVptNUhycTgvUDhBYWt4bzdFMUJFU0J4aGJCRzYwTVdWcHg3cWRQWk9SbXJieDZaV0RNTmFRUlJSZEkyZnp6VmphcFE1TG1IMUVFVGltYWhGYkkvVzMxRkh3SEhRVGNMaUVSMit0SkNtelkwY2c2U3hHcm9qSHY1UEpmTytTeE5TcVhqY3QwSU0xcWhNcXc0S0E0OUJhNEJHL3Z1aTBXV01DWk54bXJpOFBUODdCZGpPQ0hWYlJTdi9BQUhvSlYrT241OFlsR2lJakkra2pjckF1MjVtZHlNZW1JSWRNelZickI0VS9jWkEzT003bGxqU1Z3UTA4Z2lPZkVZYTNkZk15SFJjdWNsbW9yNlBLR1NXVENFcWh2QXJBNUpxSFJ0NEd0YlJjUndPQ1BSQUQzelpWWVZzZHdoSUZsY1BxWnBta2l4djFEcWNGMjR5SFFjQmNoZ0ZjdE9kSFFCWnhsRk9GdVFja3pVZ1d3MkdUMTVTSFVIQU9DTU9VR2JuWTZwd2M3amdWWGFlK3dpYmNWQUgwV3N4REpZa0thVnF2NmxoZDRJNVV1UWdyaXNWV1lRMUlWeVJnckwwZ0hPUXFHQnJCVjIxaXpONkE0NUludjBENFVCZHBCbXFkMi9HUzNDdnJsbHk0SDhzdW1LUmlmbE5IanVlK1NJbEV5ZUt2c21wQWJnUnp5VEhtTUkrL3pkVkpFRU9FNHI5RUpoV2cyWGI2R1NWcFpDb01QcFVkQVdhZzAvb3BRcFdlL3VVUDBvWTdKd0RJcnRHTTR2cjk4SGFxY3RSaGJKVFZYUXNZaUxPN1U0RzM1aHUzVTkyQUM1aEJzeFhWem5NeVh0ZCsrMGxSV0dyY090NGlMWldsZi9BUG9Wc1VsTlpLZy9zWVNDdk55amxnZ0RKTXBTMWJWWHZPNE53Wm5ob2kxRHpUd0szeXc4NTdXQXFCQ0tLQUlDN1FFU1FjQldQK2tKY2EreWU0Z0JnWHl0UmRQN01NWWhObER2Q0h0YURtbUR6YUkzZFc2elhwei9BRWI2QjVZamhGRVNWK1hXMWhtem5uWWNXUXV0aGZ1SzlkT2dzUGdwVGh1SWhQUHg2NDdwYzJuQ2hkWFVHU2QrTTJCTWlQTVNaa2kyUitWVHZPVXk1ZjdlWERWdmZGK3NHZFgvQUhpLzZoM21wL0ovNFEzVmpDZUxQeGQvdCt2NHg2M2YrLzc4VjlVQ1lSZS9tTnh0MHR0eHdMaEVkaVI1Y0RyUjJQUCsvU004OTVVYlZYOXgyWERKN0FzcWc4aUl5L0NwSHFDbE9TSW8reGxBMVVXU1h1WmVFaGlwcjZZQkxraytac3A2TnhXQ01wRmJPb3JqQytPdHJ4TGN5d0NQaTFCeUtpQjlNRDVGVDU1bUN4aXFyNjZPN2Y3bHhmVE1EbWxQL09SRVNFaURSRGEwUVlNeWhjVlNNNWRIdU5qK0N2SGVSbzlSenI2aGJmVFhOYjl5bXBHeGZobkVvRG5XcTNRNFZPTmVpNUlJZ1dwZ0l0bUxKZllDZjhCSzMzS2VZKzN6b0lLWHlhRVVCNEdDMmRUZGlRaVNaTEMyWVVaMHd4bTNmQ1E2cy9Vd1RmZ2tRNFpwb056NXhMVU5KbE84SU1tVWNRU2cvVU9WcXl2QmoyS1k0bHNzU1lYVDJJVUhoMEQwSmtSVzJiSlpwZUFQY1VzYkl0QjBLd1lxRmwzczBTdnEzQ2xUc0VDTXh6aHFxcCtVTk5RTGFxcVMvQVNvYW1JanI1eXh0ODFjSjRRaUJ3Q05ML1BFSFY2RXBtM2txeUVEVUltN3c3U0ZtcXpzZzJtekFkQXhmSm0zZ09CZE80V28xRC9hOHZOeG00R3Bubk9ZRnA0U1psRlZrQ1llUzEyc0N4d01NbnpRRVJ2VW9EeEtPM3FmbUlQc2lWZmk1am1jWm1HNXdodytKVEFhUzZMSlJFTVRkVllycC95Y2lrQTdkeE9TMytRWk5PU0kxekM3UkdQNFFmN0lRL050NnZPMUZ1YkttWWl2aWU0eFZzaWdGU092aUdZaXY2T3NabExGczNCeGNYSEZUSzJiaG5KQ2F1WEhod0RzRlpkTVdob3BVVkxvM21tb0JZaTdvN0gweGFCbEtwa2NwbVp0anNNcVdJU0JCQ3JCbktnbkphblcvTE5ybGVpVVZWRVR3cHVHSTdxYWZqQ21XRnNxckFCbVdGUGhVVEU1TU92c3d4T1d0TnhSY1ZrdDdSL2NFaUpsUGtjUm9GSFRHd1lSR3FXY1dFWmwzRHVhTS84QXFKQzdBMVZhZTRDSFF1R1BEUHJQZlprKzJvdGxMWkViczFlNG03c0tWTjE4dmZFVmhTQTRHelYxRnd0d3NEaEYrWHVMWGdlRFkxY1VBSmhDVk1KZTJpcTEyMVRhcFJwME1RMnllVmR4MVlkaU5WOHpLb25hcHcxOUc1cWxFNXIzRkMxaXdSQmdlSFNYUVRlTXJ2dWY2Z0F4Rkd6dWIxQ2NBK2pMNlFCeVA1WWd0a0JyaGUyYkwyOXduckp6RmZleDdtVzVibng2aUk1MkdKMlNaOEw3TXp0bmI0bVQ0UW43ekVONEdXQ2VBams5RlVYRXJaS0RmQWRlUi91L25kc2FacktwZjM3SWw2TWNoM0dIc21iYksvRUI3ZkJBRGNGUnVqcWVQU1ZSUDRJaDZpc0dZV09HZzRZeWExb0hxaUljSmhBL0VOaHQ0UVdGQmFqRk9LZzNVOUhxVWdvQ3l0QVJQUzlrQXlJVnZUUXl4SFdwWFMrSE9jRDhTLzhBNjZSUzBrb29xaFdwWjFuOUVmRFExT2JaaUdaaGYzRjlpbmZVT2hudEF3Y25sUi9VeERteElyajJYS0xidFlPY1hMRURmZEVGM2dsRExXMDlrL3BIVmt0ZWxhcmcxZUVqazNtcUxVV0NDSmtTWTM1VC9uVDRYdEo5RnFzV2Z3UDQ5emw2dkRpRE9UeVBnRmxwYjJCL2VaZ3YvWkxpV0hQcTRXcUF5QkxWeGY4QWs4OVYzWHhuVGY4QXYrR2J2OXQxL0hYRzcvMWZmamVvdTVaMmZKL0dUMDdaK0ZKWFpEaks0eUhWZ05ZaHZDbm9icUZXNWlsbWIrbTlNSVlTK0x2T29EVDZQakl6MjlZUDB4S2NROEd6M21HL1lsQVBKVW9OTVJZdlNJMnZ4d3dJbFdrQVZsMmhOcTRLQ1lPNEpvaTh5dERJeVFabGxmUml6YXZhTnZ0WUI3NDM4d0drM0FLUm9sUzhvaTVHTjNnL2JzVmI5UXVpSStZR3JkUHd5TUVxdW9iSEVGQkNVMEdXL2JLS3dSVVdOY2VvZXkwOENGU3hZUzR3TUxBQ3YwQVhFYmVBS3ZNalFma1ppWnNQNXczNkx2NmhZZkR6TkFHQW0xalVNQWdzODh6MnhxU3VZQWdOa3E5QlhNUnhBa0p5eDhDYVFPL2hpY0xlMGpocHN6Rk5iRFV2K3M1eGhmRnZwQlB6a2VndzZZWngzS3VrZzg3KzJCOHBCWmwwQkt2ZUtOT1licnBuV29PQWs0VXVpS2JXMEdNckJBM1pEbFN5TGFOYm5DNGMyYkk5Qys0OTNGMFdlWkdwL3FSK1FZZXlWTUtGenpEM2g5M0JSVFRRSk5QYzI3ZW9sTmhpTmlXWU12eFZ4a0JWcy9DR3g0V28zeEpzNzRmN3BYa0swRlFRMVRtTFJYWkdPVldHeW9BS0x0N0s1eW1acmdaSlMvdUpXUSs0cFZZMHhWNGpVSUY3bGt0OFpSckUvZHhLVmlTbHQ4c0FyWjRKUzhLSjJCSEdvdUVpZlVyNExHRkxNM3lzU3dsMUovSlFnK1ZUTXE5TGcwZ3VRVTg3a2xpcWFoWEY0SzZvbUJyd1NtY3JHNFBVamNVMUtDRGJFM1dIU2F5UzdncnQ3WHBGM0xJMVJRNWhuZk5zeHhoWmpMaXR1aUl1b0pxdVVkVm9GdURsaGROV3FYL2pOK285WmtZd1VxWkZZQTRucHkxb01CeHlpWHJGUlRkYW5ERmJTMDdKYXI0NDhYRHlKdDhXazUxTFZPNDRwSWh5SDNNc0F2RFQ2WjdxTXFEUTRsQUhIdzhQUmR4bkNib0R3eE1VcjF6c2RpWE1GRTVFNS9NcTlFUWRUbFRnSVVJNU85RW1hZzYwU2xGVy9ZdXgyb0xDMUpuWUhQOEE3bjFOYi9XQlJpS1VOdDFVcEpzbG1KSE1ISUZvbFhnd0RGVERYVGRWcmxuMzR4U3FBQUduN1NsbGZyUzRKdUZRMG1UMmxiWTBydUxKaTNmcTJNRGwyK1NHbVpseFg5QkdxVjRBbUtuKytCNkJLVWRzTkgyeFFNajVNc1RGTXJFSEFxL2M1MEhVNEphekMyK0MwT21IZ0hLSU5IWnlPSlY0ZDE5bWV6M3VDVkYzR0hLbktYb3pyRERtNFlFYVduRlpRUkY2R05EbHYrV01vUm1CL3JlWFIwZ1p4ZzN1bnZDbDZ1MThtSWdVdk9Ua0E5aExrMmFVSGt5akI1MXdGKzRIUnRWWmZpUDlCL3ByTDRydFhZenVkR3JSMFZEYnpIS0xsaXJMVjFSTE04NFpjKzZTalNHdVlDVkxsRkR6MzZJK0crWHVCSFZVVllKaHFzUG1mdW9sbG1Xd0hLZ0pYUmRKWEswYkpZMllkVWdZUXZxWXBzZUYzU0ljL3dBTnN2dGVIeDhzV3M1L1lnY3I0cTFhWjluUVY4Zk9MK3AvRGV6K0dwM2F0MS9yL0pQZ1JvVHpnd2l1eU50ZkQwaVFIN0krcmY2VU5leiszd1BNZnAzeFZJK2JlNTFSZ0dWOGthdmRQeTlBMnc5cVg2eGY2WTVWdjZEYW5vM0d4WnZEbkhqUG1tVDBmNTNMSzFmS0Q0cDZFSDNCZlliK1pSK1c0dnJRcEJhdzdKN0dBWS9RUzFBdE9kSW9XMU9Jb2F0Q3cvSVJKV0FaVVJ0ZVVpTE95R0JmVHdGM2kwcWM5WWxWZkxNdmJvd2VkTVVRMWU0cnRFbHZSSytYNFljZjdRZnJIL0JUVVhla2UxUDFXbWRnT0xpR2dyMFJPUFVNL3dCS1lGelJ5OUl5ZnJEbjJDZytXWDMyblI3WFErNVVNTzIrelUrZ01DZm01RExYUERBaEVWeXpaZnFEVURnTGxhS2xNUko3U1YzT00rU29DaWhBeENmeE14QVAxQzQ4Qm9lNHFzeFVGN0RNdnpsRFpJT0VlWmJpWEc0bUdkQW9SZ25RRzY5azF2dUtLd0RreUZWdzlWaWt6L3pEQU1EcXJMQmlQamRwMkdsb0NhSE5MRnNYQ0xKcjNzWUwwckFsMTRjbHkyakt2YkhaVlpzVGdDcnoxSElOQUJieURYMmtFRVhEWE85WDl2Y3R0eDRHYU9ZYnI3cGFpSzdtbEVyMGJtQWdLNmxxK2lFSTRrR1IrZ1FkWmlRRld6OW53Wmp2NUpjcUQwaG1XQmdkd1JYQzV1WUtMRnZaZVdYTEJIaU9kWDIvQ0dRNFNJdFZPcWdyb1owNVJHTkpxcjYyODA3WFZJYjN1aXRzNEdXOEdPSEhlV0NrRTROVmR1UkYrcGF4QVd2NEU0TjAwdStQeXNhRmRuRXJoc3ExWmdtTDhiTHZyRStMZ3Y0R1NKMmJHL1FRS2RhT2lXUzRLTGxtaHZFMkY0STVWa2FudDRYQ1FFN09aWEpnaVUxNHlRWmdvT0JnM2pIb085d1ZZYWJsY3MraWdIaEpCcVhlbmFHYXRLUUN0dytpV1cxS1g4VE9NRzRqZDJ2bEVQRURHMmdYR21xS1VzYmx3T1NjREhBUE5pY0JnWU1heW4zbGttRVZQWkRNUlZ3czI3NlRqMnhPOTFBTDh2UGN0QjJmVWJUYWtWc0ZyT1gzVFI4c1ZMUjdSM2hIMnhjVFdtVVBuajRNUjZDdTRabHo3Slh0Z1JMcUkwckNGTWxlYmNRa2ZPZXhtSlozTVI5M0VMOWJpdXRuRTNxa09DNkpZaHc0N2x5dG1XTU4rdHM4c0ZOOG9kMGladzYyZ0JvbzBWR3FjQ3RqRXU4cDV2dE5Yd1kxZHh0VU9Rd3ZwaXhtQTBkMWxCR0xPdUhrVEZlODh0WStBTjY5VkNvYXZjUWQzMDg1QkZnVEt0bEEyd3pGaTFLRHBCTURrQjQraUwrVVlaSXd0d2V6TENxdE80MWVXODRiOGZtUlpWREs3ZkRvSWhuZ3FtWFEzdGdxUklWMnJDc3U0YlZ4S2xkcVgxTHZpQUZPSnY4QXdoazZQekh0bi9QcjljYytoRCtPaCtMRDYwRkRnQmdBUENHM0Z4Y3BmbHI5R2ZzRzlSZjdoWlFCeG01MjBXN1YvU3JRRzN4dnR2Nm5TOEFIWmxEWllOZUpWSys0ZTRqZ2x2OEFpOEVnSFNJa3FHRG5aZE5UTGh2d21OaXpGa08xbDVyNmY3Zkd3ZkhaenYxNGowT2Y0T3pUblNiRlhpWVJxL0lyMzQvVCtRYlExY0dDb3B2d1NxZ0J0V2dJRXdFblFScmVUK0RHbWZjZFcvc21kZWN4ZDFvUTdPSWRSTVgyemRaVDFEZnpadzkzanFHZUlJMlFjR2NBUXBtR0k1MGJ0dDh4T2hVc1NLclB3TXB1QWgzWVpPWTJnMGpEdG5IZ1ZMZmwwQkdNUG13Mys0Y0gzVnoyaTh3dmE1NitwRFBXRVZKOHlFM0tnQytBbE5wekJScWFndWxSY3M5RXdTL3FCKzJPMXRtaitGUGNQejhrenl3ZzhZd3E1WWpLQjlrZGh3c1dVc0dxaVFUY0dTSEtDeDh6NHN6SGdNcW1HYkFRdHczM0FFOCtLZkNncytDeTRTSUFRaXRYN1M1NjBqK0pNZ2VpNkZDRFQyQVhLZGhzZW14bXZvNFUvZ1NwVXc3U1ByREd0cmE4NCs4Z1ZpWTZqUUtMcWlHL0c0ZTRxbVVzZGRRak9MQXh1djM3Z3Q4RHdUbWlYbFBQaHlFdUM4dFNqdEFodWRPcDlVZ2R2d3JIcUgzdFN3c2pFckJnWkdENDdYMmQ2eFZ4R3BPZDc5eS94VzcvQUNvWkxGR0pyVEs5c0JEK3ZOSGYrWWl2QU9qd3FtQnhMUUI4b0hnYmdYWVhMRXZ6SEI4aUsrWTVKRVRXbFN2MUFiWEpxL0d6cExjNTZpcEJqeUdhWnhCWXZ3aGNtVmhmUWdoMW9ISEJydzkwd3NNRURJT1dLQUNGQVJWWTljRVBjM3hxRUxEYTlmVS90RForNm5aSzVHRis5R0kwMWdUVnMvMEJaaU4wVDJ2MDErbyt1SUVIMFJpTXZZREJ2c0hOd0U2STlkNWJoVFkxVmpOUnRlQm9qOEZlTkNJZjRmcXdObmRIZEhtQVlBVEl3LzNoczdZQW5adjVtNVZEcnlYK2U0RVFXc0ViTEsrT0h3dE1MQkMvaGhsbExaSmVRMStvTnBORVhCZmRwcmZtaGNLTFhheW5XVEFHaEZBRkJGdmJLaUsyWmFGcUlGbytEQU5TQUIxOEhsQ0lnajNOcTQ2WTcxZk1JUEFrV0VnM1dwZjREblZUbDlTd0RGM0tuQzdhWHg2M2hnYmJtcUxyRStlcldmWmF3b3Rhd2Vjc3RkNXh5TnFrUWlGdHgrcWhHMTFQL09sZGY0cEMvc3djY012V0NhL2E0dFY0aGpCZ05URm40NENYekl2UzFTNkpjZXBZek4wWElwL2dwSS9yeDFneVJoYzBRLzZHUXRmQklPNmZ6TmhGSEtnS29PQmpJZ2d1dGdiUytGdzl4L3p1VGdRZHNBako2cnZuSDlscUdxT1VaVmFzR2xGUXNqTXJWNS80a0NIcDIxTXlMcThrUCtwa1lCL1MrOHFLcVVMdVNWbU9ZcWYvQUQ1ZitmSUw0SjFEaXhJQ1FUTUNhTFBDRXVkNnBTOUo3OXpwdWF4SDRWZ0tYVkh2K3RIaW9PQXdhSWVXT0RoczJmaGxKNGFFblg5eFBZSVorNzVsZUZHSmVDRS83U3NNUHMzWGhuaUVKK1diK3N6b0g2SmZ0bExyQXBZSnNDRE9LNkl4bERvaFNBY3FGUXh3MzdnRFlNQlp0elBEbU1JNUROTy9BV1EwYTVOTUZOdFM0NXFDYlQ2ZWNVejNHTjJJTkFGZUNacU5YNHVBbmZTSXlyZTRGZmF5cEhxWW1ZemxHTXg1UnUyR1c3ek0vTWNUazA4YlhSQUk5OCt6OFBEOVNMbElaN285bjRRdWdXWWowWjF3NDRXY3o3cDBxejFvTWdHMlpiNkNPM3o0dXpIWkw2ZXhLdFF2ZFJ2a1RVd010MEZZTGN1WmdGMG1ac1BBUWNZL3BNcXRFQ3N2b3NabE95QzNPR05rNDBJU3Z4dUF2R1g4SEJmQk1rQ2lsMU5oNGlzT0FsRmJXNUkzVHluREZlQ3hRdDBUVTIrWlFjQkE2RVcyMGVvUGZGVzArMFFGMjFDemFDbGx6QnBzZzZReis1YmNHbVU1TUpCcTY4TlEwL2NxTHVGR1pvekxvMUUzcjczSFNmSVpmd0UwRUZNcU5zV0NRYUpWRW9WaUI2bEdxS2xxNWgwY2N3MS9xT0ZCcUJLUWdTVjNQY01HY3ErSU5JcUNOelNZL2diaTZNdnJjekY3L2hoOEQ1dHFyUUZvWjZxR3haVDdoTEptVjBJcWhFK1lTbzlMbEg2VkJBVEV0WVZkVEVoUjBFc3U0WHlLSlNydkNIaFNPeHhGQWoxQW94dXh4b1RBMURKRTJBYkxpVm5odUIxQkxVWHdaaVB3ekUzQUF4eGlYaHlzNFhSRGpRaWV3RG1kOEJaTTk2WEtxY0ppTllucVVHOE13dHFuMDVyNS9QaWNqSzcza2dOSHBxbzV0V0ZMNW9odVZKWWpoaXRsejU2d2lqMk1FbkZISnJEVTkyWUtMRFNYcjJwVUlRQklWWGtBb0JqWHE5ZlVuSVkvWnBrSmJRM0NkcEQxYXljdlZBMVc4ekRsc1pmL0FCVVZUbC9SdG9tZTU3Z3EzUGNRRVlSZU82WEVsWE1NYWxGTld0bGk0dnkyclJPSVF0Z2owcVhwaHhJbjY3N0pxWkozOTJVVXV3Rld2YkwzcTVMY3VwcW5GYXB4RUVESC9USkV6d1JhbXZmeXlXbnpCVFF2Ny9BY1A3eVlRR1hwNWRGQUdGbVJSQnRlNTZSRlVyNXUrcHhuNFFKSkJSTVQxV3Zqb0VSSFExbDVrRW9wWWxuWEFXdmY2TnRHeTdSZGxVNW9lWUFna0cvSmFwVEw0ZC9KTmRIcVV0L3gwZDdWdVBmdUozRm0xZWFuRUpHY1dYeFpMdktZL0dYYVp4Mk9DS2wzd1JlMTA4V3NFbWYwRXlkczc4Y0pDRmZVcFk1aUZmcVozNHgwUjNFQlp0WHkzN1BPNStQNEFOUWNRazRHWGdGVStLaG5aMGR6NmkwRS9VeEhJUVZ2d3cwMGE2aUlSYkxnTzBLejZJYlRBMTRwZE1PY3BCWFRNdkw0ejMvRDdtZVh4OHZpaTF5cFVvOXlpYThVUGduTG4rR29XOXNEc1E0cVB0bGhUOFdvc3pSUGlEUXk5RUFkeEh0SzVlNEpRTHVPMFB1VW5xRFgzbUt6ZkRVS3BZNHliVGdJT3IxRnBNVkRsRFRjazIrN3FGZFptT09TSWNYTW1rRGJkcFlnSHhNdlNCVUdOZVVhcHpMdXlwVXJFcnFGMlp4QlVzOVQ1eEJwSy9VWE14RS9jUThRTTc5ZWJ0b0NMTkJOZ2FsclBpR0JUeHBzalJseFF1ZnFRTFVOZW44eDRCaHp5VjFxRVpUQmFEUFV0Nmd1U0diVFJMaUJHa2dwU2tNUGltY0k4d0pvVHREQlVzbEI0SDZNSUx0dmp6WVFzdW9lNGhSUHFKa2lwTFlMRFpUbXNRaFFkRWdxdnJraDBObW1DZDdDQUJEQks0ZGhLTFg3SlVhS2JsV1Jqb2RWbVkyamZjRk5yT0JMVFVQYzVhQXk2SG9ZZk43VkxCV1hLWFcyR2NBSE1DNm9ueEppNFBVUGdwczRJb3F2NlFLdDN5SHpPL0pwc0NBVmt1MGpvWEtRYVJzZ08vQ0RBZVJ1SUhBNmpNaGR5ckpETUNoM24zY3JneXBGbHZLSzVnM3hMNkl6SHRlUFR3clVqR1RRT3dvTU5nZ2tuRjhxRTVKV0cxdXZQKys4QWY4QVl1c09vUitZZ1A4QXpjY2hsTFBVeFFsakNmMWtJbUhESCtoUTM5SG9kc2ZKaDhvcmRnNTNyNTRsZDQ5MTgxYlBqeCt1WjJjajVLRitoUlg4U2IxbjR2S3BOTHFCKy84QXZHTm52bzlvL0tUc05QbEp1YUNkbTcyV2kwVHY0aUw5cGdTYW00RXpLK0tENmwyckhGQ1g3N3ZXQlM0Y1BnWU4rT0djdkF0K1lUUTRZK2o5SEVidWxkeW5oN3k5TlpmTXROSFI0VjFVTkhjWER0eEVtaSs1a0VTQVZTSmo0dzh6Tys1bWZxSGJLMWdoTWNtb3RSSVdvYzRsQ2NFTVRZUlp5emRoaUszSTE0cnlucmR5elpsWm1NK0s4ci9CQnNBdldKYmZ6dzhsRkhDY1M5S1lCdVh2ZkIwakRrbXpVT1RnSm5EV2xiTkpIdXRjZ1VlNXM4QkZIQnVLWW8zNEFSQTZpWkJCNEcySXBza2RFa2VvVGdJdTFseXhrRnFPeTZyY3N5MXdXUFV6dVBhM0pYYnVEVmhoRjE5dzNYdXlGZjZtcFVxWUlVZ1pqOUk1aFFiUDhvTGxodEJYdHhNRERTemZVemhYQWdGQlQwVHJqcUo1U2FBdFJmZ1lJT3p4ZW1uTUpsaVk0bFlDMnkxVU1YQ2dRbGNaRjFEeE1lR21SMUxFUHdFS3J2YTJEc0pmcUFDQVo3WjFIV2E5RUo5MEVPeW95OW9ZZUhWdG1BVnVmSk14OUJ4S29IUFZHWmp4R2gxTlcvYU9ERm1FeWxNd0k1dzNHQXVTUERBSWg0V0ZWTmJSUW9VVFV1VXExSjBDR2ZDb0Q2b0hhelZUWDZqdGI0bFExWlp6TEpYcGZReHUxUkVpV0RkU2pxVVJSVXJPZDNOWndiWHBuY3BnVGw5dHZNOTh5NWhTUXplWHhEN0hwZE1mbVQybUUrYzZoU1dOelJkWTgwYVo4a3Exaytabm5LNElqTllRVUdlQ1lmWlROZ2Zhd0VxMnpIcW1ObDVKYlkyVkRMZ3EzQjBtNXZtNC9CdmJCRW03RlJFaGVSY0pTQW5oMUV2QVhEQkZUazQ4TTBFUTBMQkhOMFJoYzY1OGVzM2VwU1pSSmVKZUVNekluQjNNUEZ4SmZEbFdUdDJZdlNGTGVwaWpNL2dPMElEejVvVnYvSW0wZVl1cDAwU2toVWYyWGs3UEx2bFVjd2xuQjMyTDBVVHR6WWZwVVFTelNQOEF0d0NXajJqei9oajRZRGQ0bC9uZVBuL05DMFpINzgrT2I4YUZ6OS9HUDJ5dEs4SU9iRUhIRk9IL0FDNnpJRHo0WFdrdTdUWlo0eEpWUEZ2eVZvQmxyQS95di81ODhtdVZSeVJHWC9tMVM4aTY3YzJCNFJtWDVvSDFRWWk5b0JzZ3FxLzFOOEQ3ajNpSGZEVjVPM3hrbEs5eFVLM1JMemc1U3pNemVuUEV5R2NxRUJhQm1PVkJnSElJUE1MNFE4Z29QcU54VE1xdUhNSHhXTGxpNkxlL0F0R291elJFd0RJekxidHIxRGR5WmUrcFVaTkdHNDFGRDl6UjRqR3ZCV29sY0lMRU41akxxNHVJVTRqOXk2SXUyQXBsWEpqS25HSmJWSWxWMDhidm53d3U1T0RHeDk1eExGM3BZRnIwRUJsOUtPcEVVbE5JTlFON29Dd2N4MDJiR2JtSlRjdWppV3JrWEJWQTRMaUtZaytISkZCdTVjUzVrcVpmcWh4NWxkRGN0QkZmRmI1aFA4aDd4RXR1S2g5SlZITURFN0p0Z0hiREhMQWNyQ3JtUURpdzZwTUh6NmxBVmFQYkgvZ1ZLNkdkVUl4K0tQSkV0TXJoWWk2Vm1Gc3c0alVsa29tdnFVaGlVWUh4UXFvTXJEK1k2Q0QzTFg5eEFlVk1kd2JEYjZpM1RiS1BKeVNVTlF6aFNXeG1NWGhicTJjZUY4azVrSUxiZUNVMUE2dDF5UTFaUTFHR3BDNDBXWUVOZFJsVVpmS3NkVndiM2lRbWQzbkpOQWFxV0RPRGxsTFJ2dE42dmdEcXBScFEwVXd0MFgxR0dhQmxBaXVsRUxzS0lydzZFNnB5d2huSlRIaGNrTUl5NWxiVU5vVjR4aEhGM0FJY2tjTWxYd014VTdSUkZJbVhjN2lxTytVcXBhL1RqdzA5VkJrOUpEZkovZ21QS25VUmhGRktCZlRMNklsakM4bHcwOUtSc3NwR0V1d1pRTEZMZ21KZ3R0WmhpQ3B5a0pXOXRUMUVSZHN3d25UTUlXUjhyRklPeHBxS3NQWmhLWitEVDRTR01wc3VFbDBsY3NnUWF3UStHQXRsVGlJaGRHWWtWNUllbk1vK01acndaK0hjWC8wUUtaRGpxSnFVbXlkK0N4MThkVnp1QWFQTnd5K3RVU1duUng2TXpGcm40UGZNbDNDVUt0UXBvdGszNE9BL2hwcjJvM0s3aVRjWDhqbHpiS0x2RG9ITFkwN2hCcU9iWmYwd1hLWGR2L1V4WTc5cXhiWGFoeGNIcWZpOFVPNlBpZFRQdGpxWk9uOTN6dndlSUt5MlphTnA5aU5NUTd1ZXJSY3RpMWI0L3Y4QUkrcTQvZmdjWDY3cHFYNFpPeFlJTUk3QVhqd3k5cFRSSDlSVWFHc2hxK285VTB3TUx6TzZUOVFLazdiUm4ycFdjRERZYUtYMEZ2OEFGaHZ2MTd1NFRxQ3F2T3NMRjVUTEgvc1dMNmhhakMrNDkrTDFRN294VFF6WVFpZUhPcWVzdmhRNUpCTnRmVEV1cEM3V2hRMG4zRkxWbndvalF1Q3RPY0krYkVyYklVUUNaRWR5R0NVZFNMTVdFRnJvamlGMVk0ekFUdmlwV25udzJSclhDTVlIT0liZFdNeFRBdDh5eFdCMmhLWDFPVXZlREtWWXFZcnNISjBlQW1UZnBlWURCWGhIRFVBQUZFZER0cGd1bW5ES09Sd1JhVlJIYW5LWDN2UjNVUlRhbUtOd0NNTkdlMkt2TnNqaStmRmJmUGdBcFQ1NGxsQ244NTl6Z09iZ3RsdHM4UW9HbllneEFKcXhFS3pzSGlQTHEwbkVyZWdiUEpLc05PUjJSb1BvOFIzbTNTd3JOZVJBL0h0eUdGeUZQNHlwZ3hNcENBNmM0V2hEcGluUW0xeGNUVlJDdW9kc0VRbUJJRTFHSFlob2xwNDNEYjBTK0xtS3R0bHlobWMyd21qU2U4d01RVGttMFZnRVpYMlY0Vml2RjhUWk81V3BCRU8rZElGdjNKVTF6RmZCTXZxWkhNNlZ1Nm41bVdiUGNjMUVkdHpNdlFxY25ETEdyZXB4R25CS0MwbC9rcTNIbjUvamNDeG40bFJ0Wk1xOEVyMGVMUHd3UzBDOUNOdXE2RTRnbnVJc0VXUHNsMGladHpqKy9DbEpRN2VUeGZpL0JMakwwWmFxbjRobUNhcUhxZGhLQjhFY1VNdDJQNlMycHU2cUhEZG5IS0lZT2FuY3ZES29heWg4NnYxTFJ3RnZpbjc3Z0dKb0pTR1ZKaWpUeXZVb1ZQZE5vRm1RbVhyYmlkRkpla0xNUnFndkNYZytDRElkTlRsZWJoS2dPRVpZYmFRc1BUdWJkcTM2WUlqa3NCblJVbWQ0M0VFYzNDdHpQTThyeDRRSE5WTGFqbjB5bGloMWFWMmZDRW93bHdsU0RFV1E5WkNxR0Zjd25mWmhiQlhzTXlvNXZKMUVMa0hHSWZhRHFzd3MrQXl4M1hvUmJCK1pvaEJvYUZpVkdMV0RUWnBqMnF0bHhoVmtaMFFuSHhPeXFCWExDaG5IeW93YW9yNll6TWR4T2R2ZGdYYmlvZVR4cHVxelJ3MFlFNEtJWkVNSW1FY01BZ0lyRFA4QXBDb2pKd0lvQVlBQXhFWnkxak44Sm9CN0NMT01VNUJsRmFyNFl3anJBeVVBcVhYWWhEZUJkQkVzUWJGNjVRdXVVUXJlUlFtdmd2VFlWMW5BckhjRTZUKzFMYUk5RUQ0OWhBQUxSZGRxSGRxbTBGQ2ltRTZSdldGbTVwTGFaMjRyMCtLU3ppQ0xhNTQ2eVNZOVFHUzd1RnBBU0NFbXM2eHNRMkVUd095cnNuVHNSVnBiYVljdzU0QmpRQWdGcUFObVNES1ZUcnYwZ1l2NWtZb0FZQUFBbFBuajFLOFV6RHh6RTdKQzRkMU1RUlN3aFdPRitvWVhMODJRVER3UmhLUFVzczI2SU15R0ZhRUR4QVVoeWJFVHN1aU5UbmRwZmRhSHU2aS9pbGtuNlA2STdVU2xnRnl3dWlBeGJMcjBvb2ZsaUtCN3Ivb3dEUUViMk8wcHk0VXl3cGFta0E5aEFGQlViSHl5bFJsS0hNUHJ2blJtQ3BOQVViVndUMURvWWR6c2ozQ1lHOUZsU2VHSHRhY1JJTER2enQrWlVkemd0ckxJQTRQTXBvcmJuQlZqczhUSzQzcUZ5UWpSRGV2TEM5RVBlMkROUndnQUtGaHhOMFVBaXlhMjZGRDRqSCtTZ0xVdGFPWjBkM2Z4ZzdKYjlTbUpySXdVQTRQOXBudUpWalVUV2U1UVhxT3NuUkZkNFE1ZkJ3U2hnNmhzbTVTbjdRQUxwTUQrV2ZMYi9BcXd4cVVudUdXVStvWUIzL005SUxtVXBWam1ZVExZeHJKaVErOHNwNVFRMjVQQ1c0WGN0UWdvb2l1YzYrRURweUxLNFU4NTNTN01TdzJieEVNVWtGTXBJTGNRNUcyQVhtOVNvT2tIK1M0cFVvUjlUUHhVMG0xK1NDdlNuS3dVRGZnZmdJY3EzZVdpWFZFQkM0V2hJNVlweGVZSVBFMTBuZ0FjWEI0a25nUTVHemNRbVZUa0VKc2FFTVJCcSs4OWhwUG1XUmNIeWlrQWoweEVVb2RlRDkrbVlGUWU0QytrM0Vqd21OWFB1RFErU0xzSVZ4cjFxVTU1UEpOV3VwUS9WbU0xeXhtVmpCZ25GTTNMR0V6Ky9VcVU1bWpFRVM4REF0ZkR3UmxxVU9TTkthcUFzeVJYQTF0ZW83MmVvbkxFcWpobnRUTVgxeVNKOHRTR1BrdU51M1FXZmtpRU85MldhbVZzZUNtWFZlK0dzcXNsNWgvY3FwYzI3YXhBaHNaalcxdUVjU2FlVWVZQm9uRVJHTjZQcUQzeEFCR2RETE5WOXZUQ2lDdFFIeEhLc2FEcU9MVTZlL21WSUYwRXlSNlVoVGs0TWNPVUZ6aWJpNExqME5PeW9peXVHSXlFVFRjclNFNmx4WVM4ZmpWeTVncXFWdWI4aHA2aWM3SG53UlExMXd5eXBZR0VobWE5SWxyRWdOSjhKU0FOYVRHaHJNR0FLL012RUxoUXhHTHV4QzR4ZTlKcFlyUlFHZ2xGUno0cVlFSzVZY0pRNVN4bXdnU3grOFFlYmdSdXEyUkdXVzZnVWFUYTNpR213UHo4d1dWdWhCeW54MWNLeUZPRGpIOVloU1dQakNZZ2pJTlFJWHZ3RUlRb3BmYkU0YllCdFFJR3E1eGNaVjVJQU9XOEJqYkxTdFVtdHZpSmgwd0xha2lOSlhjdGNkWStORkp3U0p5MTdLVVZWSXZDVXVHYmpCeGVZYmtsdWVxeTE3b0E0bHZxYTRadGJKeFRJeXArOGxJRUtnQ3c0bGNDRmhYRnV5ME5LVGZFaFl4N3JrOW1JNjI5eDl0UlhERmhiVnRnRXF6YUlycmR5UUlvL0UzamhsaDNQMFJCU3NIYlZDdmF5amxZVFRRekVtVmFsQzAyY3dGbEU0a0w0ZjdUTWRlWlFseWE5T0laUUhmMWxqWllHTEZpNHpBVVMxSzlvMlF6WHoxOXd5NFc1d2J2WEV3L09XZmpnNDN0cWxnWnJaQkRvRVVIZFVsN3VQeTZMazlpSWpHdTZPOG9BK0FKNlI3WXdmNjlkbmhHQXdiMFROUU9kZ2N4ZE13a004d3Ivd0MyWWxmMllDdkNMbXhMalFIREwycFJFZUI0RDZVNjNEeElCbWRSVWcyTWM1WU1RYTVsRGxFWWhOSkxHQ21XUGNNZzQ3aWp6VEZFU3ZoR1RCMnVKcFZrdjFyVCtpYWJuaGNzTUFXY3RnaHNGZjJGWlp3MGxubWpvaXZGZkUxcFlhWmoyTzBmN2tTenFucWNwekt0akg4L1V5emp2YXptTGsrUmcrdkdDczJJeTJCV0NGV29vcU5BUTVkQnk0UGhVdTlTVDIvRmc3VGI0cHJFZGN0WWlubzIvVW9PZFF4WGRiVU4zK2dyMWdFL0pOMWNzYkhrc2o1V3BjWExTeXU4SE1QMWJVaUtCcUVDNTRpRCtkbEJ2clF1bVdIWTZndXFYa3pzNGxxRmxVMUJMQXA1ZDFSK0dQY3VyRW5vWVBhUnVDZ2JFU20xRDdjUmxpc1gvYTFDb3NsQjI1Wm9XTXp0aTFQRmdJTEdpRG5SMHhoTjVmVW9vZjhBcEtsWkxLTVJiMlJGYno2UWtCdkhLMVpiVkFGdDZpQzUwaTBtdVE1aGJZOVZDNWY1alVCYWdTaDNaTXZjUm9SWWdkS0dyWUFRSWYyUktNKzRZb0F5bDZDYlpNa1hDUEJobWRTRFlRb1JiQWRzTER6WXJ1aFo0Vmo4bEtVUTJPbzRuelFtV000eU1YRW9tdlEvUVF0RC9DTFlBSVQyS2JqVjRFWU1BWEdMbHRsek1VaDFjWFRWak1WOHVCRmdWeUxCeE1DZnVOMDlzVkFzL0JoUDZqZk5tNGQ3RDdnRzlReEZwd2t2TENEdG1wUUZIRXZtTTBacklLdXc4UWNlSEtsZHlRZVNXTzI4UkRGQmR3c2NOUnV5Skc3Q1huMExNeWhucW1rTUJjSDBDS0pVbWlGWlNYaG9FQlZOdklRaVVtVVNjUGhyalltQ2JTbXkrQ2t0WEFaZXpxQWNjdlp4TG5XYm1tY3B5aldqdjVqRURTWE1JdEhIdU9wcGh0Q1k3cGxLaHJhNVYyaU8vcUpmZEV3WFg1alV2UUxkY2hPVU1HWXFFTnRwS2tXcXRvbkYwUjdndENwYnN0emR3cFFsc3VJb0RGUnFrNW5QVFVJMFRTRGhBbFVnVmZXQ1ZOVmRqMXNJdkdsNVluRVVVclRTWXRvNkx6SFowaktHZ1ZqNmpFTXplRmpjYUJ0TU9FcU05dVpRV2dhZUg3UUk3amJHaHJkajdnRmlzcFJqU0kxWEtvYTJDS3JGZGhHTlBsTEsraUxLRWVDRzRmWk9OZk1DdUlHM3h2OEFaazZGY01JVlFNeFU1THpqSXdRQlJmZzZJY3Awa2o3akN6RVFqK1FRcTF0dm9sSEZXVHV4Y1ROSGNWMDBwWEE3alVIazJwWFo4OHZBUi9MalErK3NiSUV2WjFoTC9aYXVPcmJnZ2Vndnl3YSt3Mm9ZUzRqNllIb1Bma3Y4MWpWalBFb3R1cXFXaDJjYlJYRWlyVzZnY0tCOWlDeFREeEF3eDJQNUdLakx3ZUFObDdKaWJPMzFhNFB6Mnd2K0J6R2tTRFpZT0lBOWF3WndaWUZQS1FnMEVacXNzelRMNkkxVFp5empSOFFuQStXVUJVM3NGaERxeHFtNEk0R1VxSVMzWjlrTU11UnJSQWVRUXJZZm1mY1JwaVcxMVRJWmFEMFJHR1c3QmZ4dHNwNjFHR0EzdlVMVUpadXJJdzQ0Q3l0R2NnL1lSNEx4ZHpwZWJUeVZXTWdxYUhQR0VyZmxhMmdnVjJjMUd5TmxJelZ5NEhJNFVsZnN0VmRHOUg3SUZzVkJUVjIyWDhJK0lLaU9URTE0MnZPZjRrZGFEN0pXd3VNY0srSUc0bmJFQ2hkVHM0Z1diRXYyaGhnang1bEdNNHNsU2tTTkNRTytWUU12Z3BnTHNweVlPa2o4MmYzTVc2cUtqY3RDT0xSNzRrc1FMSVpWekdmbXJqalUzcXRJckJDaWFCV3BTeFpDazRBdk0zaFRiVWZiei9COWNRTnpvNElVM0JNaEVnb2F1aUVaSzdFYW9xeXhoS2JWaGE5dEhIVGxVNm5WcVA4QWhIeXhXVDlBQnVJWHFCakt5eXRDQ3BNeXhFbFBoSXNZeHNleUU1K0RwWG9KYmVDeGhQeXhyYjl5MDhCbnlrZHpGV1RNcFp5eStEUG1DSFJzWXhqbElzdS9aREZMZFQ5K0ZsV0pRRkdvQWNPMXRCR01ORG9mZm85U3Jjb0VwUWFHWGN2TGgrVUZZZlM2Z09QMktCQVpIOFIyVVRsZDhRQytobURON1ZzaStXRDJ6aEJzRnlCV1F2SkxCV1JKMW9hS09iS2dPd21qRVZMaVY5UW15MXdzZzdoMzBpQXIwN0o2Rm1vOUwzOVBJK21ETkgyRXhhZGtGb2J5cHZBSWxDYzhrWVZxYXZpTVlLeEFJRXdKZm1PbFloWG80bHZVS0NNbHd0bFZMVjVyVVhDVzZsN3AxWUE3VWxyN2N6U01WS1laV3BOd09WUkVaNnI0aDJWcGQrNEpaQkpaeUVFZ0RsQUFPREhrdUE0Qkl2Z0JCWEYydUNyWVBrMXFNSXFBdVdSOEZ3U3l4MHd4b3dSMzBJRGIxNTJvS3pUbEJ0TGp4MTRiM1NpVWtCNXhlY0l4SXFNZnN4ZHlKOHJReEFVYzJMYWc2UHpNTVNwb01hVEtqQzQrUGNNaFprYzFDQ2FDY3h4ck1CS3I1WERML1pta0NLQlZvOXpETnZpWjBEbUpwL0ZtRTRDcndBY3N1ejJOWEFPRnVMY3U5UVJLTTFvaGhwV3hBZVdvMmJjSWFLYVFCUVRsRHFKaXZzbGpPV0ZiNmdOYUpRYkVXdFg2SWV2eURBSHhvQi9NWXNsTUUzQUdUazB0Um1HQXE2QUNaaXJjR0kwdzdkY0s0QmF4WnU5U2dZQmludVJkSFcrN29qVTZVOTlvZEwybUVYMWlUamE3MHJhQ2JKRlowV0xZaklRaDdJbzNlK3FjZk9IM2lOcDR4NGV3WGZNQ0Z5TU1mdFF2MktlbVpwb0ZjSWN4eUFNVm11c1E2cjNHaWV5WlVaZ1hhTDc0bGl3S1o5UnI0SENOcDgrQ3VibHVNbmcxdEVUaGRVSkMySHdLZ1dMNk5jMzdKbEcyQjliQVR0d1pHTEdyNVhsTzlUam9nZnVhUzEwbFZrSllSMDJxb2paWXNYRnRIMFdvSDVsQWt0QUJhdWEzeVhLbDMxY2pYK2RneE04T1ZTZFc2UHZHUVJVbkJsQysyQVREVUVzSElrdnFhN0I1THIwWk9JY2xydk55ZU8yakRoUHBvMkg4c3dtUmo1WEVRMVhKSEhnVE11T1JOWHlibFpQQzBFbDh4bEhBVHZFeWFxNXVKWUJUWkRGd0NXVmE4MUNtTWpBR3BVTks1ZXZCaE44d3NUNUVTcmlyaWVGUk5HVXhWN1o0RDRhWVZEVys4M1p0ZVdZeDVNTHdjanp3VTNFeXdJNGJudWppWEwyTEJESyszS0NKaHVXUnhlSjRZQWE3UHhoWWs0cXdFakJSYlp5SXJVSTFBSmh3TUJZWFlOK1JBSFM5bERFeGZRNVZ0dHBBM0wrWmFvSWVQNERwUEF3L3pCYm9YdXBub1RHQ1Q0amJYWG9sRk5FMzNvc2xKaXFsN1FVYm96S09WRTVJMm9NY1Y3RWNMN0toWlZHQXFuT0RGUkhQUHBCRFJmY0Q0NHpvNjVXSURyRjNRdFdaYzRYL0FDeGszYTlFS3R2Y1RLdytmMEZteWdTRkZ2SVI3MjF6aitJbHhZUkhick9aQmZmNENqd01RV0NPRHYyaVdSb0VTaVc5TzZHdWFTMDNYRTM3ZWM4RnlXUkticy9Jc0o3WXhDTHNSOWpwVFJvVTVKd3dnREhqK0k4TnljSUJjNzQ2d01JaUlteURWSkptNnhNR29lNFF0Qmk0N1NxTnl2WkxITWdSc1pXb3d4d3JrSjFwNFBjQVh4VmhGQ0JNVVJMZ3RSQzdSMUVLRkhwMUZVMFBnakJ6VHl5NU9zcnRscS8raUdpMlhsbTBCUjBuSzhyTWtGUGoyeFVCK2dRSmNUVWVOaTlTMVptQjJJelZaTzRDN1VhQ09vdkFBMVY0eU80YTdHSHMwVUN3aU54N2NhbTYrQVZqZDBKbHVBaXJ3YmFXREl3dDFRMEIrN29iZHloTnc4OGlPT0dzMUNKaE1qN2dOVnlSdUora0RER1VUQ2ZEc1oyUWRSOWJIaklrVWt6NjNEdGpoQjVLWVhqS2RPejRnVlluY3JZelhtTksxVnN6WmdHUGlJdHpwbGlLU0FqWEFwbmdSYzJISnhLdFdBTVZBb04wMUNYL0FLU0VoMW1JY2hMTytpQlFBamx6SjBUaUdVK1lSK1FhbFRjdDRDSjFwRmZ1Y3RyRDRzcWJ4elpjejc4NmtDN21ZRzc0bmRlSExNK2YrVXRKaWJHSmNRd3dibWJXN1ltQVhxSU5YbExzdEZRMUNhNXAwNmphTGJvZ3EvQ1RGdlpBdTBJTWZMU3YxTlRaSCt3Z1hBc2RnU2xjaFQ1RG53d1RKMFg5SWlzZnRBcUJPL3ZBaGZ4Q0xreDlsUWJoY01wVGcrWXBFWk9jQXE4TnhFTFhzekREYWJMTE5naUFFYU9lamN1ME43WmNQNVRYZmgwVG9qTWtkM2ljVkRwU1d2N1hSc1gxZENselVvMzF1N2c0SEprWUR4MFlBYlFwYmdhZHRTaVRGVmFmVEZMN2xySG0wOTBJMGlZcmlNOVRtMXlLM1JkZHlpUkNVbFZ2eTF2M0huVHZCbDR0dHZJT1k0bkJxMU5uV3d5YXNadlpMeFlkaWNRNmI5VkwwRzBCV0tlb0R4cW5CNjhjTU50VWMzb0padDR3bEdtMllFZTlRM0c1QjNCbnh3Z1dSSUtCSGwvUk5vK1JIV2dtWmZmaG9EVWhOL2pIY1Jnamdqc2E3QnlLOU9VTm4wK2NXZmFpTy9BOUlmOEFFYWhzdllRWW9zNzRoUXNRY0ZISjFSQ2dBc2hRU3h1Z3E0RDMwRmpwUjBDWGk4ZUtzcmlsVmJMTkZRbnJiNmlIY09lVEczUDlIN2VZK1BVRUY4YXJnL1BCTHVpRGxYelFkRE5mS3dNVzJUOGpIWEFINjljQ3IyRVBiMEx2VEFsZ0w0TVhRMkdqV0pFd3N0VlRGeXVMSEtuSGlpbnZPdkU4VkU0ZTJLVktTcjFxY2tlQTVGUkZ5RWR0eEs1d09KbC9mR2JmS1ZheVEzNDlrc0QrSWRKOXNzK0FsdDJJZ0ZnSXRpMWxwV0EwVmQ0YlVTbGlzVWJ1QXFGNVV1cFZsTTlTWEQxbjdseFRnYUw2Z0F4dWd2VWF3ODlXTTVPSW5xVkRVNVkwMnI0bXUreUVOVnF1cktRNmh5L1lUMFdOa2FCN0dOZkVVejR4bjdwZ2oxQXRPaU9YRGNZUGxWL2ZzYzgxVXplQVpIRGM3cmI2dnpYdDhMakJrZ2dpUHpPSWVJaWNxNWdQMVNXK1p5aGZEZmdmSGVXSUdJM2xnTDJQRmNHckkzTWxkVkNibUp5ZW12YkJ4NmNSYmlYNmRkL25Ja0lRL3Z6WEt5cHBLTXNZSFdlWUJDNnJKcnpoQXF4TTJHNmdJSEFyeFJVQzB4VWVBQ05YUTFDT1FEMERPaGluaDhpMDlwYjlISUpwUGRhdlV3enc2OGQvTEE3ZUloUUxSZWxEb0JSd2xqRjRpUW5Xem9YYVBURnRDY25YWkx5ZlNpaDk5a3JKQm9aMENDZ2ZEaHVNMnFad21HT3REbGxyajZzUlJBY01Ka3VLTFhnbDlZekZtQkN6RStvMkNub2pnT1RiR3l1QVFHcmlQQWFSYjVWVVlWRTU3UDhBWUpoNkoyU25CNXVjZE9iR0RuWHZwMmlxTkhhd3hVVnFRYmdKVk5HQW1yMFhkSmRUTGRZWmRLem9nVmJoVGdRUzJBOTVpcmJxVWJIcUwwS2Y0ZlV0UkdoSzRxanNZVDk5QTA4SmZKc2VHWGM0MVZhdnRmNmtRb2dXdWtJZWRoZkV1Rm9MVjRseTE1UkxhQThWUzJIVExER0hPa1NhU0IzWjhQNEtCbWxpVHFNWEZWYmJhak5LWDNHU0xuRXhLeW9wbHRlWVZRSUdkeXY2VEF1UEtXaGtsamZhTHZrSEQrSG1GRU9Ybm0wMzVUZFVoVnI4ZkdxQnNGTVRHZmhTWmp2SlJZUEwrTVFlb1ZsaG0wbzNwRjZBMjF3SEhjdC9BSUlJdlVtRTlEQzJDd05lV0VkN3ptQUp3WmpyNWtWbzdSaUxhbW1iWjJBbnpMa0JGQ05PVEN3Q05ML3ZtWVcrUDk4eWo3ei9BRXVBQS8xL21HU3ZxLzhBZG5JekdNLytZSDZHaVovM0FCMUthVDh6SHVNR1AvTWY5REgvQUpZQjF4Uy8zRkZET0QvdWhlLzFmdWY2NS9tZjY1L21ZLzhBYy9NLzM3L2NWVXRmZTVEZzQrVUlXa09SVm9vdlNValBHMkV2Y0lBa2JKVWJqTGVVTmZncEJNNFVhRjZLcWxsOWdzY0V4aGR0c0VBVGtsTU1rUFNtWVAyS2ZLRW56WFptTEplYTVNRjVodVo2SjZITVdvWmdhSVZBNEg3aWxXQzN6WkpRdkhBdTNpRFMweGxDV3lWcUdiYkw1b2dyTEVRQjZISXdmaUhWRnRKcnlXajhSZFlDa3hoR1Z3NW4zRXhpYXdjRGJOcHdldk5DK0VYRlV2aTRTclBBdkxTVXNpQ0xQRndmS25pVnhIYUJ1dVFWUWNvUXdJZnFWSGFjSGNQNm5HYXFiUHU0V2NnalZYUS9TT3BzMFVpSVZDV3pMVDRnTk9GR3F0Ym9BdFZsQ2c4aGliVGppaGJMcFB6R3paK1JLVHBhRHQvZEdWbGs1YUlTSHJnclp1ajRKUUx3SzRSSGp0K2psYm4xNGxjUG9OZm5FUVo0cE1OZUI5eW9WeEE0TTNDZ2pSQkN1cGdRcFA4QUNpU28rR0Zhb2hXMlZpOWtPNW1QbUVObDJQTlMzMm90eGJ0Ny9pMFEwbVlrRGZad2VNR3VMYnRXTUF5cHU0SytISy9Xa2dDMVZWekcrUUVZY0ZSWlJEeUNQbThFcUV2eU43SHlVVlhsVlJkN3dQbEhrV1BSSDVlaTdPbTVtMlQrT2puVy9wc3lNek9KVnh0T3JRS0hGTXd3Yk83eVA5K0F5S2s5RDhJTUM0VURrOFcrQ3kwYlJRRkpwVGZVWDAzRUZrZkppZmtTOGFtTVhvQ0Z3WU9LZ1hjTTV6ZWlYYnA2NGhiWmVoWWxpMjV5KzVlVU5lU21IekNvd1ZvOEpqNmt6M0ZWdkJsRVJWcTFEQlFsZlRUTnVRbW1pOFJHN2ZjTnd2cW5nTWltM3YyKzBBU3BCbjZpYXRaRHp4QmZ1QlorWmNiSGdKb0dGbGJjZ1BLMlh4UU9FYjAyZnFHL0NIQXFDN2FNUlZxc3NIYW9VQXNvdUM5Y3J0M1ZoVW9BY2dSYzhqODZXdUFVK2pNdTZrOVRIL21Kbnd0bGl4U1pqSEY3VUxzbWpzaVV3NHd3RFhieUZYYVVFcWV5WWJnRERudUZmTG9UMGV4TGpYVm9EOUFoV0JXNmMzVlpqR0MyS3NkRkpxRGt1YW52Q1RhZUFkekUyOXlYcHlFNElGMGNJTUM0bEpCRmRpeWU0bVdiMGlBT016M3hDYXZtZEFOcEJhWmpoeFdKMWRLVmxqMmh2NVo3bmI5K1pPZ0RiV1lFU1RaZWc1VktaRkw2VGx4ZUFBY0xCVlYrK1ZTMjhrYnJFMTJ3V3JxV0pQYXpLQVVjdzYzUlAxemZGMnNBU3lUYXp1VTRxU2pkV2pZcExGVU9DRVJiemlIb0RqVXVOcjhTeDIvL0FNbUZvcG1wczQwakNsVXR1TXhpT29hK01ZS0pJcFdZY2lEb2dua1dMbHJLREo3aGtZd2ZzZ3Z1dUNGSmM4aGlDd29vWG1LLy93QVJUWlBubWtJN0dWUi9sdXkxaU1GcWxydTFFMlIyL3dBMWVsYXNiWk5TNXozWkpUYXJWNVUzdUErUFh2RGM0WGt5UVpUTjJJeGhxQWxxckVtMldSTHVFV3BMVmg2Z3g2VStaY0hqS3pzTGJNaHdsaEhmL2p0QldLc3MyVWo5UTRUWDlkMzRKWDNCRDhpOFFldVZic1ZZTUZ1Zll3UitoWEY2UG9IYWJhaDNGUW9JaEVMVTJlVEtUUkNnc0VOdTFuN2pMMkpQaDhETUxiY3FwYTFvSUF4ZThUUm1QRmprUFVBM1B3emFKcy9rM1VPSGF0MjNqTE4rR29TYXNnQktHMlpXeEtnTnFER2lldGFDRGI5c3hRcHFjbVpTQWU4N3JpOWwwMTlpOFlVd0lJcXY1TXMvV3VxaEVMd0dRYlQ0ZFBTd3pXellXQUhSQnJiRE1RSzZtUllQQWFja0lRd3FvYkxCYjV0cmd0S0NFVWE5SDVuUzR3cXNBa05sTCtoN1FLWGdYektySzJRa0EvOEFCNWJiUG1ibENaaXBwVmhkakNlbENtVzk2Wm5vNEp5NVk0M1pPT3hOYUR4NGM4c1lwZ280djRzeUNGbVJBYWtiZHowY0Q3aE5TNjVZU0JzekxHWUNGc1FKTklBZXpnSlNoWHVxdGVnMXdjQ2psc1FLMUJIdlNDQ3lqdkJVNWlLVXF2ejhxcm9XMTZJckxGWHRoZHJRSHVvelhJbTdLZG5RMmd5ejNxK0JHbkgwcWtha3JpdUNHN09HaE1Oa0NqeFVHbjAxWko0N2tJdmtCaHl4NHRZR2JhSlpzWlBRYU5OWHlGbWdhOFlrSXgzeUxUN3VnRktzNEZxTzJjeXNCcnFHK2xnZFk5eVJTN25WYVZGc0tWcXdxOElVVmFkQjRqZXJYcUQySElYU0NvTGVlaGw1UkFwcGxodGx3bEYyWE1xMlNhRjc5cWllbm44Z3Jmc2dERWo1WmZ2RTMwcU9JMHJ6ZkNPOFV1dWxydVMrZjFHK3BEU01PZEZZUWNJaTFYdEFPVjZKbEtHYlRpNHZIWUlJWlB2amVDVGl3SEpCckd0SnJnM1dTR3dTTmtDMkswTmZvL01iQkEyUlZ1RklXN3ZVcnljSGdLSHE0dEFvN1d6aUp4M1BGMW9OUjVyZUF2RUNMSUR3cFVublhCdG5ERWl4R0RUUWJNclFRVnNuTFVHakJiWUFsdkhyL29FYzJ4WW5NeWVUd29MMW54U3NLN3VaTTBUaW90NHpjdk8wcTBDZ204TWFZT0djditwS0ttT2llTXhoQzhSUG9zcDRCcUxKd0ZVaFJpRnRMaDRDbnBkZzhLUUFEbVJnUEFmWGdZcEk4UHU0aXVZZzVCWk9RbEVnbVpPb0NOSEJtRU9SM1RESG56RTVzekN5dmJCYVRtRnpuTVZkenFDelJmeE5MSWR5MklEVThBTmNNd3pGeU0zTEpGUC9BTXBjdW9ZS2pzTHBncUsyZWorQ29HQTVRbG9OVGk0ZHJtNVFFMk9JWG1vcXN5NVlMTk9FSU9UL0FDVlRaUUZLVksyQ2ozRE1VWU5qYW9zMHdHaDZSLzFJMWhidzQ1N0pRMHlpNEVicFJNV0dvUW9sWllkbFd3c0pWeGFydHNUdlVZWFM1aWNjL1J4VTB6WCtMRFo4c0xVYUx3ek5HNUhnY0xNcG9jd0x5MTUwVjNMSkY5dTJrY3dxWXBIV3UxY0ZHMTlVVnBBaXh3K0g2d1p0VklYUlNqUnFBMHd6dWNjS1FJeCtSak5uZzZJTU9Hc080eHBsbWN2VlFiTk80SmRVRXZMZStSYVhzREFSWXJoZVJZS2Vic3JtWk8yS2lEaXlWZWFqVUUrZVFjVk9hdDlFUU5waXhibFZRaTdWWlZmUnF0VXM0TC9rakxJUFZ0VDEwZmtnY2tHVWgxSVhEUjhZSTFPcUxBYkU0Y1J3L1JBWnIrZkpTWmxVbzFzWDRVZlVjaFR5c1cxVmNtTFYwalk2eXk0WElGV09neTA4S3dvZUhWT3RYdGMxcVB2OEtaT0dUZGg3WFEySTZWY0JsNDBSdTREejhKdXF6dS80aHhiclM0ajZRSVcwY3R4VTlVbzA4NENCbTZyN290bE5HdXh0Sk9JQjdXRjlEQitJeGxJSmRqOGxGK3JabDZyUnpnN3lKWlFrT2dxdnZGODRXTVpIYU15dE1vMUF5dW9Rd1c5SWkyM3d2NkJZK0xvWWFPVjZTL1ZDTFFIb3dHRVFpWlVOdWk5cTIvekRiK3dEb20yZG5wY3R2c2kyV0Z6bDJKQnlIcE5Kd3dJamtGY1FMajZqdGcva1dwWHhWTHlBdEJhaE1UTWhiS3dLQStCNFd5OXoyRVNOUW5DbWtCdElvMm9WMjhxZWwzQnVFVnFrNGJvTHNXa0dXb1VST0VzRytESzBWdGJHeFM5YmtTc2JuZkRFMXRhRjVVNU9UK05VUHVmL0FJbHNQTzlTQVdxNEFGaklkMnNxMXhWZHI2WWR5eFVKR3RRN2JMTE5xL0tjSzBNYjZFTCtlVzg0dlhBSFZBbG4yZndMWW11a08xTmN4Y2FFU0hTTWJnRkg4TWUzVVR0ajBWWkZBUmt2TlJlYVE4WDZnMkxBaFJpK1ZQa0JFTVhYenhaeXRmQUcvd0NHSGludWhLdmhsaVVQa3dKSWZKRmZscWtodFFlWTVpQlFML2lhalRHaWN3b1FVQ08wU3hMQ3czQW1IWUVKZDdKT2xDRFpEaW5zblRJa055eVdpMkhMQlZjV2QwOXU2ckx5M1JoQmUvVk5LN252cHFiNzcyaXdyMy9GNkRkT1NBME01TUVMZzFSTFA5bDRWZWtZbU9OYlp5aStrTDhwYUJpbDBwN0pVUjhmS1lQSHN3T2ZMY3dxbmliNC9XekE0bHR3QlFSM1ljZGFvK21VY0dpVmZJRGJPdFNxWkZia0VvTFFEVWhFeG8rU04wM2Q0bERFVVU5a2xlS3JoRXNscjU3SEhrRmhFdnBVZUdsNGxIbVh6QlIwekdrUUxWeTdoNUl1TlFXSnpXUGl5RldGTnZGMzlXajRWeXpLVmZUSzlFWWtOaVdTeUR2UzBYZGQyblR3U0RrcUlEQUdhdjhBZzdLdm1XVmlEOEFzYkp5NlpOVEp5NUtwZVVtR01WVmZlYVVBcTYzaTVTVDlLVzZjMHNidXhONGlUVnEwK1N4MDQzRERNWlZVQlRhb2xrTHZFdS9aRnNKU0F1TEhIQ3QveHBKVGJzdjdMRUpuR0tkcGVEWE1WREtMazZpdGlCRTFNcHQ5dkF5TFJjb1FGU1VBS1lXQzQ1UWg4NXY2cStyTUFOVnNEVXYyVXFLQ1VrUTlheFpCWkFXRHVzaUcwK3dBM0Z4dlM0bnpWeGF4SWl6emNtdUlJZWdDTERiblpQeUZpRUNtSXZHdDdsMVNzMXE0QVM1WXBCNUlJSm11SzdQM1FlZG1YRVNrOE1QVUcvQVJWM1BpaFo0emtOdlpCQ0tQM0JnbXNIVVN1NXNqb2E0T3A4UE1Id0pjbFZialgvOEFKNTFkbDIwQmswOVJ5UmsyUWxlYUxZT1hpY2Z1V1pZMjlFRVMvUkxldzdNTVpub1Q1L3pPb3BsbTYvbDgzTHZiK2pYOFIwWXV3MW02b013OWduNGthRlVjbzE1VmE5d2x2cEtDYkhuMGpjbTJETEN1bEZ2aDVDZ3RNMGgvRXJ5MXhxbC93aHdDUjUzZllnVzZwaFdKQTl0Q2hxalRDRmx2WGNNRGticUlwWXFKN1VOUFV0WnhlQ3lvTnEyUlZhN3RTZTJhaGh6Tko5TEVhM0h5ZThvTlpXWmRLV0wxcFczekNrb0F1VTJDbTJIWlpMVGVEemhzRmt2bFNFTnhnWFd0MDlCa0JtSGxSVEZ6WkZDdDJ2QksreHFNOUpGaEliWlNYQTJ6OU40NHlVQndXa3FHOXg2M0FLY2JRc1J5RndYQWpPYTAyUTFXSHZ3S0htcmpVTVlTelRkM1VzQ01LS0Z4L053dHMyV3oyZGEyZWczMk1IWDdZTldyMDFNcE9MWUIvSHNyMjRXOFBRNmQvaFNha2Z2NnN0RXZXUDZyUWxOdng5ZnhNQ2g1NlN5aGQ1cTVVVVdjWGhZVnhwdy9obnhhMGlsQWhFODE4Q0dmYWdOY2RqQS81MXkrcThEUnZvS0JDdUVRTWZranN2Y1BPdXBkY1lJdVQ0WGg3RE5SaFprNnE1eHVKU2VpSDBDSk9MeTV4aytCZ3huTzNDNGoybmp6U3MyVlcvSWw4MmVJaWF2V3JXK2c4RGtlR04rV1d4amp2QlZYb044d0liVEF0R1hQb2pKNVpmOEE0U3pGRzlKc0pwZlI5ajRQSEZENkFWdjkvRXdGOHU2VUFSSVN6TFh6YUVnaTNxbXBXdVBUZDBNLzNQVCtLYm5EVlBjK2JtbVZXNjlPcjlTaEtnWFROdXdOVlZvRkVKUFpBMXQ3b1gyRHNDWVJ2bXZpNVJ4emdVclFvRnBpMGNxck5pdUlWVEIzYURMRUJTcFNWYmllcTc5Wk15a3ZXNXlYWnVrU2h1SWx4OE9LTklhckZaa1d4R05oZDR4Wk1lbW1vM29TR3hsVlpoY1cxeU1FWTJvN3NDSjFYVlhRc1dIaFhaRk13Wm5mNERJUWVmWkxBQWY1c0h1bFRxTm5xeGgybFZxVmhCWlFKb3NFQ0RXOTYzbjM4Q01wWGZ4ZG9YK0ZEc3ROS0pxNEF1cFhDY0VvcmFQVGNmeFVzTDc0Q3BmQmtoVzdseEM3VjFXR3d6RUdHVElPb1hGNFIwalZWb0hPbkNtL2NwWVduUjVNQWpRMnByU0h5UWhoRExlTEEvUlVPN1NyWVFib1Y3aXJyQytGenp5SmVkTVRPM2NZUys5Ukkrd1lqR1lzY1ZhM0hTeUMxOFhLRTdlWGNwblJYQTFvc1pzNUdxNWhVYjJQYWpUamFmcTRaU0lhN2hkenZpNm1Hd09kMUsva3dFenRWUFRUSGo5T3N0Q1hud2gzdjVPTHBjKzUvcUJIODZnbWwrTjhKWTZRaUMxZjVwR21seVZ0SUlScVdxMTBQa2lWZ1ovUWdqbitPQTV0eDJnSDV0OVFuVnFETENaRW9WaEloUlJRQ3dHd0ZMSU9KN3F2UXkyMVpRdklUa0hjWUJ1a050ekRpQW9Lb2FhaUNhbEZzSXRHZVlNZzZzaG5uTHVEUEJIYXFQUEtuWUF0WDJ3bDFxSWZXRWNOdS9pVSt2aW81eStnNVlONExVdUROM3lWT2hsczdSSmdwMGh0OWpxd0JhaGFZdSszVzVyUlBSbDdSc25WdDZEc25HZlZndUFiUlQ1R3lIcTdRUjF4bTRtektuTVZMYWwyREdSRmMwZFFsa1dBZklJMHFMVEsyd3NIVWRUVXJZNGdBT1hUTkRnZnVVaUMwb2pqSjhLNEcvOEErVTVoUFVtbUJtby9mWUJjUWJRSXR0ZTRJVE8xWFppZkFKVXV4M0dWN1Q4M0Fwa2NFRFNOVFVPV25haTQxemdldjUrdEtxbFJTNnVDeUQxTStONjJpNUM5bHlsTk1Yb20zb1JZdm1XZzRUQmVGWEdSZDAybXBpQi9QVEg0Z0ZzQ29ackRDT09sRUxWMHQzbEtTdmp2VGtRRFpGaEtZQWZVVVVmMW1oYmwvaFNSRmJ0Rmxjc1hUS3JqbHRlZHZ5WXlLQmFwUm5iUmFLWFRnaGo2a3ZJZmRVS04zbnVEQjZibm8xUmFDcXJ4SExoRnQwUmNPZXppbW4xVVlaRysvWjJrdVdvYzkrd0RGczlDRVprMUN1NlN5TWJxQWExZGRaRkNoV1ZMQy9sSGRwWjEzYXRvWExFLzRYYUVkcm9vckxlaGphZWJXNlc0L1FaUTFhNEF3elIyVmNGdzdFNkd5UmlXZE40aW9Wd0M2RWJ0ZlZSeDBtS0RiMkNnWnE0QmhCMTNmc3FZbEo3TCtRallCNzBDY0YrK3hpVmpCQ1JFckVrVlNaMWNTdTZpek5jYWlwWktvRzJVK1lKbGhDQUJLanU3NVRZWkR1bzV0bE43L3BWTFp5dWlCNnkwQVdrSzJhRzRiYlNRYlpvQUlOb0Y5SDhGeHpiMG8zOURIclVUMlZUK2hrY0NOVnJocDlSU0pKT3BsTzJCM0JWODY5NWZTc1FLYlVjSmQwNFFRaTJ3akJxM1RNWDllVmViamFJamtYVXo1NXMrcDhhZmxMSXIxanNyWEYzckRUWkRvYUI5S1lodXcrOEkzN2xWV3ZrOFYvYXczZGY4T0k3VUFPTitsV0cwNlJBZXlNRGZWdHVRL1lFMi9CSEdlV244M2Y0NFFqMG5MQzZhdlRHNDZUUmQyWldHanhJbitnUVhaV2V1WFExY0hDWUZZK3VVRVhDV0lGcTVzZkx2Q05YTVNlcXhBTlh0WUhxdVN6TGJGWUJ6ZTFzU2ZXRzZRbTJ3dEIrZjRGcVZUU0VTTFdtZ3llUmlqdG9oQ3ptZC9sb2VveFJXTVREVWloV2lndktMSk11N3V2ZlI4KzdXUUtSSU1iUnNBQUFRZHFPcFduQWlOSm91RWlCZU9uNVdLMnhNSzdqTG42U3FwdUNVeHVUY2dmTVZRSm82d0ZXWmdWWnFBU2dXMnRyS2U1SlE1Q2xvMmhxWitIOUpOZXJOZXdFNHNkZXRwZldMeEFHTDV6ZCtsUVMzNk5JTEJiZ2lab2FPVm5WWTJUTUVGcFlIU3dPay9rRDJNM0FhcmFLbFd6V2tGNGJtV0R3SDkydURGSGdMb1NXMkFGVmdNRS90Ujl1aEZ6cFhER3Z2Y0dDN3dLa0ZjcCszME1hQmZ0eGpQRk8wZmJNbVRLc1hjZUprMlRjQXRWeVhkSDhNT2YzL0FFaktKL1FyQVZkWDBEb3NaNXRmdlRVc3J4dWpGT0g4SXBoa0IxbU9BL3RjckNPSERvWFFRWHVSOVB5QWtPTVhxT0FZYzVUU01ES1ZVZVk0aG5zQmIyYmdyaFloQWc5L28xODU3RExBSFRXMHVETFpqUHVadG0rMDk5QmN5RnV6Q01xSUJWMFU3L3VQcUNZZHNsZHNMUGhsaEVxZVVUTld2TXBvcTFkdFV1UmUrZ0xoTSs1WUJ0YUpVRHgvSStLbVkxR1ZtNHJLdTRld1RYSnhWYVBYQ0d5QkgwN0hRWmVOVFBoSVlQWlRQV0Z0ekhGRUtSWGUvTG9EU0MzR1RVRXdGLzRoRTdBNUhxWDFtenFvMUgwTXo0dFNmSi9CalpHeXBRQmNYdkUralZNTGJoSERCdWF1TE5Pbm1uY0tNMnZrckZ6Qm1kSTc2T0IrMmR3R1dLc2VuclFySnlhRHhiR3VWYy8wTFp5YlJHRUdOUXRadE9jVXZHdklEMFZLaXlqZ000V2VBeThWS1ZQMnYwQkNsSXVIQlVhbmxaQmFjMWNDTEt1NGp5bHQ5cUJaZ0NDN2RHK2s5cVZsbXJiSllKcWk3SGNVZnBsOWxZNUVkaXFOK09BYUFBS21UQ2hLb1A1eExaKzRYRFBEMUxRbnNJZDlKVlJUdndTeFJVSjZiOERPRkxsT1pTSURnN2g2aUZveHlUQ2kvaWxPNisvZmhMOUJkNnE0YkdXcXQ4R3hOdXFESGx5TkRYMUFNcXVBSVVVUmovMFhQZEVzY2lBcWZKUDNMUHFoeFF6TTBrUDRyUDFBUitmYjhpZmxQa29pWVFhUi9pRnQyVWhHdTFibFpCbHl4VkRJcHp2VUtXdEpaclIzQkpmbGFKUkF0WWRFdFN4clZZNEREa2h4Zk9ZKzZXNGl1M3d1U2I2KzFUV21WQzFXNG1xU21NVnVrV1ArWitWb3JvMlVqM0VteTYreDJBbWdZVU82R3ROK1NhRlZGUXd3WUNFcTJqRXpSUXo3R0xJUEpXMWFjUU9YTWtvMmRIaDBNTU14THZLZmVvU0pLTFJIRVVXNjFFQ0FNbVN3UURRQksvMzIvVS9naSsreTJzU2xQM2lISmQwVFUxNFJKYlh1NTBHUFQ4N3lzbmwyOWpNSmFBZVhJVDRRZEdIb1lXQjNXSXZ5b0FDdExFb0NpWVYrd1ZmekV3NUw5Q0lFK3ZrTUNtVzJZMkU2dXE2dVhaYUFuam9HaGxtb0VWUjdKY1owNFlGNnYzaWFsYXdKUDdrQy9EU1BZWkRKRTJ6WXoxVTF0S0tSTGhoVHJtdk5DMlV0WWVKVENvcVBFQmtaaWEzTDhLMXZaYXJHclFEM0JybXU5Mys5d3dkZHk0Mk5IRnRBWmhJenVhRlBWaGdocUtvdW40MWRpOHJIRkV0Wld5Mm1mYjR2THpkWVQ0NDBHK2l6REw4WHpLOXJxMlpsVldTSkNGdE9WY0VHZTVBVW5xWUlBWmx2bWVTNTdsU3JUSkZpMGVsRnBSd2lEYUtkbXQ1TStETUhxUTdNcmRGZlZrUVdwbUtQVmE0OFlvaXdhU0VFOTZ2QUJzQnBSTFJqMXpRNEc3UmF2S01ZNUdtRUc2dUZBKzBMaFNhYVh6WjdPR1pFSmZUUk5kbXJ4bzBNTCtBWEN4cFRpeUc1QmF6T3NmRGhXWHZ2NWZ6TUZWWUZzVExIdmVSUjd1SXRndXV6ZEtma1JydGIwaFN5TlFYZHFFckFiMnRsZG5jVUVxb3R2TDl3K2ludG1UaHBHY0ptYndOejBlMlphRDRHVkI3U3ZzZlZQQXdaaXVieHZ2OEF5amxvTjE5Ulg4SWk3RXhMd2RVQ2dsVnJncUFCMFlxOTNnamJuQUMxZEVKL2NLelFERXI3VE9DamhoK2srTTdHc2M4TU9yVVFOdjU2MDRraURUckRpMjNVVmlrQlVyTnM5USswTkNMTXlENVFUbXpVb0J1ZUpTRFUwOW5xNFV2WEI3N3BxeHNORnNnZ1I2b050eER5TWF4bkd3bUY3U1hpR1IxK0ZCQkdPU0tQZWZYM2tZWms1Unc5Qy9LT202TCtyQlJRdS9xU0IrRWdSM2V4a0t1QmR3YW9JUTlrYlYyQ2ROUlJEVHBTeGdyVUd3VkI4ZGt1bVFzOFB3U3RGaWxJMWpvWEEvREM3Y1NNVG5BQldTa3F1UmIrbkNUUlhBUlJGSjBLVnJJYU9RbEZTOVhJSmtPVzQyU29KUDJFZFYzYU9Qc1hmR29iZkpVVzRmZzJzMzVMV29xZEF5alJ2ZUhUOVN6OXFYZTl5UnZabHptSG9RNittRTZnR1ZSbFViR1poNjNQMzRGQVVnc0hTWmpuaERHRGFmNElGV0tjcUlDMml1VGlXNSt6ZUZFdkZWUXE0bEhDNENSYXdJdlFPWXY1c0M4YUJsSXYzWE9XdHVFR3BCY0Zya3RCaTJyQ2lGTE5IM2Q4ZWF3ck9JQ2Y5WW1CNGhtM1Nod09uUzZvaFEycGtVa3VJdVJtTjJaemx0SW1UV2t0aEMwY1g1dlIxMkhKRGlsRm1KNFlVUWovQU9wM2hoaWJDVTNFWnRNandMQzhLMkxiZ1VJUjUxWGt4bXFqaU44VmpML3pGWmpIQjYxd243alRLd2RBNXFJc0NxYlJGOXBEZXJ2cXIya3RSbUFxc3FzVjVCYjNFRXBCWTBSWEdGOWhFaFlSbnZ4d3JJb3M2UUg1S3FIdUFRVUlzSjRQM0ZhOWY0L2hsUDhBS3BFaU94SWxET3hzWldEUWFnMFpsaTVoMjJtN3lxdC9xVUFveGt0d3pWcmpNYXpMS3M2QUxFWFJFOGpvcGRHUHhMcUVFOTZ2QUJzQnBSTFJqMXpRNEc3UmF2S01aVmJjR3pRRlJHMldGUzR3UHlzTU5GU0cyNVFQeWJhaWFMMjNMSjVHWFc3M1ZGem10RGtacElaZ2dGR25MSDlrTU1TNmJHNjdpOE8xUWo1WTVUNDBRV21kMXRnTlVrSHRqS0trVm1NS1hvTWdMUWJnUW1BQ3pLaFVaakxvQ3BYZUtiWlJnMGRvSHB5RTdaalpWTTJ1TFhFQ3lYdUlsR3JnQStvTzJvY0Jna2FEQjFqUE9pb1MxRWk2VURWc3ppZ3IzRkRFNkxOVVJuZGtKcWpaVk1EUlJFRHhmSU5zd1lBb1ZDMkNnRm90WHNZeEM2RGZ1RWd5M2EzZTJieGRReEFlVHpDa3dqNHBaV2lFclhreFplaGkyQllJNGppQXJ5dzY1a2RTd1ZVUXRWQ05GRzZwbUdjNThrdm1zcXc3YXgyTFFTMldCYzRwMXYxK2JKSUFDZ01CL0hVUkN6Vll2cHJZUEg4a1krTWZaSW5CUlA4QUwvQzFRZVdBcEJEZWtCVXU0SUVoQjZsUyt4UWVCQTBXWnB2NklSdDBXUnBHOCtsTVZFZG9QelV2U2hINVJ6RHVJS0R3Z1BXR1BqTkZqWS9URUVYTnFWU3NuZUNCYU92MWVHTXBvMzFQNkRiS1JpOEZTSWpMNkZzZzh4enl3a0Y3Qkl1YlhtVjJrQ0paK05sVVdpcUZMRjR2djdhdnpSa3FRYllyWERtL1FnZ0xEelFseGpJdUpxZ3B6QXpQd0E4cFlZVzB2bVBrRlRTQTM1R1RraCttZ2oyamRGV0lNQThYMkNFOUJjME5BYmkycXN5QWJ3Z1BDZVZWWlNCOUtqZjZpK3hISzdCdERRRTB6S1NXMVdIRFFWaVlmUXowS3lqZ0VLZ3hWa3dHMUZmRnljeFBzYjFxaHcwbVM0cnZHbWJEQzNRcWwzTjVqWko5aFIreUVKWEV5dHN2TE13bExtWG96bmpOeEVwTzhwSGRzeUxHVUhTOVhxS1dobUc3UmpxVnVHd0FVNkNZRlRCTXhkU2xIRm5EQUF3K0hBbHJrRUdreFhBRlRIazMrRkNyUERFSkFwdzNiRTc1S24zRUdXd3F3QnVnQmZxRXU3TVpvOWVCeU5kQlhzZkNJR1J1TzFIS2w3ejNabXZqUW12THU3b2krVVRoSjByYWh3TjhRWFlBTDVKcjBJY3BFT0tSWEhPZEMrWVFub1BnU0JTWlVDUVY4dGg4MkdRckZaeHBSR2RKeEk1eGc5UU1sdWNJZ291b3lVRll5M29yWnFsTERuU2c1WXd0UWxhQUR3ZjFiRFFZbVNyNllYVFZpemJrM2RJS0s0eFdJdlpudERwdkZBVzZhaFBUeVJwVmZac3hHWkxDL3R6aldLQzdGczN0OXJFY2Q5NVZzd3V1dW5MSzdyRWdHNkZwdEo4dzduZ3NDN0xpMkI3SHdUK2t6QnJkVWxicWVoQy9OUmJaRWZlbnBTWXEwd3ZOeStnYytsT0dOSk1xcm9Sam80alJNWi9DWVdvZ3NPOUIwOVhkdnpVck56Q3hQUTZQcXlPUWR2Z1gyUDNZbUdaVTJPMWc3YnlCZ3ZZTVdtK0lENnB5aktVdGsyZ2d4bzZsUXdNNjhiMnl5ZEwrRkVYMHJTc3lLYkt4Ykkwc1VUT0RKK0tKWnlxQnZVMWV6bHNlTFJUUW5kK3E3UVIwNWpQYUY1dHNpbXlzV3lLaWZIamFEVzdEMEl3eXJqNlRiS1pGdTQveHp0VzEvaU4ybkZkR3ZuaUExMFk3d1FERkZIU3VLcmt1QnpualJkUXhLWmduQ1NvYmEzZW5FOW9aeU1tY0NEaFdRVTBoVU5YMVVJUTZCb3RnNzdxV1lzWElWeFZxS2poakNId0VyVHZpbVJWOExESjNnVXNDNEZTclJyMUNrS3E5Z1hpQjVZVXFvRDF1ZW1YaUlpZzJSdmc5UXJoY2U2NEtCOU5PQnNoRzUyQnhTS0d1dG03QVdLR2pGcE5EdzdGR0NvVFVZR0dEa1lmWEIvQUw4OHhVZ3FsV3h0bW5peGRmMnZBQjBKVWEyUTR3V3hscVlON0Z5VTV5UjNxdXppMXFiZ0IrZ2Y3UUFycWcxYUYxdzNYZmdVamxpSXd4QkJWaEZiRmFWSThkQVJWZU9NQ2dRRGV5K2RxR2lNSnF4YmVXcXVtbEpVMDFwY2hOcFYxN2Z0OHVJZk5SQllzMEVZQ1dRTlVEN1o1c1VZUnBZUW1vUlg1c1VOMzdsRDl4OG1BOG9Wak9sUHNLaDZSSWdVR3lCU3ZKcGgwTEtEWDRET2ZGSTdORkErQUFLb3dGbnFVdXNZelJwemZJNkxpQUNFdHhGbzRWZ256S3FnNmk5MGNZdE1YdmlQTUZqSnprNkpSTUVTYkVIZXZJcGRyeTN0VjJRcXNFeHZMZjRLV0tmNk0rNHQ1M0JmUS9nL3lxOWhTVlh1U3FRMEpudThiOFRCSjRWSFN3ZExpRDZhcS9rakpraURIdC9WdjRWZ1ZZdHhjbm1Gdnd5V1dCT2I1M1dTZEx4b2NWeldOZUlHUzNPRVFVWFVaS0NzVUx2YzRxSnJzNlFjdzR1TWxPTnVibGVyNGo5WGJGQkFhMlE1dHRFUGxSVUJ0eTRQMFFvQUZpSWU2M0xrNnRpcU4zREcyZVZ3dHZEZ2xZZjFyZDBFeFVEbVdtc1JzbTV4eSthSTFWRytFdURJcG5zSlVKVUFxMTBGMkFWOFdTc1AyTTIwSmV3SUZXVE0xbDdsOGh5Z3dCY2V2T3ZVQlh5ZFpocDBzbGoyRk5ZNGlKOUNDMVk2V0JESVNyYkFiRUtHZ2JvMk14NjF5QW15ck5TeTZ4Z0hvRmp0SnNyQ1pHdDVhaGM4cW1WL2N0a1NnbG82ZDl1R1k4bzRqWEFKZTVZQXBaaElyTVhGckFCQ2lCZk1vYjk5a2ZWanV0TUxYQXZQamhZaHVOVXhqY0J6ekhDOVZFVjVwOEIzcXZqQ29xb29YZENKWXBoZ3RpNUNydWhsN2JmNWF2ME14WDl6QVE5YVFGK0E4RC9pTFYxMFVQQ3VZeThDTXorL0diQkpyaVExclJibkxDclVtVy9BWVYxa0g0UkpFUWdhUjhzTTJ5M21DdHp0U3g3VEhlUEMwM0FSdFJ5dHZoV2F4VGhaWUhRSWJoc0Vpck1SMGJ0bEVIRlZzTmJqbUZKOXhaUVBhR0R6LytLMEFGbUdBU3VHN0wwd0ZLR2hjcmlMaTFpczBLcE1DdThTSEdPRkJFcmhNT0ZGRk1TTkg2SWhrc0kvaVFaWHA3ME5WZWtTNlZkVEpEOVlHQk1oU01WNkVMZkFVUDJBMXl3L21NbGF0VzNWYnlnUDRwMVJ5M05MVldIVVhLUVF1WWxNQ0laZDFReTRDeldoUVJKY2VMeU5WY1pHeHRMamhrNlFCM3g4c3FLVFNnN0ZyaVhINkxVV0N3c1VaY0gzRUt3WXRqRG5sNWRUSExQemdZS2F1Zi93QVVKNlN2K2xSRTlXT0hrcWQzaHN0OVhjY0VISUl4cm1PbWRyNEJZWHlUUnR2ZWR0dTE0cGNDTHdraEwyYkJaMWk0UUdVZlhpb0F5dlk5QkpUOHZTbHVLZmYySkgyUXFoN0h3REZDN25IbjRlWUFyTUxuaUFlR0JZSWdJY0JZM3M1UVJDMWVBTk02RC9Jc1VMYVNqVVBwbDBqTXhKZ3ZyU0Z4OURVQ0E1WVcvcVYvejhmVHBQY0QrVnJ0YVVDamVIQ1hMdWNIajBSOGtYbHVoSjVmSEQ3NTNHYmNLZFJZMUphbEhHTlNtd1VZWUhTY09BaXY5Q0FBZ2dLN0JkMUVOamZybFFCRERSRjBMU25RaEt3TFdJa052ZFdMZ1FnQURPMTdGMDhuQTFzcEVPYk1Sb2dVeWpKNDJyc1ZHOG1WeExDbnhEb1RJS1NES0JFZkxhZHFvYURTY0JaVzVXV2s3Y1ZSWWhRQ0lYVlBVR0RwVzkzUzdTSzJkYUxWMnhMamJpaHlncmxWOEZ4VXlNRzdYU1V5MzNjeGEwVmJMWXhCek8zL0FGd3p1Wmlyc3Z1dGpSQ1hnWUhzeWl4V0VNdmhSTVh6TlhUMFhTM29LampPU2hMbGF0bVF3UnEyVlRFcVd3NUJheGhOZVlFc0JUWDhVcC9hTkk4QzVkdHhtY2JtbHFiOVdGdlpHWUNwNHhITEMzMFFZU2pOUkx6c2E0SThBaFRtalZ3cFdVRmlMV0R5YzRFc3JLbThHaEF1b3F0N0U5cmJHNW9MQWxVRG15UDJILzRRRmVXZHNoUFlQeFFRSWF2anJHdmtiWlFxTkJieHZlYkY4a29JeU9oOXNPYWJ1bVdzSTcyajQ1ZjZyOWJLcjRJWTNKcU42WWZVbVYvSHpNM3N4Sjh1WjZpT3RiSW1qYTBqQnU1QkdreklicEI3WUhZTWk3Q1Q0bGhjMnh6QUZGWGVycEZxWUF5MmFLZmVpNHFHL1BmV3hwc0tLZXFuMS84QXB5VHhDRlBqL0QvK0tDSXpUVTlsRDdMaVpWNjVYc0NRbXhsbUNONXNnVDM5dFd3Ri9jTzdCWXFaVTJYRmQxK2tyV0dCcWhrc2krekRreHdPU0lOb2tKMmp3VVlZbklUU2NLVE9OeFJ0blpRWlNlRkc4ZUt5QU0xYTVpd0phM2tFVlY5MGNwSGx5dUk5ZTJsQ3FhaU92SW1tb29xaExpamtFR1Y2c3JRalpqRzZXZUZOaE1vL2NjYkdCb1dsY0VMY0pRdnVlbkZzVldpbFFGYU9JQytyY1RtVUlyQUk1K3FXcTM1UHJmQ0JlUzlNNHRrU0NmckVScHJ3WEVDWUI0ejNES2g1bGg3bTQrVk1BQXF2ZzRiU1BXWElxK2orT3JKcUNmSVIrL0pUWWhYZ1cvQWVHcG5ZNE1QNWJ5TUZLK2c3K3ZOYmVTUHV2ak53VlV3YkphUFAxRzNZS2lVcDRQMUMxM3Qya3BwUjZpRU5oNGxmYlgxS29jSWlPK2R6S3REMVh4Q0ZBd2VLVzBoaDZlYlIrZXhlaCtQR1BYRGNnUzE5RUh1b3pLam15cjZ3aW5iT1FDYTRRVENzcm9iMXhGU040Z1J5ekJ5VHZmQ2lkMlJTQ0xXUUc0cFVXeUJGYUFORGhqRzNWWkd6U2RjeWNTaUN5Nnl3MmVsZDdBYmZzZzFBVEh0clhmY0pYZWJ1QnErN1p3SEo1ZWVZYzFPV0NkdGh1NHdaaFlveHRWcVdZV0Zmc3lZNURoOTVKcytyMUNCNFNvZktsOHVsRGlGTWJKeGNYVFJST0xWRlVCZWNxQ2Fyd04wdDBkeEswQXNaWXluM3IxQ2dtQkk1QXJMamVQVXJSd0RSZTV5TDZTdXRFQmJiZUFuRFpYeDhtNjVVVDNrcDRnVWtwNGdWNlErbmptZDFFMUZIaFFtVmdQOEF3bTFxYUk2dWhIT2MrblcwdTFkc1d5eE1ySmQ0TmQyeTdnZGp0RFFhUEdYYUZnRmNwM0N4NEFDek1heEl5RkJWUmpBcnVKV0VCQzJ6ZFJTNS9JcXRSN3RpMUl2T0lMK29UUUVnTUtOM1hIU2RYS1hXMWVDNituRUJiSnVmKytKV3FIdVVsMXcxQU5tR1RsZkhDN2xaVnFoN0JRK1dLWVBLeC9QUjRJblZLQ0xqTEVHM0xIc3pNMHZiM1BlbDF5WjNFTGI2VGJPNXcyUTdrZmJqZnZGcldqL0RzNVNtOC9kbXIrcXg5dnd0OTZQdVI5dVB1UjlpTmR2UjhiV09DaGZFMlJYTGxsN1VvdUcxelgxeWZjcHYwMkFWWXYyaHQydFBsellvRjhaQ0tGYUMxd2czaTJYbENXOGhucm5BbndCeEZnZ3NUN1BSRlo1dW4rK1lmSWZZOUduaEdoN0lLVlRrYXlRVmJvQXc0em43U3NVZHF1WFB6QXM0SHlCM0ZHT3M3ekJGbm5XN2JYdlFlTXhGc2dBTzJXQURLdlBhNVlRSGtuQk5QYk52QmlXeDJobWJDSk4yZEgwOHVHRjBlTFJ6TGpiL0FLaTZDdzBJUDVUQjFHMUxPMmxDZnJQYlJaczFJdHVTa05lMGZhSGczemh0ZndnRmVzWVZhdmtKSm1GdHhWWldtVmE0UDJuUUJjWlpTWXh6RlNGVlgreXE5K2lQNXdaSi9ZRWpidkp5WUtLNDY0NXdHeWs0QkFoL1F0Vnc2SXIxR3F3TlhpK3dPbmR4RmtadlNWdVJmREFwaHArcFZQcXBXY1dzOTRySDVsQ2FQOTdmR1BKd1hyTGtwd1I2bkY1eThXMEx2RXFORnFLYzlURXlXSUJqMmdubUs1RitSMDF1OEhOM2pxb2tBM2tabHJrTnh2NlRveDk0RnByeXBrSDJtZFROZ1ZtZWZwOXhadldaKzNIMnBuY2gydVh0UmNLSFhYZCtFbFhpaWlhQjhuQjZRZ0ZmdTRZUHhHL3JaSHl6cmFnallSQ1JPbzFsdE80KzQ1R3ZnbzdhNmlUYzc0Q3F2Um9uVE1PV0ZXTWZUN3d0ekhEdmVnbGRYeWc3S0d3Q0tVRmxuNzcvQUE1aW9jSWdpMHhPUzBzZDJqTVYvV3ZKWFMzZEh0YWptbzVLWnNZYVBzTUpzMEFWdFFZdGxnbGdCYkFsRTllRmhBQktDNU9ad0dNN2x4cFM3cDVtRHVadmsrS2d3MTNBaGtZR0Jjb0pIZ1F2d0RBOXk5NWlZa0cyVXptdW93ZEd6K012L1hlLy9ocWwvd0N1NmY4QXhUQUg2SUczRUtKNmlLYXBnekhFdnlZRndObmdBWUxsK0JnVlNjN2VNNmdFVWwySmxqNEtacEdlOEp0WGZSQXVpYmoxa0paNmRIYVBwSENDdGNKaE9hWWU0QlNCZXBnYXp2aVByMkNZQ2lKSTlFRXEwc050N2xJVDAyQWdITW84b2d5NDV5S2pWVTVRcnJodFVOQXJUMDNCMmpGOThTZlNiTlZYMlVLajIwSStXNmlvOEZLdDBHeUNaOVdHNHFpRFdEQ0ZOeFFuSjdCcGRwTjhZREV1N21LbGNPS1FPUlRCQ0JubkhyRzVVYUMwR0ZaZW1HZEVNdGc0dXQ4NXhxZ0tFSTh3cVNXOUg1SUdoREI2RlJtcllJRGt2dUhwQlQyaTZGMm9ZdGd6RjJXQ3FQcHpLRjhpYnRXM3lCS0luaDNNUGg4MmR3ZUFWbGVIWEVhRzNxS2NQaUJEdjlqZ0gxbjZsYWE5c1hRL2JYcGdWRHVackhVQVFDYWdwbVN0QzI3QlFEdGk3TkhBSlBodVZGVFJFNkdRTDNnVVdBY0dmRU9OQ210Qlora3VxTUtIZksyRFQyck50RVJISUQvcy9NUGxMSDByWDZqQWVzVGMwNTRsdmJYTDRxNVVlYXpKKzBUWTMrMW5YclVOWmxKdUc1MEZ1RC91UG9FOVFoaTNLeWtlRVhxQzVuUEhRSTl5dmFDTnVHR3loc21JYnBMOGJCRVZ3OEpnVzU0eWlHRzRYTmFQY3hPVUMwNTFxTTUyaXZwNmp1aG5LeVFQblN5azVFTlNsVWRzUE9teHliZ21TR1ZxTzErckF0bFlHemtsdmpwc01MYktnTVQxS2dmOWpIWUhhd1ZRaTJZWXhPamM2bnJaQWphRzNxcStNR0VYeEFCRlVyU21lSm0yNXRFUmRsUmNISS9LVU9PQ0JmWjdEZGRmQSs2Sms5ZVJXbmxYbFdXamE2ZmNjb2wxd2pVd2lnRUFUTE0rMVQ5RWZvUmx0L09CN1pNQ1F4UUsySUtDb1lJRmhpd0RaTTNLWkphV1paeFl3dEhKRXhkNEJQWnhHMFpETTJPK015MlNhSHd4MnQrL0t2VlNnaGFydXhZcFBSeG16a3o4d0pMYWpjc29KWUo2NitpMHFQUGVJNGxmaVNRTlhJV3BkWlRFVUZKc09pOUY3UTkxMnV2Ti93RE1TbzBPU0MrS3psbXRyajh0ZU5RbVcyMDk5M0Z0S0MybXNSV21Ga1IyWmZwR3UrbjZMV2ZLYUpvUXVQYnVDYWh0Z0FDL0FyenE0SS9nK1VIck81SFEvc0lsbEJNUmdCbGxtWU9zb3JzV1gzQVZHK0k1WWxKemZCS1EvcTNVUTVzMC93QmJxSzN0Yi96R1NGYXg4V3NDMVNud2NwTlhJeFFFRXJQQS93REpGd1AyRjFxSWxZVmVkVkQ2NzJpWGtwMnBpeEZFYXd3QlBOdXlyWTRDcmxIck8wY0RiTFNGQXBNMVFxOXFQcG1QMXVxQzdMQ1BXcFo1c1lPalFoYkJlRzBCOWZTQVZveWdwcE1YQ1F4MVl0QUlORnZvalVQMUVHb3dGc1lvaU5UZFNGYllVcmFsYkE0TDhzcVF2VERaYlJwVkN1ZzV0ekhwZmlPMEkxL2lFdmlXK1NWb01wOGt3V0tLTTVaeGJxUFVUZEpMeElZQzFHNzJoM0dzMkJoSWo3TXd3YzA4T0p6aS9TTy9lUzVDTlJ0OS9EUDlkNy8rR3FYL0FLN3Avd0RGTUFxMkk1TDhGVkRIK1lkbzVCeU1VRnN1SXBVRWZmOEFLb1RDRXJ5RDV3VE8wRmFvbHpVTGhnZDh3R0ZBYlVwWUp4c2dPR3JJSW8ycUc0elg2UXNIalVMSjF5eE0yZytxWGU5ZW9DM3RlRWgyYjhSYmNuMGx6VFJnVTBEM0tTWDB1b3N6bVdRdXg5b3QwbHRPVXpBR0VyVGNVNVF6ZGFQZEN4MWNFM0h0TlIwVUNQRnhoYjgxTTJUWUVPT29FeFRRZHBEamdyUmRSY2lGS1hCbnk5blpBWVBIaWVheVIwMWN2SmIyaGJxMWRXTk1DSlBxd3dwS1hMWEV1b2lBRlZLVURiemxyTWVNQUZkbTFsSFZPak5STTZ5MDZ2dEhDNnpSNEZtTHlnZ2dzRE13N3pyK2JrY3VaVllsY2VMUnZMQmhLUWdtQkxTdW9LekJob2RReThNVzZGRDk3THpWNXczWTFtNTZ2aEZwOHBwanJPZ3VaeTFRRGc1cEhDWXdzTTNWUytVRVcyZk1WQmpRVGpBZFEzM1VaS1laWVZod0VRNXRFVi9kdVg0TGFheE4yMjY5Y2ZERUs4ZldCZ1FzV21sWnJvNW5UdGdmaExnZVRDenBPckdKdnNrenI1WCtoaDgwQmNyOWM4RTZYNGw0VkgyaVZWcHlNd2NDMWh1TU05aURCcWloYkVkeXNJeFhaRjhPUEN4T2tqc1J5UzFaR2V3cFNCNHZiQTd1ZVZobVRoajFoRzFIWXdRQVJlNGFZeTFFUlJpZ2lXSXZnUzROVG5KZG91dy9ZVFhVby81eVUzVVVaM0drUnR1SUZxNmwxMWEyWmlCUTFPQUFBT0lhWXJuQmZkRy96REdqaUlZOWF1YlJaV2dyeERGSm81eldLdGlnWHpITXZXME8yeDhLZ2hJYXI2SUl5RHA0bWQ0dVgxUTRORStySWhoUk5DRlZSQzdtVXlPTnBJbGtKWk1CWG80OFZlcXJINHM4SkROa296Y2JnZWFQclJSQ2hSVnp3TnYxQzBxVkZsbzNIY1hZZXBSYUtjeDRRcXRRV2pwUzRKY2FyT2lIR2YwUzIxdmc0VXhZVG9TS3lPYXVkOTN5VEU2QU0wNzRKRWhOYzM4c3BCSEs0eXphSVlKdyt5TXgrTFlBYnp5cmFCZ2ZiY0Z1Z0NrMnRZaU9BMHdZeWxiVUtMU1c1ZnZXclJWVkVEYUZaUmUxb0kzZ3U5dVZXRU9XeENvOEpUNUFnVVBnbGthMi9DcGltYUNWUndhWGNLNlFKOGVWcmY2NGlVKzlQWnVFZldQS0cweVpwdURzWGREZFI5dXdqNVhQbWFvRkJxWWNPMENGb0RKbWRiYm1XbjlrTVZjMFJpV0xobDNDY1JaTHdSS2NrV2RlMGY1SmtDQzRodGR3cjE4TUdoR01PU3BjMnFoT1dObVlIZHFHQTN2Y3BMV1JTTEtHdnpIbGdDTzl1dmhpTE56RXJXckZ0SkgzdTJRaGF6ZURTNkdDbXdXRVh3RmhMWlh1NHFFRUJzQ21tRUc2d2FJaTAxd09qMzdtbndSVE5yUXZpLzhBVUFnR09ad1czVkd0bmJVOUxOaWNyMnZpbXJsbUV6RFlYbWJzZGM0eEtZNldQUWxXTHdZQ1dJSFVPVUdVRG9nT3RBdUVZY1JCS3Q3aEV6T0NKcTRvNU9TWkljTFNKOVBFQkV2a1MxMTFZNTFmd3Y4QTEzdi9BT0dxWC9ydW4vd1RBTVBYUHF3NVZlRk0rSkdjTmNOMEdFeW1YcTJPR29UcXgrWlc2anZIdkl0dG5KWDdtdVNHR0VJUW1UQkUrWFFKVmd6WmxCZnNpUHFZcVhhazJuSFFPV0FTdGNJRGlDeGJ1SnhVR2s5eER0UFNPcGpXblpaQm02VmxxUGFZT1VnbE4yNFdJVXhMUWNNVDZXMk1MUWVJN1Z5ckxOSStBYlZVMXBhZ0V5STBiUVVaTHN5aiswQVJ5TkpFMFZqSE5mRUNRYUpqY0tCZ0o2bG1pamt5bEx3NWpvRUM4cTBJdHN0N0xoTGpiTzNSTC9qTHVhN2VVN2dERFNiTWZsc0tvTG9hcy9iekhMalMra1l5NDlDMnBxMDFRSDY5Kzl4MlFUa0xlb2w1KzhBMHlGSTBoMlVFVUo0WmtCN0NGWi9oYllGMUZkWnZOU251S0p3YVlaZVdLOEZXSGZXWGh2YllZcEI4a1pFblppbDBBVmNJT0VUaUlYVm8wVlZ5V08veTVSMC85Wnd2NS9DUmVrclRUNHFZaG12L0FNUXJDcnFncGYzL0FFc3hmclZvZlRHL2ZFZXU2aW9BeXZiZ3lzMGlObGwyS3hlS0xoc1lsdjJMRGZwRllRQUZNOTIveWlwaTk2OGdMVjh5b3pKSHpwMVFPdG9aMEdCZ2dXNXV3ZzdXQW5SckdiTHhpazdYTWZ1cUZzQ3pHOUJvZkJ1b2xxRzBsYUlpOW81M3ZENUZWaWlja3ZRUVhlVGlZQVpuakdJQk1KUlR1bGtZWU9naTAwbDVlSGdNK2svcDVuTWFuRnVMbHBRTEUrR1Y5MXBuU20xYnE4QlVFTDZXd0tyUHRnR25oRWt1c1RUb0lRZFZjWTl5QlorU0dUbE9FU1dYVE03VXBabzRpMy9XTSsrWVJkeW01VlZWbGt5T2tsNXQvZ2pZRHBjeTJlV1lqcnplb1hLQkZkQzlRQlExeGNlQU9wTE5jQ3Z1WE9HY3c4ZlRaaHVrdnNsWFVkRUJNV3d6UHpOWXZkRlNqZFZUS3crVVl2UWpXRWpjU2htT2FMQzI2eXl4d2tlR0Q1OSs4eU5SWkl1SUN3OUJaN2kxTHF6TDF0QjdrZjhBT1h3a2hsZFVNaVk1WUhhRU1qYmI1YTdVeWxOZHBjcWRocm5TRExoZ2xFQkJ3Wkt5QzRGV1VnV25IUnhGUXI4VXQ5L2M5MkNXMVpnR3FqVE9Ra2RWaEVxNVFFZzVmZVg5R2lhNWtldjh5Z0lWRFJISnBZS1VuR1JpT1NHa3BEbHl4eUg4OXBlcTdScUdkVitTYWVQdFpuME5lc0V0Y3ZXV3ByeDl4SE9ESkd4TVJneERPWS9Vd1A4QWhENDhiM1NValJMZXBmc0Q4dzFDU3gwdlkvMmFZME5BcllXak9UcGpHaU5yS0M4MitSRG5Vd2xtZ1h5dUNNRzFjMUZOUVRER1c4cVgwU3JlWk0zRGR0VG1oS3FWaE41UTZsS0pVdzVYQTlnZUthMER3bjVVWkd6T2hiaWgzeXMwVzNNMjhxOHNLdnpKSEVXTGNCU29qZTBUS2lBeUVhaExFZE1zeVppb3RpTFdJTVRVQVlwQmtCU0pDVE1ZMldHUklQcUZ5c3VxaGRoek1RenpPWDRaZ0I4L3dKL3J2ZjhBOE5Vdi9YZFAvaW1BVlZoeG1JWTJ3Z0xFcFVTWWgyMmwwUVF0ZDJDT2duZ0pzS2NFejFldTdtTXc5dkJueGIrUlluWkZGV2tkYmRRbUhpcmltVytFWStaV3JuSWt0aFQ3d2c4MVViMHhmUE83RGlOdEVzb1VWWnhEQW90VnE0bFZXaW5KTjZpL1NMaTVkQzVSVnp6QnlxUWtSMmhXQWdGOVZ3RzJyQ05zY3BWNFEwVVd1WG5qME1CV3VFRE1BQW9LMEZEVEFiY3F6ZG50bTZ5RnNzUzNtb1JhSHhIb0luVjBTdW4yekNYcE1GNWlCNUZXazFiVTg0aGljcmFUakZjUHRDQlBvWUFlaVBVd1RPTjEzSExYNGdhT3BtVk9aZ3R2MUpnaWd5dDdIVVZYK1pwbGpUaFRUSFFLNllUaUJ4ME9KV0VsSGkrRjljNW95MTE0dUVmaE9jdmcyT1lhOU9yaWU2bkV3Y0REUlNDVDdWRUlZYmVSOHNiYTVmRXp4V3YyUHFMMTJqQitnYmx0KytVL252MU40S24zMWE3aUpjK25jR2orb1FxK3Fmc2NVWmZrbk8rc3J0aU0vbTRUdnJrMSszbCsyQmd3MkN5S2RMYkZEYmdXRWRKbXdZcXJlR0RkMUNEOGw0NFkyN0xsYytFZzhzeTNkd3V2aXhac1E1UEpZM1BZOVJWa1dZRjZKUnp5ajR4NUdNdmhsaTNWRFc1U3pleHd4dGtIVlY5Rmo5R1UzZERsMG5Mck56ajAwY2F4TlhWWlhuVEJDT1BtYlEwa3prVUdDVUJ1RG4weVI2cHhDMVVNQzF1eTNiaTVZNlZiOHdNN0pZaGVzaitvbHlNZmE1US9wdUdqb0JGSU9PZzdnUkRFSGVlV0x2RENOMHBobkhxOHNGWGxOd05BdGlGakZHV29HbmJNNnZiUDc5eHF3bEs0cm4yRU1TZ0w2anBHRFpYcVd5WXRNSHNJckJtNnR1Mkdpb0xFekdySURrZTU5aDUwRkNueU9IZjZEOE9jM2xvelZkUmMyeFhiRU5XT0RMS1NiQU5jS3pONzg1VGhSbW13VWR4WlhGWTUrcWJJaEFSV0ZYRktzeGpkMjhuNXFDQ3d1eHUxeitzUXFOcUN1TnVEM2xoR3FvZVp4Wk1QZmpFL2JMRzZ6S3RDSkxzVkdJQnZQaWJRa0VhOE5rQVhRNXNoUXRVQ29CaWdQak1xR1hrWGxOUDNCTWRyWEFsWFpWbXpjN3dZVVVYckc5U3QzWEE5UUtDQ25kaHF3M2hwaUtZVm00VUtWQkE5akRxdEVzMytJZTBNL0RXMWIxMWZyRnhQVFNTOU44bDVPbUpWd0dsa2NDOU5SaERsbkxLSFI4R1dCRkJJWVdqWlI1b0NEeE4xUVFyb3cyRkhwWElLUGk3ZnlyRVhIT2t6aU0vYktqZ0hLRjBPMWxWNnhLQjlzTk5qQlV6M0RyWWN3VjdQSXFBMDFMTDIyRmNsQjU3SS93Q2wxTDE3Z1Y5aDZpUjVFd0ZhQkUzMy9CUDlkNy8rR3FYL0FLN3Avd0RGTUE2aEF5dENKc0Z3VWk0UndHQmlVMnJmRTZSU3pQYzNLaTBTdVpVVGF2TXFWSHU2L0MwbEVpSFNTbmIzY1VJR1l1Y21XNmJRbFQyV3gzZndCQXh3WlJ5eHBCcWJ3WXBoblo1WTFkZUFNVXl3dmtXUEVNMkpZR1p5OEFIRU9TM0J1Y2JFU3VaeXBjQ0xseUxKWEVmRng3Q3JUN2gzcW1ZYzVDY1gxMlVORWFSbFBSTzZ1VlUrWHFQL0FDTXNYbkxxWHgvb0phQnQzTXlyZkVGdW5DSU02S25Eb2JpMUFwNWc5ZnRqS0d1VnFOVDdIWkdhNWVud2Z4SmVxWXVXREc5Z1drTFVJdzBpQ1FhV0l4bnA3Z0svYUx3M21NVFJjbmozTGhtTzhnbndJeDZ4aTErVU5mdU50M3hZL3dERFpmemY1a0o0OTBaK0xxVmNUMVFsMHY3bFNPUkR6NU5ybEE0RlExTVk4aStBdENjb1RtZTkrVk5raExWRklJRXhMdzA5em0yK0lhNXNJcllEM0YraDN2aGdVS3VtR2dKK2xNMThuajkrWXpGcE5NVnZsaEFsTGRZZUJEU2hiYXFVenI2NUgrNTZtZzRzWjBJRjVQeVEwQ0RYK05JTFZ2bUFLR0hSQU1zOVQxTTNMM1pSRTdTbmxqSFY0dEMwUjJCa21RYWlVYjE4c1JOV21HT0NMbWY5K3lDRXNDNEYyRDdtZkNFQ0xRQmdXM1RqN2xkZThFcWV5YjNHcWdCYUdCYkdZeGMzSzFVVWQwZElKQTNpdjNDVVFXUFErQXhIZGN0SHdncVZtam1UMUN6OWdiWTd1akFuOVI2bTRTS2FVTGRUS2NxTTFwc0dERXQwd3VidFliRDFLbVhGWERlUk1QTVVMV01wekNYUWFTdk5IZzVoQXFuU1ZtRWJRMnhUQW5Vc2JqbUtGUVZjTGFaa1cvbGN4Z0I3blpFTjBvSVJoQmR4UzdSYkpaV3Q0RGlkUVl6RXFCQURoenpLbUNsNlBFM0NpMDh4NmNuVEI5Z0N4WGlPcVdoaURabGFCbDl6U3Fjc1VidlBMM1Vad25GUWVpeGwzM1Axc0lHRThGYWNlMmxzY21YRHVMcFRDS1FHNDFxSVd4OEJadEJ4TkFOVERCSkZNR0ZaNG1RNitoWVE1SnFEZ1AzQ0ZhNXFvNmxyYWcrRFRLaE56TnpCckNxMnk3UU9FUVBMSDhHVC9YZS8vaHFsL3dDdTZmOEF4VEFPdjlHWWY3dHpURzhOTU1YVU9sYzByYmNOcGI0VU9LRC9BTWFQL1lJTkJwNmlwNElSUWN4S25paGJ5QmNWamdxV0s0VjF5ZFFTVE5WbHBFSlpjVVJOTVRaQ29hYnh6ZmJ6TWltRjRsKzR2RlN2dTZrZ1VCUkJZZGt4bEM4OE1yRlFPTGJRMHhMVFVLeDBJb2pTTGM1NXZxY3Z4bGpWMHRsN2dVMUFTK05jU1dIQWYzS0dLOUk2ZlRMRUxjQkN1SGY1NU5vdGJtS3NzWHNERmMwUmNVdlNSMVBxeXY0dUpaWmR3MjZ1WUFOaGgwV0Y3RUxnMm5UM0hKZGwybDU3SXg1bHNqRWhzbHFsT3lFM0IyUmdpc1N0bnc5UURVamxiKzJBQlZlRGtITndkYzFpdkl4eFZRSlNNb1VWQVU1cmlER0xoQWRqeE9BZmZqQ3Q0N20zOHFYVm50Zy9yNkpsRGtlN1VzUUhSSDFQeVN2Qy93QkVkMFBCT1lyd0pHSjVNcG9uOXg0N25NZit6M0RkYm5CK0kxY210bkJGdlI2Z2JOb0lQek9HazdodGFtSFdJK0U0d0JFUjd3UW1XNnVXYzdoVTllQTBxSVhEaVRoT29zMXdpWUZXUUJwZzBGSW5ET1VoaER3dTBURmZrSGNTQ2JQSFBodVZqY0J1cCtnU21YV2FpUk1rVVdWdGtXbE5HMFZNeFByWW9oU3NWN1ppbUY1RlFVQjY4SlJVTGR3M2o2UWtpTzJGY09QQXkzakkwUXRxQTFCUlJxaTRBZ2gwS0Mrb3Z0SmpCeUUrbWtPWWszWENXT3NZRzBvOWtkdXlLcmJhdmk5QXdKM3liZ2VGcUxoOWlYdkQ3WTVNYUJOMzlrSnlxTll5VzB3YWg4c3NYTXNpZVNBYm9IYlVVdGU0MGZVUkpuZE1RbDVOUnNNS1dUaEhUQU02UXhFVjAxY0pGQ29ldnhRbDhoQUxzOG41cGxxMHNrSnZyREc1cE1wVllNSEZRcWNUTUF0THlFWS9CT0pVMGppb2xGeVJkT1V3NkoweGtmOEFwanc2bFJndkQ4SWFyZG1Dc1MrbW5QZzZyL05QcC93ci9YZS8vaHFsL3dDdTZmOEF4VEFNdTN4VC9kOXk1OFdhZnFXSHpGSnZkSmVuaFFoWjd5b3hSOHAvNitmK3JtVi9Zbi92SVlLUUZVb0ZWUEdjSWJqdXpFYlpJZUdPWEhzZzRNQnBVbDhpMmZLTFNSOHIxcmR3N0pDSG1LdGNJTkEyTUNJb0xRMmlpRUhQOXgvN1dSREFYd2VNZGQvWksrNXoySlZIL2JEOGU0YW1yVXdBQUNxNGdPdnFKa01tZk9YenpBaldQbGxRT1dvQTZpRlFEVFFhU0U1cm1weElXczc4Rm1kczBwVnQ4RWJwbkh3TUVNWVJ5UlBYVDhNUW1BMCtLUEJCVStpYmpaUm5BV2tQZDBjUld3M0FqYlcvTE9xYUV5dkROekxLaGFTMXd4ZnJndEoxTjhGaFE4d2l1MzhLSndZeGVsalNFb3lRa0tubVBWVlREQWV5UjNFSlF4Nk1zZWs5UTVqeFRvUnBTeGdVV1BxSnFMeHNCZ2JjRWJTVWNzQTFDWlYxeTloN0plK3FTZ2RWR3ViL0FKUEdIelQvQUdmbUM1YW9ZNU5qNW9IdUtvaVU1RkdVOTRKZFBwRkFTMEVaemdmdVpGaGlCdEFhWkdjSDV3T2VsdFJxOUJvOHJDSjRxNDRXUng2RnNnb2lSalFwZ1NoWmVDOXBpQlEyZHl3d0o0Skw1Y1FRN0VFYnRhNnFORzVJUUlsWEpRRnBkTFlpaGZsR0x4WkJDK05vbDB2YkhPb1pZL1dERE1JekRNZVlaZFB4TmlqOFQzbmJoTUFSM0Jlb0wzQm9KK0prV3pQcWJ2NkNVV0Q0RUlaeGtqZWtxRUVRc1NOWmVoNm1ma2hCNXBTbGpMbDNzb292Sjd6RHBrRldBeTZtYWJlUzdqUWdvT2h4S1lOR2x3eHVrcHBSZUpUUUZkd3JKTGQ2SWhkdzlueExIS0czck03dERSQ29FOUJFQWI1TEJDcmpHQ1hhN0xJbVBPQjFIWGQ2WlJheHlWakVObk5yaUFtbzZXeGR1SVRHWFIzTWE0Z0pIcEI4VzNVZlNibUM4M2J6M0cxaHUxajB1VnBpd21xNDQwaGI5UlI4d1BxSlpEZ1NLaTZyR1NOTU1CVTVRT1pDMytOLy9YZS8vaHFsL3dDdTZmOEF4VEFLL3dDUVBEdEVmdG9WaTRFTnRrOEhQUWpiRmxLZXVDR2M4WFVMWmJxS0M2eGZqUDdpOVh3aS9uTXRMWmlEVEJpOWZKQ2xsWFJLbWNtbnVXM0dnamQ3ajRycUVCb3d4M1V3RjEwVUk2WlNXSEVBUzIvZ1dHYUZscXBqQUt1MjZDWGlNeTlYbW1OcGlrTnZTWHNuYWpQNWZmaHd2RTFDMXZjU3hJaE45RXZZb1JyOEpMMzBNRXhOclZSb1FZRXFNTXpCSXFINlU0OXpiWFRVTFIyY1FIVlVUZGFtNDFHMUMwNFl6V0dHdncrUXZ3NU9GNEpwQlhSRXFNaEJ6eXRDTmFiZERGVkxQN2kxTzlaek9TMjNlVUMwQkdaQXcxVWM4K2dqcEh4RUNVVDlUaXEvZ08xVGNYY2FPSlQzU01NeXZ1WEx4QnRReEtZODdTNURNdXVjVkwwRzY1aEVoZEdQcG9ncXRRNTJ4S3praDd0MnVGVU9Jb25rbE9JU0l2VDJWTUNxZjVqUHRiOVFhR2dKREJtejVKM05YelA5bjVtdVhRV1lsUWh1MGJmR0l2S2k1dmN4NFZqVkJVcVJadUdXNXlzYXhZSDl4WkFibmZ1RFZmQ3FlcHoyc3RpemlJL3lFems0SXdqbE90TXZyYkF4UjJhWlpiZkVvWEROM0t0cUphbjl6RU5QQVMvVFlqcjJCbkNSa1JCSDFuQkphR3czRmFmd0NwS0t5NWwyNXdnOGxXTnd6VUdrV2pxaDVDTFIwVC9lei9TK1FlcWVwejMvQU16L0FIc0tuK2NxMHA2bWFmRXFqREUyYzRsTVc2NWhOMFlUUGhINTJEOEtPbTlWRmtLdHRpNFJ1SXk0TGRSSGxzUnhTaDRadVhjK1ZYd0xKWklLcHdNelV5SDVoNG9CK1NEUkhiZjZpOXQ4UjFXY2dNWkJMME1rZm05bnVaaVdBeUV1Q0hKSGk4ZjE1Qm51SDduSjRWS0JheEJVRm1LNkRiQXA3MFM1SFl4Yk0vRnhDd0xHcVJCOU9KVFgyVmk4aG5GTG1EZGozak0rUFpLalVRd01RaXM1cCtrZ29ibFIycTV2K0tyL0FGM3YrT3JHR0krNG5uL1NkUEFYMWVZViszYjB0L0FyeGhGNHU1Tmw0bkQ0VUJ1QXBZOE5TdkVhb2JXRkNNeC9vaXM4TW9Eb2xCQ0dmajRsekt0SHhYNWx3ZmliQUpNbS9lL1VOeEw1WU11cmVuTUhFS21KYzV6ZmdwZ3gzNDZWTFRxMWxFb2hLb0xSbUMxUWlvRzI2M0IzYndDNTFBczFBS1BWa09xL0hPUXA4azVxZHpNR0cvVWFmU0U5bXlsbXV3d1MvcnVQUWFTbnhpVmZTQldNZ1lIWHFESUQyck1SS0wyK0pvaGJua25FWXhRYlFscitKTUZ6aEF5VkNYUmhJdmxsTUZNZUdHWWFzVmhpU0dtYVdLUGsvaEU5c3gxZW1hUmxQV1dXVEhwY0d5S2k5Q29ERjlGVzRXUUQySTQwK1JoSnFMQS8ydmtSdkpMSloxejhEMUVKTEsvZ0dtNVFmVml5Y3pqWGszRGY2NU1YUTU0SWZoUEVvVUhNRkdWZE53NUdYMm1SVG4rR3lXSzRaSTdCaE5oRGRJVEo3bEhuT0UweWliMU5MUDM1L3MvTTF3UkFYZVNWMzg0UER5UFUvWGhNUzhWQWFGNDVibWhiSUtaQkdCYlc4WmFBdTZJR205K2tCVXlqRWYxTnpYU0g1anJtdWhCV0dXSmdSVDFLRG5FREtVekFyRXlMVmU2bkRjWkJWZ1BCandYNHRlVkxUVmp4dVZyc05vTU81bDh3dnRMS2w4YVNBTHhkeXhZa0tOb21iZWFFNmZzbHRiZm1YN25zVHNDVDJKN0V1SnRjdSsvRnBXc1V4R1VDUUU3aWVZaXZnamlYUGNCQTZJY3Y0SnV5QUZRR2lLMFJWdnJxRlFjeHhmOEFCZWx6R2tuVE1mNkt6MCt6NElDclJDTnpseHlSZjNBbElHQVpOd29UZXg0dTRQRzNxT0l4ejR0cHpBRU5DS3poYTJEWnNOcGRDYVlEcUJXRllnTEQxWUxQUzNVSzBmS3l5Rnd6MUZxK0VncCt0M2NjZTBHekxaREFxMjR5MnIxd0pMRE5tVUpTdkVWRGZiUmhKMlYvZ1grdTkveDFXaTNuK3dBeEZnaUpoOFpjWHpldHhRbTlyNEdnMCtnNTdabU8vSDFjb1p5ZmdZb0YrL0VMOXZrekFqTFNxM3VOSUlDNy9PQXkzM0NtcmpoL3ZDYm10RmQyczh3WWEvVk1YOHdmMlZPR1lkNVg5eTBHQi9WUTBqNHI1SzhLbUFCaGY0bDNiSVlod0NNMmRTb1ZJM0Q2Y3NKN1F6R3RyRU9reHByaE1PNHk3MTd2VVZPY0VUVEpwdXJnT2tZcFNyQ0h1TlFOWW9tSFlQQUpLZDV6V0owZzNNUTZvZ3AwdG13V21ZMGFXeEt5UFVJdExnQzVHWVpjUnBYTjc2aUthVTVZMmR3S01oSHF5ZlVMREtnNHMwa0hyQ1pPdWtoZHRtRHdURGZickVSRmhjRytJNmN0RVMrZ1dHUmxteGF0bHlUbnhMYjBUd3daQVhncDRsZFVKbzdsbUxGRlVUU2ZTT3hjN2pzNTRBWkxnT1k1WXJHV0RLTERDUjJUUHQ2VHVDd1UrSXYzRW5Od1Zna3FVVERyREhxT09Jc1BwQzR1dGNFWGxNSFU1TjJnbDBVZjZGd0l1VkdYU21uY0phZldBeE1RT2JncThXTmNObjZuN1RITnpLamVwaXZpWG1ITUJvK2lNVnZ2a1FmZHhCSy9ETmVZVnlKaUZsK1lJNDF0UWowUWgyRERZRlhMQjlNeCtHYlBHTHBXSkw0a1pINGZFN21QQkVFbE51a2xKc2tCRHdXZUUrZzFPT0RKOHhrTU80UVB0REdtNVg4b2hjZ0tuL011VndITTFLZFhDSXp4VUplaEppemlzdUEwR1dGN0RuVVVJRko0cE1nNzZmditHRmRuMElxZTNjWS9KUlRIMFJWOVQ2TUphb3ZNdStjUis3ajZNcUU3aStzQjBlTDNDT0NKNU5zeStDQ3dXUGhoSVo1WHVJVzQyVkNwNlNPekN1ZVlIa2E1WTRGQ0wway9jTnhGTHRIKzR3cFZybVhudTR4RVhPdVlDQlJubzRnbWpsNThMWjA3cUEwVzgxMFJEcy9ETVJRd2c5VER6eWt6am14ZlNRZFdBdUJiZ054UFE5aTVZY0hobkxMcGZjSmdaOXY4ZFgrdTkveTFFWk5RM1JCZi9mVThlaFVIVGdJeXJsM3JmbHcrb05TSWFGb0dBOUhnbTQ2ZHdNL0cwL2krL3dCbjZoMm12K1lCVCs0TnFYRHhERjhRZ1F1TkFJZXJjeXJBK3F6RzJWelV4YkJwY1hZRHhadUYwSDFXWXMrM0cvbGlUVlNLUE9rbHo5Ty9EMTJnc3NMcldMbWNNVEVwb1F2S0VHbE9JQ2xpVlp1c3dWQTBIc1FXaDJBdFZIckdHZFZpb3hwQW45d1VrYnlkd1VQL0FBT1lHQ1ZyM0tQN0Vtb0Y5c1lna1NGMm0zTEtqMlprY0hiS0kzS05ZR3dnaENzWlk3SXJzSUY4UlRKUWx5REphcFpnaXZ2d0VXZzlJU2lWYmpEMXh6TXFNOXFKOTFUREVEbGpRRHJFUllSOHdSVjVyY3VzcEsxM0F0TU0rU0YrVFZBdklsNFptb2hJajl5VWFpY3dpYVhMTDNGeGJIeUExT1VzOXpoTFNwTlFpUUFMM0NvempCNDFGVWZpUXNHbk0xYUxmVVBDNk11WGMxcUpRc09ZcnA2cVkrbEZhR3FpeDIxek03T2N3WDlCTUFpa3JrSVpRenpHS1BzVEdBdW9lNzRpRnA0Y0V4dUdFdXRTbzNRUGdQeEdZazd4TlN3c1B3aFlDUFVCMEJQdm9obUJVenFGNXNZM0RFR2Q4RWJPMTRZakhMVEtzVEZjKzV2RURLNVNucEdwamxHQVpwbW9wWktUV2ZkbGxRd1loRmxDOHlFTStWUGJERWdIVjlSRmNCNGN3QjIvb2pUa3JybGhmWjd2MW05aXgrOGxkbWNTd3hQU1pVaWNFVXFkSm1vMXNqeE1La0ZnTDFOdndpN29MRFFNS3hBMlZ1OE1jQ285eFYzL0FPVXZkQTdtL1lEVVp2dlVhYmtOcFpGM3JNUFZ6U1FueEV4QktlU0ZaYlpQVW9HQjdJb0RnSVdnOXhBOUZWRklyYS93RGdLR2NmZUhxcytJRFM2ZFpEcDhWN3pPRVliclNKVE56UFp3U0ZDbGpBVFJYd3U0a2ZpL0hXaHEwWDFHbEhRc0VCZ1ppL3RlZWtWWGFxdzBNckh2d3ZFSGpCb3dscnlsSE9IbTVJcGk5d2lKVjlQY0laWld5Q0JvVS9wbFFNcFJ1TDY0aTJaWDJQeE1qZG03Z0syaXNpbm1RbGIzSmNmNWUvd1A5ZDcvQUphcTQ1VDVKeHg1VlBsTVhBYXZoYzhtOFhLcFA0VWtXanhEOTk3ZEhLUlpBRXV4VjlqYXJ5bC9nMXd4RnFXYndPS2dZYjNpTVRLcVAxSXBhRUZkeFZXS0hqZUdKbU1UaVZNSysyQlNwSW9PTFJXSmJ0UjBzcXArZUtUTXJORVVsdU5yQXJQUkwxTUZvUVJvZ3JjeFdYd09lMjhlNDRJbVUyUWRLOUVWM2ZGZ0d1cWVBNzBGZlRISndXSWd1RmNXTGV0SU9MWVYzbmhqc2lKdU8xakdQbWNMVWFjZVJOUlZ3VTRiSUorbk1aazNuMHY5RXltd1VVdjhTd2dBdWxZczZ2YkU3b1g2ajd0YytZQldnWUppQjZseUlielppcnNiZzM2RnJOV3VBbC8xMUZQSW9mSVhJUjRDMFVEQklpZTVWT2N0VFhBK3V6Qmx2SEFMTXU0bGpsVFd3NDMzRnkxdWN0WDlGNUlPREF0bVJOeTlINGU1V1dIblJ5L3dEd3htMVhqc1lZNXFWTkVIYkxjdUZnYlZqNVg0bm9QQVJUNVE4Q09MZWlVeHNETE9nMHRRYWRFWGpXMkFZVjJSSnJpTU1KY09rbDYvY1Ntd2lKTE9pMll4eGtabmZtMFJkUTFDczBjQ2NFOVBqQ2JBZFFhMG9Jc0F6TzlzNGpiTXR3VmpReEQrc1FNL2N4cElCZGxBeHhsaDVWUzdpbUpHQm5jdkQ3Z1JGaGlLSnc1aFhWZWlOcE5yS1FNTGRSbjljUFJGRUVDRkhiR1ZSUmUxU1FUSEVuajNoRlpRalRmR0ZTb0dhSkdnSXpTa0N4WGFnaHArR2tkdjdUUkcwcUw4U3B3eEN0N2FnbWJqUlUwQnllUGZ3ajkyU1k4cWVLMG1wR2Z1L3dBT2xrQWhVNFNWWWkzTVFZUWI0aUFPYnlROEJhd3czRHpTbk1OdlArb0F3Q1p1RUl3TFhFN2JPM21BZXpuSFhFMzVReE81QmN3UGUzeE8xOUl4aWlabUtPSzRUQWNoQzVDclpjdjJ5NEdIVVcyam00dDdtQnZvaWpKRHRHbkdhZUlDaG9TdTRMUzJwYS9aSGhoUm1XS2cra1RkL3ZURU5scGlsLzhBUDNORDRjc2FpZjJvTlRPYzlTcVBERHZWWmF3b2N6L2dna2kxa0hUUXI0UjhqaHhtQ0VPUHdnb0dEK0MxaW9XR05DMlBvSktQTEJUMzlIOEFqcmgyY0owbzUrT2F2M25GbHRRRGdYZ0hBb1A0dUJkc3pOOVFnZHBmNElaMkxSeldWdThBR29LV3AzMXc3SWV2OFF2cW54V0NFN0sxb1JJbzYzTEdLUVY2MHhVcVlGMFFLQUZzRDFMakYzZU9HNEE1cDNVdlpROFRSaGs1b0NqRmZJUTE1UXVHNkJSV0dvdXMyU3F5YVZqUXBzWTFWcWwxSEdXeHBBcCtGd0N1M2tvWHBBeVJiRlJVeGpoSzMzY0hrWDFjelhURUxmOEFnbnVpVGw4N1JFaE5xMzVPcUxsVXg5WU9GaytHV09zbDZDVmlGM0ZCL3NrUVVGakwxMlRobWFkckw4RFpEbVZxTGtzaVNtS3d3UmM1bSszblREbHd3UHFIRXRhNWFORUdLN3d0eEV3b3FBSHVOb29CdW1YclN1dmp4OVV1R0FwQ1BZTlQ1Z0ZscWM1Mzc4NlNIcU84NW5rcitEZE9WTEhEV0pTc2h2VXNrY1I0YzlFNW1VRlZ6T2xEcVo2UVNzQ2kxc2dWY3dMTUxDRzdZZXR3aHUvd1lBcFQ4d2Rza1dQNWpEQmE1SEVjOWlxSjdLK2ljY3dDdmdXc283V1l3UFBFTmpRSXlRTEgzTWh3Z3Nyd1hBbVh4a3VqSDRSalQrWDRoQXRVd2l3c29lNnd1Mk13Vis1YVQwc3BUeGRSYUpqa2hKdWJJZytzNkprbFg4SE1RSzhtamJNL0ZQN1k4RlNXcXE1NWwrUnBzd2tRanJYMHl6SE1PODlLY2tMdEZFaFdldUh0bUZaN1ZPUUtsNGpjaWJtSkRtMzl4ckloNWkycC9UQnprTTlyUDlSUDlBei9BR0RQOWd5eDV0TFFxdExpSXNvVDN2ekxFdHZiTDBySit5bGsvWGdSbHBKYXZnamFXdkVEengyU2dXOEVETXl4Qlc5amlKU1BzOFhNQjI0anQ4TVFXeWttMjN3UXhvSnFoWERHOVpRQXEwUTAvRllpRXBQQmFNczR6TUlMV2twZ1RNUDNHQ2hUTUE1Nm5hT3luRVFDckRNUHROSUpxQUxFQ093OEVPM3dOT0czN2dPcVRJbEI4NEh1QzRnOWlHaWoxQ2loOVc1bW9xYkhNQTNBSEpaZXJFY2ZobG1lVGYzQTVHMXJBam5OTnhDa0xNRjlsRUdiSWlHVUQzRmYvbWRZd1JvUEhjQTVSZFh0Q3UyeW0yTUJxaklZRHpTMkxyTVNwMjI3bDVxN2VvVmNsNVpHWEVVamtsallMcHJQSHpPMzBWdUFhMHFCQmZwdFBtVitwSEg0RmF4TzgvaWZzOVNrNVY2SlhvV0RBTkxtcmZpemtZZDhSSXRpcXVNU2l3ekpVekJsdjFiRUJGeUlYWEF4Q1YwTXpmS2h5amU3UGM0cENSUnk0c0xod3NxNEFXOTdIVDNIOE5hTFdEK3JyVnRXRTdsbGJZNWdQR05HK1VGMjhBWldXK0JFTldVZzVEcEJobG9pNFhWVXJ2MjRmd3gvV2w4QjdKaUJmYUZtZVNYalk4OXdkSWYweFFWdUNnVUNwMEl3Z0tkWmxnTnVZdkZVQzVmR2xoVXRUR2hya3lRWE5abzhWWEFkWHVPSzFaRkxGaUVzRjNKcGdJL2pZaklmYzlCY1EvQWkzWGV2TjVUamdsdTZFUXE3R05PTGxKdVUxendTNjdrMUZzRjl4VzRFekxwL0JhOXNOVFYrYXNpTjRTeVpGZXBhT3UwVEhCTDhiSkVDamUyRXR4RzZGMUxaaVlKWjJPYWlTcmlpN245THloY1hMZ3dRSTVlQTJNMUJnQkZYY0NPUVZPRlpqUU9tbVBGMWNkNkpSMm81K0laNFNmaWFIZ29nQVVUQmlOSHZuTmRRbnNVYzFBQ09kcnhLRnRrYmx3WW9XOU03SlR0NHVsbG5URkNmbUhMajJvZzgvWmlxcUt2Y1AxSjM0NWVUSE5SRGVCNTdJaEJncnkyTVl3MlBPWVpqUUJTYlJRd2hrOXhRV3F6Rk1HMmJtY1dycUlTV1dWRGZiUmRTb3lEV0dCdFJDMnpxQXFrQ3lja3RobStvSXhabFU1SE9vNHU1Z3c3UUJjY3BVaDU0RWZMUHpXQ0loU1FCWlZYQVJZMXAwMDZRdm02NGgveFAvWXdlOHJQMzBUai9BQTVCMndGOVM1bDVmL0JPQ253ald3VEdRSEVWUnY4QXJ3cXJOSjVIa3ZpMjJkRXNqSEZWVmJpeEwrUHllT01SaEI4ZVQ5VTVtTGZFWWVCL001bElQWkF2QnRaemhrWm5aV1VmdnQ2bGp0OUhFSG42bURnSjRHbGtJSUJNM3pMTUQ1VFBMY1JaSjhTanhwQU9IQWc1QW9KMk9OUXJoSjNOVDNLSWVJMCtvQ2dDM0g1Z1RRdnpCOU1jMVJ4UnI5NDR2MC8vQUpDeFlzVzlPblJZczZkT25Ucmw2TEZuUW1DNXcxTGxBdGd0Umo3TUxzYXZ5a0ZXS1p1bXBpTHFaMEE5MDd1QXVLTU9qdVlEbWRKZ3dZRW5EQnY4eWJsNzl3NVpWUVVBYm1IVTEwUTA2NUp0ak9tUTJpd2dHZlp6TS9EU0ZIQ2MxdU5yc1Ntc1FmQzJ3UytXM01uMFFTYkpXRGs4QXRBdHVpRXFoVWg4UnNLYTF6dUZ5eGUyWTNDWEMwSllMWmNUT3kreHlWR0N0MTJHTG50azVmQkJ5b2wyL3dER1FVRktGOU5uWFB4OGtWV0ZOZ0orNW1EK3M1eEwvRFY1ckZUZE1JeFBVN2VEQnhLRmZtQ1k1bGFqZXNZSWx3N25lQk1HbkVRdnU0UXhzc3RRdnNqeVlaM0xrWnFpR0lHWld3d0ZFV2dDS284N3FVdVA3WW9SZlJuSlpOTUlzREZ2VXZPd0tFT0dNdFF1Sm5xMGJZYThKeFhYaXhhaE1WL2tCS1M1UmNoR0Q3aWlMb0pkdG1Qc1phSWdqVy94NHhDNWlOWW5jSHJteDlRdG9XYWpLL00zWE9ndzNXNG5MQVNvcFNRbHNEd2tmbG9zMkFLdGZ1amEzb2hvczZQSTdkK1JqN2RPRDFPZFptbXdndkNQU21TQ3k3TVBOUkphckxTSzFRNEM0WFk4UjNGTlRtQ3pFdFVjNDBsTkc1aVl6TW5uVWRaeHpGbTR3RXdYeEJZWi9qRjQ4U0pLMWpma2J3QTZ5alphYllRZzlVaGFTeFA0SERpQUZoREQwRDFQUVB0QkZ6NGJqaTQ4b0xaR0w3ZjU4UkEvZmNrMFdsQ3FRVUhpRFlaZUxWeCtBVU9PQUlDd2lFcEFwbUc5WWFtY3d2YklWekpNcWZsTXRDVndxNjl5cTBOeUpkd29UYnROd0tvRGJOUDFNRmg0RmFlcW1Bdng2YWp2WXRjdzM4b0lac3FpVy82NFZlRDFxRVpac05yY3BkMjZSdklTOGJYYnJlakZ4T0tuZk5KUHlkNGZxY05YVEx5S1llY1JrN2hub0YwdnNyeTFjVmY0MHVmd2ZNSDFGcnJFN2NvbzZCN0FKbldDVHJGYUpDMHkwUXZkTEE0WW5TTXNNUXlRWXlJeG9scWE4a2pQMG1YVUVtNHJnTHdZckFGc2w5SHJPSTZnVjdKYWpmSk5FWHNTUnRwZUFvQ3NBMngrRDA2cTRvc3FoYlh2d0hxUWlBdlpBRnpMSTNrc3R6aVlxZW5tQ01rOFNoMldPa2syeEtOY1N6VGxsUXd3VllsRVFtbm4rQXRJd1JwU1lNK3lLbFcvRTF1enVLdEJDMEFBbGU5NFNuUzlWeEswYjFGTWI1VGM4VlR1Rll1cGZQckxsSkdtanpUKzl2aFRuSEExWUI3Q1NLbE1ndUpnVlphdjc4YXh2Nm55R0pWbGRoRVZhenEyZUVLR1NqNHdWZC9MQmhJTXl4TUxHbkpxQzZPZ3J3TzlqYk5zWmFROGZidXVHYUNYUE1vTWNENGFBVWYyQThMeHFLdjl5TUpHRERTdlp2UzB1dlcxbnRDTndqVlJob2lqRlVWVUZUcjZDT2dlYSs0d2VYTjRpL2pCc0FweEsrM3ZrekdFTm1EOWtXZXdkUmFpc0xmVTAvVkN6SDRoZWo1UVFhZmlWMTd3NHFKUi9YejZCWnkyQTRqUkhqejUybW04ZXhEeXNZeVdyTmd0Z0RLb3Y3UUp0ZVRDUGd3dXdpY1ZsNmJPVERUeEdmcFA0ZE80NUVTT1RkY0xoT1RSZE5YcUxaTFYrODh2R0JZRXlickRYUGNqK1M0dUJTaGxFRTB0WkE3dU13MWZ0M3dXcTZoV3FqTDdRdmJkdERsak9XUTlkdHFWZDZsei9LU1FkclB0WGg0Vk5LWEI5UmFWZ3I1WHdzYXVwVGNSdUZNWC9PczBncU4yM3VCblB6MUYvVWd1MjcydVhNUHl1bFlxSTRYMHNIaWZwMm4rRWY4QVV0ek5sUndWOVVDbzlBUyszUms5eW1OK1FSQmora3N0RUZVTEZkTXk0dlRTNVphaDJkZk5sdXQ4US84QURkc2w4YXJpRGJKcDlFWDdrazlDRkhMWURpQ3F1TU5aMmxXS2dCYUROTVg3QmJBR1ZSN0ZSUUpjbjZRTUF1bzlzZ09NUEQwd3FudTIvbHJ6dTRSUUQ1SnMzYzdUdWF1dFhIZWszK1RHY054anlHZzN0Vkd2RjBZeWJRZDl6ZGlqSzZoV05JUVZ1eUR0Z1BWU1NUcnVSY0lTeW55ODlTd0dsNGRVeGxoN1FFMk1hbUlDSU5PY1krRktaUmlMNTg4YzdYbjFOMElYTlZ1V3RSRnRvYmZlVjlzSUVNQnFDQWVpWmpKNW9WNkV4bFpieTcxZ3Rra3hUcC9iVmZJWk9YcEVMOVNmdjJIWmxyakJFMS9OWnV0OFFtNnZ3djZsNFZUTXkwa01ldjJZZ2MydjBkNU11cFZlckhYMG53L1JEWCs5RDB2bmNLZmQrbklkdzNLNDZaUGR3eDhFVmJrdlF1UkUyUTdKUmJEMXM5anJGK2ZlWXhSclVyTkU3STA1Zy9PbmczSFI4Rk1LMFdrSURTMlFjSXgzSFBEQlZLRUtPN01IUFdSZXVwNG5CdTVsbXNCRTFkcXhMZ0tCUmFLemdOWFVFcnBqdDlCMTRHaVdPSEE4aEtjd2ppK0NVTEF3NGhhamMwSmk0UlZMbW9RbXE0WVhHMFJHOG44SUpPSHJBWTE1SUE5a2FpNkdjL1MvdC9nQ3dWWDVLc3FISEFzcmo0UmxMdy9pdzNLb0E4UnZ2MjhFYWR3WUFWTk4vd0JwNEw2Z29YM0lkdFp6SEdWNjhDbVhLVy9DTnhxQmFTVVJPeDh0WjJNR3FzTDA2Q0xja3RxTmRBSEVBQmdGQUZyZ0NNekxZVE5WMkdZRUtxeXVsUVorRlJiMGlMeVMxUlc5WXNEaTBJRzkxdjVWOEJhZnd6UHYrdExRbGwvNitaZkRmTGludjNLYWdEdC9wbXk2NytUL0FLZ05LQzZPUGlZQ0NjSEhzZ09VS1g4ZitZalVBQjM1bWFORjRIYjh3NmlyWi9heXF1VndoUmJQTUE0endPdHFQaDRSZEtjNWsrTm9xQ3lJZ3VPdzBnVlZjejdyMzY0dFRoWVNlR0hUUjlOVW5Jd2FaNmZUM21vU1ZWZ1FGclhUNTdvRU1mMVRLcEdxaHJvMldZeHFJK1BISExsd2JhSmQ2YUJZVmgwenVXTFFyM1VCQXZaKzFxVmFBVVcwd3dpeXJQc3JOL05aNlAwVnJCaWY2UHJFQzB2WVo3VFFqQm4rTjk4MjNJdzJTYmR1enhoWVY1M3VRbms5TS84QUFtOVNYb2djZVA0SlZSOXlaUXV0TFhTTksybkYyT0oweEVBWVprdkxoNG0wbGFDVjBmaWZWNDRpRXpmTnk3d3ZDNEN4VzV4YkZzdFZkTUJYVTVpdEdoeTU4V0c2dVpNRVdERnpCMjEwZnpyMmVibHdTZXRrckk3Yzh5aGxQWGhFZi9IWnRFenlyMGNFejhDWmthOHYzU3dNd2ErMVg5akNNYjVnMCtlN3A0YSsyLzBjVEk1MXZpT3dQYThKVU9qS2hwUlFoL1NBWHJWU3hDaktyR0pVVGtnQjJ2MmZEZ3lFbDcvRUtjOXFuNVA3dzNnQkhBdmRiVVF1VFBoalYveFk5dllQdVBFSGNUUGNFM2h0Z3RhdXVYOExnamRJejB3b3pHdlU3WXh5ZkE3WmtNNjBsRlZEMUxVSWw1bXpXbVArdzRoMGQ2dEhrNlpQYkxYdDF0VTJuSUhxQS9xV2wxUzBvbE9iVENsaGRzY2ZtWWM5U2VUZy9mRGQyQjVWVjhYTnFEeHViV2tXUHpIclRmc3hiN2pHOWdoSTJoemx5N0ZtWC9NN1creUZkWGQ2YWxyRGtHRkhmRGVXcUM2Wkd4OWJJT1BhaXdTWEFpSEFoeGF3aGRMTU9yb0JkRXkrcWN5STF0VisxOEg5cjA4YTNoQk9UcSs3U3ZxNEhZM3J4VC9JSlAwbDVWekhDZkFCMkQ2aXFMMytOcjhTQlliejBWKzJaOG4rMzROdlg3U0EzcFFidE5sbllwTENOWGFMelZzVEJFUTRVS0ZHMnU0VkM5RDZoRUx2RE9ocytRcFQ5VExGejdvc3ZYTjdabHY5QVdOb2JVMFlncjBvb3ZFOVdLbk5vdDhXVldmeFhGWmRsK2NjL2ZIWHRncTZ1RmhLdEJWMWxMV0hKS1VIVzJtU3dXSXMyT3FncXoyMElJUXNCU1lPQ3NSTCtPR0pnUjFaZm1EQWJxYTRWOUlEMFJuYWNrd2FLNXVEdktsYlpnNnRGL0JEVDFBeTBVKzJwVWtoOVFvU01OZmVOdjVGZmk4VnhrWWg3cWNzRit3VXI4YmZRNXZaVzFlMjRkSGpaVmZzU0tZemtTZEx4ZGoyZzB3UHo5RWd0bkM2Umhqbys1MmtvbnZlclVSSFl6RzVxRWhtQWFXTEc5TlFaSy9qQVVFN25MZXhVcm1Kd1JJK2kzNWZnOFVoa2pEaVN6czV6ekd2dkU0WTN0SnhGTVM2L3AxTUE2aUp0NEZUbWxMbmlsUjVpNFBqNmdsTGF2U0szQ29naGc2akZTL0NnZUltNHhlWXJiRzRuSkVzdjFRa2VmTUl6czgrSDliUmhPakhtZnFSNWhIZldyRmNoZ0JUdVRtZGkrOU9Nc2p3U1N1Q0c0NTQyT00wWkhaN2VvQlZ4UThNTHZGWVFGNUo0VFowaEZhT29xTE1ReURRV01GVWFLUzhBTWNxVWVGcXVmRHpHSytVVFBLL0d3TDRGakdMN0M3RVg5MXhodk85SzVGSHRJL0dMUThtR1FPQ1A4Q3cxVDkrUldCYjFheUk0dW16Y1ZMUlJrMkVITlpjL3ZRU0JBUENwUU9mT3BpYUxyVnFGaXh1WUp1TWE4MkRmZFcrNjRPRUZJTExRR2VCVUtIU2ozK09WaDdFaWx0UVRPcXc3bGl4S2ZxVXdPOVR5cEppeFMzT0E4eEdVbFFKZ0kwNUNUb2pBLzdlazkzeWR4anJLZTc1aGlCQmhncXg4UjlRUUJjQnU1TEQxRGNsRytkK0QzRVVaUzVEdjNFY0NUQW01bUlHTE9kVGY3Q1l4ekZRUDVSQnREQVQ1WnRhVDh2bEkxL3BTbnYrN0xjNUI0WFhqeUVKdFliRDNIUTNTM3duT0JadWtZdGw0YWNBcjJ4YVVHRDI0RENDZkg4WTM1c3RsZ3pCMkJSeURUS0MxTXd0VzQ2NWkyUFRZNTU5RTNLRTBCRVVkeDRCdk1Fekc3a25hWmpkYmJHcnVRT3lBQkVGVmdvckxGY3hQb0JGVHhZd2x1bDh3dFo5UlVleGVTdjBDRTdaYVUzYWdxbDdFcHgvRUlibDkwNUlEaUJoWXk1cDBUTTR0WDFBZ0RlVEFDcHFiWXZyb3ZVRFlmWkRsd2U1NkNVTTlxbEcvd0FpZTErR2YrVkJ0ZmtRMEhIckw4ekdMeWRzWDBnalZjM25FWmgxY1N3bk8vditoWm5YY2NOeVZyaEw0aUozOGVtLzNNbTZZNmp2Mkc1UWoyTUYxN1JiN0MrSmpnZVhkOExpcWd5WXptQkhMaWJHdG5oWlNkVnNtS3BQWmQ0eE5qd3lVNVJ5ck1RN2xkV2d3RHRaUlltbGg1Y29KbFRPb3BXcWNsanpGdnBqR3FHVWdPY0JIT0VVelViSGFlNDhGK1R2c0kxQXpDVVF1UHJ3QU9HOWpUOE0rbWZTWGVwbkl2Y0hNYWNRaUR5RDR5SlY4a1Z4U2N3MUxGMmVVSUZjMSt0a0N0bGRRNnpkTUo5R1YyMC9qTkdIRnc1c0d1NWF5M0ZaMjErNUlkcG56MjZuc3ovV1dUZXZRcEpZZTdDb1IvZzQ5TkovQ2d6NklWandTUjVwYUs0QnRiaDJ2WHU2djlFREtFTk9nQlhDU29pZzBxTC9BQURsQ0d0MStpTFBtMGNRNmVtRUE5V1o1SXlxalM3TFFUb0FZeDdQbGRLYjlYSk5CbnJUUFlvSmZxR1hDdTlFZG5HbkNyQnZRcDZCMGRQSDNyQksrNGxVTC9xck50Q0YrRjhLZWt6bWYzUjhHSmdMYUw3SUJVdCtiVDlRR01OcVZWeGhjV0pwNGg1RnJpWVRvbXZSbDA3bjArZ3ZpUHNIQzc0YU1FcEVDRjFsYlp1di93REswRXpVbHpuNXNDL293KzNtVXFVeWd5Z3ZVcHFXMDZ6aHJLenc0Y2hpRnZtRC9Ca0xSRFpaZjI4UHVkNzRtaGM0YytLTXA3emVQZzh0dEh0Q3kyZDQwSkRrNEhXWENYVkFyc2hBb3RDem9MNGhaSzYzT2hmZUQvT0VxaTY3ZFJpdU10Q2VaZndvejArL2RGeGVyQjlXbTdDNnQ1bS9GNXU2RTdXVC9iOStDYU9IQjhzVHpRcWwvd0EyV3ZVQitmbzdQbTh1TDEvamxrd0srdUZnUWdVdjBNRnY5SUJoWDNGdW1mQkROSHVabE1DMVQwRXV1WndkZUtteUNWR0taWWZvT1pUa1NETlZiMUd1RzRGV3c0WmlsZXRENEdZdTVTUHVvYUJoOHk4NStQbUUxOFozSnFSTUFGYk9jdXhTckZ6Z29HZGlWeVpPWk9Ib3Fhbit2NzhYVnpZMk1zK1l1ZWx4VnArRlpDZ2J1YUEzUzMwdWovNHlENFA5cDNoNDN0NHB2M2dlTThlNzMzNGY4bGhwRjMvMWZmaXFSZ3ZXckxmMVJnY25IekIvUnZnUno3aElsZW9tM2F6YXRkZmY4YXN0MjMvMDlKaXlySDkrdlVVR2hiQ2Y0aFFicVlUL0FCS3BMWHYvQU41Z1lObXVMeDh6R2krNzlYT3B3aUxUMVd4UDNYcVpMZE5mOVVKYnMvd1IxaWdJdHF5b0hWZmNRcGF4aEF0Si9Fa3RJMXY2dlB2bDMrSWJselU0SWcvWCtRQnZ6WmIvQU5yMW40M2h6WnJndUhzQjV2eWZ6VSt4VDlNL2QrTEpwZVNXcXFUMFlzZVptR3A2dUVNRkI3NFp4WmVpSzlMMlpnNmIrSERQWFRjWHNSbXVaU3NoUGFRV0FEczNMU3ZnWnRNMndQSXZjcDdqY2d3aGN2dHVJU1dtWDE0b2cxRE5VYm01MTVZZ2tRbDNFWVRXYkVvRGFLTjBucmkwUUFzYXlpRHROa2JWeUtHcmoxc2NncEdEYmFTZ1FjL3prMHZya0hBV0txVWhvVXRuaUsrbGwzcTcwTjRRamNnWjVKaUxWdENFU2c2eE4xZGdKRGtZc3pRdXJSY01sOGZ6V3Z4Ri9tWEZhTFp3NVRNcUhGM0JINTBBQmhwQlpmUkdwZlI4cGswdHQwQ3BXNkJXMTFvdXRtVXhHTnc0WEVLOVhDMTErQXY4eTQydVFYd2tLR3RMYnFFTm5zSW13eWFnR2JNRjN4cE92YXdHVlVzRTBlME9rdnNRbGVrNVFSMDM0TU1VdmdqZkowelg0NHdoRjBFd3BxSFBNb1JHSkhTU1hreDhnZ2U4U3EyVjlpTC9BR1J5M1E0Q0ZlL2NJZnlFamczSDlvSDdaY2hyczYvcEpHb1pPc2l0OHFIQjhUcm44QkhlZVkyY2h2RXM2aHhockM1NEtXcTJiZksyc0daSXhPQlNPRVE5YWh4WFJzbHFYZWtOK1ZhOEVURTc1OG9VNGlZK2YrOXo0UlBscXYxV1RiY2RzNFZuU1FqaGdSVW9oVXRsZlRaZ0IrWWdUZGVlVnVNUEViN2lFUEpPYzlGUlZjRzI1cTBteVF4cmYrMzVLSDdsdlNsOEpTM2s1SXQ5eHM4aEQ5U2srWFBRbC9wRVhqZ1I4Q0sreC9PeVlaeC9zVS9iQW85bzdYK21sRDZXbS9WTEM0Ty8yUXVUVU5tR2JxWjdWMW5xVG1GeEc3MklmMndLem9YOHRFbjhjUUsvUXJEb3VMSjZhNHdiYjg5SUQrMG9JRjhacENEWmZPdXkvaU44cExqcFp2eXo5S1liV2p1a1AwUWxUazdHRDJzc2NDSkl1QTNoQ0l2UGgycXRkUi9pWisxVEd5RUo0WjJjMHY0VHhFMGwvd0JkM0dEVjloZjhaU3Q2ZUF2bXZWa2w5aVB4WnJaQytWaEpIS2x2MEFCYmdRZkR5dk44RGpzejArdHhoOWhDRGhKUUJmcEdKWDF2aENLYTlRQlJ0OFI3THZiTnJ2cndOZUxncU9CWmN0djlVNmRFeGJnaXBkRFQ3amVmRDNBWFBFeStqK1lkYlhsL3EzdUZ6eDhPQjNHY3NSbkpEeWxicUl3Q3J3VEl4bWUxdkkyWjV4YUZKZ3hjTDVoTXZGT0VLUXV1ZGxxTEdIZ1orQnZld1p6VFNJb2tPeE50VkFxK291MWhKUVZWY3UrREFkTzVtUnI0UnJJOEZxdTFWOEcrTmx0aW1Kc3ZEcUMrSkcwNnRkVUN0TUhkMDlTeXV4Tnd1MjVZY3JCMWUyV3BZZXVrdWk2eDJCNFI3QnErQndQdk1EdjA3ZDlVM2NFZm50VXlHWmp1RU1pZ2hpYkpWZDAycXFYWWpYY2wrcnZRY0EyOXRPVjVVTWQyOVlhWXhPNU9iNDJrcE1HNDJpeXpKVlN1VjZRekx1QmJsWVdMT1J4NHVod1UzTE5WZ1RmR3BiREs2bkQvQUY4SWJienF1bnFaSkJvT0lJaFRZRGlaQW1sb2RBa3lOamJTZW00Z3hWOExuMUxzMW9YcTlreTg3V3lHNjg5cUtieWFsMXFXdmV3M0VFYk9wWkdXTDRJZmh2NU1ERGtUanNSei9jZFBHdEZxTGFoUFBUOEQ0OHY2dkw4ekwxeE1VMEg5ZitCbXkzL28rdm1xYlErc2Y3K2I4bmZXZ1g4S2ZxUDNza3JQekt5VEhoVm9paTFUWUErRVdleE9VOHlvbVZ3d0VCS0RRYnZVcTRXOWFHQ01lRklTd1RtclBGNmo4WXRkUmVJeXh4Z2hFS0pTTGxVakE0dHhBTGpKNlBNczRZajQ0cVpRam9zZUtFNjNtWGcxQVdIR3ZoT3E3bVlJVEdmKzFrbzlXVmpyZnNndlc3UHBnRmFtSTZyL0FGaGFySkZIR0VNUi9yaEtQQ3FzaHhBMkdvTHBsallMbUNxYjJ0MmVIajVZVUZoU01KNHduMDlJY3FwcS93Q0dYR0RiYnlpZldQQkNKR0Z5dDJZOS93QXlYK1FKODJmVEMvc2VINXM3QVNPSXRzOFN2YmFMZ2JIZ0lnUGtXOHRRNWx1VjRqNTFJT3pEQVJhckd6aHJBamx5cnA4NFh4NEFVQ2taMkhCSFZ0ZHU0b3RDRDRmcU81Ykxvb0ZOcXdabElXSHIydUNZU3hlRE1kR2VJTzhSVFFTa2xxN0s0eFBYYjJVbXhUN0VDQ21xcnR5a1JUUkVhb1hwcUpYYUFzZUp4ZmJWVG1ldFFCb1VmNW5SZjNDN05mdjM2aURjbEkyZzFVL1BIWXNyVC95bWZKekEyT2lDb3JocDhLVXhuRFBKWHlrSjNZMXEzUUEraUlvODA5V0FBeXUyemJtS3FIVWU3bG8vVEc0WmZvNVBHYStGaEJYKzhZZFQ0RmNGWXFKOFNrL3lVWG9BeE4zSTNqTzBHdkZidXRBQnlMUEdCYi9HbVp3amx5TWpFV3lkcUJWZUFXTEdTemZ4bUJSdXFTaEUyRXhmVkZOKzBneXpXZGVqd3YxSU5YV0ZGMkFuYjRsL29DYXdlKzFnSlNNR3hIUEdwMDdUdFNOSGt2c0xnckZWMjVTTE9YUWF3WHBxSlhhQVVsUlduMytwT1hyVUUxejdiejdWZTRYMGVlRElBZXBCQ2ZIaXd4Q1VwVUhPYUljRjRNWE1tcllNS1kyVjk3WDZMUmVLaStlYWgvaCtURDFCcFJHRmRHZWFkSElaaE9neXBsOGRkbUx5OEpDelBGcGNXTlhQUXpwTUhkN0Y1b3d2TjhFMEc5aGJRWXFJR3U5bHhnR0c3MmpMOURUQ3lYUDUvc2lDcXpZa3BhUVJvVkFiV0s2VkI5dnFkRXJQb2diNWdJbnBGRHY4S3YzbkpXakRsS2M4K25oZnFRZE5mWWxDRm5iNGxNYmJPQkl0ZDlMbjVIemZBZ3NSZmFEMFpDZUJ3aUh3Q1JRaFFCTGhyTUJDM2xXRHVVdjBZZ3lrSHpjUmdHcWdjTDRnZFNXcWkyRzNIQW5KQTY0OE12cE5nRzgxeENhNzJyVzVGTFdLN0I4SHVlcXpHNitENEZUeEhyd3lrWi9DcFVhVitrMFFZQ1dwcURiQTRhSVpuNHBxL0RPdEhMTzNjbWNhdVpFTDRNVGYvd0N2SWY3VHYvOEFqeFQvQUhwQktOdG4yNmdHaWdLbitJWU5Zd2xJN3RYdnY0aGh4dVdyeXBlemE0aVdMN1RtNEV4Nll3bnhCVi9NdU9BK3orNERNeEFYUnpIalplV1dha0UzL2xjdXNNOTFlNXFsWE9TZ3hJL05NZ01DQ3JsSnlPdGNrR2ljaUc0QkIwd3U0R2pETmNkaFA3TGVQTCtyeS9NdHJZM3Ivd0NQMmdsZC93QzdWaHVvVDIydWtZZ2FWWGtXVzY3L0FBZURJUnVwVjlrVXpJRGNFSThxSTRQeG9FOUVFZVZ6TklubEM5V1dVKzErYlZ4Q3loZkxDWktNZ01Cb1ZGbkJZQm11T2RrVWYxUXg0Wkw2cWI5SXVzMU1VTVFRUVZ3eGhhK2VrdVhneEtGSXBZZU1xNkNBZzBvSlFyZnhpazJNVWZlSXhoM003YXhUUkNuY0ZRbU9ERkpsejh4eG4rK0ppM080ZGFwMmpDSGsxM0VEZXIvY0c3K3JnZ2xJQ2tEWlVMVlFqTGM1WmZxUXpVSlhXN1ozT3JaaGFYZ0lTL29FS3QzOVZmRHFTQStaL1dzeDQzaXRaUEh1RktlQjIwZVdON3lwb2Q0cks4R25rOG1GOXJZa1UvRCthZ0g0OFdpbjE5NE9XZTU0Zys1cWVsVXA0NDR2Zm1PUEovZkVQeDRyOUhzRkp4WVFIWUtZSGdKMFBVNHVINzI1NmVtaXpxZVBYaG9IQ1FDZW9MTzZ3Z3ZVT2c0Q08xZUNFbEd5UUV2RWFSbnpFMUtmeEN0bWV5Wk11ZDJXYjR5dC9RU1ZZYU9EdlJJeWFhR2c2Und4S2FOdEhkaVdiZmJwZytHb0NmU1hIMEFzcm1GeGU0WkpldUYzQUltVnRucUlHQ3ROcGl5QzJvVkJISW9rSDVoS044ZkhoOFZ4VnorWWYzUkI1dXE3VmN1cGd1RCtlaS9tRERCNE4rWTlxaExRNEZnM0dtd0NoUVd0Y3ZnbWt0TDltRDFTaUM1VGpKTmRuZ1g0VjRQV2dDZ0dBRG9uN1Z6K2dJeGJMOXNHd3JtY0llcGhXSGJGcHZmNENFalFGVnVYMFNWN3lQRDBqaGlRY1ZoSGRpV0hNMGdWQVR0WjhRcUJzNGxrT1FsS29pVUhNZHMrVm81NDI1aENMQ3VJcWo3ZXpWaUdEemdDZ0hBQnFCMGZCZytnczBJNlFmQUJESTFBY0ZrMHg3WXJpM09GNlk3aThIRGRBWmVjRjBDc2FnTEdDS21BL1h5d0FqSG1iMktiQ1J6T0NBVGhBQ05Ob1RDd3dVQWVCOGwrTXc3SDNzYjdxd1BBOENHNHpxNDRJbVh1SEFZZVlsSHN5c0pyQVkrd0tJM1NuazRZTmI3Z2E2N0V4cmpobC93QzA4WmdMVEN3N1g0Z0swUjl4Yk1RVytSN2xQWll6bW82SlcyaDQ0WmVobDBPNWluL0FPc1Evd0JwMy84QXgvNlBwTGhyNUFsRXFVVTNCcnVqZ1loV3d6S0dGSzdtVUI1U0FOTmt6RUk4c0dVSU1CWDl6UGZsblBjV0xGUzMzamZHQWpmQmNKdzNiZzhpNFZuR2drWHVobkRoUE5MMm1OZ0pSdzBlUkI3WW9WZ3Yxd2pBckJNcGFScUd0Sksxa2loa1FOUUduSVdOQzMzVU9SUG1HaW9VNEV1bnRzRmpUbTZyR1hBMmpvRlJLUkFKeDA1KzE2L2VCOXVSZzRlc1AreHp1cjBBQks2MTN5bHVOeXdqU2FsWm9Bb2hyVDRRS0NBeFFCdUtaSStiL1I1S2d4Z0FVWldUWEhtanVBaExRRWxMdGRIUmNLemxFWkt4QTVsa2dIWXc2K0dJL3dETjJKRFUrRWdNSndWZXpMYk1MVVhRQ3pGN0o1dDRHRzdJMXJMTmNUSHErWUhrVVN4OUpOWWxLYnNpTVp3dzNrc0xOa2pBUFp5aVFNNS9YYnlsQ2RJdGFtSGNHWGNmeE9VMWtteCtrVkR3Zm1VZ0dYaXBpZ25aS0g0dW9TK1c5c2J0YVkwQ2FpcHJnTWJZcUFYckI5RGZWMjVMY2pjRFNNQmdRT2lsd0FBQVlDRjE3YVFMdzJDYldQTVArdUlKOG1RV2prOE9uYW1ndkEyR29sVWczOUwwV1V6M3lCZ2ZEUHM2K1Yyb0RvUk5zcGlVQW9EZ1piWHJjM3p3d1lEeVJxVjA1V0E4V2NSc1hUSFJjSzV6M3luQzQ4QUtvMXJMV05GZFhoMHJGajNiYnU1ZXJvdWdDSVJSNnpVVUVwd1BKRkg2YkZZdDhNVUFzdWxGWnQ3eCtDYmlzb0N4b3FpUDhTdGwwTXNvSGRpSTl3bUdQZTVRSHczbEJjS3BEblNSdmRqWkwrQUViMUQrZmlZRDNJcHZpWmV5WHdFTURNNWs2c0hYRFdHREtrZmlOY1kvZEpSd0VpTldYY1ZCQzhEZVdZV09xMnpHdHRoK2IvS2ZwUTNFSFNRMXFocUJlNkpVTzJvM2lnbW9sdE9QRlc0VkxBODdpRWJMMHZUMDFVenpnNmY1cmFGUS93Q1A1WUZSUUJ3UlFjZU5NRTRRVERVMVlLNHQ0a2NZaURDdHBwUWo4aDZtVlgrWmRtL0Q2aHRMcDE1S3AyWWxDa1N5NG5xRHQ5ZCtGS0U3aTlaTndmR2hjZGxuQ0FxcktFTHlrNFpsNDNNWmR4elJYWTVuRnl2YzA1YzdzV0k3NWwzSFdaVFVFUmgwbC9SNWRMM0JtZEFOekg2ektvSHNzcHpVQXBtM0VDQUE1SWdJcEs3em5QS0dJbk5EUHo0YVJzSEVkWnJvNm1PcWwrR3JjNWViY3NUcXd2Skp3SXIvQU1XQjNGVkkvaFVhdWVhWXUwYkx0KzREaThLMDY4ZTNSdFR1dG4xcU02UmZGdDB4ancwMnd4cy9hd0xpSUlrTWZHVk95Y04ybFZMNG5yMHVqVXpwd2VHNzI5TTczenVPOFczU0hVdHh1T211MmxiL0FPZnh1MjM2L1AyRnV3MEZYRWtKVmVCMHpZa2ZwOFdvbU00cUUxanN1WldsWmQ2Z0w3RU5XdU0zZ200TkVYYk1OTHh5Z3VGT0llOUE2Sm5VNVNtN0FtUUJJQUlpUmxycUcvV0kvSVppSEl2L0FLV3M3UUI2WUJnUHo4SEZDOW9sZlNsTld5WDFWT080QU04ekZYWDh5Zm9tRCtOU085NWZJbGI5S2lNbFo1TURJNUpuMzJDZi9WdFMxZmFuZkpVZWdFZVdhb1RKWnFyNmlHZG5mdGIrR2FHelJ0OVU3MytNOWwxZ3phR1U1VmxjcXNjWlZPWjNjbnRaU3RkZnVwaTk1QURQL1lURmRObXJtZkFhY2pGMjFlNll5akVxRVZSeVlZMnNLTnZBQnNqRGJkL1VUOGMxbURMdjM1cndNdUpqdEZ5d09YaytZcWFVem5mZ2E4RWlzN3I0Qy8wQ04wcGp1YlpXd1VONGplc0h4SDlWUS9CS2RzTmM3U3lScEJMTitHdjZWQWZjWUptSkVzZkpPbGtQTDQ4OW1vNTNGZHhJL3dBRzJjak5EY3JaYnRTV2JlQ2MyNStxakVqT2lOWWFXZGhKaHZTMW5zdCtrbk1ydTdPMlc2R1lDeEJVQmZRUS93QW5GQks0Y3l5WFpUT01mbU1xSXpINXZtWmVuL0tGT0l4VGptbHplTWx6TTArbDNNK2lRM3JPU0NWSVdYVHJxTVd3MnBsRnpLWUd6ZllaMzhGa1FYN0lPeVlhdmVDWk9WN0poYXpjTk43akVHR3lMbGprWTdSMERpS1JZYWZOMnozY2RJSE5OcnM5eGdSVFJZKyt2NXExUE0rZmlmditoWnhFcUFjekRVZkkvZ0FWTERlc2VETXc3NlhHVmE4QmxHRE1JSVpidUhqRUJyUVg2aGcwUzFwZnZKVWV1cHJnd2t5bDhFSEUxdVN2RFMwQ1RFdUhSRVVpVWt1Ym1Xbkt3Qm5nbTZXUmNIU1Q4anlKUmNHT3MvSWx6T256RnRlQkZ2dldNWjIrSUJNM3dkeDM4WWlhcEFwUTlYQ0Z3VHY1bU5jV2d5c0ZVcllFN3VWclNSaS9vUkJSR2ZLbXNuSjNMSytiRGVKWWpGeGZ4Q0FxbjVURTROUmxxYlhqTXFoZmtRaEJmVE1oQUc0UmNjSkRlV3JoTDJiZXlFRGRPU05YMWpNc0h4YzRTYklNNXVMNGlLWFppVXZZcUhoTVplWkZCSEFtbTBpWG5HRUJhRExNUmN0ZW9xVWN2VXpmZ0dNSHdJQ2pWTXZETUZaNUNBQmlFbDRMZVNiRTJETnh6UEJ0eE1sdUk5UUtidVpSV1RJeitrVnN4Nml6NnlEbS9PNEtxWWlwd0JONkRVR2VrUUwyaVBEM0M5UzE1WXRaZzZKZmo2VDNCUmp3cndvQkRBYStGUUF4djA1MWxueTlIMUhlOFNyOGRKN1BndHU0cmJPb0N4K1psK0dFSWZjc1BTS1prN3pLMU1zVjRxdWozWWpYcFdwcndpaHIrWVZ5b3MySURqdGdzSExJT1loWmNzRERvM2JwRkswV1dDdlpTSW9OTGp1TFVrN1htQXdBanZqb3pMa0ZkRXU2U0x6aVdRTGlsN1h3a1JvM3FKMzJlTG1pNFBYVlQ3NC9jSXRvWERMb3dkbXZPQjl6QW9vMGFuREY2Q2pNNTVzUll1MkhDYjRnMm5CQnF0TFJEU05CNDRiNEZDQjRiMThVSmdBS21iQlJ2dzFDQ2RjemxaaFhnRkdlNmxUOWt6RUcyMzlUbk9LVFAvWkc2SitJSmN6eEkxZzFLUnhnUXZ4S2lWVDIrSlYzc2g3K0tYTHhhREFhdzFMNjJKVmNVMmV1TDNMS21vczlNUlN0NGd5czlYRjVvZG8waG02ZlVWTzlpVVNrSUJOZ3p3RHd3emhtQk5vM0EwQStJRmkrR1I1OEVjblRXNFNRaFNPbVg1TndGL2p4TDE3ZC9oWWEwcTVFa0NLSFNzSXo4MXVmd1I0dUw0ajZnZ2dyVDA4ZnRoNlpxcnNnZndZWUxVNkQ4U2xTaW01aEp6aUJOQUVTMklzM1VwbkYrbjNLWnl5Z2w3Y1d3anhkd2JDYThac0xLUHd3eWlmaWhNZ2tBREJpS3BZRzJiZ0p2RmsxREMySDZIcGkrL2crTDlNalJMUCtvOHF2YUlqd2U1YzNISkdGWVhaQklrb2d5RitTQmZzWWh3VDNDZWFKWXBjRXE0YmFQVVhVQkd4Y3JVcTdRb2wrNVhNVjl4VlNnZnVkS2lQUmFYYzFvZ01iWVBnNUFZUVYwaEVRSzhXeHpsSFI1bjFYVGtqbkFHL2NxcW5RbE5zM3FVRlQ5eTlWNjFVWUNxUHVNWDA3STJleUNJMEhWR1JGNnBrajZ1RlNUQ1UvRWZHRnBqWW9WaUNxVjl2RXBVamNTNTFoaU1jM0tLYmZGenVhcG1oaXBtVXM0Wm1xaG5XL0JEdm1Dclg2SEVzQVNpa3FWVEREQ2Fpc0tvRXhVRlVFVTIwVS9xQUQxek1KU1pidmtpTjROam1JT3VXZWtPcjdiaE54WWR0eUYzWnZsUWx3N2k2TUpmM1hQazVmTnIwVENTV1U4MTAyd3dhenQ0Y1FUd3FxSnNWYUNjc3ZtdldqV2srZHJ0c2lHWmpPU0dyZGtJLzVSbHFjaUhibGJhcXZpOUQ0eVgyY2NKUkIxM0QvQUFaMUVSUHpYR3ZkUVdsVG0rRWlQWG9FQkxTWWZaRnp3R2p1WVVmVE1WcmhxNHpsOWpTcDNGRTVPWit5V2dwRUZCZFFRaDZ3d1JlY2N2WHdlY2Nyd0RLUnBoZnVUZzRpdXo0bHNyTGxoNHlQUzdndDRzQXBGbWlJbWppbUNXQVl3SWh0Z24vcCtidHkvd0JzRDFBNDVOTFZiZ212TTNYTmlUcC9uQitQNVQvVzRDQmRsazFVUUVscnRJU3ZZaFFLVjd1REltK29LdFoxNFJLMXUyNHd1ekFjd0toOVYvSkR5b0lhd0pWSkJyRTBnR3lCVmt5TkV4RFF0bUN2NTRKeEkvR0tXMXdPQ1ZuQ1ZqNGwrVklXckJIREZXVWRWRXlXSEoyc1hlc3hMQzlFdVoyRGxLYTA5aUZFb054VzI4UXBncWwzMnpGV3RmTEtDa3djUnBSU3ZjMUFhNEh3blZFWW1hemdoek1HWEVzVFRsRVVDZGlMQ3o5Zk14QmNLaXBIR0h4Nk9OcjQ1ZkdiYk1GUnFBcnRsUktmQjVKMmVmQXVSVXhDRVFHS2crV2U0NnIySjJlTDA4VW1oOEVDQkR1TUxSZUVxL1Rsemd6YkxmcnA0VWNCSWtUZ3pCREdhcWw5eTN3ZnlqR0E3OXhLeElkUUZSaVl1WTRFcnMyWUNBN0hzQ0h4c2Rzc0E0eU0wT0NVSnk3alJPcUtsc0lPdWs4MTRkaEdXQ1o2NWlLQlV1WktySC9NMldCb0lJVGRMaHRYQm9qbUdnNUZoWVhFUGRJd0lxaWdiZzY0SXpxWGttRERaSXFzMDc5VEZSUU1lM3dhNytINmxIM3RGbTkrRTBleU9PU09VMUxabk02U2dqQmNjSHFGemFtNFBvWGtweGprZkIzeXpnUnFEVkVjRDRBRStVd1VWcUhmSWtWSFVSQU1xWlp1N3VaS2htcDVsMGlYTzhlRkQ1aXFqUXVDbHRtU1VabXlvbU1SR29UUEpBUnVzVlE4dmdJQnRhSXdDcjVmRGhXSUs2V09FbGlHenlYQTRNUjFzOGNJeXU5WWlzdlUxMTFGMFhKRWEzWGxqbFlINzhKYmFoT2Rjb2JWWDhzMjU0aGFMZUNYd1crNHdYUFZ1QStXMlpDeVdtSG9zYWJyNk1TMlp1c3dKYmJGSE10YmVPRmx5MWx5TUp5NHFWS2pFVUtRTzRMNjlRK3NuY1NrV1NuYXdVRU9jUGkzK0dHd2VOcGUwRDB3aDQ5eHkrdkpHRWx3Wk9pYWNVVENjRE1lbng5a0d1bVdlNFVyVTl6N0R4VU1RV3VFbDF6T0lSWFVyL3dpdUt2TUdsZWU1Yk8wbFlTNzNBNDIzVTlia01UWC93Q1pISUx5SXQvSFRiQTVydzBvb1cyWEd3Mjk1TWU0M1Vqb1JBa2ZqcVA3Y3JYM0RETzFUVTlxQ0hMRjZSRHVpcGx3RXkrNXJzZGl3OFZIZnRRYlVGTndkT0ZxRnI4QUtYM2hPMnBEYkRsMGdEWjI4S0ZoWU4yQW1CckhYbEt5ZzViWW9uNVdBQXhCeVdsOEhoMXVIY2FWUFdOVGJsZkpjU2x5VVdvaFpuL1VpTmlJbXlvMWRsUStETUVZdUxWckJEcVhEdFBoQ21Nem1QZ0hoZ2xybDBUZVpSbGplU1BTWmhXdUdYWTdoMHVKaml1c21hZ002TFo3ajRTbmZxV0RDK1JoaXloQ1ZBNnB2cGlnaVBITTNodVhpSnJQbEhMdzFFeFRBYklnbk56Q1lWZXlwYlJkZG9MYmt5MEdob1Rud3J3RUVpOTU3dVZuYnhtQjQ4MWtJQW4xa1Ywa1o2QlhaQWJEZnNpc3V1YjErbU5PcXpOTzRiMW5RbUNxMUtMR0dBMUNGc1l4RGNTajR3VWNqQmlYZFZNbDBka0RGdUpCSHNFWDFETU1sNUlRZzhZbFJQRkJKTlV5M09YaE9VZ084S29sOGRkQkM4dk1jK09PNEJXQU9vVE5qUFV4dHRXMThHSEdJZk8xbUgrT0lqNTR4N21HRUFaeGxaOFJBbk1YVEJQVS9zamF5dmlDM3hCdjBpQW80aXdSYkVXbnFtWThVVzJLMkRSaUFvNTRtTmJtQW9yeGV2Z3JiVXZyOUVUMmg3U2IwSWhqN0NaNGlHbU84VVRFSjR6NGZHVGROU3MyRHl5blpwemxJSm96RlR5OENFd0NLcUdoeEZWNE9qRkJ1QkU5T0loYmFOc0VUSWIwbGJLQ1ZQU2NLaFY5eUcrWXR2VTlaV05YRUxwWENYRHRoWmtrY012MVc0OTUyd2hCVlRoN24vL0VBQ29SQVFBQ0FRSUVCUVVCQVFFQUFBQUFBQUVBRVNFeFFSQWdVV0Z4Z1pHaDhEQkFzY0hSNGZGUS85b0FDQUVDQVFFL0VKZkpaenVTcHR5Q1ZtRXN0bTl4UmRKWnc4SmMyaHJLWVM0TXh3c2xrVUp0TFBwREw0MHluN0xQR2lVYzl5ejZHMzA3SnR3dmszLzhBK2xmSlI5R3pqYjlDejZkTXA1dCthNzRGUjdTNWZXV1FxWTQ1KzlOT0I5L3REaFNZZ3g5TWp5VWNmRG5vNTcrNk5KdDlBaHB4T05FMCs4UG8rUFBiOWgzKzYyaHpiZmZVODF3bUpSd28rcXRFZG5MZkRIREhERXJodkFSYmg5elo5U3o2Tm4wQjRaNFk2ekgwREhOdExZZitIZk5aTDRVL1JKYnlVZlkxSzVySVo0REs0WDlTMzdZMDR2R3pqazFLNUF2ZzRnT0VhS1NnMVlJbkNsZzVVaElBNDBTbkN1VXdHc3c3d08vQUY0YVFJbjBUNnRTejdaNXR1Yk1xWWwxT3ZHempVcmhtV2M0ZitCWnpiVE1wNFV6TXp3eE1jTllCd3p5WDkxcktxS1ZMSGdCVW9zWUROU3k0S01RMGpwYzNxYlNwVTIrNDI1aURnWTQyeTNlS3JkeWlVYnl6UWdrMCtvMmlydU9TVUlDbW5BNUxQcFZLNDJ5MlhMNFdjTGVOZlpYeVhMK3FjS0p0OUhmNk4vZVVTaVVTem12aDJtSmZTREN2dUxseXViV0V2amZCMG5WSzFRb05KVE43bTl4eTNLbG4zMm5BMCtpQ3dUV0tFN1kzQ3lkVDZLUWgxOEdHSEUrMnh3MC93REpxR09OOCsvL0FKSGY2VHh5WTU3K3hHUEthUStwVUNWS0pmRzM3SGJtTk9GbkUwK2haQUNQVExoRnZnYVF4RGtOK0VPWVNKVXRJQmlHVW5FMDViT2VwWEdwVXJtcVZ3enpkcFIvNUp6anlYeHY3V3BSeHZqUndvbTMwYWZyM0xseTNqY3ZnY2E1RDdTdnN3cmh0eG80N2ZRc21BanpDR3MyNTZKaEk0ZUhVNEp3UC9BdDQwZmZYOU96a3ZpY2FQc0xPZmJscDVMT0czS2ZRb20zL21Cd3M0VjlqUkxPT2szNDdjOWt3RVhrSElmb3RxSmNTdUZFcTRsY3I5QzRNdVhMWmZMYkxmbzA4TGxrcCs0MTVkcFQ5VGFQTFp6V2MxbjFySlp3dmpYTlJ3eU9lM2hmMWFaVHltdjFxSnBENkp5R0dIMkY4S3VZNUxPRzBwNVFWcUJSSHRNVEV4d09GdkFVUVhlYTlYb0hkZElSdldzWXYxenRMV3JRUk1sM2tTaE9wejdFU3lWVHcySWxuQWZwc1BzcWYvRldIRytTdUY4S0pSSzQ3L1kyYzljOW5NY05WUTRIUDM0NSt2UktQcG5KcERtZU8wT0ZmUXJseHpXY2E0NmM1bzRYZjBCYkZvbXZYejRVL0dzT28xTWgzdlJ6cGpNd0FUVTN6L1lIVkZFdUJpeVltSTlvcmlYeGRrRy9HK04vVXVYOWxkRXJVdkZFR1FVQy9ja3ZQS2dFZTZnZThkdWZRd3ZaYWpXQkh4UHhCMnZRSCt4eWVxUDZqRkcrSWZtNHFKYjBZOVN5QlR0dU5ucWNocHoyY2p3cVU4YUp0enVKbmhSTUVMU29xVndMbUNHWU0zNUhqUjlXcFV0bDhLb2xrdGxzdDRWOUVLNU5vVGZuczVUaUNxSVpla2QxR05HQ2FOK0k3d2d4ZFFSZG9yU2ZSSDZGa29odDRQSDBUcThBNTRTbVhad3J2cHBUVXBreVcwVVdMUjM2elF3aHBPOE13Nng0S3lVWXFDak5TVlQ5M2JMZWE2ajBjaTN5Q1VGMW1KZkM1Y3Y3VThBWlZ3RTZLeGN4ZnVlTExHVEJ0WWJwMFhXeHBDOERFT3RxS3JURnZlc0UxY0FjdzFsRXV0SHhXWGpWd1FHelRMNzlZT3ZZNUUzbEUwNDJTeVVjaHBINmQ4bCtWVVhwd0NGenhtMG9tZVMyYjhsUjRiUytTMzZnSEdwVU9DMEZLWlhKY3ZoY3VYOUM0UEhhWHdPTkZJZ1VEM1pueHYxSEJXQUxodTZvMUt2Wk1tUXRQanBmU0lIUnFNVStHOTdRbHRycm9CMEh2MmdiU3E1cU9CeWJjYTRHamdIbkd3QncxY0FhaW1MMzZlbXRFb2NaUFhheUhCVndMNDNMSUtPS0RBbUljY0w0YVN2c0tsY3RTcFR5S0RNVnpDWW0zRnpEeW4xYTU2Z1EwTjEwQ055OUF0SGl0MkxvT1IxTzNmOEFFTU95aWpUM3VkK0t6UUhWWEFSZTlic3ZwcWc1Uyt2OVVsOXQyRmVReWhyaWNKb2ozaTRiUjZ3MENtdmx1ZU1acWEremtmU0I3Qm83OS9jNmtNb0FzVFJIZWJRK2xSS09TajZBSm1Eb1p0TUJLQ3A4TkJOMHdwbWF6Skx0TTRVd3pCTG04ZUx3MitoYkxlTnN0bHpXSk5JVGJNdVh3M2hjTk9EQm9sY2xrczQ3ekV2bHY2RzNBRzBZbld5MnJtNEtnQk5RbWtBMlFLQ25SM09uOGdxd3kwOUhRZkJpbzZsWHFoTHFZd1NxeE51QnB5MGM0dDROSUl4TVN1SW1BT1JMaVZFdTdyZlhWd2RQSHBrTGg1T240SDdoVnk0TlM1cThUUE9sVGFESGpaeUc4UG8zTCtsZEVWc3BDb1FGM2xaWEE0TUl5aXlVOFQ2WGZsMjRrcVdlb3V3ZDJEWGp5QjBPL1ZsTElMay9pdTNXSnBNNmcyRjQ2Uk0xQW5WVTRJY21WQVF2Zll3cXJiNktQaU0zQnMwQnN1NTZES2hWWTBMSHZWckxtdnhRNktWU2RFMmkrRmlQb0hrRXNOeGtwVk4zTnZCK3lvNDJTamdOVEJmV1dOS1RmZ3pYTVp5RXV6UTBnaEsxVE8wSXJrZUZ2THI5SnhpYXdZc3ZFTHBsa1d5UVpmRVdkK2J4bU9CQytlM21TcmpyMm85eXhIWEUydXNDQnZHNXBlMFJOSnE4WU8weWJ4TURvVjYzRmQ2NEpwcktDb0M0MTVUa09iZEhCdzBuVm1FajB3SnpwY1h4UGlFSVFoNGNhWnR3MjRkZkJhSmZSR0FrdUtYYVUzS1NDbVhUN1MyVzhMZVJWcVZLdkVMVUpmQXlUTndVVXJncDRKeDFEV2JjRDYrM0d3TGRvcXN0L1NlbHUzVHRBWWFlWDRpa3lySXU0N3l6bVZsaEtQVFNJMmxkS0hSb2RhbGtIdlNqZW5XOWJnTkt2VkV3eXkxNmJWTnhqU0ZsRkZYdW5TYVI5VmpaTFdyMWxFdFdpSXU2ZmFlbUhZa2lDbDBkM3A1ajN1V2NlLzBNUytTK1UwdVVwZXFaWlNoV0xNSzNGQ0V5SlVJb1NtTjNNU2FFMXpFQVc0cXpqWncwaDlDbVV5Mlc4Vm9sQXZnZ3UwTGFSUUNTcUpTQmNuU0RURUdMR1ZxRGhUeElRK3VMaGFXUDZ5d1ZlOFpaWkJWQWhia2d5aE1UbUFXM2xlSWJ1d1hNTm5Xb05YUmpYdVhBbDRFWXl0QnZ3Mm1KdHdmb3oyNUJTRFo5RkxKVlk0YnltWTRsc0NqaG9ocE5FMHgwWnBoR2lHazB6VnpHam9vZTgrZi9BQlBuL3dBVDUvOEFFK2YvQUJQbi93QVQ1LzhBRStmL0FCUG4vd0FUNS84QUUrZi9BQlBoL3dBVDRmOEFFK2YvQUJQbi93QVQ0ZjhBRStIL0FCUGgvd0FUNGY4QUV6Z25lMkRYRlNwVTM4WlBHc2U4UzdtWFl4ZDA5aVhvYlhDc3Vqd0NYUWtDYTdDZGlBSzlIQXNTMjRkY0U2Y0FPRmJTOEtaWFRHdXlrQzR3bDZRalFqVGFtZkQvQUludy93Q0o4UDhBaWZEL0FJbncvd0NKOFA4QWlmRC9BSW53L3dDSjhQOEFpZkQvQUludy93Q0o4UDhBaWZIL0FJbncvd0NKOFA4QWlmRC9BSWoyNUJsME9yeGJxVzVzWVpYdEZ1TU94NFRDQjR5a0RtVVVIeTJXQTdaaWxZb0NvS2dPQ3ByY0dvZ043L2E4elBqUlYzeFdwNHdBb05BYUhBUFJNVVFidUNuRnIwaFFnTmEzNzFPdEtIcGJOUGg0NFVXclJlaFZKMTRjYnFRc3lzQ29iMjZwOFA4QWlmRC9BSW53L3dDSjhQOEFpZkgvQUludy93Q0o4UDhBaWZEL0FJbncvd0NKOFA4QWlmRC9BSW53L3dDSjhQOEFpZkQvQUludy93Q0podXF2ZzhvK1RRY0hieGcwY0szZ2FHQU9BaUZEQW12QzRyck1STUNKbGlDNE9ZUkNoZUJ2RGpYa3lEWk5ucndzZ2dEcnZWWGIwWjhmK0o4UCtKOGYrSjhQK0o4UCtKOFArSjhQK0o4UCtKOFArSjhQK0o4UCtKOFArSjgvK0o4LytKOC8rSXRoQlhEYnlqNmxiUENHZUFGcGdFRUpuU1ZVUWxNYmFOSUNaYlNqbVVjd1hlYW5GR1lOZGxJRnhnZEZCRzJVMnBwbnovNG56LzRuei80bnovNG5mK1hoUG4veFBuL3hQai94UGoveFBqL3hQai94UGoveFBqL3hQai94UGoveFBqL3hMbDdLdGJ2cXlsbUJSQU84b0Z3SmwybDdVc2dsa0NYR3NBNjhQMjhBUUVYcXg4MG9YWjdnZXBjV2hNQ1pMaFJlQnBNOHBwSGpSd01GUjE1ZFAwbTBIeDZRQks1TkVJNWdqYWFZYTV0RFNhWnFqRGs5ay9QR25IcklEMVlLelhhMEY5THVyaTllc2lCNHQwUThqUlpaWmVsbTE3WERiVXNvQTZqZUh0ckV4Vk9qcmVHWlJtNjZJbGRiMG5uSXlNUEhTSkFvcGFSb2NsK08wV0NGcXBHNncxMXB3eHVhSEpBVTJ5NjlvWVVhQWdxK2wzVjlvaVdibGxqRHJXdGQ1Z1JaVFRkSnM5SGpiN0w1Qi9YTUlNZks1dzdXWkw3VFVQUWJGTm10Nm1KRWl2Q0F4NnVrVURTeGVjcitFV0RJd2RWb1N3MVNYV3poMmcxZHRHaFlXaWJSZVBoZVJkZGlIUkJWQ2pLaG11S3krQVdGMVZhS1UyTEdIMFU5MUJWb2EwSEtQMVlJSW85SHA1eFVGRlFvTnBxR2NwdjBpd1JwZHBqcWRMMjZ4WktRdGFGSFY3ZDVwVDF0Qm82dE9DQTFWVTJVM3BUbzN0VTI5aGRYbXRMcldyeGZOcHVuNW5kQlVUWnNzVVJCcWpwV0k0UFliTmR4MXJzalV2a25SVitwcWVaRzZMVjBoVFFJZEdXd2dTNFppUzYvZnRDVmVpeWgxVGJ0Y1V2Vm9sS0dnOXQ2MHVVRU80bUU2TVBFMjVqWGZ2VjZNRW1sT080YSs4Mm1wODkvZmhhZkFIK01sMjBuWlJWVW5tRkxObEk0Unc4aDl6UUtDK0hYeW1Fd05GQm8xYTZHN3BFQVFxWkdWMERyZTFhd2FqWTVGWGRWZW11UEdVWTlOWkw2VmR3TURSWmVTOUxOcjJsc0x1RzZ0YnJYSGp6TWloUjJ4bG04ZzNCS29seGNaeEdRZ013MEZpZXVtR1JOUUVkWnRVeVhOUmNlWERDaWVRdFFXVUJnWExPeWljdkVIK0dsVTVId2cxVm9QRllFYUtwVUJ2U252dEFFcGN5TUpxUFN0NzBsTUtvY0k0ZEh3ZG1EVnJVb0RXdFp6VUc5R0twUzZIWHlnWVhXTExMMHMxTGhjU2JqWjAxT1ZzVnZ4NERiZkNvYmpwRHZLSUU0TGxrc3FDRWdycUFsVUJWY003NGpZVmRWb1NrcFl3OXlydXBRb2EwSEtQMVlJSW85SHA1eFVGRlFvTnBxR2NwdjBpd1JwZHBqcWRMMjZ4WktRdGFGSFY3ZDQ2bEhsb2FPOU1TUVdJb3BYUUc2YjdUYjJGMWVhMHV0YXZGOHV1eEFlNllydk5yV1dldlJuV1RTWGZlWUZzMGFrNzhadVREUVZub2Rld2RZUzBES2F6Mm5WNnZXVTdiR2w2M0NTb0NucWVrZEsweVAyZVRNamJCWlRveEtXVzgybkpaRDdHV3BYaHZMY0MzZzdPR2lFSWNSdE5NTmZIVE5YTjdKK2VJMmFoTUN1cm9GcjRCY0lnTE9USk5odEZXYWd1WWRHckEyYkpRSURiYzd6NzQvaVl1MFZnVmFvYXlodnVrYUNVcU1SUzd3OUNqMFlGQU5pb2Vtc2JlNXVtKy84S255M1hOa3NwMUJENmxpbFdMSHFoQzFGM21yYjUxSHdObnZTOWlmUDlPREt0V1BuV0lxaTc4SzRJSlRDcHhVeWc3dldWclQwZ0JCdUQyT0pVQzZVNnVhL2hZTFM4bnlJcmVCYk90cjV3cVE4THVQR3VmSzlITWl1Vnp1Q3IwblF0TjhUT05kVlJ2cGJVTGVnM28wOXhjQUVaUlh0bFhxWEdaejVqWDdtQ0hwZjZ0eW8vYVBFR3ZlTDJ0RmU2dHNkMFNnMHFpL3lIU0Z6TXVjNnhoaEJNRlVnSHh3Yjd5cVJEUUpYd1V4TEIxZGFOZHNSdHAvQlBRQ1dmeHdxL0tpcGd3dWFDUjJLTDhiWWJYcnZGc29SVlJhMU9wREpxRmw2NTFpRmY4QWFQNytoL1cvOGdzZmFNSTJEOGxmZHo1RHJqbllYa2svS2w1d01ObHZvRTlHT3QreW9QZGk5Wk84a3Z6Zk5RTGl4ODMvQUNXVkJJRnJJakJocU10akpocVZPR1pORERXelBSbDdYaEVGdzBvbXFtWlBvSmZDN2tTTDFVck4rS0o4RDB3SHVQazZQSU9BMnB5Z0FkRFA4c2UxN1BJOUI1UTkzeTU5cXQ5VmhWY05JbUlOTVZ0MURndmdTOVNpTldtVndVdVVZOWVQd0hSeklybGM3Z3E5SjBMVGZFempYVlViNlcxQzNvTjZOUGNYQUFHVWw3WjE2eEJjK2FtdmN3UTlML1Z1VUhVSjlDSTR1MTJGd1dGcVZva29Md08rOEJoZThHV2RKbzVhaGIzYUR4NndEd3R1UEkySUNCdmFmeHZEdVBjZnlkWU1ZWjAxbTVobzhkenpoYkVUQkdzZUJ4dUdrMmh5R3NkSG0wL1NYSmlQRWcyVFJDYVdhSnROTU5jZUdtYXVGOGJKN3cvUEVNSUxPK2l6V0hNVXNITGRGYm9PZWtxT2FyZUcxd09IM1FSVm1hM1JtNDNGcUJycGdpb1VOTEZUWjBTb2FJS2d0UVRMMG9RQk1mT1pZMUx6VndSN0l6M2VuN08weDBmRlFLQ0pZTjVFSHZEWXU1aEpVZE5kV09KWkMxTHBRWGdmSklzSnJRcUd4ZENyYnNFdlljYTZZb1lZVVZEaThMMUFhTndVcmdyOFc4cGNkWmtoVUM1bmdVMGlTaVhldDV1RkxwSTA4MVIwbkV0MURwaVlJckNWeW53dlJ6STFRVzlkUWFIa2FRSzZPaW9yQ2xCU25aSTBzTjBLaGExUXFsN0JBNUE5RzhQZkE0UUxkYml5cGJvQUt0QlhRV1l4eEN0UXF0am9NQUcvVjlKSTlLaHdaalpUVzZteSt6UmZqUnlmTDdrVnVKY0NpcmphVmF5a0pydkc5c0dzQWNORWF2Vmh0ckNZYTRzeDNnb1VGb2xYMkVqVkt2UUwvRTE1bEJpQUFrN05ZN1VPRk9rYWh1cFJHV1IxTEJUeS9zRDhyU0tPZjZmWUFHOWMrRUhyZDZYbGRUQm9HOVNrRzVaSlFUQkJxem1LTUR3NXFsbzB2Uk50UWhNckRhd0lMWldyckNPM2lMZDN0dEt0eFcwVWg2V0d2WVdIRHJjSWUyV2VxNi9mbFo3cFE5Q0txb28xWU1MV1dackxFWmtHb00zaU9naU9HQmk1bmdJb2pRcGpvVkh1eTNuQ2ZFQm92VHpvWVllbm52R04rTjB4VnkwQzZ5Q2hXQWpSWm1CTHc5NTlhdE54TXpNZkZkaTkyUHJXVHV4UWFrVVl0MnkxTDJVOVBJelM2dDF4Y2Y3YkJkbERJRzljcGl1MzJMS2FJYVM4U3hjdkhDVWhhVWdvamVBMVppQlNNRlMyTURNMW1KOEIwY3lOVUZ2WFVHaDVHa0N1am9xS3dwUVVwMlNOTERkQ29XdFVLcGV3UU9RUFJ2RDN3T0VDM1c0TzVJQ1VzaFdncll1T0Vva3JWWlhBclVCSUFOK3I2U1I2VkRnekd5bXQxTmw5bWkvR2prWXpaUHF4Tm9VMUpiMTNpS0tobHJwQ3VUMEhpZEpaTFI0SDhRaXhQRVMyaURkdGVXMXlnVU1GU3RleHBNMXZSQ3R0dWR2a0cwclpQU2YyV0tQRi9FL01EdXZMV1lkK0QwU2RSTExLQkZaSEdPRnN2bXNsa29ock92TWdsWldWbFpXVmxaV1Y1TnVHT1NpSVNBcU9LNVNvQVFBeENTa0FJNWxTdVQzaCtlTlloRk5EdWJOa2VqWVk3RDB4aGRLaU1CRmJtSHFBY1ZLanRTckJ0MXEzVjFXRUFzWGpBSTBDdGVpVnkwTlF2QTByWXg2Tmhqc1BUR0YwcUhScmlLTlZ0YXYxUjEzYThsdWlxY2JoMWg2dFNoNnhvV0dscjJZUWNEUUxvVkpRUFlqNUdvRlZHdDdDekxjRWNKQnFWVk9hMHZIU3FZWmdJbEMybXhqYzRINHVzSnZCY3NjQUlXNVY0VndxRTB1SHl2UnlDWGFjZUswZVZzcDFGcFF5YUtUWGJXTlhnUTl3cXNKb2NYVmhidlRxdUhFeStDbW5RYVZXaDBnc2tZR3RGMWpXN05hMGxMSlVvS1Nqa3kwZFZoOVJaVUlwVXhxWVNNdmJBQVZLWFpudm04UUdVV2VCcXJ1NjJZMTE1QllkRyttWVk5WFFnL3JvUFhyVWFLcGF0SmtIYUFSZ1c3REg5b3FQWVpmb2h3T1FOeXFabDROMjk5QURwYkZZWm1HVWJDekZsMDNyVXg1em9qWU9wQUkwZENoY3RwQmQ3aXVFMG01eWxRQTFWcTkrYjdDMGtQY0ZKVFVWVWE3dUs2QVZVcmkxdkMzRXdURm1hbVVFR2diSFRrYTFaUmh2SlJsNzZ2WTBackFZRkdobk5YcU8rOHA5UnJBbzdBUFhPekQ2Z0xCdlJldW1ycEFpb3RSa2FBYnhuNnhvK3NxRkZVM1dsNU8yc01HakZTeGRaREhTdVIzalpZU3lHNk1jSXQzRGFuV0pkYU1ERmNabmNCVkxFcGpVRWFNRFZta3A1MHNDRmxvQ0J4Vk9Pb3d3bTZSVTBMS0Z1aWdneFZRbEQxeldUSlhjV0FYa2Ewc0dTR3BLS29wdWVtdFlGckJaNGdNcUdrS3htRHdzWW9Yd0tUTHRyTUVZeFEyMmFrVXE2dzhyanNXZWR5Z2hUV1dWTHFReG1CTlNDOXBUTklDeEIybTh3MWxUU1VjQUhINEhvNDV3YVQxQU5SMHRodXVuUGV1Myt3blZJQVp0MXJTek8xU3FwRzVSMWRxclN0cG9BcWgxT2FzelNHTlZWQlFkTlhXcGxkRG9DZzA0QzlEV0RGak0wR0JqQUJzeWxkczRCUlNxNnBrVGFFZlZPZ29xN05WdzFtRUp5V3B5YVhoSWZNVE1ISVV6NDBWRGxvYytTbCtkWHdkZlBxNEt4MEtkK2tzcGR6OEpGV0tlY3Npb2J1MHk1b1hjdTNid2dzOUJ1N3ZRZ0NOc1dLZ2tFY1JlMVV1eHJyV0xtVHhYckhDbWpvTTM0bldOZDNkZE1IbktsUG83Y1RrSGdkMFdQU2ZFSDhueEIvSm9TUFI5b1JYRExyVTJFK1lQNVBtRCtTM0ppOXVwSEN5SlBSbnpCL0lZMlVkdUZ4enMvRlJWYS9XUFpvNk0wSnBxZEkwS0x1OU8wK1lQNUx4MkxHZk1IOGxsY0xiZFNZbnlqcDNueUIvSjh3ZnlDYnBuWTZlRTFCcm9kWWsxVjBNZjdIN0grZnpGSFhkSCt6UEd5V2NQZUg1NGpyYmw2TnZzUlU2MkJya1o2WUZsbXVBSTdwVmUzdkFrb1djRGRGZWpSTVpnaTdCcXdzUTlrM3F4NmRjaEtjclFHcGt6MHdtYlhubE5TMHBybzY2YlI2TWVZQ3Y0OElnOHBvSUJ2WWJ2T0RicExhOWdxQXNPbm5xU211V0srSS9vSTJlQVV5WDNlVHc3NnJoV2VDT2pMSW80Q0pLU0MzZ2p3VGlSUkFvNGZLOUhJZU50RDZCZlloTlo2MWFPZEVwb1hKRk5nSWJkTXFxNm5zY0ZjRXRzVU40MU5TTVNZQk1DRjNscTYwaWxtRkxCcDd4N2F3ak5haXdvRmdERmxJbDY2QVhZMU5qS1dicGdCZnFDbXFlZ09UUjlCNmpMSjZpa1VkaGI0Ujlvdmw3dkpnZUZGQ0JhQmpTRUZLQWU3QjZRK2E0YmQxYjdySGJFVXJUcVRHRytqcWd1SHJyTm9hOEFoNnRZRHdsYkhlVlVzVFNTL0RlZGFyRUN6TVFpMWlCcDFDSDBZZStlYi95dlZQZnZ6TnNhK29NcmJub1U5OUlKM1FCWFFCZllTQTFGTm9UR1dTYXdSVnpONVUxeFMzM21sOHRaWVZmbUFZYUNWYjNMaS9xSVlnVjJzZXBCQzFlMzJvZnQ2UnFkbEZNam5aMzA1QlY2UFVSSzFsUXNWQXRpTzh4RVZHR1doUEFOMDd6S1RObG12V0xlWW9CdWthQ3ZvSkVRV2hhdEc2TzFNelo5RFYwdUcrYkROajZOdmFVV2FnRzNCaThkR3lTdWc1L0t4dEpYMVVtamFrN1pONHRKRmR0clkxQnJzZEtsbkpiUllVMWdLTUtqeUkwTFdtOTZNYVZYZVkrL2V0TDVHMjJqMFgrelNYQkRpRUhSdlNQZVF1VXduUWpzdUdKZkdZSUNjZmdPamlMVnBId1VzVlZtd1c0elRLM3JLbmQwSXdvcXI4YWx2U2EwU1JkV281TU5VUUNiRkhzeUI1dFM5NFFxMUJjWUVjeWptdnJpdnNNdlZLVmh6UWJPb0xBSVZlVVlsYTNDYU1oUWw0TGIwbWRqYUZZcThGNmRXOFd6dWRyR2c3OUNObXVuMEVIdFhCSUpndFB1VFVXcUkwcVZDZEJqeEgrVFdxYWVWc1BIYnFYQUcrWmtCRFIzNm8vYTFtRmdEaHFWbXVZNW5laG5lQTZMSC9hZktXcFk5Tm53anNlUXl4eTN3cGxQQytHMDA0Ynl5V1F5UndzMmh3OWc4S1B2Z2FycndUb1QrWlYzWDZmN3djNmhLazZqL2YxUGN2dzhQYUhCanRYSHJqZ0l0d1JGSXhEMldQM1B6ZjF3dTgvdytWM0orSitYZ0tXZWxBRFFwMU8wWk5vRDl3Zm5XSmxLdmdpMnFlKzh6eWJUM1orZVJzN2JnUHFFTllaYVlGNnBXV0ZEaFFJYU9oWmdsV1hSUVRIWnhMdDJxc0ExMHdhZG8yZTFJQmIxdWpNQm96cndaZGFxcmdXQmRGRmgwR3JEWEJGWkUxRUVmSm1sMkFoRGJBbUljRWRrRXhwaHhpVVI0QWV6U2RqeEFEME9GQ1V4V05CVjRPVDI0QXVreTFGU0d0TXNNdnFTeGN6RHJOT05IRE1TbWVQeXZSeXJYTFZBWHhRZ0t5N2RZcjYxVlhGazZTelMwMHB4a29Db0NJVVB5MG10czFvdFhXZ2htanJBWDRsWjg0WWxyclF0NDBSMHM2b0JmTUxueEw5Y2lDVTZSUlNWWDB5eEdWcXcrZmJocG9vVjBMWFM5T2syRTczc2c4d3N6VjBzSHJkUzdVMkZ6czJYTDJ5MU9vWWVjZWhaQzY1YVBwR2pUV1lVYWhmaEhLek1td0d2d3VBdUlwRmlOUkl3UEhvVE5QakE1dnRUdFlSMFRveEVWSnNveTYxVlhLNTFhb0YxcFYxZFlNUysrcldzVnVycHZSS0tzSWh0RGRoalJ0czN0aUlxelpxSFdxcTVVTjBrRTlHTHBEUllhOExNUU9STmdUM2pXMTA0R0hTdEpUbjBnQjZISXREZ1V2Y2Y5bVV1cmc2S2lEU0FKMHdwSVN6QW5RZ1pqTVZmQ2hMNEZjaUZXQ1hmMEVpdldVRjlhdVUyRjBvcDZrRW1xVVVVTktHcnFwYk5aTkF0NzFyQXlicERxMXhuemlRQzlBZmlPa2pWQUw0b1RNMkZJS1BVWFRRMDVVMVI3VGg5NjRrQXVVRmtwZ2NIdEdreUlOd0JielZCR1o0ZkFkSEZVQm1rR25xWHBvYVRSNEVvS2VEcVFxYUc3THI2M1YzRXkycFV2eHhtYk1LaG9zT2c2aEdvajJDL1dyZ1lUYTNlYzVjWmN1ZThTRlF3VUtIUzlkMlAyYVNCVHdkU0tBdXc5MVhCQVRvZ3A1cGNVRkUwUWE5U0FJQ2c0QlVXbGp4eWxjWEhTT1lSMmhVWFpkL0JpYnc4M28raytBWTNqN0FZUENYeFdwdDZHc0FWREVZY1hMTExLVURnaXBPLzBIaWFURW80UnA0SEQyRHcvRi9YQTUvRDl6TjQzNjRlUzM0SjVtL0l6M2I4Y1BhSERWOFRnS1hpekg1bVdlNm41djY0V1hRVDkvcmg4YnVUOFQ4dkQycCtPRFd1MzRqQzdyakZsZC8rTS83RC9Jek5wZW5pdkxpQ2pzajZNK0QvQUZQay93QlQ0UDhBVStEL0FGUGcvd0JUNFA4QVUrRC9BRlBnL3dCVDRQOEFVK0QvQUZQZy93QlQ0UDhBVStEL0FGUGcvd0JUNFA4QVUrRC9BRlBnL3dCVDRQOEFVcjRpbkRQUndzdVVSQm1GaUNOT0NrVVhITDE0VGR5T29yR214WFdmQi9xZkovcWZCL3FmQi9xZkovcWZKL3FmQi9xZkIvcWZKL3FmQi9xZkIvcWZCL3FmSi9xZkovcWZCL3FmQi9xZkIvcWExTW1zdHc0WFZOZTdRcFBBdUdvalZmY3lkY1JOa050RXZDbGxOS2QwaFpLaFpjV2IxdERWTldvWnFxTGRDS1NXc1k3M0krVzB0ZFlwVXRNUzQ2QmxnTi9JdjQwRGlBYVlWVzE5VTZ6NFA5VDRQOVQ0UDlUNVA5VDRQOVQ1UDlUNVA5VDRQOVQ1UDlUNFA5VDRQOVQ0UDlUNVA5VDVQOVQ0UDlUNVA5VDRQOVJjdXNjMVdQT0ZhWEwyTndOOFFXVkdqVVRTVVNrRTVnekdzOEVhRlJjSXVPSnl0bkJybEcvalBrLzFQay8xUGcvMVBnLzFQZy8xUGsvMVBnLzFQay8xUGcvMVBrLzFQZy8xUGcvMVBnLzFQZy8xUGcvMVBnLzFQZy8xS3lFcC9Xc29vMmx0U2Fhd29aUTFCdVk0QmhiYjVXcXBvVHJ4UWhYS3JZcnJQay8xUGcvMVBnLzFQay8xUGsvMVBtLzFQbS8xUG0vMVBtLzFQbS8xUG0vMVBtLzFQay8xUG0vMVBtLzFQbS8xRzdZNCtMaU5XemdkUTZZeGlDclU5Tm9sd3FWQlpiYUgwbFFuSngwWEVOSXdJZHF3MHJWUFVoL1VrckVmeEVDeTVvaUc5Q09ZMVpuZ0VwbE1vbEhFMG0vQ2prVzBPSWNmWVBBSXFNREd1UE9WbXRZbTlNc3U2RDltZHhFbENlb2Z5WFRzL005Mi9IRDJody9PY05UeFo4WjFaNzJmbS9yaDRuZm5IRDNiOGsvRWZsNEQ2TVZ2RmpyUmVzQkhrdytIWHk0V1l5dFNCMXNaY3ZsUHRMVXNPQXNVaWhOekh0Y3FMR21zRzhyanJ4cmdUYVV5bVU4ZHBUeWdGWVVuWmlhK1pUb245NndaR3RXdVlJbHZRVm84SXNBZTFZOVl5VVcxMkwyMHhBbGNwMHorSXhta29oWm05UER6bVVsY2FtTnNFSFBiNnRoKytoQ1JVSDBNeXlYem1EbHVYS0pwRkdwVTNHRWVFeEw4SWxLT0VpZzFpRUtIWGFMYjlzaTdsRG1aOEtwaXhISktEaTFwQVFFRE1IR21iekU3Zllzc01KaWxPc3U1amhtRWZDQU1wZkFoSzNYdHZwdkxZdDBaOVBTQ1JVZFBRdVd0YWliM2lOWDBRWW1BNXZXS2wxZUZITVNvYWNiT0NwdmhSeDlnOExaTkYrVEJSc2pjZDRQNUxBNkIvWlFPejh5cnFQMlpWOUU5Ky9EdzlnY1B5bkRYOFg5VDR6cXozcy9OL1hCSFQyZlV2aDhidVQ4VDk4ZGJ4ZmtpV1N5bjNuVC9BRGhiTitwKy9FZ0N6UjRYejJTejYyMHpMWUFseWlhY2NRb2d3encwNEY2dEpWY05wWE9jTnVUYm5ZNFRub1A4WnFEZUZ3K1QwZG5TWENTc2RWSGZSZ2hZT2xrMWxNQWRJWU0zdm8rcHY0a1VDMDJHNjJ5WVgwbDU5RE5iZHRtS1NuU3Z1OTRHa2FBZ2E0dmIxbVpRZUQ0ZFROTHNnK25Ud3Q0VThLNWtzandsb3JNR0dKZ1piVUJRRHBDQXVadERSV1h4cmpid3Q1TGg5TnJLSWRaVXFJb1FhSXEybExLcVU4TlVNck9abHYyZWpNN3dSMHNrM1BaQjEwTlJXOHJ3aGJNcUVBZ0JxalJoTndFMUZhSjNYd3JnYVM1YktaVTM1c2NGWndlbVZVK3dlQURSNFRlQUpiTy80S2pLS2dZMkE2Nk45T0hjaDhIc0RoK2MvZkQ4N1BuT3JQZXo4MzljUGoxaXVHWHpha3hIZ2Z2aHB4b2Jkb3RZcUZrdmlpVkdRYTlZYkw5RHdhL3RaNmY1d3VXL1J2NnRzdmswaEdhRXFCQzhxbmdjbUpjdGhwOUxiaFhDdVNzbER4Qi9uVW1kZ3lEUG1QNmdJS1pCTHRNZVRBNVJKS1dqMXF2NXBEcnhsVmtiYUE3Vm94R2xlOUUydytVdzVMclRGOU9rb0MzWGtwOHY1RUVKV0ZwWGoxOFl2bDVWVVhicVBoZjhobDZvR3J2MnZxNWd3MEZCekgwTGVPWlJ6cFpVU01GeGJTZ2czNGJTMlZqTVpUS2ZxWGYxSDE0QVhTTXFaVE1vQ0NFRWl6YjdvUktoSmRDVkFGZVlmMHd5WFdSR3p1ZUVkdFh5czZqMGxZR0lsYVJXRjJZQmlhbm1Xb2FUYmh0RFRtMzVEU1VjWFR5WHNuZzNKOG5DN3RDZDdGK1hrdW52OWhPSHNEZ0ZmaWNBV2RGL0JDTTBWK1dHNk9zdzgzOWNMT2dBOVQvT0h4dTVQd0g3NEd5R2hCY0NRMTQzNmdJZEtmbVlQZy9Ed0NEdXZESFBYQXFHZUMvVUpVcVU4bU9PVzhDdVdwVW8renhMWXBJVnN4ZDdxSGoybUZjeTNTNVNuTzBDU3VFdHE3OGFnN1JjSE5CWElkNzFaaHZCaHljN1JHbHZtQ1VCRmRndGp3b0RaMThnL2FRNVV1NTZHaE5PRmNUaHI5R3VRNWFPR3BNbWt1RVl5a2FPQU14T3prdGx2UGN2N0JhQlFqWW9sakRLcVd3SUVwNFdTNEgyOWtTS1JjZUVlRzdSbXQvU1V0QmU1bUtVVk84WWoyL2NxUmF0Y2x5K1MvcHV5dUd2UFlQQU1oRHZ3ZHRUTHlOUDNFcGVzQUd3UGV5TGFMWnUvd0I0ZUFQMjhFRmEzU2Y5cUlrdFhsNmppSXNDUzJ1TDZOY0ZUTWZrL3dDVFY1LzF3OEZKK09IeXU1UHduNzQrK0lTR2c5ei9BRGdlRE5kVzRDcUpiK29lKy92d3VITWN4OVhmaFVxVVNpVWNONE5UWFg3cW5rYXZ4d0lIbjBvNmlWSVBRbFVZN0FSNU5xNFd3K2xUd28rclNWM2xkK1FKaVltUHZLT05JQVN5WHhxSDNsb1MyV25mNUxQb2p3T1VPSW93YkpyeGVJcnJPejk0ZEg3enlvaGdqcnhZb25aKzhOTTJWaU9sUzErWjJmdkIyWGIzSjJmdk96OTUyZnZBRFdsL21XeTd2WHhnM0N2UC9JaHM2N2Y3REFVRWJyR1d2ZWZPWldVLzRWT3o5NE5Kc3JIaVNoSXhXWjJmdk96OTQxVFM3eCtGakJOaW5mOEF5Q05MNnY4QUpkNmpUb1N1Y3BoQ1dTdUZrZUJDWHlCOWNmc3NISmlaNDQ0NW1aWEhNcGpDV3kzalR5VWZTdjZHL0crRlBDdWVtVTh0U3VOdjA3bG5DeVdmUXJqMisyc2xuSlJ4Tk9HM0pSd3FWSzVyWmI5RlJsSUhoR2hLeEtVSVJ1QUdXU3NNcTRTVXdDeXNOeEFSRlFGWEFKQVFGZUVVcEFES1JBWWlvTFpXYXBTSlhPbFBBYTRXU3VRbXNEN0E1YStsbjdMTXo5QlVxVk51V2o2Rm4wNlpUeTF4cjdpbm1PWEhBNFY5OXRMWnJLSlJLcVhEVGlhZlRHcFp5aWhVMFFjK0VycE5KcW11YVpxWU9VYk1rVytOamZBZUlDYW1HdmcwSXpWTkUxd3JwTVZHSldZdHlpVnk2dkhQQzNqVE1jVDdXem0yK25mMkNjbHpHOHZIRFBDeVdmWlh6ZHVOeStTcGN1V3k1Y3Y2MVNwWktPQWNiSmNzbEVvNUtsdjNKeTdjRFRneStOL1NxVjlBYStHaU9XYXByNEd0aUxoQjJZS1pyNE5GSFZHQ05NTkpxWWNCMFIxT0hSTmNvbVZaQjJZS2VPc3JqWEE0TXFWSzQxd1BwR24xTE9VejkyY3RjSFNabWVXM2lmU3Y2OXkvdURrMC93REdOT0ZrdVhOdU5uMWJaY3RsdklyTnk3bERLR2Fvd3hzaFM0aFVyTnpWd25STUlaTXhwd1R1TlRBcDRqUm1pSlpBcGphQUtwV2Jpenh0NFh3dVo1c2NjUStuZjBOSmR5K0Y4bTFjOWM5Y0srcG9mUXQ1Q2JjTVRQSFBMWEhUNnR5NVVyN081Y2VGazBseStjKzl1VWNUU2FjS1pUeHVXL1R1WHpXUVVsdldhUytxZU15Y0RNdDE1QVpjdFpiTFNXd1VncExaYjFnMUxaY3RscGJMY0xlY2g5S2o2TjU1Q0xkRTBhL3pyQWdjRXowejJnQzQrT0lkWlBoRFRnWW1iNDIvWHArclRNOE5PVTU5T0JYL0FLcktKWEpmVVFUUjQzZjNocExPSVJhVjBmY21rc2xIMHo3bkVKaUdlYlBIWGw4SnRBRUUwSmphR1dNZ1hWYnZlTTN2RzQ5WVdFZkR1UDVsbG9wNjYzMDdRc0I2ZEZ3THJTYTR3bXozakU3ZGxtczZabCtWK09zdGk0YlRiaFVxVktaVExaYkxmb1Z6NDRBc0tNc1U4SU11WVk4bzRCTGVSNDB5bVU4S1pyeTc4MjBwREZtTmVXamtYTCt2Y3Nsa3VVU3VUWGhmSFJIMWZkb1EzSjVMZmVYcEQwZmlPVURuci9VRHNSNmluN2kwWVhTVy9sN3pQQksybktXZExJbys0Tk9GbkNpTEhqcDRFRzJwM29VWTRnR0xKWDJtMHMrNDArdVNvR2ViYm1Ia3B2Q1liR3YrUjJUWW5SMFdCRkJYSzlQM0Jna1J1MERGbTRkWWMxL0pnNkZtY2Y3QXdBSEkzN2Q1YXFieTVUcGpXVk10MGF6cytVSEhUaGcxcWRrZW1LL3lJMlY5akN1UzNrUkpVcXRZcUV6d1poalJVV1ROSkZZZGc3TXlNR05HNFBIcnk3L2FXclJBZUFmMU1NTlhNaldvZEJ2cVI1Y0FPem9ua3hJN3VLZ3RpMURIZjlSK2hMMi9jdzV2S2FXMzlwaVh5N2pBTUlacnJySDF5ZXJGUFJHT2FzUUlXVzFseGtlcUhHOUNKdDR3eENpRHU4SHBkeS9PMEZidDJwU2NhcTdCbFlTcmVXWS9jRjdDa0tyN25XQUwzbExtUkxhWlpvczZGTUdaNHNwb2hLM2VJcW43SzVmSmI5TXlmUnVWTCt3T1lsSEppV1FiNExVb2FHcnUrRVNiU2pxZUhqS0JDQzU2TTVoNHRtMXZYajFnOUZSd0IxNnhYSkJ5cHIyOElTMm10bUhkcldNbTJXVTRMSUZSVUdhMzdROG9HYnJRTTM0eTV3dDBOYjEzbWdJSzlRN25YZEF0ZmN6dEF5NTI3LzdMZm8weW5oVXhNYy9oS1NDaTZtbU5NeXpRNElBS0pscndMR0VUd09lbldMTW5oUmttNHdRQXM0SDI0TE51VWJ5WFdvdURWUkRhOW5VbGVvUGdMS0paMTRuWjNUMTZlTEJnRllXZzI2YnNWQ1prQmxwZld3K3NXbEQ1YU1YNHhLcWpVZm51WWdOOWZzS2xjNkZDT0FhTjE0YWF5OVlZSTVZRjBUTnRuVjZ1N3crRU1UVUl1SGgxam1WcUI0N253TVFPS0JNS3FWSHFoQTdJRXBPbU1rd1dlM3Q0ZHZzYkpaekJjSFdSZkJWbFhGUVdBWHJCVmN0dWwxQmI0dWpFVXI3ZmJrcmx2TmZkM05PTndPRjhGeStHT0M1UmIwS3VnT2xtdXhQQ0RXMEtoMU52Q1pIbGRDbFRQbjNsRGJlMi9XRHJoYjBOeG9saHNsK2VKVVc3Sm53Z2xKbkc4RzY5V05TSURGR0lpd3JncmMwQ0xDcEZONkxYMGpsU0JickpjWHdMTlhaOGZDQVdDTzJrQm42dVBvRHJ1VllHUW1XQ0xiMFB6S2tDVThMcG1uRE5FbW9QaG5yQXZFS2NMSVhIcGJmcWY1eUVya3BsUDBOZWNLZ1d4VXZTTElLcWpwTVBycXRXY1IxOHp4TXNKVjZzUzBadkVTN1hXZWpOVlZCcWd3OU5KRGJCWkxhOGFxZTAwMDZNc2dwNWJ0Q3dvQlI0ZElaK08wS1VXM2pmMlJ3QW1YZU5BMEhvTm5xTVJTSkxEb2d5eFRSKytDSk9DQUJMTG5zSDlseXFKQXV0dndHWVdxTlBybHpyYndOamNEMlFqaHR2dUxnSmV5NjJmNHltMUMwblQrSDgvYjNyRFZoaEpIQlptQ00xRFZ1QjBocFVPT0Ezd0FZeCt6MWhpRnBva3lJL1VHR0dHR1dXR0dHR3ozOUJsbGxsbGxscjVzV3JYTkc2dWdmWER0RThKMy9venY4QTBaMy9BS003djBaM2ZvdzYvd0JHZC82TU9yOUdkLzZNNzMwWjNmb3p1L1JuZCtqTzU5R2R6Nk03djBZZFQ2TW9EVjZYak0zaERyMDd3eHUwZHFsTFRBVnRicmIwaERhYU5DK1UxVFN6V0E3Uk5iK3N2L0hhL3dDNnhCa0w4SFk3bTlSK3NOV3F4MEdHdDVXQzlXQkRWcTF4NCtNRkliUGM2enRjZmMveVdaWFRGR20vcERaZW9PeVhwNVRJZlVaNWJsOGJseStORW9tT0Z3Y0dDczBJYWNHcXhVOUtUUHdpYXhRSzBnckdOWm1ucURoMTcveUJBcmlXRlN0b1hoclU0M3gxNUg2NnRoZHpVaUI0bTNUVGJ4bXJlNkdNUmFzOGIwUmRLRFczdGE4WmVDcGpwNTZuVHJMWTZlaU8wQWNhUHAzTGx5NWN2bU8vQ2piZTVEZlM2OW5lSVNWZUphVnEvTXpyd3RLWjFkaHJGN043K1JvU2lPK2VvT3hpNFBPQXJnQ056N0dUNzFEWG9LYjk1UjBXbzJibTFNWTNVUHlUS05TeDhUWDdJMDRqZWEzZUdpTVB1NXJSRWJ3czNLVFZSQm9NY0lMNDFlSmJyQVNWWit5SlpQYWYrRmhlZnM1clViVmRWbGhMZERSVXllQXkzRy9kbVJRRFp6UjEva1dhK2gvUEdGOXJYeUljdUF5bUZBaGRtb1doMU1UTTF3cHlnUHhlakZaMDR4N1NybXlXcEFTNXYxOUk1VVBEMzN2eGhFS0V1azNtbnZCaWpvTzd2anJGNlVOYTJydEVDempZOVNYZFFYN0VFRUVFRUVFRmxGRUVFRUVFbnJDSDNOUUxXNjN5dXN0aDI1V0EyZ2s5dUJacy9QakRBdEgxZHY3Q1BRSmZDbGNCVThEYnhtU1B3RDl5cURDSmZKY0FUWmsyZWxQMlNTUVFXV1dXVVVRU1dXV1NTUTBHenFXbmsxaEc2Vk4zWDIxaEhJZEx4VHIyaTBVcWpwcmtpbjQ2ZDY1QkRLWlZDRjBidjNHWW50WVozeDVhY2FVSm8wd1FHYlNtMnJwc0FzQ1dOV1BNRUVFRUYySDBrRUVFRUVFRUVGaFNCZmd3aVJjV2pOVmVOY3hLZytzQUZ0dXphK25nVHVDSDExakYzWUhaRDV1WW1TZ2lYYUh3SWVGMHY5QkdvcXk2M2E4R3dnMVhCR2hzUTc5U3VuUWRKWHNJKytZSTRqYUl6Z0xPdzE5dUlYajc0VjFob2V2RFM2bXpZbG9XaUF3R2g5ZUtLS0tLS0xMTExMS0tKSGdFU003V21XamJXMktSb1ZDcklDOG9JWHBOVVhERGhMeWFSS0FZTVh6VVAxY2NhNFd5MmV3KzAzc1AydnNHcURqdHJtcXF1bWJ1SlhVdnQxMFhURkpwdk5oUzlkZUhSMTZ3SzRMYjdFalRPU3RvQ2tRSmRTb1dKVXZSWUdxVk50UlJtc1hmUnFBRmFkLzRHZW0zTHBFQmZTWWVDbDk4SHBMTXJqTDB2ckxRRkZLNkhpK013UkYzZlVsMHRqRzcybWxIVlIwSVNpcjI4SW1vcGZoZUFpcVpzaHpidlVRaG05VHYzZkNVeW12VkdObVBDQmFwc2Q0aUxnZEJla3NuaTN4TkNPc2lrVHBvK2NZWUZXNmIzL0pxQkNOZm1OOVpYNHhMbHo0WG81cjBDYUNVK1ptS0R0QTU4WTI3eXU0dE1ORG5sVlo2Nkc4ZE5lYmhhU2w0T3BvWmhGUU1DWGNBS2VGeXBVd09uSzZiV2VMUjFocTNRWjB1cnZUWHZmS3JDbEtlZVB4RFhlZndpd2h1WXZ2QXJjTHBPa1htdjU0c1N6WGw2d0VBeTRSWC9TTkh1YmoyOHAxN25YemhxMXc2UU9QdW44dVpBYUJWN0dXRXFqQndkSFRHdmxWa3ZsT09EaXkrbWNkTGxweHE0UzdWZVEzMjFoYXMyQUhLMmxDY1REeHA0Yjd3bHJ4Q0FER1d5MDYzVmVWM0xXd2xZVEkwbWVVbXVEYjR2K1Jyb2xIYWMyK3loNDBBNnFjRkd2UTdSTTg3em16dzBJVkFTNW5oajJ6N2J3MzJpeDhGZTZSUW1uSWJYcGlYT1FWNXNHK1JNY1M0MVdHMm9zRVhUR2txVWRwcWhCZEhMY0tycFRpeXphbXpwTFFpQmh5bXhwc2VUdE5IL1NPUEszN2FieXRDbzhMZzB1RHZwckxFaEZDeTZpaFo0WEt0MVlVYzNkWXEvVWlTc2dDblFhVzlOK3ZMcW1ZUFBYMnViQVVXVWowWnZ5bGdTZHFiaE5VR0IyTklxYktwanhhaG1Ob1FXazlvNmt5VzY5dmFLWXdWWG1zb0QrMDZWMVlwT0RWdVhBdk9NWThFTVpOeitVRllSaXVxTTF5RWswMUtiWFlZSWxuQXdPdVVHeXFycGNOcjRwZ2t1U1lVSFI2Y2xEQldnNWVtREhuTVhOMWFYVXR3YlZwTWNoaGc1UXB0aXpyVVhqQTJhZGRDcXZXSWJMVXM1MGNEVTNtTjVpMXdOMDNwdDFtWDdUZzYzc3E5ZTNLZ3JOUFZyN1hHcFJFc0xWWHJHaGt1bUt1Z2NwMEk3WXNDeVUyWWxRRlF5NWJDTGhoaHI2NjVYSDJIL2s3SHRZdWx6eFY5MGpScUg0dFB6d3h1aTM2T2VRdUtRbS81VWF2ZEFWYU5Xb05hMVNJV1EyTllvUm9wb203eXIweVY2Ym50S2owYytkZnFkQmNIRnZudEVNZ0NGU3FGMnZ6ZFloM1hIck9tNEhqUGEvekxJWkREUCtrYzdBTkdlM1N0NVRubkcvSXpBSm1BYzk3bW1MZlpkN2QyTmtBWk9McE5EeGxSQ2R0TUg5aFVGTXVkWmMwVjVTSWxZWHgrRjZPYi9lNmdLOUVBN05mMG9ocU5WdldrVk5DOE1IMTE4R1kxYi9nUXdqWTJoZEFDOThNRVhSM3EzbFluY2ZRLzJKN0cvdHdYQlRyTCtKK2RpRXV2Ny9oTHQzQjRCckJPakJvSTBZZFNhM3NLcDRZSmFkRWR2VWlabVJHMHZEZmg3NTVqNVhxakgxUzlhSVh3blJPbnFSMXZENmw4b0FUaG0wVzM3RTBVdWRqUWhyV3VZcXVUdVBMQ0RRcUd4ajMyaW5vT2lpKzN1bW9hUFhjMXRxMUF3VEF2aWVydXdvSzRZaHBOOVkyMWxyNGdMeWJ6Q2t1RjhwcEswM0xrOVhWOUppR2pDM0M0am00L0Y5SE1YRmdIeHl5TmRhMTQ1cG9MTmZXRTI4eE1CODZNdVJKejB5RUN6V2Q3d21lYlVYeHUzdnloc1phL0JMMVpOdC9LQ2cyYVdiZU1ySTgwYUNBOVlDS3RQeDBEeU12QTlBQTlZWU5DSHBHbVlsM2RwL0V1Q3M2VjI2V0JrV05RcE9oNDRtTndQWDFoaE0rVUlHNFpzUER6YU1kM0FBZHhtTHRSNm5ENVRvOHkzUXI4K1JPNzlQSzk1K1E2NGxYdEpoNTJlVEFQeU1JbStWZWFCN3NBRGRpaEtYVDBSNWFnN3Y3RVJaWXBpbEpGTjNhSVJZUmROUWk5ZWtWYjFZaU5pZ2htTWhkZHdHNnFvTERrYlEraGZKZkgyMzJpOWgrdDBjK3pDeGhrY2lzTU9LYzJReFNBYXNuaVlyYW9KUkxZSlBSYVVQQklxck80ODRzdDQyZGJsam00S2F1cFFWcmVLbEhZVVpXblBDMHpqOVJHbUpYSFdLVW9WWVMrcWgxRjZwZVFyNCtFbnE5NGJRd1dhMS9ZVzJLWk55dXN3Q0QwNlJjL3hqbVNxak5XTk84MlJrdys1cUs5VHgwSmZZQzJOWFk3Vm5NQXJEZmlyYTYyaFdyQlRTb01PZDNhcmtlOWFTcVBhTXRvYllGb3I5UVlOZ3NPN293aXUxeTcwZ0dOdVB3UFJ6QTlNcTFxTlo1Nmh2Mm1PZ2F0aWxsRkwyeUJsc1ZFbERwQmJSUnJhekRXcXhkSjRpN0FzbFVSQ3FSU2xXeTFqVUlvZEVzVlFHOTNVMzJsM1lXUzJDUnhScUVvQTdkOXZiUDVlUjJjRDBxbm1zRVJKVzB6Ylg5djhnZGZHSVFaZnpLQ05IaFZUSkVUZ25VVXg3ekl1QUhoRTRPdjBtamo3NTVqSlZYVzFxeExxQXhwQ3FiQUZhMU5jWWhFcUNqckJWbURIVVNXeXZGSnJtMVc5K2xRcVFzTFVTK0VOSWRiajNsU3NCb2dDOEZiMnNwaXArdXQwWHZkYXgwUktMMUxyUTgrUW9WSWs5R1pVeXZWbjVnZmxNcUxmN2xkRjlvVkxRb2JBMHJ4aU9aZzdxVmwzZHdBU2EybmpLdlYrTGczS3N2MXp1T25pLzNTSHRDbVhJRnc2MWhZaEFHdDIvMmFPSHhmUnpWZzlvMkxOV3pmMmpoZUFMWUswb3NzcmNSbVdSR3BRQmlCWjBxMU9aYlpLc1hxOXhvRlZHbWd3MHNMSzBXdkFqdTQ0YU55ZFhYRUp6WVZxVjBXaHByQ0FJZHlGRjlpMnZWNXZBV0JycU5ZZTUrWWpLVjFlaCsyRXFoc2NLMk9nL0ZIYW9xSyt5WCtZMjhHZ2ZVbG1JcEpaTHVPdFJSLzBFZE9JbjBuWmtlaFhENVRvODJJSmtLMXRwZDQxdVBzQkdGT0E2dFVGYnpDZG9ndVVFc3RkRHNGN3pKaHAwNnFsWDBhMTd4WUFoZFVDQWhoeUdxcFZVZFhKaDNWM3ZqTllxTm5lV3JOYlViWXFFUGJMUFZkL3R5QkVmZy91Q2FTa3VxQ1RBQ1doaUQwMWxLbWwxQmhkUUtKMGl4YXdnc1psRlJFQVhHckxKZkRUamN2alpLSmNzNWZZY3FwVHFodEI2RkpuclArUkU2UXN1cnJDTjE2ZGVMMTZES3VnUXpEQnY4QTAvYjZSTTlzdHIwTVMyN2x3N0pkbm8yUTZBblE2ZVRieDBnM3lldy9ZKzFqb1JLcUd4MjFoOUxxb3VjTUxieTZ3VGU1VWFOMm1WTXByTFc2S3FFY1ZxMml0S01XUkFKVzdRWXRxbTBqaWhGVHJlRjkxUFFpUVNrTkFDM04zVU9xa3RDeU5YV3RrRjZRUkhKRmt0ckc5am1MU3dNTFN1am9vMjZ4QUxHdDNwMVhxd0FRSVd6U3JzYnZPQ0VYcjEySThGQkdCemJjcDBsMEtWRVlGQ0NiR0E3bDM2SEJSTU9qYWFRdDNsTkIxN0JFYmNEVVhxTlN4eGRiM0NJNlA1NlF1T1Y2dnpNcFEwNnZHQUJGMWhWMzNoZTRuakd2bEtNRG5veGphTUJIRlRVUkpMTjAxZm00bTFBV2crQ3BjR2x1OWk5YWg5dW1uK3NzWmcwTzBFeHgrTjZPQlhsWFBtRFh2R05CQWxRR0tidmIzaHBTUzdQTVhjTHNRczZicUtxc3VSN1F4SU9LaTBvM1RuU1BZSEpidU5wbzRmYUptd3hiU0ZFTHczMDZ3UzdyWk1LRk9jNDZ4N0ZpbHVRM05MdDE3UnBWQUxxTXYzV1NBVUlDckNnYytwNGt1RnF5NERFdlFzbHF2VUxHT0J0cmNwYW9NVkYyV3Eya2FGS1kwZlhMeXhBTUl4amVJUFdDbDAxUVVLaFNPMFFsd3RlczB1WjRhTXFOeGdlTVJnS3FiUWpYYzY4ZmZ2QVVDMkpLVnE3R3V1em8zckx4Nm5rS2VEVHZFVlIxQ3BUYWx0TnJ2RUdic2piZmFubzNyWFhFc2ZRVm1TcUs2bUtZdTBuUU5BdDR3cWpEMWkzc290U0lqUU5xT2t6a0JyQlJTNmpzN0VaeVpDbmZwZlJzelVzNkZSTHVrZXRGd2dRaWlLV3pCV2NqdkhIZ1ZsQnA2TjRTSWFTeVdzbGQ3UnV6SGpIUkNWR3JlbTR3N3h5N0ZwNWpBaTZLSkxVTG1qZGZ5dzM4bHZxbGxyc21wTU10MWtETUxNZFFRNUowUkNqcmNvc1dJZDdVMTNxbUFQWVBZM0YwTW9kaGdlc2VKUVRKZ01Ta3Z2amhaUGkramtxamdFd2VpM3UzQkJwN1dMTzgwMHRvajFBN2M1cDExeG5NRUoxc3RDMXUrdVJjWk9MUjB5ZTVXQ1dSUjRDaXFYVlM4c0pVYUE3aWlyN0JLMVNpV2lWbDZXOUk0RjFxeFVLMXdNSVpyTEs1RkZYdGVhSUdwREphMXZWNDdpSDRJS1hYMUlOb1h6SVM0TlNzR0d4cUd1TkU2OXlINk52K1FnSmtwaGwvTWRXMTRUcjNxUXpGL21BcUVQdnNsMXl6MVJrbElyTEhyaUhENVRvOGlWS1JmaGpRZUpzYUt5dEx0TDlJdGxvYW5xV1BLVzI4UUlWdzNLc0J2UWl1VldiS0dqWUxzNndScWd5T1RUVFM0YVZRQzZqTDkxa2dGQ0Fxd29IUHFlSkZtc0NxaUM5SEdOS1pydzJ5MkZsRHNhc3BLbGRhbDd0OEE4VndPajNZbDhVdHNPWlNyMGdKa3pGYkdZZFo4b1pZS1ZLa3F5VUlKb2pRd05vYVRGbFRQMGFseXBYTDdUamtKUzNXcFptbXVsZkJ0NHVlYjdhcUh2ZFE4RFY3OHlaTEczMTNlVGJ0OVlUVHo3Q0dYZ3RhNjFyTzBZclVydTdUR00wVTIzWVp6bTRxc1l3em82MUR4eTJ5bFdBMTFEZVlGb3FCYU9HN3RnN3FpelhTdGFBQUhBOVh4WXNVWFVrdDNPd3kxcXhIZW5oYm9VcXh2QStvenZaVmJCNmJ3d3JqMmJ4dHVNQ215NGRJdVJsR2NGUEdyT2wxSE9ScDN5R3FzS0MzVlJEMVpYVlJzZXRTdGhRV0FLdFdyd05pVUFJTWF4M1lJVHVIc3ltOUg2bWdKYTZOL0dBZE9rVHJjbnJpRXNzMEtoYWt1bDQ4b0FWT3pUNTBtcnJXL1R4N1FuZi9BQjcrRXB4RGRXN3NYS2lsK0hXb0JLWWx0Tk5aWDdRN3ZBbDk1TG93UWFwZE10VFVnVVZ4K0Y2T0RENnI0UEtBQ0FTclZoVFhOMHI3eTQ3Y0ZPTXQ2cGxMR2ppeUNONExXc3MxK0JQTEtBaktNdWFVaW0xYnZLRCtRZ0ZyMHNtSHdNSlMvQXRtaVhWYlU4OTFEMFJIaHBkK1JwM3FXYUxCc28wRmhlWG5sbDJpYmFyS2huZTJNb1dSUktWL0FscGtQV2VnMW80OGJJNjJBRDQxbUR2dnNRaHFPa3dWNkI4MjB0dXBBbU8xUk9pSG9oajZDK0Ewd1JJVTl2ZmxCV29tVHBEYldvc3ZNQ0lFaTZjZHA3dC9Ed2FCdURWbzNHeGVMTlFjSnFZWitYRDJERWJTcUhrV3ZSQ1hnTnFMb0dIT3lLT1llQ2kxWWExMVlvT3BkQXJXbzZ2QjZyQ0RrTjBXVFlNUXk4OGFXQmh6c2d3WWc1ZU5hdnd1M3hKc3dRUEFCUGNvUHlPOE5uOHFqWnZqckZzOHQ1ZEVLMjkvTkhlTlU5Q2VNSUE1UTBpSUlNTkVMN1dYc0NtUytzMVNJQW0ybHY0bHV0Q2VxLzVEYVF2SGFzcnJZaFRvektYaWhmV0F5RmNLbnhmUnlHSnRweHR4d2RJZDlrWjE4L29RMFhxNk9saVpiMStyRnhxU0dqWWcxcjhKZ3lWUGVpM1dkeXg0VE0yVTB1b21BWFZsczdhRHJjS09laGJtVlZxYTVTa0ZDNjkxZ0JsQXFWUUN2Vko1ckpCckdMTkpiWkZFcG16cTIwY2FaNG02NEg4c2NORWJWRVBqYTFldGVEcjVNQkpZNmNtRlB4QXhtd1BnaG93dTlEWTYxdExnb1phODlQekRsTkRYOGZtRE5PZ1FBR2RucExVczBTT01hQitEQk85L2VQeW5SNVBnT2pLZTE1RmpQb3ZwS1NJQ3RPNHg1SXh1VGtsWEJXc2FOMVowaWxjczFmbGVXdGRwUzFhKy9XOE5YamNMdG4yMlhma2FkNmxtaXdiS05CWVhsNTVZQnRXQ3Fxd3J4dGlGeXJyeHVuaFpBQW9tbWh5NkhIRW1TOUd5QzJSbHlVVGdMRkpSU1VOQkNDa2xOMkZuaExScEN1T2txQm1wbHZBSTZzbytuYnordzRaeHFTSG9ncExNdXN0ODMyanFWZVFzZHkwVjhWdmdhb0JyR3E3ZEEzWXRrRDF5Zm12YUROZzNjZWp3RlcwdmhvK3BjT1B0RTdQcDAvYTdCMytzV3p5WVZ0dktHTklyUXJvZW4rUms0dFpYcjBneFpqU21vbEJ2dkhtZnFXaGZhNmNOWEtvdWVrT0oyWlJIZGdXZ2RsNmRvME14UThwZUVNbjRnQ2pZM0E4MDk0dEhTWU9UNFhvK3hZZkx3NjFka0s0Uklqdm5YcEM3Q0FHc0E0STlwWWVzTm0ycjIyZ2RlRlFRcGpON08yMDE4MTBobStzeGkwZUFpbFd5dmZrOTIvbHh1ZC9PTDFxcjk0Z242TlI0aW1WOWNvaWd2ZEZ2dmNYaW05TXNkSFlZcUFsdGFDVVVqaTF1YjNxd3V5dWtTOEZGMmpUb0VXdGFBRXJDTmxyTjlUcXdLWTRKVG90VjEySUlRVUJaa3AwWjBERlI2ZDJZOHhpOXV1OEhGWlZFdTI5clZLN3lDR1JLTnJlaGNVQ3c3SlZZUnpZcm8zR05WS0Fjb3ZLVmU3dkFBb2xzNEMram9sUzEzZCtWeGJDdEF0MWUybW1ZS0xxa0thMU9oUGloR282YllSNk80YWowWldHaHZ4UFh3cVZDWGtGdlRmOEFjOWQ0a2RYYTlMWThza3NkQ0JlZlh4aFd0cmZicW0ycUdyMHZhV1h2SmIzWCtSWGVCcFBpK2o3RlIydW53ZjhBWXRkNnFaclcxMHFPQmh1elk5UzNTQmR0ZmdtOFlEMUhwRnFQdUcyTXcxQUk1bnpDYU81Z1lib1REczZtTnBoQXNybzFwa3Z3Y3dJVnRZMTExMTY2d0F6VXJmcHA2WEJjcFFMUlgrUUJkaHJ4Y1I1cmo3MzhIN0hSMUtlZXo1TUhQQlI4cFF3WGlJZlJMZ1hBN2FSbXFHNEVXM0VWcVlKQ2xNdEpaYUpiZldPRGtONDhsY2xjbU9QdE9HT3UxTURWYlQ0bCtva0ZOVklQRnJsK1ZKMUhyamliaDFlcXZCVGRrUFd2M3hScmRlbzQreGNPejZad1V2YW9yY3E2bldkLzZmeE8vd0RUK0ozdnc3VHZmaDJuZmVrTzkrSGFkLzZmeE8vOVA0bmUrbjhRNi8wL2lkejZmeE85OVA0bmYrbjhUdjhBMC9pZC93RER0TzU5UDRuZStuOFRlalJRVjEwQ0xCejE4WmVISEJGVXhFZ01oVEN1Z2tKbFY5VDJoVU1IaExZUXF1OTI3eS8xZm1qY3UyUEFJVmRKYkJORy9hQVJ5RE1NRnB4dWFzTXhqZEZYOWoxVlZWVlptWmxWV3M5OFlWRFd1MTRsSXJJNnpOTGlnUmd2YVUrU1NWQzBDQkw2SlltZDRFWjFxVThkN0RkWFY0VFducjA1TlhidzM0blZ2d00zNEhhOFR1M2h2RGVGMVdObVRHNVZJNU9OMFZIV0pxdXF0RlhEYnFFdGRBb2wzWnZ0alJadHdwZlBkbDhHTEJFRG82UFNibHBLNk5mRjBtcnFRYjVUckcrSzRTZzdzOEttaFU2OWdZM1JWMWVycjdGVlZWVlZWVlZWbWNFWTEvVXVBRWNDWHJFeTlyNmhFZTBKODdFYlNDQlZnRDBYZUd4czZEb0d5bTdGQ3ZabDVsZll3cFNQR09TdCtrUnUxODVlRnRNQ0ttUHBlT3NxUXk2djdZQVd6VTlYL09OemNjajBLODNDYnczaHZEZUc4TjRidzNodkRlRzhONGJ3M2h2RGVHNU4xR1Z2WFFxZG1EVUJHVXFVWW1lY0xJWnNkUGhLOURPc0VzNHVWc1lZMWpZb0lWd1Z2TnR5bS9MVW80KzA1TjdseS9lMy9aeCtWNDhQY2NUNUhvNCt4Y25aOUNwVXFWOUt6aFRLaFZjY3lvRUJaQUs4MDEzZ0JXSGhLeFA0aFhlakJsMGloVlZhUFNGUTJkWWErUUdZczNuV0tQRjZlVVFFY3RmOGorWnY4UmlGbHRCTFVkSEhYa3RsdkMvcEhBc21zd2tTbThuY0VLcElsUjBtc0pIUXdLaERTVU1xdUJORGpua3d5amtvNFhMNDN5VVM0WTBoM2hpTVA2N3FsbCtFVE55dFJWbVl1V28wWG5YZFNWN1FDVTQzMmhyQ0VvMW1QZndlczB1ZWZVTE5CblZKOTFuMXZXcDJ4VVBZNnZFaTNwd3RtWlR6NCtnU29KcFQxaWhIWlBXVWZjblJzakFDUFJBaUtUTDNZbFd1QjEvT2svNmgrSnN6OVlHci9JU3JWOUdLbG9iVy93QVJDYndTMzhKWjlodHlHbkcxaGlnRWpMaUJnMjA3eWd1RkpURTEvYUpXTWhKWENqRlNYTGxrdmd5dVVsa3M1L1ljbTl5NWZ2Yi9BTE9QeXZIaDdqaWZJOUhIMkxreVdmUXVYTDRWejdjRGd3NFZ3WW1uYXFpN3VBQ1hvU3BMOFlxRys2QTBvOTVua09qUERHTU5jWHZIWmlPcWJkbzNmeE1zQmtQNWd6ZEZtSlhET3gwNytQSjMraHB6VndEaVk0VVN3cnFnTzZJNjlvNHRNR3h6RXQ3NEZsRXNoTDd4SEN3dy9SMjVNOGhqbHF4SWNFVlZLRlo4TDVQZGRIUmxCWkRnMXhQT0syN1lRbExDWUtZMVRVbVhkOGFacHdybXQrcFRHcGs4U0JLbVV6NHhYVHV3WWNDcGNqd21yUjRIVW1zR0tpQzZuV2VFYXF4alRvaU5DMlZIZHpYMDFsMks5bkVLK2xSejJUVGpyQVhtVXk3U3dpUWdMMWduV0hCVUkwVnFZcExLSlVvbFMrUStwN1RrM3VYTDk3ZjluSDVYanc5eHhQa2VqajdGdzYrcG5rOGVCd09HM0ZaTHZsYlFsRDR6ZjlwZEl1RUNXL2FBMHFIdkUzQXVZalJKVFZzNlpnV3p1dmFDaGhXN3RMamhmYUYzVjlYTHN5c2MyM0tTM2lZNWsxam0rOEhIZCtNdEtCY1pyaEZBVkxZSFprVTAzYzRKa3ZDZjFESlZUcXk0U2lWS1Bvdk1QT3lKMzlSNmpxTXhkTm0vSjIxUTdNTzlVVXYxOUpSL2RoOVRXNGdsVkE0QWNWMFoxaXJ6M3lWTWNsY2xjcEdIOHhpcWRRZUQ2OU1NRURSbHFzZEhTQ0V2V1A3TFZVNzZ3WmllQXNSS1BZZzVTdWxHZk5saDdmcTBjdEV4S09GSENpVVNvcWJRYkViZ2hLd01jQUZQQmM3UVNpSzZ2b3ZBNFZ4czV2YWNtOXk1ZnZiL0FMT1B5dkhoN2ppZkk5SEgyTDYzYkxlRnZBNGI4ZkRoZkVsSEZid01LajkxVDFJTkZseXJrWHJFQm5pTmRhaUxNZ0dtR1BvMTljUy9aUGFBTkJ4Mmw4Um9yNlp4UG9EZG1HSjY1bEZtQkxodHJIRlY4Y0VkcWgwMGVzVjFPcGJnQWdHM0hmazI1NytnYWM5Q1psWWNkS0U5R1pjYmRXZWt3UkhUSEFyUWJ4WHhFekJ2Tm50SEkzdkZzOWhOK01CNTgyQkw0MVhWN3krSm5qdEMrVGFYd3FXeTVmMEs0YlN0MWtLSzFqMWxaVWo1UzAwaUdxUFVFdEFQT09VcjBNSG51eWdHaHpXY0xPRkhHaVVjYk9HM0xaeDM0Wk1qTGJnazFCTnBURGRZVGRoajdqMkhKdmN1WDcyLzdPUHl2SGg3amlmSTlISDJMN2JPQzRVUWdwWEthOEJkeXVTampvY2I1UnJqVFBEaG1hY0s0Vk52cE1kWlF5a3FhU3NBNEdrT0ZRNDNjdUhKaVhMNER4czRtYk9UYm1YMUlEdE96RHBRQnB5RXErUTRKeW9yaWNtM0xkY3hjd2F5MzZkSDFOb2FjbW5Hemp0eUNKYS9WbzRXOHRjM3RPUmU1Y3YzdC8yY2ZsZVBEM0hFK1I2T1BzWDJmYnpXQkJJY0hrbzRrMmxjbGNjOENWS2xYTnB0OUMrRng0M0xKY3Nsa3M1SFhpWUpVcXVRNU51ZmJnY0hocENIREJ5SEI1elRsTkpYTml1RmNqcE1WTkdqaTRQdGJPRlAwN1BvM3h2alp3UHNLbEhLYzN0T1RlNWN2M3QvMmNmbGVQRDNIRStSNk9Qc1gydmJ6MmNhbGNLT0ZjTEpubWVTNGNLNXpobG1rdmx4ekd2QTQ2ODFrc2xrczU5dm9aK2h0OU5ocEtsYzFjaHcybFFqck51Ry93RDRkSEY0MXpiVGJoUjlyWEM0UEgybkp2Y3VYNzIvN09QeXZIaDdqaWZJOUhIMkxsN2p3c2xuMXNjNURqWkRoYnlCekVyZ0UxNG5KdnlXUjQ0K2hYS2NiK3hyanR5YmN1MzBiZnI1bDhDdUJNNSs3c2xuSlp3Tkp0d3M0VndPV3VOeS9vV2MrMDIranZ5ZTA1TjdseS9JRStCdmo4THg0ZTQ0aU1iZmhjZll2dHUzZ2NUVGx2SEp0eUdaaXVPL0U0Skx4S25oSzVjelhpODJPVW5lWEw0SDJsUEcrTnZEYmdhUTArb2NwcDlLbmtKYjkzUktPWTBtMzJCcDliV1VmVHNsejJISnZjdVg1aWRTZW9uRUdtcmpxbTc4cnJnVmUyK0FGMFBpdDhOZk5BZUsxTkZJSzlQb202SlpNOEtsU3lXZlRLUHExeE5PRzhaVnpNcVpJTFhDdWErQnhyaFU4Zm9uTGNFajlDNWJMWmN2NkdrMG0zMFhudStTMzYyT1VjL2MyY2xuSlJ5YWNLUHFXeTNsczVhZVN6Nkx5ZTA1TjdsemZJQWZqSGJ5Yk9BUndhSTBubkxzdXZDM3JWeG15clZjcndFaHZmby9mbHlld3pOT08zQ2pqUjlHem1PYzU2bFRiZ2ZWWjRTdUJ4T0RDejZ4RG5YZ1RibTA0azA0VnlEeVhINkJmR2laSXdsZlF2aWNpV1E0NSs2TkpYSVF3UWFtdkIvOFNpVVNwN1RrM3VYTjlZN1dSZEhvOW1MbkQ1WjFPNXlIYm5WMkRxc0FaTjEzVzd5ZXhmUzdPU3lXU3o2VGpnY1Q2QW5sSUQ2YXhtbDVQK0hFdlZQekRMcDRlUHRkL1cwNGh4R1o0NG1uSGE0Y0Rnd2w4RGhjT1M1cHdPR1pVMCtxUXp5TXh5K01PUXhMV0VDbmdjMXluanBEN3lqalp5V2NUa3Y2VDlDamtwK3k5aHlZY2JLazB4NVo0M1haS3lvdGRXM0xicnlVRkh2cWVEcWVVVVh0clEvVDd3TTYvZ3pROXMrOEZCTFlLNWhPMHhLSlJLT0ZFb2xIMXlOZlVxMStYa0x1N0R1eTVoYVlHdSt0OHFJc1luZGJlSWxJYUkwKzByVG0yMTIxK3R6Q2NUWWYyTzU5aThUeEVvNE0yNG5QaVhMdmc4aExlTkVvNFZLSlJ4cVZ5bUp0TG5mbjE1M1NGaHkzTCttUXl3ZnVxT0JwS1B2RDdQMm4ybTlwNDVMT1N5YmN1MzAwdUV1L29yWEIrSUhkL0FqSFcycGFzUXY2RitSd2NFUVR1dEdKK1ZRYXJIYTZ4ZDlFMlR1Y0xxRnRGM0RxVEc4bUd4K1ZuMkpEaFhBYTRzY2h4MjViWms1TjRjaHdzNFd5Mld5M25KYkI1Y3dPQktybUlGa0hrZnJOVkFUNjlIQmh5QldpQ3dOc2wrakZlYmNUaHVvUzh5NWZsZEJIMHlnRld0dklQTnIzSWcwRmUyZnhjdFBoL1dONGZRcjd1dnFhd0NEeVNkejBQOW5jOUQvWjNQUS8yZHowUDluYzlEL1ozUFEvMmR6MFA5bmM5RC9aM1BRLzJkejBQOW5jOUQvWjNQUS8yZHowUDluYzlEL1ozUFEvMmR6MFA5bmM5RC9aM1BRLzJkejBQOW10R2p4OXZzZHVZZm8xanZtRHA1R3JHcHNWTzY4TUgwZmQvdUJCMVQ4eGRwWHZBTzY5blMyNzZIbkttQzVBMTZMNTB3Nk13NmNmaVhmc0VmMDlSMFNZZ2FWMEhSL095ZllCbHdhbFBvMjg5emZodnhPR24yT1BvWENWRzJaR1QvaWQ5NnNBc1l2V1dkL09kNzZzN2oxWjMzcXp2ZlZuZmVyTys5V2Q5NnM3MzFaM3ZxenYvVm5lK3JPLzlXRFhZZU9QV0c3SzhaM3ZxenZmVm5lK3JPNDlXRE1UdGNIR3dQZitNNzMxWjN2cXdkdWdGMWJkZFozSHF6dVBWbmNlck85OVdkeDZzcGN0ZXI5STBqRFRoaVdRVkx0NW03K0FsdlBZOUZWMW5waWZqYmlQTXVJSjVnSGtVWHJCUit1MitvZ29FY3dCMjRQdEdYL0FqUXB2cnhFQ3NFdWVTbEZCVE5LYkc4T1FKWkptcndzTDYxSU1LQ3JzRWxEK0l4QWdnMVplZXJCNURNb3JpL1JzNFd6Ym1wbFAzNXRxNWN0bHN1V3kvcG4zNVFHcWRWY0hiRExPYkFwcHU3MFN0UENhRURMVnE5RDk5TGdRbGV4TDcwQ1IyV3k5NlVGOSt1dVk5K3hkWSs5NnhuU0srd0M5YXZldDY2VHBUOFkzWU5iOWJnYmNPNWQ5bGFRZUl1NkQxSDhKOEV5eVBTYVRhR3U4dVJJSEpLd2IwV2o2enJsczFlZ3VsbkFlODhPNGxhdlRocG1WZU9aZVdEZ0ExUUNnYUd0MldIMy9BTDQ3RnIxRXFGd2ZURCs1aVdHdnJrL21ibUtEK0c1QnBNZWwvQndZY1JmWi9hM0FDclFBNnJwQzZoZGdENG8zN1N1Yks1S1N1dlc1WjQ2OEtuRjlWYTFOM01XNnZRdlN5YndndFZhb3FyZW5BYTNLQTFUcXJnN1lZL2ZZRk5OMzBTdFBDYWVETkxWNkg3aUVvZXhMNzBDUkdWTm5adXB1QkNuVUZkMjZjTkRlSXpxeTZucGY4WTNhR3Q0eGJWZEE4TjEySW1qZVo1NkgzbXRTUTZOWG5zYndRSmZwUVgwTHRZaXdZTjFXdTBMUGJtbEZYcGFqbnFWR2FnMUhVT3RtRW0xRnU5VE5kU2FQUUkxVmoydDNzMW5nTVBqRDNGNmNQSEpWMERxL2p4WUQrSUhzdjNsMWJISWJuNmVwd3M4VmVGVGkrcXRhbS9tTGRYb1hwWk5pZXJ3cTlCYjB2V1l4QWdtRkR2ZHQ2UE9iV1c3MU0xMUo0NnNYUlM2dnRwYy9nQWVZdTduWEQ0enFsTmF4NEZtMVdmREtlcVJRbUNSbVVLdXBpM1pMSXl1YXF4QkdyZG5yT2h3N2wzMlZwTEtIUVdQVS9CUGlHV1RxTXJobmtwbS9KYkFsUXp6RU9PdjViY1BiRS9EL0FBUzNGUENHMnA0bkpxTStCY1lvcDR3a0ZyTzk5STlLa2lhMDRGV2lLclQxZ3UwV2gyek85OUlpTlBIV0RISnY0d0F1dndQWGcrQk9tTWVMaU5HMmJIOWlTTWpwSDdnTzNKcGVQMDl1R2t0bHNhZWpEMG9WNjFDeW85U0NlYUxCMVFDWFVRcUdyV2tBWnZEUXlNeFFvS1FxYlNlUkpvTkZZYXN0eWE2a2JybUIxTEVQZWhmQWc3TWhLVW1JTndSSEpUYUVhVUN0Z284ZVJxYW9jQmxOQ09nd1d1bUVVazBnSlFHZERadGNNNGFxMWdGckEzZ3RRQW9XQ2wrYlBlUHhLWGhsUkJlRVc0RWoxQ0ZOTFJPRFlLSFoyekJ1SzJnVnZhQkxtczczeFRuc3p6dVlieThXZjJGOVBRQmZCVHRCY1ZKcnhlYStOSEN5WHoyOEtlRlAva20yc2NQK3JRaEY5c3RoMEJqd3lRTjN4MDJteWFMZmRIdUVEdzRzanJZMTZOTTY1UThRbjRxVTRhSHFQMUppcXcreFI3cEFQYmg3aVM0S1ZGdFVvcW9FV3JaNEZKK1dPV0l6alRGbVphTGJyVTEyeEF1b0tPeFZDRFNLWUZJM3hVZFZmek5Cd0w2Q3g3TWs4MWVETFZhSWcyWnAzcTRyMnNEeExQeEFkZzhHcWgrRXRWWlQ4TEhzcU1DeFdqdlF2MVV0cHlyMHA3ay80WGlKaDBuRDFNMGUrWWJ6REJqVGErWWs5d2lVT0Z6cGJaN0JFd0xZYWRwOGgwajRUcHdBdi9wUWhFOHN0aDBCUjRaZ2J2anB0TnMwVys2UGNJRkJ4WkhXeHIwYVlSbWkzalIrSzRpeUxBeWpUckxzZzdLVDh3U0RCNlpEOXZPSldyYnU4MzR3ejFwQjRwejZSa2FHQjBNUHlYRlExVzNuQXc5cWlyZUdEdXFmcWEyMGZJYWZtUHFhajBwQTFYUU5kbG5vaWVjMHZoandGUFVQSUxnQ3E5RDB6aXZDSDB5SjVIUHZYRDRqcFB5blRnUDJ0QlBGUVBraUNsU1U5azFKV2lWRWxKWEt5Z3poVnBDN0w3REJOb0I1M0Q2b3N3L0NIcys0UVFOdjFGUHhVOXpMUDdHbHB0eFdta2NjeUszc2xucFhxZzhHWjV6aFhBNWliY2RIeTI0ZTJKMG1nbDlhUDlaYzBOWkIwblFJeis0Y2REazgrRGFGalE2djhtaEpxcjhIaENOaU0rSi9TYW5FaDY2ZVhDbWczbFMxZjVGeWxEVWljcXJVTlBHZkdkSjdQOHVCTkZsNVYvQlNWS0lnMHFqRE15aTZ4bytVMWZGZ3Z4LzFHZ1dTM3QySXJTSzZWait3ZVZNMTc5SHJDcWFoKzRGT3FabFN5T3EyK2lWNlF1Ymg3RVFqUnM4SnBlUDFEaFRLWTYrZm5BQVNWN0tMNHJyQktNRW9XOEVFMFgzZUZMRVJCRnQ0Qk41cGRJTkNGUllTZDZhZkZVanNrdE9HcTdzdmpPaytMNnA4MTF6M3FlWFM5NTFOL2FYOWxrb0l4M0F0S0c0YzErcGlWNGdEb2hHR09WcFlkZkYweFFtMUlmVERVT21sRU5aTmw3ZFVHNkk1cGlVLzZGTjRPNXBCT2o2N1ordUxEbG9sbjFibHN1WHdzLzhBQWROV3kzZ0Zjd3U3NU0xOENCQTBtKzB3Mi9hZW45b094MEgwVWFMaFBscy9nUzY2ejZwUGNTc3hhYWF3Q0sraExaYTVQREFmaGdRYnFpdzBVNWV4SFNNVjVHaTJWMDNodU5HandTa1pNd29GNkszcjNsWFJYT21vZjNISDFGNHg4T1BVL21ETGt3NnZBOU5JMjZVQktNeXpvRGxpL3dDNlFqaXFMQWExcTAwV1YrWEYxMzRJQjJnZklYM3VaL2lLNEpCNlJpYXJlcGhyWGNmRTNQTWxnZXdlZy9zWmQ3VmRRL1NiaytBNlI4SjA0QVNQR2xBb1RjdkF3VGZxUFIvdmlMYTNHWVowdCtvMzVqUkExRmV2YUVLUGdjQUx1LzRQQTBiN0IrRHdSL0tkR0hvWVRCSStzYkZaNTBUOEg0ZUFwOS94SEM4T3krNDRmRWRKK1U2Y0J0VDBlWm9Ibi9aWFRTdjVpL3ltdjhNK1RSMWhUZk9VMFpPUDRiWDFuZkU5QzQ5end2Ukh3L2laWEVtM0Mza3VYTGw0NEduMGRIeTI0ZTJJS1YwWTY0VEcrVWwvaW9LQ3RrL0NmdmdZRFpiL0FEQ2ZxZTdaQUtiRGY0bldEK2poNzFsZzJyOXhCNm52cFBqT2s5bitYQjc1bnYzNEpxK0orNXErTE5vZ1l5alpQendKZDNXb2xzTS9tZXgvZkQ1VHBQWnY2bWo0L3Y2VzNMdFBodXZoVjdLTDRycnpJcFlUZmhQNFo3OUw0enBQaStxZk5kYzk2bjc1K09JeXByK3lQQlhpZDZmTDZJeDN3Wlp3bzVLNFVjTDVhT2MvODAwMEtMSDZCRzRKMyt2OXJHRWRNczZGdlVJTE1yKzhlNU5DYW9QRlE5elBtdXMrNGtCTzdCU05rdWdOYTZ6OEJZZGpzVFJvV25kRDdNRnhiblhXMjdQQlBZZm1pcmdDZ3VwdlVvaWtlSGo3MkQvZURIdG83Tko2cmxiVzRSUldBWm9aRWZOOFlCM0hqeWEva2dOeXdFVW9HVGJJOEhKM1E5V0tqcjZjSEI2Z21wc25STnliMFI5RXQrQ2ZJZEkrRTZQQUNhN2o5d1JyZUh1MWY3V0lFNlpkWjB6NmcvVTlpNU9HdWFxK0U4ek9jTU4rS2hXblk5MExmdFNJZWlmd016L2VUNjNpb01WdkVQeGMyaEdyd0ErdzRIdmFlNG9pS01WTEZnOUtmMUttcDhNUjhKMDREWE1wV2VWNHR5UWR2MlNhOHJSd282S20zNjBOZlF2YTJ2dE1uOHJneTExVFk5NGhybFcrU3RuaXozTWhSdjhBbnkxMlI5aURIQks1U1Z6QjlMNXZMZ1ZHL1QvWUkyQ0VjT2xUTzduU2ozYmpjYVBUV2JOcURQQjZpMXFTazd6WjgvTWRETHExWDUwUFdhdlhvRjZjQXBWYmRsbmlWbVpkdXJtMWpDdXZleG52QVBTRnhWVEhndjhBWjMzdExsNng0cFZ2SGdTMFViSE10T2NyaU5XS2J6Tm9kVmZVNzd4YXgrYk5iZEZYc2YxaFlOaXZlTkpGOE9DbWVBTnRpS0xHV3ZlYVBqKy9yNnhTSFY5R2hkWVQxNFRYeFhYZ0Zja3BJZllQNFo3dEw1em96NHZxbnpYWFBlcCs4Zmppc3FLZk16eG5lbjRuMVE0bWEzREgwam1vNVRUa28vOEFFTk5iY29MVUkzalFYZkJrUzlHQlRvWUNqTFdycTcxaVVaaUlkVk5pZGJSZTRGcXNHU2xWcXFJazErRUFjK2JiT202ejRVdUtnUDhBSUorYTZ4N3prcUEwVjJvQjJjUDRQV0svVko0V3IycUlucUtBT2l0Njk0dXF0Y2xhUUFSZzlVUDVtZlluREIrL0NGOWxHM20zMGNJbHNRZUY2am96eERQbGlUOG9JSTJEbXdjY0dvTEI5WmNMZWgxNllYZUhFMHV5dE9sYUYrTExFQWZBd2dQcXRTdmNDZGN1ZmVvMURsVVhsd05kT0FFRnFFVFJwTHZneUplanN3S05MQVVaYTFkWGVzU29FUkRxckluVzB1K0JhckJrcFUxV0xsaHJid0E2K2JiRWJrTEJlZ2xlOGJ1MDBRTlJYN1JyT1poblMzNmg5YVpxbVpZRUwzYlJzcitCNHhhcXI4aHJYbk5mb1hVYTQ5UVgyWUtpRkZLczhDT2JpdThzYzIySnRkZWpEaGlHK2xPYWF1a1lqKzFpYld5ckRXZ0UrUDJUWDliNk9hUFY5OWJyZlNvVEdDTkxvQzY4TEgxcUNnanRWT0YzWFR0Y3Y4RHVtbXdQRUx2eDRVamdUcmx6N3BHb01xaTh1QnJweEhxU3lxUEp0UHlrMU9GYUxyUmJkTFJjZnZhMW1ocm9HVlllZUFBNkFlMVpIejB5aXRhTDk3aSswblhkYnIyU0dydXNzTEpkV3JGdks2aEZadTZucXVyNFlBNEU4WlgwejZXajViZlQrVTY4UGV2MmVqNC92NkZFbzRiOHI2ek84YVQzU0dsb0R1RFNtemRxNkpEVnlIRFlYUk1FTENNajhmRUJlSzB0S3RqUDFaWGRGQjNXZ2xDeEtPalJaNjhsSkQ3Qi9ERTB4M0FxUGN3VmJWNGl0ektDYmFUS2lnS056NXJybnZVMWhxSERDSDYyZzBuY0ZBb3hJNkQxcmdlYlJLR3lidFpENzBuVklxd0phNkN3WHNMbUxNZ1p4RmFiaGRJWFlhdzk2QURVYXZZbzhRUUQzOUZDOFI1OXZvM3lHbkNqL3dBUTAwY2xuRmx0cTZpajdTMUo3bC9NdlJTU3M3YktUMFdXZlFyaHB4MlJ5dnA4amhqRzFvYVM5Q0ZpcGJXbWhlOVMrS1BVeHhWcTNKWm9YVkRRdUNsSm90MDhPbkNtOXFuUzVmTnd1VnYrZ3E5TGxxVmwvZ2JqVDdTeUI3bC9QQUplS3VvbyswdUFlNnY1aDVLU1ZqWnNwUFJlUjQybWVpMWVsMXdTZEFoQjZERktyYkdyVjdrL0V0dFhWVmZWNXFRN2ZCNlhYRy94RzQwKzBTc1BjL2xENnBkU3VGdjJ2d2VYMC9sT3ZEM3I5bnBlUEp0eUduRTRZNDI2b0s5dzZuaU9ZMjZ2a3pmb1piMFlEWGFaYmFGRGVqcElPUU95NkZHejJHcmdxUEtKbTNIZ0RGbDZkUUlBdzBROUdNd3dhUWs5Q3AvNnFIaUhWWkp2Vk5oSDdwY2FveEQ2dzBDQ1hzQ2tzWjNFU0h4VU5wU2lwcWFpd2dhVkNVemlyTFJLaGV1SklUVzRZTkNEdEJTeERrckRBejJCV0h2V0hSWkdKNEJpcFl0Qk5hV3BWN1dxR3RnbnE2cGVQZnFyMzg1SXNkN3RLUFVQWml0ejBvTDRLS2ZRQ09MYVg4N0doeTN6WHlXZlIyanpsU0V6L3JKLzFrLzZ5ZjhBV1QvckovMWsvd0Nrbi9XVC9ySi8xay82U2Y4QVdUL3JKLzFrL3dDc24vV1QvckovMWsvNnlDcFNhM05WS2VPME5PYmFHa2VKTjRYekVlU3F1RUhjWUlUWmRub1Bab2tISWlvN0FLT3JhUTA1eG9LeDdIVEFUUXdBMEF3SEN1UzVjWDZJWEs0MUNiY0Q2R3YxejY1OUhYbFYza05hNno1RS9zK1IvcWZHbjlud0ovWjhEL1UrRi9xSC9UL1UrUi9xZkkvMVBpVCt4YXozbjluZmlVWGF2Yy9zK0YvcWZDLzFQaFQrdy82VCt6NFgrcDhML1UrUlA3UG5mNm53UDlUNWsvcytkL3FmTy8xUGxUK3o1MytwOHFmMmZDbjlueXAvWjhLZjJISys4L3ZOcE51QkxlRkhJZWVrM2hTc2R6UHFWNzNLVGp6YVhpazNNcEg1M1QySnA5WUMyUWhHRTJwc3p1TkVTUElCYVZaenhZN1FuZGJmVmxwYmdOMzRTcCtKUVlkRmE5T0dYVlRGS1lxODFRZVN6bXFWem1uMENMeTBSUjlUTVBodjVudzM5ejRiKzRmRGZ6UGhQN253Mzl6NGIrNThOL2MrRy91ZkRmM1BodjdudzM5ejRiKzU4ZC9jK0cvdWZEUDNQaHY3bnh6OXo1NSs1V1VDclN0ZExkczg3eE5Kdk5wUktKUnhKdHhOSnZHR2ZwdTFQVHV0azJTUENkd0dQQTd1Y2czZFJuc0xxOTlDZS9LcTdxM1hnY004YzhINkpYRU9XcHA5SXo5NFo1TGxzcVZMWmJ3TDRWeE9Kdzc4aHB4bzQ2Y3VlR0paeHM0YmNMSlJ3T1hFQ1Z3c0NzZFRVOUdkdDZKMjNvbmJlaUxmSWt3NTFsODVLNEJVYmNLbEVvNDJjbG5MUnkyU3o3UzVmUGJNY1JseTVjdGw4SzRXY2REaFZ3SytvZWJBUkxFN2tWSW13WC9MeVlxZW9DdjBveXVMOEgvQXlySDQrNlFnWjZrdWZTMHV5UG9vK0cvek1PblFhQm9jTFlHNlk0MUtPUzNsUG8weW43anQ5cmJOZnFIRGJrenowU2ptZUZITFJ5VXltR2VCWDFhbWpsWDZKd1p0RDZGbkdqNk8vd0JoMmxQM2hwSGhpWWh6dHVPMWZTSjQ4QjVxaDlnY0RsMit3MG1uMXprcDU5UG83ZlF1SDBLT0JwOUlLbFE0QnkxOVZYNmp4UDhBd2o2MVBQVXJqYnczNURqaUZmUnJISFQ2T1dITmYwQ01PR09Pc1VjcHdQc2Jmc3JlSnd0bS9IdzVOdnJta3M1Tm9hY0xPR2tzbW5KY3Q0M0xoeGVhdVptcml0L1RKZkpvTHkzeG9uLy94QUFyRVFFQUFnRURBd01FQWdNQkFRQUFBQUFCQUJFaEVERkJJRkZoTUhId1FJR1JvYkhCVU5IeDRXRC8yZ0FJQVFNQkFUOFE2TGZRTUJnWWxZbFNwVUs3UkxjWWxMY2doTER4TU1xWnFHSlJ2VUtKdnZvVjBZTjROazQ5SGJvdDZhZnBMT3V0TGwraGZYdHBiRGJvb25PbGFWS2RMWXl1amJvMjBwbE90UFI1bEV0MHgxVnBqb28xdVdkZGZWMGFZaG1Va3BxQktsZEdhaFpxSGVCWE1PbXBYK2VicUt1OGNYb3gxNWhMSnY4QTRuYUhxY1E2ckpjNDlDblhiVDNqMDA2Y1M5S2xhSFRtWWxuK0UyNmJKYk9ZVHZwdnBVek84SCtjdG1SMFZLbGFWS2xhQnFxVVRQUnRLMThUaVZLZFNWMFV5dm9hbEhvMUtKY3M2cU5MbWUwem9hWDAxcnpyVXFWalEwenJqb09tbm9xVWFabGt2WEU0MHViU21WMGtxVWVqN3krNkZQMGRzcVU2MDZFM2xzdGw2RDZ4blN6UzVjdVg5UzBiUzcybHh5cDVuaVVBSUk3UlFaaGRVemdJa0lMbzVRd3pGZFZvUVVFaUxwbDVwbHEyaWlpUXd6Qi9IUnM2MXA0bGRHZXJIUmI5U2RSMTFMaW5xT21qME05T0ptY2RYZlhIWGlYcVptSlpLNmlIcDNlOHdmUTc5WjE1RUhlTWpHOG5lWTNwYWFWc0JkaVhUbUFqUE1zdksyWldpaHMzRXpCcDY2UHE4OFFjQ3luZUNna3BObVdGREdtMEZodmJMYmNtTktoVVpoeVBXdExzcVdwbUMzbmFHTjlXZGszaDBlZlNvbGEwL1cwU29lbzZtMmg2L0hWVXFWS05MZGJsd2xQUlVvMHFWcmNzbGt1VjZXMVBvcWxNejBrNWhpWE41djBGa0xHSGRObTVWbTQ3dHcycHpBQTRTcktWUkszaWxFekwzVWJTaURWRTdyejBHbDlGeS84QUEzQ1ZEU3ZTcVpsc09uZlE2UGZxMjF6S2RhSmcvd0F2WjZ1ZW5Zbk14MFVkRlM5VGJxcjFINlBpWjZUVE90ekhvR1kwbzBvMXJIWFVwbFNwdDlaY3ZwcUZkQnJXaXRLbEhSVXZSMXQ2TDZPTkhTK2k1VEtsOU5mNVAzaHZybm90Z1NwVXFWclpMalBFeE50YWVpeVhLZERiUzVacHhwWDFkT20vUlVwNitKeDAweW1YQkUwenJjSFRqcnYvQUFhMW9la2ROZEZUYnB0bnYwZTg0bkhYWG9ZL3hPSmp2NlZhblJUVUxseStySHBVYW1qRDZIajZIaldqb3BqUEU4NlU2NDlFd2wxTEp4MGJtdkhVTXQwcWNYOVl1Z2ExSFM1Y2ZSVnB4ZWxRNmJlclltTktaN1RHdFRub3RsditMcEJySHA4dzM2YTAybE11V2RkRXJyOTRHcHBSS0pSSzlNcFlYOUpqU25wdjZHdFF4NlpLMFBxK0wwRXBsTXFFWlRLWlRvaXFWQ09VNEdHZ0c5dUxYM0Vka29hUjdjSmxIT3ZQU012U3VtbU91OHBuUFRVeE45Q1hQZVpPaXZxYWZvelBwMlN5V2RGVEhvVmpvcjBTSHJFcjZ0OFMzU3A0bU9xbjBhTkQwanFzK2p1WDFiUzVjdVdkVzYwQS9ERXJqMTJtYlFPQjNEYXJNeEttVUZxSGJnN21ZN2FlZ2JkQnJjZEtsU3BYWDUweksxclhqU3ZTRHNJTEFyTG9GRXA1WmczWG42TTI2YkhsMk13c2EyN3VTVW1SOWlITy9rZjZoeS9vL3dCUWUrZTVDRm9mSCttTkJwODZIUTlPTktKUnJVcld6VGZUTG9hRzF1SVZ1eHcxTGkyV3dpMkNPaFhlWk55TU9XSURTdWNmU2M2Vk1TNmpTWDNRdXQ0UzVhRGMzNnJsK20ra1JCdkZZaFExRzF0dUpnWVlGbUR2QWpUQkJqU242TTBxVjBFdUxDSUNia3BzSWhvVmJzNEdjdWMxVXQwNTRMYmE1OXUzV2EzTDAyNk9Pb3pwN2Ezcm1iNlU5R0o0bCtnREtWckNpaWM2bTBhUkNTcm1NTE15blVhbStsUDBoNDdXS2owZGorMk5RUVBZK2ZlVWdSZ3U3a3dJVmJSWENTcHVubmMrKzVPM3loMy9BTk1VZ1VuUlVvbEVwbFN1dXlXZEZ1bGRHMDM4UXVaUTd5Z0tsc3pCaTNPSmFTNzEzZnA3eEJ1RkNWb0lCcXRvQURFR3oxNjFycHJRSlVBZ1Z1MHJDRzdCc2t2R3dnc2dLczl0NllWRlBPVzhUYU9ET21EejZ0RW9sbWpvZEZTalM2MU5DSUF5YUJTNnRrVk9hRWh0VldPL2w5M1ZUcGZRZEsraXpReHBmVHZMTlBmcHIwZHRoa3ZnbHJOcDRnSTRpMWhHR2dJNWVuejlGeHBXUzNsNFBMTWY5MWYxMkpReDRqd0NFY3ZqNXRGMWdPVlg2aHNsQlFCM1RFbGoybGpaZ2c1QkZqQmtxK1g1aW9LU0hUV3RIVFVxVktaUktKVXJXNDhVT0tCUkxqWnBXYmxtaUpXTFpzdUQ5UHpQTUd5REY2MGxqQWdqcnZFSU5rOTliWmZYVXIwRmFPaW1LMk9FTkVwdTRGYWJhTGhhWW9aMkE3YnY0bUdjQVNvZ3RnaVdldnhvRjZEVU02ckw2cmViUUNoZGF1ZG5MdEZzVUpCVk9xNUxLbStTMlEzOVluRjlWeStyRWRibTh6S21OTG5pYmRRS29sU3BFVExweUdZQmdaVmtTbW9PZzIwZDNPZnB4Sld2Nk83QjMzVnhmbUJLSWpWUkZrdkVzYjdNTGc2Y1RjUHZXOVFLeWU1Qk85V2Y0SlN6d3J4UENsK3lHTytQdkMyUVRHTzUzUDhBWkE2Ymw2V2RkOWR4M1NBdTZqSmZJaVd4VXVHZFFkaUlqb2JFNUprV2ZUdHNHS2xjRVlaaGFJaVh0TWtXZEFxTFJkOUhqVWp0Z1FWQkRHZ3hCQVN5RlNpb3BlcUkrenZCTkVKa1RHWGoxcWpBMXJRaS9RQ3lxTzRiOUlsYTBkTnk5YW5NSnhwWFZqb3A2YVpUcGtHQTZVZDFYdGlXRndGaVVZVzBXTUVoaGczMU80K2lMaDRoenZnNFA5a3VteEhlRGJqYlFZY1dKU1N5NmI0WmlDVnZMOHpJQmZmRXN4ZHc3ZzhQay9pWWNGcXV3N3czR0FBSWxLejRpWERVbDhublBIYzFzbDlkU3BVcVVkVkVxeHl3VzBRQWdMalFnTFVRWU13SlpwamJoeUdLbUdNdXVuUDBkTU9aV2FsaFVPQmxvMHdpeDVoRFNZbFZIWkZIa216UWJQb0tsYTFLRVk3ais1bWk0SWNvVXlsM0FUSmN3N1N3WUMxb3BPN3ZmaVVON3QvcGh0bVdWTjB1SzlaZzZhcCtrSnpDTTVqT05PZERWbk11YnhDUDRKOHpqNW5Iek9QbWNmRTQrWng4emo0bkh4T1BpY2ZFNCtKeDhEajRISHdPUG1jZkU0K0p4aDduRkxXeGRzdHFvd0gyNzljd3cxWStWZGozL2lVQUxvSHR1dzYreXovVTkvSmN4TXplQXFNbzNURERCYWlnbVVYMzdTcGN2dzBOTk1sd3NWYlZpMFN5bUxKOERqNEhId09QZ2NmQTQrQng4RGo0SEh3T1BnY2ZBNCtCeDhEajRISHdPUG1jYlBjMnBaczNjRld5enZvYW92cy8xRkZKS2k0S25ldUZsZUQ0YlBldHN5a0Mrd2h3WUNMbUZlNjdydkFnd1Y0U3l4Wld5OHAvRCt0V3FqYXc1NVdQYWY4QVJncnlldVRKbG9odXo1SEh5T1BrY2ZBNCtCeDhEajRISHpPUGdjZkE0K0J4OERqNEhId09QZ2NFUlpBOXpBanNKYUZaOEhFb2hkWmlwZ21HSE54RUJWUkNZbU5vSFp0RkZoR3hwcFRFV0swY3hDMjIreThqUCtyQlU3RFI3VlY1SjhEajRISHdPUGdjZkE0K1p4OERqNEhId09QZ2NmQTQrQng4RGo0SEh4T0FXU2dGOTJEa3JvVytlWlVhaU5XUXkyVlpMY2FWcFlnR0VnRG1XdU43U3UzUXZ3ME5OTWx3b1ZhbGl6TEtZc254T1BpY2ZFNCtKeDhUajVuSHpPUGtjZkk0K1J4OGpqNW5IeU9QbWNmTTQrUnhRdFZZQ2dIWXJQRzhRY2htVUJhcVdWWUNHbWFpaGlDRUFlREwvUkhuVGt1SHhsMmV6djhBaURhY2ZRMDBvbFM0K2tiYVhwZlh6Q2N6bU00aEhRMW9sR254bloxeGZpNlJWM29GcUpoM0N6S0J1MVYxTFB4MkUwM29TMnVhamJTK3dRMkduWnB3MXRDVGdJTXIySUZxNDJRY0xwdVpTOXJ4SDk0VllTenNVNXRuMnhaczk2d3ZiTzBEa0Vnb2dxb0Y3cXc5bUdGVlN5TEN3MllzeVh2RGJrS0ROdHFCdTRkbzNGQlpFQnVpcm83N1JJQXROR2oyZGwrTG1RZEJZSmF1aGU0OEpyUVhGZDV5L1JSTjJDb3I2Tng0Y2ZxTVJUTVg3U3dpMDU0Vi93QkJGUGFINWIvb3FBWXMzKzBMamFyOVNvYldMWlNLTnVaeW9nYlJIRzBHVEdOQllhVnh5RmZRVWxqR2tsYnRsWGFRTGFsdlNJZ2JTSUR1THVlU0JCZ05nb1ZKc3dMQXU3REFWeUUyYmhqUGcyNWdZSlFwTjdxVVpwbXQ1dkxWRkszc1dGdmdqYTlxQ29OMUtzcm01Yms1YkRzWFY3WFdhNmhicS9jY3orQktpRzFvbkxLV2QxWVNsclQyWmM0Z1pxVUV5eVF5cUliWEVvb3JDemNTdUI3ekJMV2ZuRVJUa21nUnMzUFpka3FtODgrVzVXTVJMcFdBTzQ3blFMNExRS0I1UnNlOHdXRllTVzJzRldzbzNZblFoUlRZTUtPQWNLN1NtL0N2SmhXVlZkVm4yekRpeUxvbE85MVZSZ1pmWU5VM3AyYTVyYU5XZm5jTDRYdG5iYnFHbGlQem5BZThITERKTVEzbUZiaWxGaXFsVnRMT0lvRUx5eTFUaXBkUzZaYTJoSHRVTFY0WUN1VU1FOCtVcjltOTRGZDI2QWk5c0JWOWd5eTBxVmhLVnZZRmxjd09oQWltdzRFY2k0RTNsSnBiWlFVM3lOemszSlI2R2d6YkpZR0xNbHdXRUxOckhjVmhuZGdWbGdJYkp1RHMxelVaclBjQ0paWmh6a3owNHBLN2I3aEtRYUl0d2Q0M1VwVVp1cVhVSkFSekZjRExlOHNjekIzbE8vSFRUMVlWOVlFc1kwa3I2dnE3Q0xhbHIwaUlHMGlBN2k3bmtnUVlEWUtGU2JNQ3dMdXd3RmNoTm00WXo0TnVZR0NVS1RlNmxHYVpyZUJnaW95ajJMQzJLZGplQURkU3JBc3l5M0p5MkhZdXIydXMxMDA1OUVjVWJiOFZGWmN2YnQ0bmVTdi9BTWc3RVJhR2dzcUtFeWdmUDh4NytqaTZ0N3IybEVGUEcwU2xiUmZlT09SS2xSV2VydjhBUUVxVWFWS09rbk1kNXpPWXpqMHZqT3pyV1JZc29HUTNWQVBLaEM4eThDb0tWR1c2MmdxU01Vc0FJVnFLbEZSTzFoN2Z5eUFvR0pYUUFMUmFvdkF3V0d5SGtWQldZdStBbHFtd2dsbXNtYVdZMFlidU1sZmUrSjhIMnhKd0JGNGQzK0lnMVVDblpIY1llM2RkbFE5amlIUVY1SHZEN3RQaWUra0hpd3llTHpBTUdDV3k1VTNCVTNYQ3lLeWRnYlI0a0NoTTAvNmpnV2gyWU4vekVaZnVITlN2T1EvZi9zVnFRRzJoSzM5RDBldDFhY01MZkY3cHVidWV5MGxzbGxkM3FtbzI5cDNmOWNHdnRFUzRNY0MwV3U5UWFzR1Bpd24yQ3p6Zy9nT2x6VGFQdGVmMURnMEZIc1JYdExNRUd0NFdNdytrZ1RFb3JDeXN0ZnhDMG9QRlN5L1NWTHkzZmRZSlJIT2hOZ3ovQUZDd2Jld2YxcCtoMU95cDkvcFB2YVFEbE1Qdmx2c3o1enNnb2ZFa09iTzRSNnFhOGRsQ2ZjVVlZVmJMd0YvUkRiMG4zQmYwOVFYdDZ6MkgrMlVxRUJIQXl4MFpoenVlY0ZjeXJYY1RKbExMRHUwdTh3M0NZSmdvZ3o2RnY3aitHQ2hScmNOdEhlaDZORVVmZXBSUjVXZm5lMk1QYUN1VmJscjdCS2F0SkQ3Ty9kcCtwMHNPVHIvQWY3MUprWEI1bkU0bFFqQkcyWVJZbGx4dGhsWmpoOUdNZXQxYWNNTGZGN3B1YnVleTBsc2xsZDNxbW8yOXAzZjljR3Z0RWU0TWNDMVd1OVFac0VQaENmd0ZubkIvQWRQWUtINWIvcUU1ZWxlWWNjSCtKWGo5dTZDTXhLaUZSTWRvUU5mc1RkZ2VIQS8zRU9aYjFuN1BhQ0ZrZUhhYjI4U20ybGtkK3RzbCtzYmVqVUp6R0dqT0ljNk1OdFRiUzJmR2RuVkJCYWlxMmFGdE1kNnRocHFHNGJtaTdURXNuMXpSdFdNakkvYXVaYXdvQUtRb1dMc0ZyRGUwb0VYYW8zVWU0M0RFSnRpb1NqTDJnZHptTVpxTnpJZ1ZkUlJqdU5GLzhaYmVaVk1QcnE4QTFEc2lQREdqYmY4QUF3dHZ3Y0RMSW5PQXpBTjNaa1pkME1nVVZ0RUFvNU1HYTl1SEt1VnRkM0VkcXdzc0Y0VUZhM3BwOG53ekVJRU55Z1M1aVdNdTNlQUdZbGFwSW50MXZ4M2gwSEVPV1U1RW90Nmd0V3k2anQraDZBaEVYQmgzK1I3K0lDYTVBZzFpQ0JIY1ZKS2t4WUFTWFJBR3VUVVJxQmNwc0RSbE1pb0cxY3pQUk9Cd3dGNDR0UkFkYjY5d0N4RjJ0SEZ4N1RBVHVzVEh1UnR4QUFTMmFVcFRoUzJudVcxM2VqOXQvS1VDQzdxV0MyRHIxd1pyM2RpS0NISzN0Qno3eGY4QWNUYUhiVHRNaTllK0lCTHZFVVNPRm04cFdOQTBSbFJXOTdFcld1eitYVDlEcVhhTllWVzl0dXl6YWhsV05SSUFXS0lXbGJxcmxSdEFVU3dtckVBdlp5VVVBS1hXRWVkbVlHZFVyUWpPd1hWNXRRNmhJVUZDMnh5b3piVnhOMS9rMkN4Vkt0YlFtZVhycjJxclAxMG5VM3MvbFlYdGNvUVRtV3NZRk1NVVI0RXB1WlFEVkp2QlZxV0JMczk0a1dDWDZGcDJxMW9WZXlZdEQ5ekFjQ2dNOG9GMGJsVElKSVVXeW1XYWd2U0pIZzFSdTNaSEJoZ0JrY0hCVWlmZ3BZdFZremxXeEN3RnR3TERNeHlOajNmdURMZUFwRGpHUVl0NHM2WkNjcC9JTlFZWnhDam1XMFhsNWJ0T0lFOHdoaVk0bVRwWFdpQWhFWEJoMytSNytJQ2E1QWcxaUNCSGNWSktreFlBU1hSQUd1VFVScUJjcHNEUmxNaW9HMWN5M1JrSndNQzllTFVKWm5aTE1hMkVYYTBZOXBnSjNXSmozSTI0Z0FKYk5LVXB3cGJUM0xhN3ZRUGxFL0JvWHRRU2J1TzBLbHNhVWhsVys1RnRMSmg3ejlwZkZWN0ZkZmZtVWdCcjhUSEFjR3Z6M21Ha2p0YjdHTVp1L2VNTGdHdjlmZVVSY2UzclI2Tk9pdlhDVktnVkNLbFlnVm9yb3FlMm54bloxc2xGc3RMeWJpTzVIT3dGNXE3M1pCM1MybVVYYXV5cVppN1lMbkFNWFJkTmdqcHNRWkRaeTIyMjJTNTMweHhxYnFVcU9kZ0x6VjN1eUR1aXNwUk5uYjIzdzN0S2VyN0hUdXlLVnNrWExvVUdtNXNNMEc5RmpQMnFjeHpZMnBseXQwUTA0Q3NvTFZpTE9GZmU0a2lScXk3RUF2aGw1dXlOelJacW1NcmM4dFBqK0hWMUFNUkdpa01NQUcwdlM2SkEwTDFITDFPcWFpWlRlZ1ZYbENoaTRxL0NiTEZvdkppRkxrVTR4THZMYmk2bVo3VTNUVTRHQVh2TFVWbzJMZnYzRjVpTWljMktnMXdVdEY3d3NWdnQwZGpEZ3RyWktpMW1SV0tJM0RUa1lPMUZJdG5BQzE0d0dXTkVqWVdoc0V2SzgxVzNRRHk3QitSSm13cHRLcVNoSGJ0SzRYcWVjT2ZNWFB0Q1hpM1duaThRRTFxTlB1U3JNYS9MdXpHZkpidFc5TXkwcmtkeG0wVmtwVkkyMHRKV2xQWllINjAvVzZFQUxkRzFpQkxNN010eEFqWkZIRGRsVzdqVXJUTzIyR1F5RnVxVU13NW9xdDJFdTZPYmwvU3ZaZ1Z3RzI3Y20yUzNtWGxLb0UyT0paTUs3UUp5clRacWlrWjdYb2dyaXBMd0x1OHNMSVM0Vk43VkdjZnhMbmhUZEZzS2QxRjNjZG8rZ09VZ05YaFo3ajBBRWdNME83S2xjcFFwVXVZZ2txMXpCS3JhWm5zbmlBWUVkeTVSNkcycTIwZDFHbWNpbnNrZHB4cUNLcVJRQXBWcGp4WGlOakxXTExOT0RzaEdMeEY1VWJZOHFpOHdWVzNNZ290ZkxOcERoTGhMQUNHMmVCdG1QdXJMaE9heFVNWHRBWFlVb3BiYUlPMjRla2QvNHFsdEZRSWhGdThvOHl5N3lwektsbXBETVdwYjFRc1pQRHNHbG8zcEVyUVdMbDBIa2JyMllpRlFxNER5d1d1YnVHdnZ0TUhKWm05MlY1Vys0UFprTEdlSUFGYmVWYjM0TnJvTHRxcFR6QmlxMTNaV3FzNGxrT01XNUdXMHV5U3hFTVdvSFFBQ2hLUlZnMFlCZTIybFBCWVhSczRxVlpIbGx3MW9hY05iTUxZNmloTVVqQmt2dkdBdHlyM3BCcjdYV2hzZmpDVWd5Ymppc1cvUCs1akVycUM4RzF4SXBNc3o2dGhDcXZWUmdZVlZ1bHNTRjVnN2Q5STlXcFJxSUJrc2loRzl4UEVoOFNWQ2ZDeTMrUkwrSXZsQ24razdpVWoyWVV0TEZwdFFiSTdzOFNIeElSTU1VaXJGT1RGTDRCM0VpWXprbmlRa1lMTktzREc1MEphWllzTGdQZVp2d0pVdjhua0w4Mlk5TzFvbjdXdnhMZjdvOEEvcE9TS3gzWkVWZWU0M29uaVExOU5jTFFsT1ZXRHhJUmVtcEZZdnJJYmhCSzVBamdLR0FUd3BmQ2xGSUpHM2VqaFJMdmJweXdmMnZCRHlQSWxuN2JQdENFdzhMZm1qR3JSM25JRzY5MERjYmV2NVRzNnQxUlkrNmcvS2hDbXl4c0dEanZrRWJOc0Ezb0xQTzQ5cFdxYUdXaVZMd0tLOW0yTGxTdzNYWStXOEVta3EwUUM1TTFoZDVhNk9OS0ZUanZrUGRxRkE1OERsVXVEY1N0M2VVMHFQNC9WSzA5clVVMVMxMkVBVlpkRU41WDByeGVxVmI4bUt0QktxdCtkc1BiTUJmem0yR2d2anhUVHRMK0ZkTXNxQkdxbllaZHQ1SUJNNDB4SEpMbUt4Q3lCcmVXYUdDWGlXYVk2WFNkVVdNOTBBKzZoTDRKSFlXaXQxWW9NSkJCbVdVYkNEZFh0eGRhTVRUcW8xWjJTbE96czhNR3FCVlRXSldBQnl6dkFRR3dVc2Q5aXl4TWJ4Slc4UkNsVlhCTGVTRGh2RWhtMWFlVXJHNDZ5ZW10bEJNR2c1UzlHL0tuOUxtQ3lLc0lNM2o3bmI3eGgwc0ZkbDNpOUFXbkZiL3VJWGdzQndHRDhFQWRBaHY4UlVNRW1ja3BmbG1BZ1crNTN4eVFuZ1RhbHhkS05vTW56eTZmb2REOHIyejlQQU1oeEhBNkVPNHMyQnVCNEtnQmxWckh1cUtVRktLdUd4TG13SXlpVUtsOW0xQ2phdEJGTnl6cGFSWW1BMlFVNGtVb0p1WENBZ3FxYnU1TkUwYTV1eitQelFqdE9WWUFLN055ckRvWVRjcSt5dzNsUUlGazJJMHlpNVV0NEpUQlJBRkFpTXA0aEY0d3NzSmtlaGFvTlFuWmhMZHNxVkRXUHpzd1MzZ3BNRk1VTUV2VWpNUUdYWW9obWNsZmRMWDZJTENWZExNbG9JN1p3OFNxRXBZRU42VnB3cmN3dVZ3dGNhWGt0a09lS2hTcG1yUnBvS1laV3FPUVpOWHZYRjF6MzZEc00zL1pEL0FGQldHQ011c3ptNVpMMVFOeDF1S3hTQjM2b3pjMG9QWkJrVlYwcFJrTGNBRzNZaGQ2NFMwYlk5cjBJMm5uMnJxMkRrdTFVUmtwMDl3Sy9ZUFl4MVNnd0NnM2xEQVpsd2JOL2pmc01MK0x0SEMzUnprMmJOWEVqalhkMnhuS1psdDFaWUtRMERRbzNTdlhXOTFncmFiMTRvM0oyUXZjSHgzWWFiYi9KYitUUWRqbFFQR3ovVXZiY3BFakdJVDR4K2F6QnRQWTUvMElpWUVVRXJFREJqaktoazF3akdnMXh5ZG9jQWZ4N3gwWmlCUjBVeW4wVGJvK2Y3T2pVSGpJSzl4U2hydTZDVlN3K1Y3L2lrOXAzUkhZN0g1U2ZFNldIeDNiMENCOWJMKzFINUJwdlFnQUtyYTFYUkNMV0FpY2pzeWpXWXZkby9GdnRQM05LdFRZdjNBMFAwZW9OUGxScEs0U01rVklGd0ZsZk13ZWFTWDdQM2xGY0tQQVpXUExxbEVVWGROUERURUVwMmdSVXVuWllQeU9yNFRzOUJnYjRVZmhVbGo2TkZtRHVEZGc4aEhQcnRDVTdyVGxlN0dURmVRWmI1Rzh6TkRMb1M5cnBYUG1VY2tRV0JOa0Z4VXQ0VFhHZHNycnhjdFZlZGdCc1hTMkRibkVPRmV5SW5HRXlZbVNWeUVyZTBOdVZjeGNXdTBDdkxhTjVsbms5NytTLzNLZ3hpMFZlNnVpVlpETjNDL2N3L3NocHF3dWNjTXJ3bVpaRHNaV0tLY1ZwZHdLbHVnVEJoNi9TUnNnMGsyQkQyRlNYaFZDbUFONnU3cStJR3BVQmlMTFF2RGF0NzJzVVJiamFMbkRxeEY3MWExZEVkUDJLa3B0UzluaXBUWWZhNm50YTFDb3RzbUZkaGE2Y3lWWkRiS1JIZitURUdLaE1tSWg3MTJuYzh6N3dISjNUZkVHa2pZOE9HVjlKejJWdGhnS04rM01VWXhNSEw3ZThwVWhvTjF4cUZMWW9SSnZCL0dlN3RyK2gwTEFFQ0kwaWJJOEpGSkpsT2NPemE2d1l1WlRaZGsyVlZxNnRWYjN0Z0xONkJlV2k2THZZdHFOeTN0RjVVcWx6bEtLZUtJS0VtVTV3N05yckJpNHFlZVFzNzVFY3daQzdvck82MDVZN1ZOMUUrNkpLTlY3elpkOHJ2N3pqZk5vcTdXcTlETzJJZUIvc2hjTmhoVENNQkk0aHRLbDlvbUxsU2x6S0x2T2NpanRNRnBRVVRaNkJ1ODZzQ3kzd05aZ1F0OTh4NzBrVnJTM0lOM2FYUzNtKzhCR3hMRkRzV3RSSkM1Vy9kMkcxUU1qTmxxZTFyRFd5b1VIc0trRHFsQkFHY0FhVExoNzlJdnNML0FDSDZ2UVpUWkpWM0dYT05hdEdOUzRHQWdsUTc5WEl2eWFDQU00YVM5M2ViRnlSQzl3YVkrVFNrVkU3SmRWTm5HSUFQWUhFNWxOMkxPNlhTK1dlZEUyL1pVZlE2VTRjTUdjR0RCMklrQVRiZGQzdHRWNE9PSnQvakVMM0JwbGprL2JQZFVhSzI0TDhCcUt3YnVYbnZTUjY5cmxYZGRIdmFFTDJ3aWhkNFhtWXkySllENUpnRGlFQWFEaW5SUU15MkcyamxiWlVnOTRRMTI5WjFXU3lmSDluUXFkTkY1NFA4cy9oZCs3RkF0aVA3djhSbml2NEU3VDQ3dDZOaUkrZTJqSlBFVkZ2TWczN3lmdWFWWkdmc3pmOEFNYWZyOVRMOGIzYU1uRUQ3aE1XUGNuWlREOW1tV08wb0syVnZjSTJUUTdzQ2lrTWtzRWNkK3BBdHduNUg2TnhSUndaeHhoaHh4eGh4eXh4eEFEZHhpOXpJUzhST2NOZ3k0TEtVclc4cnVvQnVhVlBFckVzSUtqQ2I2aTdBdzVBam5IMFRqampqampqbWtqamlsRGxIQ3pPeHI0R1EyUmdXeE5aaGZNb3I4dG1CMnU2NHAzalQ3dkhpS2ozUldhN1Nza09CY1h5MTNZQVlOaUdDSng4U3p2RmlzamFXN0c4VzR4aysvYjdhb0c4K1dleFE5dm9sSEtGSEpQRkZLSEhIRktIRk1oNkRXV2VTeUhkQytJYnl3WEhlYmt3WUl2YlFYWmpqTVZ1V29pMHdkbVhhYWhNd0MzV09KYng5RTVRNVE0NDQ0NDQ0NDQ1WTVaVEJEeTF4N2lKWEdZVzVodkZqRk5hRUNvbGtxeVdsTXBnblNCY0hqa0NKZjBKeHh4d2l6eXc3enlvNnp6d1djalk5NUNoQ1F0YWxPUzYzaHlzQ3paSGUwNHVPdmtLZStOWEJidEIwV2syZXFqQm9LYnhGa0M3aVltOGROc3Q5QjZYeS9aMGNiUElLWHRBSGRDMWd0OXdsSC9ld1paZGlCbXdvS3FPTFA0cWVUdytQelBNaS9DWjR6djdoNTJvOTcxUGp1M1Q1UHMwMmZublJ0ZlBPa1IrNG43bWh6YXFUNEc0YWZyNGZBOXRMTks2bGNXckQwR21xRGNWM2IybExvZHJ0eGZ0QTZOdC8yc25oN3JrbjZmc1RoSGtlSDFLMXZxdlhuVGFXR2Q0M1VKWWJSa0RHUVRsS20wdzF1V3V2VHViNGxBOUVnbEtzWUphdGc3Zit0eUJtNkdDbnpFZGhHamFnaGR6ZVhab1N0dXdLbWl4R3lpWHh5K1g5b3FsZlNvNnpicDJsbGJhQzVWOUZoaHpMbTJibDk1U29iVXR5d3RTOTVZZThOSzlhaU14cHgwQzdTNHFqTFk2RytsU21VOTQzV25tRHJEMTZrcDJJTWtzU3BXQ0FXbkROb29SYk5rYkwwZmxtNWNzaEhjSjZ2YUE1NCtoRzVSS0o4UDJkR2pqUlFGRVFkdUdycTQvTzFoSElubVVGbFE0Qm92R3lIRjFvSGc4R2ZsU0o1VUg4ekd6emZrSkNndkdtZko5bW54L2JUYStlZElqOTVQM05MTmtmbE0vdGFmcitrUzFHSktTVWlUaC8wZEllQUJmTDNNRGFzSWp1STBuMjlHMmNkR2V0bnRPTlNHYnd1WG90Smw1Z0p6S25jUXRKV2doUjZwdm9hYzllNmg3TzUvc2xwT21mL1R2THBOVURmRGNaUVZJeXplVjVxaFVZKzQvMURCaU9MMmZNT1dzV1JVUlRMTDJXdU9ZblZyNmdNNWdhQzJYQ08xVXBHSXhOYlNodktjTURpSXJJQjEweW5vOW9aMHMwTWRONnNJck5LbFN0WFZXcWdadjBFcjZKcHRBSmNHUGxDZTh2bk5zdm1FTGNXc1FJeXJuZ2diZGhDeUxOeEMzR0lGZEZNcDlQblFaZHMrWDdPaWhzbWl6bUMvTm1QTmIrQTd4Y2RhQVZiQmdJQ3ZWR2N3V3JDNm8wL3dDVDVUVDVQczArUDdhYlh6enBFZnZKKzVwVlhjait5bjl1ajlmcUpUQWU2dTd6S3Rqc3EvekY3SnVndFpUZUVVQnBVdENtZGtmMjZyZVgyWGtTdEJFSy9JZy9sWjliZnE1NmFsR2dWNkxjZHBzOVd0S1BvNmV2ZUF2WVQvZlppbnZ5eCtTTER2ZTI3RUtKUUFhYXA3M0RIVGZqT08vdjRpcnM3Tnp2dEt3YnE2dmlJRk05eUlPbG5lS0ZqRlRFUUtIK0grMzJ4SHh0TFdIMUlRa0lLR3lPTlU3eUVuT3FpRGFvYllRUjBHbkVwMHJwdS9VUnN5aHB1SEpEb3VMZTBvM25FQ3VtbjZONUVKb013V21oNDVZN1dTMCszRDcxdkEwdVczL3NFeEFwdVVsQW9tNUNraW5MOUU3YW04K1g3T2p5MG50MkdyN0FXNkh5Sy93Q1BCSis0YjZLdnY4QXdqKzJueWZab3p1Q2Z6L0JvNFRaSDJGaHhVSys0UmpNOGZ5Z1Q5elNzOTIvNzUvSFQ5ZnJaV3FadVYzUjBFSEtQK29LRHNmZ29KVmdCM2RxRzkzRDllZ200VCtML3YwVXFVeXFNeXhMbVlVOUcrdkUzNms3SWQ4WWx4cElEVUNLR1paVVVUTVBxeUxJbkpLTFIzNWlqbUF4czBObnZHMjJDTlZnNy9tWUVuaHU4WDRxYnphS0dDSlJxRktnOHRReE0zakI5MWdqNHlZL1BmUXFHZGM4ZlVVVEpzeG96b2hkVXl5OW9DMktnNzVRQTI2N2RMWmVsUFJjSnhPZE9OTVRHdHdadjBEM21OQlFBMHVXU3BYMDZER3FMWXMyWnYxQnF6WGE0VjlvMWtmdExJeVpqYmVxbjFuR2h2UGwrenBkZCtnTGVXMExiY3Q2TmRZSDMxLzBlNHpiU0FmZ3FWSjN0UzNLVUUzSU5XeEJUa3BHd2RMWngvRlA1SFFPNjdBWFM5cC93OEhXaElVVVNwM1JZVEFRaWJJNUU5eU5KcDNTbzl5eHAwdFRLQjJlL3dCa3IzVDl6U3lacGY4QWcvcG8vVDlBbC9jUmZjcEQ3OW50bTl6UkJQblNzOTJndU5oUVdyc0J1c0hkeCt4L1FQUkRFdDF6MTc5YjBVY3dEUzhuUnY4QVhGMTdJczJ1SEZlWmIvZExJMTViaHJYMXQzTVNoM0lBYkhyVXlweHBScFRNem5wdG1lajIwSmN2U3BiNm1QcGFPb0hFZlVtOGJSTU1NVUptMDFPZXlGdUxxUFpRRDVZc0FCekM3bmZsME9zRFFzTTRvcWxpdWM4VXQyUy9LT2h5bVlhVmExYXBySjBISGZOWktLcGVBNHNneXI3SnI4cGp3bFM0bzlyUDJUd0JEUUI1c1YvTU93WGF2OEJzQnNCZ0plYWxjTWJsMm5mUTRFNExnZDZ3anA4ZTJWOEZBVmhlOGZMMXpCU0RsTzJweHpoUmhjQys5TTd5eWNKeUpzanlNSzhrckErYkVmbUxPcDIvM1Rzd0psWjlsMkI1RFNwWFNaTTc2WEwxMmx2VDQveXgvZ3E5V21lOEpjdDBzZ1ZwUktKUk02MDlGRXFWSzBwbFAwVmt2Nnk1Y3YxV0c4VkpiTHhMWWJSMjF0bHkyRFpwZWczMDNMWmVJcjFOTFplUFJGOGtkK20vODRmNEsyVSttVE92R252MFdhK2ZTMjB0bEVvOVNuL0dVOWJPSWJSR2p0b2Q0NkRNQ3BXdk01bk01bkduRU5wczBKek9ORHREdEtseStuR0RvMzlHL3dEQzM5UGw5VFQwWTA4U3VxdGVKVDBaMDg2V1N6cG8wclM1ZlJaTGxTbldwWHAxSyt2cGxQcXM0aHRBaEhhYk5EdEJBbFF5UjJuR25NNWp2T1k2Y1RpY00yUTA0Z1hNQks1LytSYzlGUDFOc3RqMGhwYkxkYmxFb2x5aWVOQ2NhR2xkTm1tWlgxTnYrS2RRMURNWU1kT0p4VUdJN1EybVREZWJPbk01Nk84Q3lHbTVDYmt2RlRaS2xhSzZiWWEyek16NnA5SlQxVStnZlJHSlhRNGg2OU1wNlBIVlhUN2RGTXAwc21KWk02R09uMjF2UzlMbDlOc3QxdVg2T0pUL0FJRzJXNkJvK2xScFJyUnBScFIwMU1RcVZDWTZDVVNpVktOS05MWng2Rk1wMEpUOUJzQkNxNHpoVzhQdGpkVk5uVjBBZlEwK3RaTE5EckRwTS9RTTI2S2VuMm50TTY4ZEZTaVowOXVpMlgwZTNxV1Mvb0xmVnA2N0paTFBvSy93SjlIdnJ0TWVqYzNsTTIzT0FWMzhTaFcvQ1hObnd2aUlHMVoyNUl5RlRqdktQVEg4ZUpkZ1V0ajIzMDlSclJXaDFYNkF5WExsUFdhSUpac1FUZGd1SmNKUktyYUVWMGtYMXJPbmVWMGx0akVEa25DY24vblRiTGc2VXpqV3BucDRqcFRwdjFXYTFLMFNaWWk2eWladUg3ajJ3OExQMXRDMS9WTEUxMlNwa2l0ZHhsM0tsZlQyOUNDTGxyRDNZRmJTamRoYVhVQTlOTXBsT3AvaFIvd0I0aUMraUZ4Y2JxNThFQ3JQQ0loZVQ5eHF3RnpOcUJ3NHpDTjFuSGp6TmdONzR3Zm1aczBNN2Njd2J6WTkzdkMwTy83bHNXcm5vOS9SdWVaVHB4WFU3UWVFT0xOa1VXWndzaGVHOEZKS2dqYVVia0hyTmFaVTRseStrSldwSzFOdGw0TW5ZaWpTU2tTdnVNdHd0NE82NGdIRXRyVU9kckwwMlltUnZzOEdKaTIrYldHdFo0aTJ4b1puT21kYk9qMjlHK3ByV3lLcE1PSTJKWmp1UEpMc2kyeGJYbU1zTjJRcEVoV1lBMzkxK3hJcmhReTNDZE1PV0FyUkhrWDlXdDY3c29PSU1YUUs4RVNvTVFnejZWc3Qrbkd6MEtsYVU5TlBWUktsU3VqR21mUlhRZ29MNEhIM2kzZGVDR29WYTMyakM4Qk9Sdm5FUjJMaU1Cc2Vac2ZOcWVZSG9BVzV4RWFzdlA2OXBZMUNnOFg1alZ4VWg0di9BRXdKdGZhSWcyNThTdWkzcnAwcGhybm9TclE1TXB6S2ZCQWJFcE5MdktESGVHWXhydFUyUjBVcG9JOVZla2E3em5TblN1bmVXMmg4Tk1DUjU3R1BzeEpkTTEvQ0txcnFJLzhBRkcvZm5nZjdZNjMvQUtmaU4yUk1CZnRHR1lUam9zbTByVGZwb2xTaVZLNlVHMWlKYmlHK1NJZGlEWmhXSGw0ODhlVXdkY09BYkQyTk9CZ29ncGcvZk9kZmFDUHUyK0lPR2dpcFl2dTZMRi9VTnNDTXdsdkU0bEV0RHNnSlJyUjJnM3JiTFpUS2ZxOFlQcmVlc2IwT2pMZ2xLTHJldTBTS0FjQStZWmU2N1ZIZ1FZcUVwZmVORFEzMlp1cWZxRnRFR2ZmeEttMk1XMmp6L3VEdGlYK1NZNm8yTVFsK3pzZjZpYm1Wbk1aMTFiYWMrcVZXMWtTdFZFOTF6Q2NWeGJIUUNRQ0JFRUhMdy9jdlZUR1paMWVxbzZGeS9VclE2TGlsa1FaM0tRd1B5cTM3VHRYQlQyU3gzak12UDVQL0FGTGlmYzVIeVJvcjRIQWwvZlBIRUI0alJpTmw4YTJkSHRLbCtzU3NoTStOdnNqekJ5RGlPYnVvZm1ZL0tYL2cvZHVoZ1dsQjNXRlNBTVp5dmY3UmtzM1o1V1d2L0lhZUt4L2htV1cydnN4Rnp0VlczK01JVTM5T2FHenFHREdKWXdRaXAwaDNRcXBYMGR5dlZhSGNuQ0p0NmpmYmJiYmJmYmZmWWUzb1gzLy9BUDhBL3dEL0FITGxEUXdQVkFOMTllcEVmY24vQUdDZjlBbi9BR0NmOVFuaWZrbi9BR0NmOWduL0FHQ2Y5Z24vQUVDZjlnalIvWVEvOWduL0FFQ2Y5Z2ovQU93Ui93RFFKZUNhM3JNRjFzbTBPYVU1Z1dzYkQrc1Fvenl2ZjI4ek9ZQk40S2Q0MjB0YjhrR1FhYnRiK0lLeHRSL3Rpd3NyWm1VcUMwMEovTVphWTVtQjZOeno3d1h0YjZWS1pqWGpvcnBwMU42WWJhWXVvcGJWUUFIaTV2d2gySlV2ZFpzZS9QOEFxWENORVZ3dUlTSXFPem9yVzVtVkQwalYwWk1VTjYvaUdBbThtM1pTOGFoaTRFd2dDME15cWZ5ZDVhWnM0NlJsbWx2VFRQTXhMbGt1WExseStoMGJUeGQ3WENCNGE5emlEVVdGL2dTaEc2ZnR1VDk2WDNNTnZDL1piRGx3RWpieTkzSzRUMjZGOXVJSW5qUlVia28rOHBGdVFHdmpoM3h2TGZieGRtQ3k1MmZjK2xDOFFSS3pNYVN1MGlVdVlpQzRVYlNLYklyNktsUzdIUWZRZnQvNVVRdXpwTTkzMndCRzRsK1VIQTNkTUc2RGZpRDZiWGZqa1dXOUIyY202dDdxeC9hVkVYVm5kdkpEYWhlRUsyYzNLQjdjd2FtUitiWnRLektTTUFIdk1ERnY4VGNTN1Y5cFVqamxPSUJodDh4S2EwdGxadzBOb0VCbjZGYWJiTExiTGJiNzdhYmFiYU8wT1hETVJWQlM1cWdERXFKVUd2ZVNoNkNFdUl5N1JPVjZEQkYwSnNQelNyMmdlWmNkYmxQNmlORFdCc2liZlJHbW1tbTIybW1tMk9tbW1tbXRwOCsyYi9mdG9STnp0S0N3T2EyUEhsaGdWdHV4SEx1SkQrSjM0ZEE2Qmc1aTdzQlVWd1VtRVlCbzYxc3N0cUh1Sjd5MEsrdFVncVZHa0drcjZDMjIyMjEyMjIyMjIyMjIyM3VvRHZPSnM0YWJCbXN1QU12R0o1SDhSMDhLZkhtTVRkTnp0Vi9LMUhLM1lIc3Fmb2hQVzRCNVkrR0JmZHF2eXFJT1I4NW1UYnJiMk5qUUZsbjhaOW50RFZOd2luRGgvcUFnengvUDduKzlYQnhqS2I1YkoyTkNxUWtGalF0dWp1OHZyaW0yMmlpbTIyMjJpMm1nN3F0RXVOdnNBVzg0QU4reERMQXhEdktkME1TZHRGWkNwaUNSZXNzdExzMU5MWmIwMHltVXlucC9aK21rSy9TdVdlaDJybXpMVFlybGZlaXE1bElqQWNhb3R1cHU0bmF3VEw3MW0zYm52R2FsTUsybUhmR0U1UjdETFZBQXFGc0haRnh0b3NjUmJ4dXFxdXlOSlUvTFg3dWVuZURRSDNhZ05iRWZyUDdoc01zNGdGN1pZZDVkMWs3SGJ2SEhjZVNteUxicU5xRnFLYzVSaVNjT1Z2Tmx0WXRTL2IxdjlqT1UyOVZDOFlXMS9FZm5ieEhVSzh3eEN6OHVYTFFtM3RIMlRrRnE1M3p4QVlMYTdYRk16ZVU5YXJQREJzYjdzTFhzMHhrd0R6S0xHMWJ1bmE2NW05V0RXVXAxZDRlS3Q0R1ZFQzVCWnNNcFdNMjRpUUlibTMyU1JlOVJVeUttOEc3TjB2Z1ZlSlg3cDJjTUt1OXMzVmRJaTJsL2JMK1k4WGlFUlpoUjdTeFZLSW1ZbG5YWVlsb2pDNGRod21UN0cwQVJyZUNVOHdNWHIrbzZvbExjRGExYUMzRzhXUFVSc0ZOcnl1R043cDRaUU5HOHpBYTc0ejNxWis0bHFtWVlYam5iaTQyVUJJQWJsUlBaYzNzYTVEaFJHaDdtYktDTEhkaXJ2aHpWUzFDQnlQSU9GMzdiOUptN0lmaHpNdDU5cVZEVDh4YWNGMjl1VjVqUnVjYllOMEdRTnp1eGM2MzNiaEJ0V2xzNkdyZHd6UU9YYk1LdEhmeHZEcFM5WDJEZjd4OXpFUGp6MG04cGxSV2YyeHk4MUtHcklVZmVCbG1XaWF0NmF1NHE3RzdVNEd5bDVDVi9uRmhGYUc4cFZibk1HOStYN0hGZWF2aTVYR0NNaTJLR1U0TjlvaUFpMUZPektQc2xtUWwyQUt2TjA3bXpNYVVPeHVMQ3J2Ym1xNlFsdmY4QTRmdW9PS09hc2ZtVzFmRzM0WlFycjdsZm00d0p0Y3ZoZ2J2WWU0V2Z1bzV6TG1jU1hINENQSFYremNmeTJ3TTZpRG0yMGZ1VTJnKzhBR3VMK2JFVzh0ZDN2Q2QxVEtYZitJWlBJU3F1ejhjNnBtZ0cwM04zZmMwVGlBQ0lBTUFaQlRjN3ZSbjVnMkZkMlVYN1d6bVRaWXpBTW81VXpzWExGWWhzd2RMZk5MeGR5aGpRRjVXV3U2Mkx2NDNqakdKb0xPVnYyZGlaZVVwaTNBbFhTdkpBbFJsbHRsclhmQWVla3ZiTHYrSDdxVTFLaGJLaWNTclBNQkdyWVBkNS9VRlZwYkdHd1lsMVo2WFpLWlVQV05QMi9waENycHQ2YUpSNkhhS0hQNHJmMG9YN01lMU9vd2dIcitRajd5c0dFT2JFWXcxaHNCSUhEdWJESERnQkxwdEIzQnlweUhTTHV6L0pjSTd2ZVh0YkdQdE1UK3MrRDdjektFODlsekd2c0FFeklVenZVZzgxTWNBcTFTakh1cEt1cGNRQTdzSXNvYzcvQVBibGlaWURzeWhhdHkvMUJETFo5cWloUk9FVW9JZjNHZ0N1UEVlZmVNREdxdTdNZWdxNXZXK0NsWjk0VEJIOXdxSWVYZ08rU29CYmo3SFQ4Wit5WjJjZnlvSXNyeGQxVTJGTFlpRG45TWRLdE5zUHUvOEFrTmZiSlJObTAyWGlHN1FCcVpONGZ6Q3FXOW9tdDlEVi9NR2dsalhhWFRlSkdVVm16WDlCL0hxK1Y3WnRaR08yeXZiU1VOQ2dpUEZnL0FmZUVoU2Z6eFJkdi9CVkxVRUZhM1I0VmZGMU1DWDJyNzVQNWpCUVgzeit1WVcxbmw0ODBuYzRjbjdoalpIaU5iWU9BdDBiZVZRTzh2blIzajlGT1dGZU12YVVIQ3J0dG50NHBpdGxTWG5QWjVxTnlnZTMrd1ZzU3dsYVZpVVNFOUJzMDVsRDMvV1RhYm1abnRqL0FGTnd5dyt5bjRiY3k2ZllpQVlCelpZNVZzUVcxdU1YQkJnZUsvZ3JwdzlyUysyWCtvdUJza1dlei9zbUxtbDNlUExhbzJQT0JYNDdubVlZcVZXTTkzZ04xaDU2U25iZjl0dkJvOTViZndwKzRqMzByN3U4SUJ6QXlOdVlJS0FOL01wRGo5eHJzWVlFQ3B5VkhWdVhVRXJNanA4VDNPb2Y4d2lLY3FzKzltOXArYzdJV21WNTJ1OXZ6STBwaE0zWVg3WHYwU2xHNkZFVFZSemtPa2xwc1YrOUxCaFBlWlZTV3VkdEdmeEtCVjRHNzVsVUd4KzlPTkF1V3VpV1hHaGNGN01aczE4empXbVV5bVV5Mlc5SnArMzlPSVNwcFpvZXQzUVpOalZCWnlOMllwc2lsaEU2TEYzeHozWkVZdUJYQ2kzZ2srNHdNT1lJb3lLT01VNXhVTHc3V0RobDdZRjNBdEFhZ3N0dnBRdkcyK1lHQWcwQXVRcmJCYkx1SUNDOWgvRCtqb1lONFM3R2FnRXJ3OFFpcVZ4RFdWVXZIZDRKWEsyYitKWXVJajdmMXdrU202K1FtS2VmSGVPK0ZxY1Z6dlVNNThaUEhtSjJtTWUvaTRxQ01yLzFFY3NwanhMS2pSaUJoWlRQL1lOMXJZZXhMYjFqYUlxekdud1hmMWJ3eXp1R2dIc2NNZkp3cmJhMkJ5MG9qWGdRYnQzVm90dk5BRXFKWExoWWljR3FWcDdVVkZ3bEtEdG9hRVhtNldZQ04zSWhYRFlWemNIQ1Job1VzemRkTnFONWV4UzJCYmE0dG90ODBleDBFdStjTVdZNVl5VmlDeVhxYnYzaC9SRUxsUVJ0QlZqQlFrM1JLblRiR0t1ajlCL0hxN0NHM1YwTlhtcnJlbUR3WFdhVXdYdFN6bVBaYmI1SXVEbkw1RlZEQ2pCblp3QXJqRk54cUtLZ0ljN0ZETGlzUSs1Q3h0RTl3cGtvVEwrNThDT1BzWEJLTENiVFF1WDdWNkNoc0UreUxpRENKeHhURWNJcC9QMjdRQ0hHZTMzbktXQ3N2M280endNMjNpSGFWYmtCekVKRUxWVEVsTE96WXBlT0dvc3RsVVN6RUQ1TFVteEo1YmRYaTVWK214N1h4REpyanh4ekNXUFFyWENmY1MrTlc0NTdrTXdnZ3FxZ2JMQzdJSS8xa1M2V0VxTjBhQ1lsYnVOaGltOTdkVnVLWGFxeWxHZ3h1dEZocjNnK0Nkall0dnpLR3Bla1FmUEZTMkpJUENMYUhsQVB2UjBIM0IvdXRNcVhQTXY5ZmFGeVB3aWZpQ01wNVVwNW9BL054TFNiVmxkRUZHNUgyM3h0a0N3THZLc01HbWNhNGdibGlHVUJHWUg3SWIrOGdvSGpUNW51ZFY2M0F0dUV0VTNkVnVRcTZUM0M1cHNaQzhWRDJvbEZBaE5rV09hT0pqTmp3Ukc2M0cyM0tSeDA3QkdpbzVHRnVnN1E3bUtZcS9zREY1dWJBcVhnUjdsWjNmYW9tZVhydjJxcVAzMElhKy85ZjZoekdJOHFpWUtLdG5EV2xqdUtSZ1hGQXhMaHZITVBNSlkzR0s0VFpwYjAwZXArMzBoOXRLMEZPNnpCNDBCTlM0Wm91V1hRRzcyMUlBb0FES3JzQkZoVzVzcXZodEFJVVhOTCs2MnYzWmdxc1I3YXVhRDhGRDdNWXRMS3NnOHY0T1pTTlBxUWg5SHR4bWlUa1I1T2RreUxSTFl6eEJWYkJMQjRvdUpRMEFxR2tsY2NPd1p0Qm9zRmdSc3dWNXFCdEZ1YUtKUTFEN3J0TGRqWHRqSVp5eHhhR3QwQWJLdmVDYmlGeWtwcXpGSlE3eEVyclFxSzAzYW1oTXI0TWhZWnBGQjdQYUFCVTBGVVVJQnRSc0VXRHM4SUYrWGpudGM3UUlxa2FWM3RjeDUrY3BLR2h1Mnl4ajF2ZkxaVVlhL0pTZkNkNXRMTXNxNHJtT2VEYU1BNGR2dnYrb21ES1JFNUV3d1ZjM0ZLRS9qejVJSFZjc09Ya09lU2NqdENLN3pVeUY1ODdmZUZ5citWR3FIY2Q0d2UzZFhIMmlRRXZ5ZHY5eS9CYS9uRVhBS3FBaW1ZcmNxY2Fpc2IyR2ZhOC9xNGRLNUJOdnZTcnorbzVDVlRxZG1sUjJyWnBnUWVRNHdCVzhzcERNVkVKa05CaEE3QXNLN1FGa0wvQUdtUmNScFpFaXJUc2V4SzhscXVaZGVHRzgyVktLSjFHTnhWTHBBd2Q1a0cxMk5ubkRSZUdaMW9Gb1hHRHpiMmFaUmd4Z0xQTXJkcjhpVXcyTUdxemQzSlV0aThpWHROU2x5OFlxQWhYWnA3bDRoL0ZmTjVpc0VBemVNeTQrNlZsWlJaQ1E2MHFHOFZ6bUh0bHhwalFNYS9xTkJGUVdzUktnWGRWTm5QdUpEVHRyNzQvYXJpWVBvRzFzemFMbFlVWEJOVjJseUxiV3NRTmprWmxKNlM0RUVnTm9YWmx5c2w5a3NGTWtiVnlMdEJTcFF2RVRlK1Z6Y1NIcGtiVzJFTHBnV2h1d2dxVVJNYnJhdmN0aTVXL2dKU3JFN1cxVFp2RTlEdWJZVTVzVTBsa0hhVHRVZ1piS3RWYjJRUGhEQUxWcjNLSlZPZDlvajFhVWxGYjNvY2w1ZUxxRlpTQjhKbER4c3hlNVhIbWNOUThsUEV0U3J3SE4rR3g1R3p1TVc0SW1hYndKUWszUytXeWlsSEdIdGR3aEpzUGdEUis1S0FyOTJGV1JkMEZGWlV0L0c3T2RHT3hZbXZHWVMrbHNiM0lnS1psVXhTQzJNR0NBY0tzSGVoYVpneHBLZ09GRHN5MWlWQm5wZ25CVktLeFJDVnFqRld4bkZxUlRWSkV1V0FKRk5EVmhUVkVjdUdvYjFnQnZEaFdtVXl0blFib084bDNPS29qWmRiazdwaHhrUXlXNGNwdVhkanFwY1Z1RjBGNmpNdUY1UzdhaTRCUEtYNEI1RWx5OWR4NGFYS0NoQTlWTElLdWV6bFh2S2xkNXpBbzk3Q2ZodldpbkRZZGlFRmYzWCsxUngyNW15UEdqMzU5cDNnQi9PWWxIbC9qTU5QbU81MEhmWW1qc2xNTU03RUFkczhhR2dORzNNTHFLbkZuOE9WdWJsWnh5eWczRzJOMFVXc0tHQzJPd3p6dEY1REZNUXJNelZnN0M2bklOcnNiUE9HaThNenJRTFF1TUhtM3MweHhJMEFoeE5ObHNYSnRIYmRaTE5TdVRBdGpOeW9xRFhzRkttb1oyYVA2TkFWTUNYQTd4VHZIRlhHOHlJZmRsSVFMYkx2YVZBTE1aWTBVMjlIWDZGT2xzdWZ2NndDMDhCZjU3SGxsYUJaQmtlNytCaUFCUjA0WmpMeTNHeDl6c2VPb05XU2djTGIreno2RUxucFBRN3NJek5hVmUyemxEZURPd055bHliOHRVUmFJYmRJRHdXVTI0UUlJeUVnbFJhNUdtT0kycVN0eXlZYnplZFhLdEJvS0pSREk3TjlpQkNtRWo3SFlib0M5aTJKdE5aQVc3WFQ0RlVSYVpENGs5d0p1MmlXTm5sVTBxTjJvSTVBVTNoczJLWXlyVzlZUGVyai93Q0xnQ0F5cGJKUWIzcUZNWGUzRVZYWXE1YjFGc3E3QUJSc0xhWUF6TEZOTW1HTG9Oa3A3dzFkblBzTXFCdzE5eGxaY0JUWlNYZDNSMDdDcGVzVGtwYjJ0MzIycUxCalpHcDc1Z3M3TksxbkJ4MzhNTkRIQjNHUDB1bkc4dlBQTUI5VXVhL2lVaGlkb0phb3V0OHlqamlYTDZGUlA3ZjBMKzBYZ1V0YnlLWXhWbDVZWEtRUnBaazlnYk5uY21IcGNwM1FESkJTaHJlYmQ2ZjZqK0ZqdmdFQ3I0WGV2UDhBWk5vV2VkeGorUlFxQWtZTWxBeGJBdkt5NnJGUStiSzkrQXA1YitMbFlHdHROQ2lnazJpOXNFb3pDQzd4MkxZc1psZGFDTnY3ckgzSXZRR3hTOXluMnBJQUZORGpDdGZxV3Y4QTdhLzBzeWdHNEd6dWhGUUhpRU9KWmRvYnRFcVZFU3hFTHN4WG5qYUFMMlkrR0lic29xNlAwSDhkQ2libzlyYWppOUxhVzJLVnM1TktmMjRQVDJMUGNEOGpCcVdWM3F4VmxtNjJjMUMyMlE3OHJseTdFQitMdmxIRUsrT2VWdWZzSkhkeUlESlFlZGhURWs3MVExWlp1bzFWWmxDalYxdGFnRjlsanZmSmU3ZDBRMDJ4cXo4YlJHTC9BR0REZjNKaDNaZnU3ZmFJaHl0OXYxeERhS215VWQ5NFZXR0dXcm1lWlVRcGtGTHB3bDRCM2hGZ1ZBY0s3UHRtY01Mamt2S2VGQ05SUzcyYkhzb0NaOExMdUMvcUVZZ3VveWlsL005YlpPcUE1VVVhSE9ieFJuTk1TMEZsMllPTGUzS1dGMnNHOUpUd3ZCKzVDaSttTXFBcmt1dnpsS2RRZ3lnbmF1QU5WQXFvbUhYSXNMcDNLaHNTZzlDUXZoaUNXTm9NTzFwTEZzRnBRUlFTWHNYc1F3UnBEYXE5K0ZMMzd1c0x6U0p6amF0cFhjc0t6Z0xyczNhdG5WVFFkdDVDR2xuZTZobTROeGh6Z09DaW5GYlo0RVBtbFVuWk9ocS9kU2Z3eTBLZkRtRXFMUk4zbDIzZVlYcGF3djdWZjhabFBibmJ6ekVmeXB1QStYWTh3TTZVN2h6Qlk5cS9NUjhmK3RmbWU1MGZBOWtOZTl6dTk0KzEyZThjYXJoVE9xbjdvaWVhTmltUTl5WkxONVNTc0RMS3FlKzErWnNWYTFqMzNPejJxYmdFbzc0UHNYZnhjckExdHBvVVVFbTBYdGdsUUFCamFvMjlxSVVwazdEZkUrNnAzRkJ4Rmh1RjNmeWpxd3ZoZnlVeFFWTXBnc3JRTEx0SEMwWXhWWEErNUxFRzF6WmpDck9KUlVWc3dLNmpTOWFaWFgrM29EUHMxTzRnU2VGRUFQelc3NWVyRFo3UjdyUkRTb1E5Z28wYUJFdk96d3RicndTNDBPMkw5QS91Y1liR3lma3E5empRS053UDJYMkF5a3crdENKWjlKMlFkelBlb3cvY21PR3pLUWlkcW1lVU04VVZubk5SUmU2dWdxMFNKNGRUTkVaZUNsM1FiUU0wNzloeU1mWnVQN0R5TzlrdkYzekV2azVpbTV0WmVLSTIzU0VacFRLWnY5RktFbkJuNUpUK2NNeGVpK3dpc3ZlRmN5emppTEJnc0hKRXJTK0puSWxLYk84YjFJaXN2OFlsc1hGTnVlajlScUI0cWZDUGU2LzJnakR2dHVUSUZZVUlYSVM4c3BTVUF3TnFnUFhIYTRqd2h5YmdDSXZaTFpLR2liUEFiRVMzd2lVTWlxRHZ0YXdWQ2xZdGtvYUlnSU1HeEZmWWx2S0RMZzNYWWlZR0Z0T0lBY1c1enVsN0E1QTdCS1hDcWVBMklnakFCZ1VWczFHdTBTdmt0ZEpLNGlndHE3cTRRTnBSQlhJTmlCaFZZaFJBS1NtV1JXQzFjRzQzUmR4Vkt0ckhUVXNQczVHWTdZZnQ3d3FNU2h6elc5ZUlGY0NpcGJ2MklXbEdONTBiRDNONGVUblM3Mmx6aTZnU2hWVlJZdTBNRGM4NGxuWkJqdTNzWEZzZm5ISWVLaEU1UkRrTVA1WlNBQTB3MXVQZmxNV05oK3o3c0NzME52b213TmNVUGZkK21YU2l4RFpHZFRFYTdzTndtNnd2dHQvZWhta3R2MUhmUkhsdUh0VS9rSmFWcVV1ck1lMHg0alRTRzVkSmV5WERXM2EzbExjbFA1TVFNRkN0N0dOdHUyMHdnQnZZNzcxQmJudjRsanMvY2NOZDZJTERrTDdaUW0rdnpQYytoM3FBZmM1UHVSRkxFVDJjd3pNb1Z0bHN0bFBOeGNxYk1ZWFVRd0Rvc3dSZzI2V3kzMUxlbjluU040Q1N1QUEycndHaEluaTRBcSt3TnZUZ0szYS9qUDhBV3F3dXo3QUIralFQSEEzMnEvNURVOWxCL0NQUWhVZWpjQWJVdHNYUUJzRFlKNGtYaVJlTkY0MFhpeGVKRjQwWGdSZUZGNEVYaFJlQkY0RVhnUmVCRjRVUjJVVmYxU2dxNjIzV01yV2F6UU8xOXlXVDMzZDdQZVUyZ21GUjNXNmVFRE0rQTgrYmpVbWIyTjRHY0dWWUQzdmhsS1A0R212QU1MUnMxdmJBRTk0M0FNL2c1OC9FZGpiWGJzK1llUVM4ckl0VVpkTmtTMXFUczRKblZscTZYcVpuckVaa1JTUlRSbVk1cUJRQnBWb2IxYlYrOGQ0V1ZDcTBJYmtIN0RMdVhVd2xvVVpsaU9YUVVkSEdHREM2cEhheTl1LzBYZFROM3N6VlZVMWZSVjlQS05tNUVKMlN5eWhhTjZKVWtqaFFlMFZnek5GWHVJYXVScUJjS256U3ZXY0lMa3p4eW00YlhHcE42Uyt5V3NZMmp0Nkg4cVNzemJGZG5rODhFQ3ZBOC90Zkx6T0RvcSsvdHJ5czdabTUxWTFkTHEvb1RJaUlxdTdJaW9peTRBZlB1ZTRqVTRYS3NYdjVKY2doK1V4QWZ0cWp2a3FNYzhKV3NPZURnSVZBRTUvOXBYYmJoSDhwYVMzc0xlOVlZZ3BJOTZsTEI3TFAzRzhFZmRnbTMzSmYySGk4SDNPWXEydXh3SFlSOE5MZ094L3Q2T05NbmV0K3g5RVJFUkVSRVJFUkVSVTR1NWtEdHlWeG9iczRpTXNsNkFMZ2FVTGgvdGcxYlRIdkVFTTFCU2tpdEJnbWRLaVUra2RWT3Y3ZlJQMDNUaDhEeTEvZjZmTzkzMDFLRmZVK29xVVRsNThvakFQN1A2b2gzbEdoY3VtMmQydjdreEhtZy9aYitLais3YUtSekE3akR0bWN0aGNnN2lPM0ZUTlRZNzZON1dibnZBZFFiSnVYekxTN3JYdmNRZ0N5Q1pyS3JXTkZ5M3JiVGJwUG9PTkJTMGFUaUV6RmorNEpjZDR5MlhJcXdnWG42VWFoaG8wcXNhTFJYbTlqVEx4bHl3L2UxUzdsVW9zMkltWGF5NHQ2UENsYmJiSFBZRzNjZUxKa0QzOXBZMlgyM24yOFBmMzlBOWNydUtxMm5hTS9taEU3WTR2OVdJK1V4T1FZSHNxa2QraTEvd0JFZkRMZmRnVkZ2c0xONVZmRzhFVitzLzNFZGZmT1Y4dnp5bUpYbHdmN2xsdnZOSCs0SytvVkxKRzZ1NDdRSmFNUjFBYmNsclk3K2JsdGI0KzBTN3hkNmpBTzhCR1d5OUtlbW5wdGxPbHN0MS9iNkIrbTZjUGdlV3Y3L1Q1M3U5U2xDcVY2WnBVbzZ6VTZCRjVDMkNHMmN4TWtlRTMrOHNHNTJiL2lHYXZIaUd2Yk9ZamNkaDJTT1hmVHhPd2pldG50QkR4U3hYeEZCWERIUmNjdlRuMERwTmJOQ2lHZ204R3Rsa3MyWURteUE0TnBsSzRpaGJNc0pxM2wzRXZmRUN1aGg5Q2FVTVZQTEhKOXB0SE1jUndVdVVnVWFYcXZaS3BpV1llZ1M1Y3YxYkVRbmEveVFObThQOEVlV2xCWGNiakJzQWZka3Y3M0JiYVpJVHpoSHRMU0dIdEFYZGhRYnk3SWd0VVRLYndiZm5hR2wzL1ViUyswYk56YWJrcUNXWEZTMlVGRW9NM2N2UUlsaEFwUktkS2VzMFBSL2I2QittNmNQZ2VXdjcvVDUzdStycFFyNnpYbm90eERLM1F5aFY5OG4va0xLemNwcitaZFJMN0dFNm1NRUZCTGdPQmN1N1ZVd0Z2ZUhVbzc0MHBsT2xXVk1WaDlFbDlXT2hoQXBVek1rSURXSmFaWUtKNFhBZDErQ0o2dDk0N3BRd29LTkxKY3NtOEN2cE1KRC9NeEpDNjRYWjNpRktRVXBoRjFYUWlRb1BRUFV2cFFTbUxidGYweGdHS3ZudzZaVFNYd1p1VE5QeEtqdWczb0lmSnZ4RGhYM2liUUQ5eEFvT2UwcXBYMVpMaU56RVRUTGlxbHR4aEFaQTJlbFV4MDI2VXltWENmdDlFL1RkT0h3UExYOS9wODczZXRTaFZLNmFsZlFWMEduSldlWlFuRk53aER0bCs4VHZjVjVKaW44SlNzU0tyT0pmUVZ6QU5ROVUweHJlcEJxWGJSRERGc0V2WlYrNEhpejNmOVRCTDhTMXRnVnJ4MGMraGoxaFZZek9tampPOWU4d3podU9iKzhWZjZSaVhvVHc3ZmFwWmdCeUpFTjlOK295L2RBMGhYVFJLMHF0RFU2T2ZUQ1dqOS9KMmU4Y1g3WEgyZ1p6eW1keFZudTk0b0lXY0VzbTZsRUlRQXdlcFI5Q0p6S1cwV1pZQnFwWnVZSWQvMEZUUFNjd243UFJQMDNUaDhEeTEvZjZmTzkzMFZLRlZlcFhwblNZbHZwaXc5Ym5UR2xhOE1xOUxZVVJWM2xPMnJwYzNKVTUrZ0pkRnphQlhvYk13RFovbUYwajk0RnhyV2g2WkNWclQ2QkE2YUlwdVFMaWJBZjRLMllKUk1ldFRLZEsxT3Y5M29INmJwdytCNWEvdjlQbmU3Nk9sQ3JTNVVvOUt2cGFsUWxZOVVMbFMzVzJWcFJLamdoS2xFc2w5UEhRZFIwWDExY2QvVXRLUUttUFE1bnRvRXFWcTRMMHJSbGRKOUhaS0pYK1YvZDZKK202Y1BnZVd2Ny9UNTN1K2twUXErajJsc3Q5UTZOaVVWOU1PQ0ZLeDBldWlVU2pxNDBmU09mVXVpNFh6MUY2WG9hblV0a0RSNmEvOEFnNmVtMlV5bWZ1OUUvVGRPSHdQTFg5L3A4NzNmVDBvVjYxSzlPNWVsYUJLbFM1ZlVZMUtaYStxU3pwdVhxWk50SDZIZjFEbjFDYzZtbUw5ZHV0SzZBK2h2L0w4ZEg3dlJQMDNUZ2JueC9JblNmeHZkcUl2TGZ2OEFWd25ycVZBMTJmVTNnaTFOdlZEMGpWWjlBZXFlb1RHcHFabDlWczJubWJkTlIxNCtndnJwOVM0T2x5L3JMWmJMWmJLWlRPSVM1YlAzZWlmcHVuQWtObHZZQ3cwVlhxN2VBbEkrNFdhVVhDUG5WeW5nQ3Z2cHRqS3ZZRlp1cEpYNzUrbmhYTDlERXQ2amZwT294S0lhYmVwZm8zRGFQME9KZWxrdjBLdVZEMVZXRnNOZU5TazYvYWU4T3F0YjlXL1J0OUN5V2FjZFZTb0VMZy9UMHlucXpPWmJQMytpZnB1ckIzdGg5OFlmc3AwS0h2aEJIM0dCVjJlOVA0UDFDNWd3QVVCMkEyMFlQZ2Z5L2o5dnJvVDBtMm5HdHNKYUdpc2RXM1ZYV0dsU24wUTB2MDYraU9kVTlVb0lHdGtZSVRqMEs2ODJvSytrcVY2YjAxMEd0ZlgzUDMraWZwdXJDdERETzhkenc0aFV1MjQ4SnVKMmVoWFhPT1IySFA4QUJNTDNIQUd3Znl2TDlSQ3JxNzlGUytqaDZOeUdJTFAyUDl4SXYrUi91YnBHbmpUbWM5SG1YMFludnFhM3BSb0dxZXU0OVFKWFNhdlZRd20rbUk3UWxkS0JVeERIZnFEMHJsNm5yVktsRXIwNkpSNlZtbHkvb3JmVy9iNkJiK05qUTArelpxb3Bqc2kyZzJLTUFHd2RGaFhKV3o3amgrNHozWTh0dnZ1ZmdKaXhuSm41bFQrekVKRUx5dC84UEI5ZkNjZzF4cFJvT3RSREd1NW1lRnZQK29BRkdxQ2t1WHJtOGJmaVVRNDc4ZFY2TXgwZWRRMDQwOStyTUN2cGFla2xrZENZaHE5ZTB4cGNja0NwejAwcFpFNXVYMEI2Zk1PZEs2NzlDbjZRNk45VmY0TDkvd0R4MGhYbTV6cGpUZVZLSmpSK0kvdVYwb0p6dmRXZzZ1NnhGcjBFdmxab0dzQVlTYnBIK3ZIUWVsNTZyMXIvQUIxemNZVTM1MU5iTkx0QTBmekFCalExdVdRNk13dnF4VXVCWFRSS2xrdVhMbEVvOUZBVzdSVXhuSmo4czM5aUFucHMzbjV3UTFVQnUxbjV0SStnVUFHNjdBQms5Z1pjWis1cCthcFZFQ29Rb0FpbENJNFgxQi93bTFhTjlrMmVIOFVlSDhVZUg4VWVIOFVlSDhVZUg4VWVIOFVlSDhVZUg4VWVIOFVlSDhVZUg4VWVIOFVlSDhVZUg4VWVIOFVlSDhVZUg4VWVIOFViTk1GNzE5SUczVngxa3hCUERuMmczR0dpOTB2N2lwek4rNmlDY3MreFBOMlNPelAyMGVIWXo3Ylh0NldOT0lkTlN2b0s5STByMWdsYWJkQlVVaVJIaWNUc2hTd2E4Ym56citvR0swam5HVFdxVUd5V0V2Y256citwODYvcWZHdjZueXIrcDg2L3FmT3Y2bnpyK3A4Ni9xZk92Nm56citwODYvcWZHdjZneDBkbHAzc1U4MU04dXF3NFRoRUVkbWtueHIrcDhhL3FmS3Y2bnpyK3Ayb2todndGV3ZnRmxYbTJtQ0cxMENrK2RmMVBuWDlRaGFMeUcwVzN1OFdDWFBqWDlUNDEvVStOZjFQalg5VDQxL1VFNS9VVDQwcGxNcGxlbXFkVXYyY0grNFEwYUJ0dTJ4eXBlRWVWZjJqRWU2eXhkc1VQNHJaVElVOTdHdUlvTk50eDNsY2xuY0lwelgyS29ldzhIU2R1WDNDczJIOXM0NmVka2dGcStMNDByTHNONEladnZxYWNmL0RzK0NyNGlWcDJBWlJ6a2xlMTVJcFZWdlk1dnZCclYyV29EYTFsRGV1OU1ldDVIM0FXVDlKalNRelZCVXVtcnF0c1E2dU5Oemg0cmRwVzhxRUdwZFhSWVhtcjJ1bXArcWdIQVZ1NnJlZnhjVmg3bDNLZjN3Sy9EL0xPSW1IK1JPRW5mOERHNlV1clZIN3RvYnlMZ1doUHhVL1pwQ3diMDdYZTB0TjR4ZHVZRzc4azJoWE4vd0NHaFozVXkzbXlld3NKSGUvNWd2SnRyN3NGYjNwKzh1Tjk1YUdZMy9neGxaeHFyc0JsWXdDaDdnZXlLL0xMSkpCaHNzWGpaS2xQbXZaZm04TjdSeU1CbHlhM3AvaWN2clhzSmQrdzBMTGlvdEhzQmxkOGtxK05KRktxdDdITjR6RHhWMldvRHV0dzNydlRIbzk0eVBJc242UXdtTWVTcm5PNjM3UVZXazd1aVkzWVhWcXVwMzVYSlZKMnJlMWJ5aysyUEN2ZmdPV1h3bTBValBiY01LWHJDdmNzMjh0NDhzWWd6TGR2SXREdWQ1bkFsS3V6RFZqUkRiMWF0YUl1N0FwMmJnUXJYWVd5YmxPVjJ5enh5ell3dDM0SlpIcWphNlIydWpjcDJONWU5eFBiZjZsYU5wRXdCdW5ZUDU4QXNXYTFoM3QvZlVFQXNOSnV2N0hjZEtQTmV5L040YjJqbEtETGsxdlQvRSsvY0F5RjRPRzB5emxJN3lWaXV4YlBHck5qQzNmZ2xSMi92aHNQTlhVLzJRMzRDbzdHcmd1dzdYcmV0NE1iZHJZdkxoSDRZckJZdy8zRmUwWFIzTHpLOGdPTHVrVkYwWFNiMVA0dUt3OXk3bGJYdUN2dy93QXM0N05mNUU0VGs5T3RSeHFkUTFwdDAveUhkMHlVRHU1VlQzQmFuZ2ZTbjhYZlJ5Yi9BQ0ZKNTRRQS9Jc000TlU3QUZxK0FuL053Y3BiQnNuY1pScXZZUjBJL3V3bERiWTdMTnFoeFUxdEVhbHFtQ2lxT0NmODNETDJPVFZmZEtGUk5WZ0RZaDRaV0t2S2lHNXNCYUxxMVc5Q0ROWlpWOEpWNXRVU1VVQlI4RDNDdkl1MGlOd29WUXU5VEVoRUFyN0hSOEoyZm9CemMvVUNZQkJsRHpoazlnbFBRWkRoYkExM0M2OTQ5am93NGNGSnRaa0h5d283b0hzS2ZZREtoMW9JV2kzQUNsMVlBdGhrQVk3TTl3Sys1b3o1ZnVnZTZhQkhOOWcwYlp1QzRDdGJUM29GUFpteUl4M1ZkSDlqQzZpUmNJNU5tN1E0N2FZaG9rZm9SRk50Sk1KY01vR29ONkRSS1lhclcxOG9nWDdNRWNMMTN2MzU4VVd5cnZ2T0gzQS9sTnYzc0g1WEtTRFptWG5GajVySjJnSkxIL0JNbitEOEVudCtNTE1ZbW91Y3RMN3hialBMbUxlaUZPMUkxN0szemN0Y0tCcTJzWFh2WWpRYlk5eC9KZ1ZWWEY5bC9IL05BdEtVZm5jbjRVZFFwRFo1eloraEZBY2d0RmdRM3Z1UjR1Q2Z1MlA4UlhrbUZMUFlZTjhob0M5bGE5MGJXMmw3dVZpOFdpMExYbUk2Q0hzQi9FQ0E1aGc3Qm9DMVdERUYzd1FLejJmbGxtOEVQbFA0UXZCcGxSM2hNdnZhQXZ5UktnMDIwUHNrL3BZTW9YWXZORG4ydFltUlM3K2ZlZkFkNStSN2RBVEQyL0NGL3FDSldvdWN0TDc5MHR2Q3pubUxlaUZPMUkxN0xlWHVGQTFiV3pYdllpMDdVOXY3RHF4SHlUR2xtM0JobGtjZ0g4MUxySzFYbGlwNVFFRERDVUZZcnRVWjdWaSt4MmZ1R0MxU3E1VTd2elVJM2F3VmpMeS9OcFhMbS9BTkh1eGl1STJlOGZ0K2tEWXd2ZmRzYTdnTFo1Vy9OazNmam5vcExoSDdwRDhXL01walRlUEpWTjk3anhiRUh6UUg4T2o1anZQd1BabzBDQnBUMkRUM1NUbFdOaVczODhORE9xeE5IbUwxVnlBV09CcmZLTXNWSXIyS1I5a0Vxb0QraVg4U1RsMEhzaC9KWitwSEFlVUJTaWc3M2NCaUNBUEkyZmUvUlZvL1FiOGgzWXcwWERjSjFzMkZFOE1YWFNCMUZGbHBhRExCSVM5NUM3eTNzRXpMdGlWeTJ3dmxwZWxYZ2R5OWhYc09lQ0VRYnFPUXF5N1hDMnFsNEFBRjd4dmRrTmxpR1lCb2JYZ0hnZnNkR0lxMEZQakNpamRxTE11T3k0M0d1NGJiMk1Kc0JiMWhDN3J1SU5YMExLcGl4bEVDaXJzQnZnU2dHd0syWFRsc3lJK1NPM0xDN1JITEtKd3pZK2VZQjVRSCtNUVZSaFpRM295bER3QVN5NVh6dmVyL0FCd2lnaWhXMThsKzZtNkdsc1kwdVFFNUZoaFZzRUtySWxvelJkdFpvbHRGRzc5ckpIa01RajFIZEVhVGVVR0tPS0JxNjVLY3o0VHMvUWZHZGtGZXhMK3loOEIySUJGK0tsbVZWZU5ZWldFckVlNmZPZG9jcWtDOWltMk1IOGpkaXl1dVlWc0JTZ0kvaXIvS0NVOFhWUGNhanNLTFA1YlhOdjR2dW53WGREU3VvVE0rMEpHcUV0V3hUVlZVS1NxYmtjc1BGbUh1S1RJUVFwdWRqZ0tZTXZNdUE1MkZ0MjJyVzJFVzBrb2dsRWk4a2d0MzBSUW9wTmxaUVlibTREK05wL3VIL3dBSXo1VFErSnJTYlhtYjhCMmozN0RmdWkvd1NsR1NYN3lVUFdrcDVxVitYQlhmWS9nSitwRk1Nb0M4cUlQeXdTekpMM0xYK1l5MUNOTHVGZ3QzU0dyZ2pDWHNnYzRoN2JhZzkwQllOb0xkUnVVYk1XeCt3TjF5bU8xdzJmaC9PcStHNGhvdVNiYWJ6NTdSaU94S2ZrYmhFeVR6TTU3ZjNOeDdMU29hUHkveXhmYUV0MlV3L1p6RWRrY0t6T1YvQWxjTmsvTDM1SGhud0hlZmllelFFbjRIRHFhYlhkbS9NZG92amcvdWdmNE5VUmVYd2xxN2IzM3VES0MzRTdCV3hDVzc0T2xOZmorZWdNMFB2L0QwaGZPOTQzL3duM1o1NkdjMXNmN1pyeVFVL2Y4QWwwU254L05vUG13MzJwL3lHbndIZWZnZXpTcHlYZ205QmYyNSswdEJ2NFJPMmJmendtL1ZuVnBvbTM4a1g3cUQ4cWh2TzBudXAvalAxTkVNMDgzODBES2xhMUE2SzBWS2xTcG1jZE5FeE51bStRN3N1ZklQYXJ4dlYycTFZRUUweWJvSisxQjV0cU9WZHBLMVRHWG5hdGJiL2hld3MvWk5qNEQ3aCtBTTJwRjl3djhBQXp5WUh2YVB3YWZOOW9KTzVKN0Vmc3h2T2ovWmZ3SHFXVmJCUHhQaWJIenpBV3huM09DQjI0SHVzL3dPampjSDdzdjVFLzhBTEJ2WDZxZnQ5VFo4cDJuNFRzL1FmTWRrL1FsL1pRK0E3RStYN3B2ZTMrWStjN1I4cjNkVnZMMmJmeGZkUGd1N1JOdXhmTjkwdmZsL1JuNitnTGtwMmY0RUZIOGNhMS84RXo1SXkxcjk3UkdpbmNhcjk5RVJuL3BpWXcyZCs2aGdoZGIray9oWUJyc3JqZ0QvQUNKOGoybjlTSzZjTklsQnExbFI4dHF0WGxZbkhjRnMwSS9ZU2wwZFNiWlVPNWFuc00vZjFnTHdBbjh3MHk4NTAveDRDdkRHRTdydEx1aitKWTd3SUJqSDlyMGNDenpJdWg3UW1Ia2VFZUVnL3dCMHZ2US9sbnluZWZpZXpSRUFscldlYlZBdlNuY2FyOTlFWm4vcGlIUmJxdjNIVkMzOUpZTFEvWmFiRkdNUDVrQlIvd0FUS2dYbC9GMzZqS1lSUE0vbFNDUVZjVjdJZ0h0MTltWVpOdE5maEZ1WEtsWS9LTFlnV1FqbGlEN3FYbytRN3o4RDJhVkRRdGg3SVl1WFovbE83MURiK2VHcG5FQjVnVjV6NUZJZnlKZUxnRGxHY202ektvcUdUSzFCcExyZFAxSXFyWWY5SlZqTHo1YVB5RE9KYVFEcmN1VytpZFh0T05aV2lxSm55d0M1KzloUkhhemFGWUpLU2xlVnhlMXFRTXhuSkphemlubStaNW9rV1UxV2FOQnJaRlpkWHVKeW8xZ3l0SVU3NVlEdWpPN1ZRREwzYVZyNXJCY3dJcnVsaTBmT1VxbVZzWFZjV0diMENiZ2UrY25sWWxHQ2l0bDNwZDF5d0lnTVN3SWc0ai9ZWUxwdVdMai9BSnYrc1pCYUIrQ29JT1ZRM1phd2JRQ0JLZ3RuM0p0U1NDMkY3SG1CZnFSYkdSNUpiNE9hRmJkdDJMbTFTNlpTckJ1OTdxNjhYQzFBelVWN05XY2RDdFl4T00wNDFWaWlpWGJCSUZuQ1lzMEplQ3hMQWlEanpFWUNabGltNi9lZkNkbjZCbncyRWQvRGc1K3loOEIySTdQeHRQMHY4eDg1Mmo1ZnUxbDVmRDc5VVcvaSs2ZkJkMmliZGkrYjdwKzlyMUYzWHVmeUk4LytXaG56VXA2YVpUNkNJTU1jWGVETlpiQTFzYm5tSm5FNU50Z3VRd0hGMjVTVzNSWFlESWV4VlQzV1ZlVjJ1bHdpQVRhb1FtYTl3emo3QWZaR0ozS0h2ZXYzRFlyazhXLzFPZkVkcC9TMVUyeEVjeHNXK1ZmOG44UWU3UysrWSt6Y1BVRnVvM0tObUJ4VUNodTdMN0VJWGV6VEw3MmorSkVsWHpNWWJ3SDhSTEVnZCtiaWg1M2FCNHF2ekxaVWRGaG5PUTR6V2JYZ2lXZ2pGaWozdmRyZll1VWNjajV0RkhqQVhMMVpQdGl1M0ZnWmFPZ3BLVGJWTGVnSkZzTWRYZUROWmJBMXNia2ZHSnliYkM4aGdNVmR1VWxwMFYyQUxEMk5wN3JLbnE3WFM0UkFKdFVKL0EwTTIreFgyUW5hV3ExdWw3TURLQzNFN1VOaUMydmhMVjIzczk3amJBQXU3WDJxS0pWTlYzc3Vuc1cyOFlnSXR2TERQdmRYNXFva1VvcGh1cys2bHJ5RW9yZ2lFSGR3SVZ3bUV2amI0VENPTHEveVJicE43THN4WmRVT2I0alROQTNtbVdsdGFvR2pHeTErU0JjeDRKVjJxNC9ONkppVzJHN3ZVY29nKzF4NExNV1hRcTNQbXFsM29RVXA1cjdLcTl0SzFhZmJGZHVMQXk4RkF0S1RiVkxldFEwMkl5KzZCUDBwdC9QRFEyQ0xWZmV6VVhCWmJraW5LMEFkb1V5RnZNV1cvWnBsN05VdDNTdjZJRE40Z3ZBSlR6YW9oYnhIQk9iQUJrQU1MQS9waFRzWFRlcnlyS3JXOWFsZGQvVHpNK2I3ZlIvQ2RuMDZla01DSFB0Vm9jSGhmS3A3Tmo3TU54V1psU3RsdkYwMUEwd0p2S29XMldyWlc4OTFBZ0g1dDhDeDRiS0g4djhBYytjN1I4djNheThpNTFYN0kvbG0wSUwzUVA1aDZ2dGlyZEFYM2MySjhYM1Q0THVtU3dwVzdGc3RqQVR0ZExCQVhDM2NST2F0L2RnL2JLeHdFUFlFUHRVR1pXaUIzVVVQTFZFTEZiMTZDb0FXbVRISXhySGE1dDk2VjNwalRIOXhXdFkwc2Y4QTRGbnpRNzJrRS9ES1ZUc0FmZ0NQUnNlR0tsVGRFdnVnYW1la09tcFVvOG45NllMN3paRWdNc1FTbUdnUzVRQm9CY1cvdnJmNFBKdnlxNEFVUmlCT0VzL0RQQzhBSDRBaEdVUDlwQlB3eWcwN0FINEFpd2JIaUlGVGRFdnVnVEdwcTVQN1YzNXE5RFFkc29UN3BLRUtKVmNkZ0g3R1VobHdBUHdhMFN0R3dMNFJxNFZXakFDY0paK0dVdkhZQitBTktsU3ZTZWcyK2lvMDIrcXBuemZiNlA0VHMvUUZDdEZlQ2JQczdTclpnYit3T1R6SGhpRnJiZmRvSy9LSVlwS1FISVhRSlN1d1Z2QkhjeksxdHdyWHNLSU9WeXlYbTE3ODRpMXRhcVlRbTJERVNnUjdURkgyMnBVNU1OamhZNXdhaXF4S1N5RmZBRnNORlp4eXNpU3p0cHVMK1JoKzR4RFJXYXE4SndzYmJGVUZWRENHaFZZNFN5ME9Gc0lLckxzYkhtRCtOQ3F4d2xnWmxNMWFRVHpXNjd3dFZleFFDNHVqSys4UFpnN2lQZmxmNUlpSmNBSjdLWXlwMVBnditjZVZRdEsva3k0Mk52TU1HZ3I1NWQyVksxcXR2cTBJclFRZmxuOXo1Wi9jK1dmM1Bsbjl6NVovYytHZjNQbG45ejVaL2MrV2YzUGxuOXo1Wi9jK1dmM1Bsbjl6NVovYytXZjNQbG45ejVaL2MrV2YzUGxuOXg4eEhPWk5HNWIwMnkzMTZ6ZWxhVjFtWHBKVkd6Y2hvM1dYb0dFYnRqKzRpUzE2NjZ6ZjZVMXQ2cmxuV2RGU2lWS09uMzY4ejh4R1c1dVZWUFRISHZISEh6SEhIcUlpa1hFZHhKOFUwRHRFQVlIWUNwOUdQbU9XTy9tbW5tT21PT21tbW5tNktEeW4wRkVGakdWeThPUHczK3BiK2c5NVdRUlZHaHZjZTlIRmFvRWQra2tiZlFmZTRERW9nRW9nRGFXcm4yUXFRSEFVU2lVU2lDMFh2Qi9tVUdPNEMvem9rcEpsUUdtMytBZHVPNEFheVdObStmcEN4WXNXTEZpeFlzV0xCQWdRSVdMRmd5dHFib2hlMTBBWFFmVUhWWkxJZEZtTXl1YmRuK3VzU25zZjdpaExXRU5NZWxVclNvZXBSSzZTWmhuWGI2WFBUektlaW5xTk9aUktOSG9KalErdk5wUlowMmRuOGs4cjhwNTM1U25sK1dwb1RqMEtaVTIwejFIcjJmU25vMHluNmM2cUpVT2krSUtOa0lvVS9jM0o5MFR0K1FqdUIrU0VPWHNsL2hlTi93QXpLM0tsUTNXMUw2TDBPdS9WT2l0QTlLcFIxbnAzcmZwbm9HbU5OM3JINlZLZW5lVksxcUhSWFNHaHFGYUhTbnI0K2xOTCt2ek0vVE5EdGJESkxsa05UMHJOZDJYZlVkTlE5WGpwTnZTb2xlc2VnYTcra2ZUR3Q5SmgxSngwSFZ4MUgxbHkvUnRsdlhiTFpUS2V1cFQ5TFhwV1Rib0FLZFBPcEtoMGJ3MGRUcXZxMjZNVEhWZlhVcVZLUFQ1cUMzdDZ4OUtmVDdkQXplVzZEb1IxSUZkVzhvbEd0UFJ4Zm8vLzJRPT1cIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/img/slide-1.jpg\n");

/***/ }),

/***/ "./src/pages/Home.jsx":
/*!****************************!*\
  !*** ./src/pages/Home.jsx ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _HomeLayout = __webpack_require__(/*! ./components/Home-layout.jsx */ \"./src/pages/components/Home-layout.jsx\");\n\nvar _HomeLayout2 = _interopRequireDefault(_HomeLayout);\n\nvar _Header = __webpack_require__(/*! ./components/Header.jsx */ \"./src/pages/components/Header.jsx\");\n\nvar _Header2 = _interopRequireDefault(_Header);\n\nvar _Slides = __webpack_require__(/*! ./containers/Slides.jsx */ \"./src/pages/containers/Slides.jsx\");\n\nvar _Slides2 = _interopRequireDefault(_Slides);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Home = function (_Component) {\n  _inherits(Home, _Component);\n\n  function Home(props) {\n    _classCallCheck(this, Home);\n\n    var _this = _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).call(this, props));\n\n    _this.state = {\n      modalVisible: false\n    };\n    return _this;\n  }\n\n  _createClass(Home, [{\n    key: 'render',\n    value: function render() {\n      return _react2.default.createElement(\n        _HomeLayout2.default,\n        null,\n        _react2.default.createElement(_Header2.default, null),\n        _react2.default.createElement(_Slides2.default, null)\n      );\n    }\n  }]);\n\n  return Home;\n}(_react.Component);\n\nexports.default = Home;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvSG9tZS5qc3g/Mjk2MiJdLCJuYW1lcyI6WyJIb21lIiwicHJvcHMiLCJzdGF0ZSIsIm1vZGFsVmlzaWJsZSIsIkNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU1BLEk7OztBQUNKLGdCQUFhQyxLQUFiLEVBQW9CO0FBQUE7O0FBQUEsNEdBQ1pBLEtBRFk7O0FBRWxCLFVBQUtDLEtBQUwsR0FBYTtBQUNYQyxvQkFBYztBQURILEtBQWI7QUFGa0I7QUFLbkI7Ozs7NkJBRVM7QUFDUixhQUNFO0FBQUMsNEJBQUQ7QUFBQTtBQUNFLHNDQUFDLGdCQUFELE9BREY7QUFFRSxzQ0FBQyxnQkFBRDtBQUZGLE9BREY7QUFNRDs7OztFQWZnQkMsZ0I7O2tCQWtCSkosSSIsImZpbGUiOiIuL3NyYy9wYWdlcy9Ib21lLmpzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IEhvbWVMYXlvdXQgZnJvbSAnLi9jb21wb25lbnRzL0hvbWUtbGF5b3V0LmpzeCdcclxuaW1wb3J0IEhlYWRlciBmcm9tICcuL2NvbXBvbmVudHMvSGVhZGVyLmpzeCdcclxuaW1wb3J0IFNsaWRlcyBmcm9tICcuL2NvbnRhaW5lcnMvU2xpZGVzLmpzeCdcclxuXHJcbmNsYXNzIEhvbWUgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICBtb2RhbFZpc2libGU6IGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZW5kZXIgKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPEhvbWVMYXlvdXQ+XHJcbiAgICAgICAgPEhlYWRlciAvPlxyXG4gICAgICAgIDxTbGlkZXMgLz5cclxuICAgICAgPC9Ib21lTGF5b3V0PlxyXG4gICAgKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSG9tZVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/Home.jsx\n");

/***/ }),

/***/ "./src/pages/components/Header.jsx":
/*!*****************************************!*\
  !*** ./src/pages/components/Header.jsx ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\n__webpack_require__(/*! ./header.sass */ \"./src/pages/components/header.sass\");\n\nvar _op = __webpack_require__(/*! ../../img/op.png */ \"./src/img/op.png\");\n\nvar _op2 = _interopRequireDefault(_op);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar menu = [{\n  href: '/boton-1',\n  title: 'Boton #1'\n}, {\n  href: '/boton-2',\n  title: 'Boton #2'\n}, {\n  href: '/boton-3',\n  title: 'Boton #3'\n}];\n\nvar Header = function Header() {\n  return _react2.default.createElement(\n    'header',\n    { id: 'Header' },\n    _react2.default.createElement('hr', null),\n    _react2.default.createElement(\n      'div',\n      { className: 'container header' },\n      _react2.default.createElement(\n        'figure',\n        { className: 'logo' },\n        _react2.default.createElement('img', { src: _op2.default, alt: 'laopini\\xF3n' })\n      ),\n      _react2.default.createElement(\n        'ul',\n        { className: 'menu' },\n        menu.map(function (item, index) {\n          return _react2.default.createElement(\n            'li',\n            { key: index },\n            _react2.default.createElement(\n              'a',\n              { href: item.href },\n              item.title\n            )\n          );\n        })\n      ),\n      _react2.default.createElement(\n        'form',\n        { id: 'form' },\n        _react2.default.createElement('input', { type: 'text', placeholder: 'buscador' })\n      )\n    )\n  );\n};\n\nexports.default = Header;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY29tcG9uZW50cy9IZWFkZXIuanN4PzgyYjYiXSwibmFtZXMiOlsibWVudSIsImhyZWYiLCJ0aXRsZSIsIkhlYWRlciIsImxvZ28iLCJtYXAiLCJpdGVtIiwiaW5kZXgiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLE9BQU8sQ0FDWDtBQUNFQyxRQUFNLFVBRFI7QUFFRUMsU0FBTztBQUZULENBRFcsRUFLWDtBQUNFRCxRQUFNLFVBRFI7QUFFRUMsU0FBTztBQUZULENBTFcsRUFTWDtBQUNFRCxRQUFNLFVBRFI7QUFFRUMsU0FBTztBQUZULENBVFcsQ0FBYjs7QUFlQSxJQUFNQyxTQUFTLFNBQVRBLE1BQVMsR0FBTTtBQUNuQixTQUNFO0FBQUE7QUFBQSxNQUFRLElBQUcsUUFBWDtBQUNFLDZDQURGO0FBRUU7QUFBQTtBQUFBLFFBQUssV0FBVSxrQkFBZjtBQUNFO0FBQUE7QUFBQSxVQUFRLFdBQVUsTUFBbEI7QUFDRSwrQ0FBSyxLQUFLQyxZQUFWLEVBQWdCLEtBQUksY0FBcEI7QUFERixPQURGO0FBSUU7QUFBQTtBQUFBLFVBQUksV0FBVSxNQUFkO0FBQ0dKLGFBQUtLLEdBQUwsQ0FBUyxVQUFDQyxJQUFELEVBQU9DLEtBQVAsRUFBaUI7QUFDekIsaUJBQ0U7QUFBQTtBQUFBLGNBQUksS0FBS0EsS0FBVDtBQUNFO0FBQUE7QUFBQSxnQkFBRyxNQUFNRCxLQUFLTCxJQUFkO0FBQXFCSyxtQkFBS0o7QUFBMUI7QUFERixXQURGO0FBS0QsU0FOQTtBQURILE9BSkY7QUFhRTtBQUFBO0FBQUEsVUFBTSxJQUFHLE1BQVQ7QUFDRSxpREFBTyxNQUFLLE1BQVosRUFBbUIsYUFBWSxVQUEvQjtBQURGO0FBYkY7QUFGRixHQURGO0FBc0JELENBdkJEOztrQkF5QmVDLE0iLCJmaWxlIjoiLi9zcmMvcGFnZXMvY29tcG9uZW50cy9IZWFkZXIuanN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgJy4vaGVhZGVyLnNhc3MnXHJcbmltcG9ydCBsb2dvIGZyb20gJy4uLy4uL2ltZy9vcC5wbmcnXHJcblxyXG5jb25zdCBtZW51ID0gW1xyXG4gIHtcclxuICAgIGhyZWY6ICcvYm90b24tMScsXHJcbiAgICB0aXRsZTogJ0JvdG9uICMxJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgaHJlZjogJy9ib3Rvbi0yJyxcclxuICAgIHRpdGxlOiAnQm90b24gIzInXHJcbiAgfSxcclxuICB7XHJcbiAgICBocmVmOiAnL2JvdG9uLTMnLFxyXG4gICAgdGl0bGU6ICdCb3RvbiAjMydcclxuICB9XHJcbl1cclxuXHJcbmNvbnN0IEhlYWRlciA9ICgpID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGhlYWRlciBpZD0nSGVhZGVyJz5cclxuICAgICAgPGhyIC8+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb250YWluZXIgaGVhZGVyJz5cclxuICAgICAgICA8ZmlndXJlIGNsYXNzTmFtZT0nbG9nbyc+XHJcbiAgICAgICAgICA8aW1nIHNyYz17bG9nb30gYWx0PSdsYW9waW5pw7NuJyAvPlxyXG4gICAgICAgIDwvZmlndXJlPlxyXG4gICAgICAgIDx1bCBjbGFzc05hbWU9J21lbnUnPlxyXG4gICAgICAgICAge21lbnUubWFwKChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDxsaSBrZXk9e2luZGV4fT5cclxuICAgICAgICAgICAgICAgIDxhIGhyZWY9e2l0ZW0uaHJlZn0+e2l0ZW0udGl0bGV9PC9hPlxyXG4gICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgICAgPGZvcm0gaWQ9J2Zvcm0nPlxyXG4gICAgICAgICAgPGlucHV0IHR5cGU9J3RleHQnIHBsYWNlaG9sZGVyPSdidXNjYWRvcicgLz5cclxuICAgICAgICA8L2Zvcm0+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9oZWFkZXI+XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWFkZXJcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/components/Header.jsx\n");

/***/ }),

/***/ "./src/pages/components/Home-layout.jsx":
/*!**********************************************!*\
  !*** ./src/pages/components/Home-layout.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import './home-layout.sass';\n\nfunction HomeLayout(props) {\n  return _react2.default.createElement(\n    'section',\n    { className: 'HomeLayout' },\n    props.children\n  );\n}\n\nexports.default = HomeLayout;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY29tcG9uZW50cy9Ib21lLWxheW91dC5qc3g/NzBmMiJdLCJuYW1lcyI6WyJIb21lTGF5b3V0IiwicHJvcHMiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztBQUNBOztBQUVBLFNBQVNBLFVBQVQsQ0FBcUJDLEtBQXJCLEVBQTRCO0FBQzFCLFNBQ0U7QUFBQTtBQUFBLE1BQVMsV0FBVSxZQUFuQjtBQUNHQSxVQUFNQztBQURULEdBREY7QUFLRDs7a0JBRWNGLFUiLCJmaWxlIjoiLi9zcmMvcGFnZXMvY29tcG9uZW50cy9Ib21lLWxheW91dC5qc3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbi8vIGltcG9ydCAnLi9ob21lLWxheW91dC5zYXNzJztcclxuXHJcbmZ1bmN0aW9uIEhvbWVMYXlvdXQgKHByb3BzKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxzZWN0aW9uIGNsYXNzTmFtZT0nSG9tZUxheW91dCc+XHJcbiAgICAgIHtwcm9wcy5jaGlsZHJlbn1cclxuICAgIDwvc2VjdGlvbj5cclxuICApXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhvbWVMYXlvdXRcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/components/Home-layout.jsx\n");

/***/ }),

/***/ "./src/pages/components/Slides-layout.jsx":
/*!************************************************!*\
  !*** ./src/pages/components/Slides-layout.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\n__webpack_require__(/*! ./slides.sass */ \"./src/pages/components/slides.sass\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SlidesLayout = function SlidesLayout(props) {\n  return _react2.default.createElement(\n    'section',\n    { className: 'SlidesLayout' },\n    props.children\n  );\n};\n\nexports.default = SlidesLayout;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY29tcG9uZW50cy9TbGlkZXMtbGF5b3V0LmpzeD8wNmE3Il0sIm5hbWVzIjpbIlNsaWRlc0xheW91dCIsInByb3BzIiwiY2hpbGRyZW4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFFQSxJQUFNQSxlQUFlLFNBQWZBLFlBQWUsQ0FBQ0MsS0FBRCxFQUFXO0FBQzlCLFNBQ0U7QUFBQTtBQUFBLE1BQVMsV0FBVSxjQUFuQjtBQUNHQSxVQUFNQztBQURULEdBREY7QUFLRCxDQU5EOztrQkFRZUYsWSIsImZpbGUiOiIuL3NyYy9wYWdlcy9jb21wb25lbnRzL1NsaWRlcy1sYXlvdXQuanN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgJy4vc2xpZGVzLnNhc3MnXHJcblxyXG5jb25zdCBTbGlkZXNMYXlvdXQgPSAocHJvcHMpID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPHNlY3Rpb24gY2xhc3NOYW1lPSdTbGlkZXNMYXlvdXQnPlxyXG4gICAgICB7cHJvcHMuY2hpbGRyZW59XHJcbiAgICA8L3NlY3Rpb24+XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTbGlkZXNMYXlvdXRcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/components/Slides-layout.jsx\n");

/***/ }),

/***/ "./src/pages/components/header.sass":
/*!******************************************!*\
  !*** ./src/pages/components/header.sass ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY29tcG9uZW50cy9oZWFkZXIuc2Fzcz85NTlmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vc3JjL3BhZ2VzL2NvbXBvbmVudHMvaGVhZGVyLnNhc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/components/header.sass\n");

/***/ }),

/***/ "./src/pages/components/slides.sass":
/*!******************************************!*\
  !*** ./src/pages/components/slides.sass ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY29tcG9uZW50cy9zbGlkZXMuc2Fzcz85MWZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vc3JjL3BhZ2VzL2NvbXBvbmVudHMvc2xpZGVzLnNhc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/components/slides.sass\n");

/***/ }),

/***/ "./src/pages/containers/Slides.jsx":
/*!*****************************************!*\
  !*** ./src/pages/containers/Slides.jsx ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _slide = __webpack_require__(/*! ../../img/slide-1.jpg */ \"./src/img/slide-1.jpg\");\n\nvar _slide2 = _interopRequireDefault(_slide);\n\nvar _SlidesLayout = __webpack_require__(/*! ../components/Slides-layout.jsx */ \"./src/pages/components/Slides-layout.jsx\");\n\nvar _SlidesLayout2 = _interopRequireDefault(_SlidesLayout);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar slides = [{\n  src: _slide2.default,\n  title: 'slide-1',\n  styles: {\n    display: 'block'\n  }\n}, {\n  src: 'https://images.pexels.com/photos/1110656/pexels-photo-1110656.jpeg?cs=srgb&dl=calm-clear-water-clouds-1110656.jpg&fm=jpg',\n  title: 'slide-2',\n  styles: {\n    display: 'none'\n  }\n}, {\n  src: 'https://images.pexels.com/photos/1109541/pexels-photo-1109541.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  title: 'slide-3',\n  styles: {\n    display: 'none'\n  }\n}];\n\n/*\r\n  img de pruebas -> https://www.pexels.com/\r\n*/\n\n// let slideIndex = 1\n\nvar Slides = function (_Component) {\n  _inherits(Slides, _Component);\n\n  function Slides(props) {\n    _classCallCheck(this, Slides);\n\n    var _this = _possibleConstructorReturn(this, (Slides.__proto__ || Object.getPrototypeOf(Slides)).call(this, props));\n\n    _this.state = {\n      slideIndex: 1\n\n      // this.plusSlides = this.plusSlides.bind(this)\n    };return _this;\n  }\n\n  _createClass(Slides, [{\n    key: 'plusSlides',\n    value: function plusSlides(n) {\n      // console.log('ok' + n)\n      // n = slideIndex + n\n      this.showSlides(this.state.slideIndex += n);\n    }\n  }, {\n    key: 'showSlides',\n    value: function showSlides(n) {\n      var i;\n      var x = document.getElementsByClassName('mySlides');\n      if (n > x.length) {\n        this.state.slideIndex = 1;\n      }\n      if (n < 1) {\n        this.state.slideIndex = x.length;\n      }\n      for (i = 0; i < x.length; i++) {\n        x[i].style.display = 'none';\n      }\n      x[this.state.slideIndex - 1].style.display = 'block';\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.showSlides(this.state.slideIndex);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return _react2.default.createElement(\n        _SlidesLayout2.default,\n        null,\n        _react2.default.createElement(\n          'ul',\n          null,\n          slides.map(function (item, index) {\n            return _react2.default.createElement(\n              'li',\n              { key: index },\n              _react2.default.createElement('img', { src: item.src, alt: item.title, className: 'mySlides', style: item.styles })\n            );\n          }),\n          _react2.default.createElement(\n            'div',\n            { className: 'container btn_slides' },\n            _react2.default.createElement(\n              'button',\n              { className: 'btn left', onClick: this.plusSlides.bind(this, -1) },\n              '\\u276E'\n            ),\n            _react2.default.createElement(\n              'button',\n              { className: 'btn right', onClick: this.plusSlides.bind(this, 1) },\n              '\\u276F'\n            )\n          )\n        )\n      );\n    }\n  }]);\n\n  return Slides;\n}(_react.Component);\n\nexports.default = Slides;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvY29udGFpbmVycy9TbGlkZXMuanN4P2ZkYWQiXSwibmFtZXMiOlsic2xpZGVzIiwic3JjIiwic2xpZGVPbmUiLCJ0aXRsZSIsInN0eWxlcyIsImRpc3BsYXkiLCJTbGlkZXMiLCJwcm9wcyIsInN0YXRlIiwic2xpZGVJbmRleCIsIm4iLCJzaG93U2xpZGVzIiwiaSIsIngiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJsZW5ndGgiLCJzdHlsZSIsIm1hcCIsIml0ZW0iLCJpbmRleCIsInBsdXNTbGlkZXMiLCJiaW5kIiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsU0FBUyxDQUNiO0FBQ0VDLE9BQUtDLGVBRFA7QUFFRUMsU0FBTyxTQUZUO0FBR0VDLFVBQVE7QUFDTkMsYUFBUztBQURIO0FBSFYsQ0FEYSxFQVFiO0FBQ0VKLE9BQUssMEhBRFA7QUFFRUUsU0FBTyxTQUZUO0FBR0VDLFVBQVE7QUFDTkMsYUFBUztBQURIO0FBSFYsQ0FSYSxFQWViO0FBQ0VKLE9BQUssaUhBRFA7QUFFRUUsU0FBTyxTQUZUO0FBR0VDLFVBQVE7QUFDTkMsYUFBUztBQURIO0FBSFYsQ0FmYSxDQUFmOztBQXdCQTs7OztBQUlBOztJQUVNQyxNOzs7QUFDSixrQkFBYUMsS0FBYixFQUFvQjtBQUFBOztBQUFBLGdIQUNaQSxLQURZOztBQUVsQixVQUFLQyxLQUFMLEdBQWE7QUFDWEMsa0JBQVk7O0FBR2Q7QUFKYSxLQUFiLENBRmtCO0FBT25COzs7OytCQUVXQyxDLEVBQUc7QUFDYjtBQUNBO0FBQ0EsV0FBS0MsVUFBTCxDQUFnQixLQUFLSCxLQUFMLENBQVdDLFVBQVgsSUFBeUJDLENBQXpDO0FBQ0Q7OzsrQkFFV0EsQyxFQUFHO0FBQ2IsVUFBSUUsQ0FBSjtBQUNBLFVBQUlDLElBQUlDLFNBQVNDLHNCQUFULENBQWdDLFVBQWhDLENBQVI7QUFDQSxVQUFJTCxJQUFJRyxFQUFFRyxNQUFWLEVBQWtCO0FBQUUsYUFBS1IsS0FBTCxDQUFXQyxVQUFYLEdBQXdCLENBQXhCO0FBQTJCO0FBQy9DLFVBQUlDLElBQUksQ0FBUixFQUFXO0FBQUUsYUFBS0YsS0FBTCxDQUFXQyxVQUFYLEdBQXdCSSxFQUFFRyxNQUExQjtBQUFrQztBQUMvQyxXQUFLSixJQUFJLENBQVQsRUFBWUEsSUFBSUMsRUFBRUcsTUFBbEIsRUFBMEJKLEdBQTFCLEVBQStCO0FBQzdCQyxVQUFFRCxDQUFGLEVBQUtLLEtBQUwsQ0FBV1osT0FBWCxHQUFxQixNQUFyQjtBQUNEO0FBQ0RRLFFBQUUsS0FBS0wsS0FBTCxDQUFXQyxVQUFYLEdBQXdCLENBQTFCLEVBQTZCUSxLQUE3QixDQUFtQ1osT0FBbkMsR0FBNkMsT0FBN0M7QUFDRDs7O3dDQUVvQjtBQUNuQixXQUFLTSxVQUFMLENBQWdCLEtBQUtILEtBQUwsQ0FBV0MsVUFBM0I7QUFDRDs7OzZCQUVTO0FBQ1IsYUFDRTtBQUFDLDhCQUFEO0FBQUE7QUFDRTtBQUFBO0FBQUE7QUFFSVQsaUJBQU9rQixHQUFQLENBQVcsVUFBQ0MsSUFBRCxFQUFPQyxLQUFQLEVBQWlCO0FBQzFCLG1CQUNFO0FBQUE7QUFBQSxnQkFBSSxLQUFLQSxLQUFUO0FBQ0UscURBQUssS0FBS0QsS0FBS2xCLEdBQWYsRUFBb0IsS0FBS2tCLEtBQUtoQixLQUE5QixFQUFxQyxXQUFVLFVBQS9DLEVBQTBELE9BQU9nQixLQUFLZixNQUF0RTtBQURGLGFBREY7QUFLRCxXQU5ELENBRko7QUFVRTtBQUFBO0FBQUEsY0FBSyxXQUFVLHNCQUFmO0FBQ0U7QUFBQTtBQUFBLGdCQUFRLFdBQVUsVUFBbEIsRUFBNkIsU0FBUyxLQUFLaUIsVUFBTCxDQUFnQkMsSUFBaEIsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBQyxDQUE1QixDQUF0QztBQUFBO0FBQUEsYUFERjtBQUVFO0FBQUE7QUFBQSxnQkFBUSxXQUFVLFdBQWxCLEVBQThCLFNBQVMsS0FBS0QsVUFBTCxDQUFnQkMsSUFBaEIsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBM0IsQ0FBdkM7QUFBQTtBQUFBO0FBRkY7QUFWRjtBQURGLE9BREY7QUFtQkQ7Ozs7RUFuRGtCQyxnQjs7a0JBc0ROakIsTSIsImZpbGUiOiIuL3NyYy9wYWdlcy9jb250YWluZXJzL1NsaWRlcy5qc3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCBzbGlkZU9uZSBmcm9tICcuLi8uLi9pbWcvc2xpZGUtMS5qcGcnXHJcbmltcG9ydCBTbGlkZXNMYXlvdXQgZnJvbSAnLi4vY29tcG9uZW50cy9TbGlkZXMtbGF5b3V0LmpzeCdcclxuXHJcbmNvbnN0IHNsaWRlcyA9IFtcclxuICB7XHJcbiAgICBzcmM6IHNsaWRlT25lLFxyXG4gICAgdGl0bGU6ICdzbGlkZS0xJyxcclxuICAgIHN0eWxlczoge1xyXG4gICAgICBkaXNwbGF5OiAnYmxvY2snXHJcbiAgICB9XHJcbiAgfSxcclxuICB7XHJcbiAgICBzcmM6ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xMTEwNjU2L3BleGVscy1waG90by0xMTEwNjU2LmpwZWc/Y3M9c3JnYiZkbD1jYWxtLWNsZWFyLXdhdGVyLWNsb3Vkcy0xMTEwNjU2LmpwZyZmbT1qcGcnLFxyXG4gICAgdGl0bGU6ICdzbGlkZS0yJyxcclxuICAgIHN0eWxlczoge1xyXG4gICAgICBkaXNwbGF5OiAnbm9uZSdcclxuICAgIH1cclxuICB9LFxyXG4gIHtcclxuICAgIHNyYzogJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzExMDk1NDEvcGV4ZWxzLXBob3RvLTExMDk1NDEuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJmRwcj0yJmg9NzUwJnc9MTI2MCcsXHJcbiAgICB0aXRsZTogJ3NsaWRlLTMnLFxyXG4gICAgc3R5bGVzOiB7XHJcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xyXG4gICAgfVxyXG4gIH1cclxuXVxyXG5cclxuLypcclxuICBpbWcgZGUgcHJ1ZWJhcyAtPiBodHRwczovL3d3dy5wZXhlbHMuY29tL1xyXG4qL1xyXG5cclxuLy8gbGV0IHNsaWRlSW5kZXggPSAxXHJcblxyXG5jbGFzcyBTbGlkZXMgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICBzbGlkZUluZGV4OiAxXHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhpcy5wbHVzU2xpZGVzID0gdGhpcy5wbHVzU2xpZGVzLmJpbmQodGhpcylcclxuICB9XHJcblxyXG4gIHBsdXNTbGlkZXMgKG4pIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKCdvaycgKyBuKVxyXG4gICAgLy8gbiA9IHNsaWRlSW5kZXggKyBuXHJcbiAgICB0aGlzLnNob3dTbGlkZXModGhpcy5zdGF0ZS5zbGlkZUluZGV4ICs9IG4pXHJcbiAgfVxyXG5cclxuICBzaG93U2xpZGVzIChuKSB7XHJcbiAgICB2YXIgaVxyXG4gICAgdmFyIHggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdteVNsaWRlcycpXHJcbiAgICBpZiAobiA+IHgubGVuZ3RoKSB7IHRoaXMuc3RhdGUuc2xpZGVJbmRleCA9IDEgfVxyXG4gICAgaWYgKG4gPCAxKSB7IHRoaXMuc3RhdGUuc2xpZGVJbmRleCA9IHgubGVuZ3RoIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHhbaV0uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgfVxyXG4gICAgeFt0aGlzLnN0YXRlLnNsaWRlSW5kZXggLSAxXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xyXG4gICAgdGhpcy5zaG93U2xpZGVzKHRoaXMuc3RhdGUuc2xpZGVJbmRleClcclxuICB9XHJcblxyXG4gIHJlbmRlciAoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8U2xpZGVzTGF5b3V0PlxyXG4gICAgICAgIDx1bD5cclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgc2xpZGVzLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGxpIGtleT17aW5kZXh9PlxyXG4gICAgICAgICAgICAgICAgICA8aW1nIHNyYz17aXRlbS5zcmN9IGFsdD17aXRlbS50aXRsZX0gY2xhc3NOYW1lPSdteVNsaWRlcycgc3R5bGU9e2l0ZW0uc3R5bGVzfSAvPlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyIGJ0bl9zbGlkZXMnPlxyXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT0nYnRuIGxlZnQnIG9uQ2xpY2s9e3RoaXMucGx1c1NsaWRlcy5iaW5kKHRoaXMsIC0xKX0+JiMxMDA5NDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9J2J0biByaWdodCcgb25DbGljaz17dGhpcy5wbHVzU2xpZGVzLmJpbmQodGhpcywgMSl9PiYjMTAwOTU7PC9idXR0b24+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L3VsPlxyXG4gICAgICA8L1NsaWRlc0xheW91dD5cclxuICAgIClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNsaWRlc1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/containers/Slides.jsx\n");

/***/ }),

/***/ 0:
/*!****************************************************************************************************************!*\
  !*** multi ./src/entries/Home.jsx webpack-hot-middleware/client?path=/__webpack_hmr&timeout=20000&reload=true ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! D:\docker\www\sitePromociones\src\entries\Home.jsx */"./src/entries/Home.jsx");
module.exports = __webpack_require__(/*! webpack-hot-middleware/client?path=/__webpack_hmr&timeout=20000&reload=true */"./node_modules/webpack-hot-middleware/client.js?path=/__webpack_hmr&timeout=20000&reload=true");


/***/ })

/******/ });